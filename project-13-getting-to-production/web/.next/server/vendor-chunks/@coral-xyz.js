/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@coral-xyz";
exports.ids = ["vendor-chunks/@coral-xyz"];
exports.modules = {

/***/ "(ssr)/../node_modules/@coral-xyz/anchor-errors/dist/index.js":
/*!**************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor-errors/dist/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// Instruction errors.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ANCHOR_ERROR__REQUIRE_EQ_VIOLATED = exports.ANCHOR_ERROR__REQUIRE_VIOLATED = exports.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_PROGRAM_ID = exports.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_AUTHORITY = exports.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION = exports.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION_DELEGATE = exports.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION = exports.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION_AUTHORITY = exports.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION = exports.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_METADATA_ADDRESS = exports.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_AUTHORITY = exports.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION = exports.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_MEMBER_ADDRESS = exports.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_AUTHORITY = exports.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION = exports.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_GROUP_ADDRESS = exports.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_AUTHORITY = exports.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION = exports.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_TOKEN_TOKEN_PROGRAM = exports.ANCHOR_ERROR__CONSTRAINT_MINT_TOKEN_PROGRAM = exports.ANCHOR_ERROR__CONSTRAINT_TOKEN_TOKEN_PROGRAM = exports.ANCHOR_ERROR__CONSTRAINT_ACCOUNT_IS_NONE = exports.ANCHOR_ERROR__CONSTRAINT_SPACE = exports.ANCHOR_ERROR__CONSTRAINT_MINT_DECIMALS = exports.ANCHOR_ERROR__CONSTRAINT_MINT_FREEZE_AUTHORITY = exports.ANCHOR_ERROR__CONSTRAINT_MINT_MINT_AUTHORITY = exports.ANCHOR_ERROR__CONSTRAINT_TOKEN_OWNER = exports.ANCHOR_ERROR__CONSTRAINT_TOKEN_MINT = exports.ANCHOR_ERROR__CONSTRAINT_ZERO = exports.ANCHOR_ERROR__CONSTRAINT_ADDRESS = exports.ANCHOR_ERROR__CONSTRAINT_CLOSE = exports.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_INIT = exports.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED = exports.ANCHOR_ERROR__CONSTRAINT_STATE = exports.ANCHOR_ERROR__CONSTRAINT_EXECUTABLE = exports.ANCHOR_ERROR__CONSTRAINT_SEEDS = exports.ANCHOR_ERROR__CONSTRAINT_RENT_EXEMPT = exports.ANCHOR_ERROR__CONSTRAINT_OWNER = exports.ANCHOR_ERROR__CONSTRAINT_RAW = exports.ANCHOR_ERROR__CONSTRAINT_SIGNER = exports.ANCHOR_ERROR__CONSTRAINT_HAS_ONE = exports.ANCHOR_ERROR__CONSTRAINT_MUT = exports.ANCHOR_ERROR__EVENT_INSTRUCTION_STUB = exports.ANCHOR_ERROR__IDL_ACCOUNT_NOT_EMPTY = exports.ANCHOR_ERROR__IDL_INSTRUCTION_INVALID_PROGRAM = exports.ANCHOR_ERROR__IDL_INSTRUCTION_STUB = exports.ANCHOR_ERROR__INSTRUCTION_DID_NOT_SERIALIZE = exports.ANCHOR_ERROR__INSTRUCTION_DID_NOT_DESERIALIZE = exports.ANCHOR_ERROR__INSTRUCTION_FALLBACK_NOT_FOUND = exports.ANCHOR_ERROR__INSTRUCTION_MISSING = void 0;\nexports.ANCHOR_ERROR__DEPRECATED = exports.ANCHOR_ERROR__INVALID_NUMERIC_CONVERSION = exports.ANCHOR_ERROR__TRYING_TO_INIT_PAYER_AS_PROGRAM_ACCOUNT = exports.ANCHOR_ERROR__DECLARED_PROGRAM_ID_MISMATCH = exports.ANCHOR_ERROR__ACCOUNT_DUPLICATE_REALLOCS = exports.ANCHOR_ERROR__ACCOUNT_REALLOC_EXCEEDS_LIMIT = exports.ANCHOR_ERROR__ACCOUNT_SYSVAR_MISMATCH = exports.ANCHOR_ERROR__ACCOUNT_NOT_ASSOCIATED_TOKEN_ACCOUNT = exports.ANCHOR_ERROR__ACCOUNT_NOT_PROGRAM_DATA = exports.ANCHOR_ERROR__ACCOUNT_NOT_INITIALIZED = exports.ANCHOR_ERROR__ACCOUNT_NOT_SYSTEM_OWNED = exports.ANCHOR_ERROR__ACCOUNT_NOT_SIGNER = exports.ANCHOR_ERROR__INVALID_PROGRAM_EXECUTABLE = exports.ANCHOR_ERROR__INVALID_PROGRAM_ID = exports.ANCHOR_ERROR__ACCOUNT_OWNED_BY_WRONG_PROGRAM = exports.ANCHOR_ERROR__ACCOUNT_NOT_MUTABLE = exports.ANCHOR_ERROR__ACCOUNT_NOT_ENOUGH_KEYS = exports.ANCHOR_ERROR__ACCOUNT_DID_NOT_SERIALIZE = exports.ANCHOR_ERROR__ACCOUNT_DID_NOT_DESERIALIZE = exports.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_MISMATCH = exports.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_NOT_FOUND = exports.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_ALREADY_SET = exports.ANCHOR_ERROR__REQUIRE_GTE_VIOLATED = exports.ANCHOR_ERROR__REQUIRE_GT_VIOLATED = exports.ANCHOR_ERROR__REQUIRE_KEYS_NEQ_VIOLATED = exports.ANCHOR_ERROR__REQUIRE_NEQ_VIOLATED = exports.ANCHOR_ERROR__REQUIRE_KEYS_EQ_VIOLATED = void 0;\n/** 8 byte instruction identifier not provided. */ exports.ANCHOR_ERROR__INSTRUCTION_MISSING = 100;\n/** Fallback functions are not supported. */ exports.ANCHOR_ERROR__INSTRUCTION_FALLBACK_NOT_FOUND = 101;\n/** The program could not deserialize the given instruction. */ exports.ANCHOR_ERROR__INSTRUCTION_DID_NOT_DESERIALIZE = 102;\n/** The program could not serialize the given instruction. */ exports.ANCHOR_ERROR__INSTRUCTION_DID_NOT_SERIALIZE = 103;\n// IDL instruction errors.\n/** The program was compiled without idl instructions. */ exports.ANCHOR_ERROR__IDL_INSTRUCTION_STUB = 1000;\n/** The transaction was given an invalid program for the IDL instruction. */ exports.ANCHOR_ERROR__IDL_INSTRUCTION_INVALID_PROGRAM = 1001;\n/** IDL account must be empty in order to resize, try closing first. */ exports.ANCHOR_ERROR__IDL_ACCOUNT_NOT_EMPTY = 1002;\n// Event instructions.\n/** The program was compiled without `event-cpi` feature. */ exports.ANCHOR_ERROR__EVENT_INSTRUCTION_STUB = 1500;\n// Constraint errors.\n/** A mut constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_MUT = 2000;\n/** A has one constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_HAS_ONE = 2001;\n/** A signer constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_SIGNER = 2002;\n/** A raw constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_RAW = 2003;\n/** An owner constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_OWNER = 2004;\n/** A rent exemption constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_RENT_EXEMPT = 2005;\n/** A seeds constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_SEEDS = 2006;\n/** An executable constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_EXECUTABLE = 2007;\n/** Deprecated Error, feel free to replace with something else. */ exports.ANCHOR_ERROR__CONSTRAINT_STATE = 2008;\n/** An associated constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED = 2009;\n/** An associated init constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_INIT = 2010;\n/** A close constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_CLOSE = 2011;\n/** An address constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_ADDRESS = 2012;\n/** Expected zero account discriminant. */ exports.ANCHOR_ERROR__CONSTRAINT_ZERO = 2013;\n/** A token mint constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_TOKEN_MINT = 2014;\n/** A token owner constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_TOKEN_OWNER = 2015;\n/** A mint mint authority constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_MINT_MINT_AUTHORITY = 2016;\n/** A mint freeze authority constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_MINT_FREEZE_AUTHORITY = 2017;\n/** A mint decimals constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_MINT_DECIMALS = 2018;\n/** A space constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_SPACE = 2019;\n/** A required account for the constraint is None. */ exports.ANCHOR_ERROR__CONSTRAINT_ACCOUNT_IS_NONE = 2020;\n/** A token account token program constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_TOKEN_TOKEN_PROGRAM = 2021;\n/** A mint token program constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_MINT_TOKEN_PROGRAM = 2022;\n/** An associated token account token program constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_TOKEN_TOKEN_PROGRAM = 2023;\n/** A group pointer extension constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION = 2024;\n/** A group pointer extension authority constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_AUTHORITY = 2025;\n/** A group pointer extension group address constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_GROUP_ADDRESS = 2026;\n/** A group member pointer extension constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION = 2027;\n/** A group member pointer extension authority constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_AUTHORITY = 2028;\n/** A group member pointer extension group address constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_MEMBER_ADDRESS = 2029;\n/** A metadata pointer extension constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION = 2030;\n/** A metadata pointer extension authority constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_AUTHORITY = 2031;\n/** A metadata pointer extension metadata address constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_METADATA_ADDRESS = 2032;\n/** A close authority constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION = 2033;\n/** A close authority extension authority constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION_AUTHORITY = 2034;\n/** A permanent delegate extension constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION = 2035;\n/** A permanent delegate extension delegate constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION_DELEGATE = 2036;\n/** A transfer hook extension constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION = 2037;\n/** A transfer hook extension authority constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_AUTHORITY = 2038;\n/** A transfer hook extension transfer hook program id constraint was violated. */ exports.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_PROGRAM_ID = 2039;\n// Require errors.\n/** A require expression was violated. */ exports.ANCHOR_ERROR__REQUIRE_VIOLATED = 2500;\n/** A require_eq expression was violated. */ exports.ANCHOR_ERROR__REQUIRE_EQ_VIOLATED = 2501;\n/** A require_keys_eq expression was violated. */ exports.ANCHOR_ERROR__REQUIRE_KEYS_EQ_VIOLATED = 2502;\n/** A require_neq expression was violated. */ exports.ANCHOR_ERROR__REQUIRE_NEQ_VIOLATED = 2503;\n/** A require_keys_neq expression was violated. */ exports.ANCHOR_ERROR__REQUIRE_KEYS_NEQ_VIOLATED = 2504;\n/** A require_gt expression was violated. */ exports.ANCHOR_ERROR__REQUIRE_GT_VIOLATED = 2505;\n/** A require_gte expression was violated. */ exports.ANCHOR_ERROR__REQUIRE_GTE_VIOLATED = 2506;\n// Account errors.\n/** The account discriminator was already set on this account. */ exports.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_ALREADY_SET = 3000;\n/** No 8 byte discriminator was found on the account. */ exports.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_NOT_FOUND = 3001;\n/** 8 byte discriminator did not match what was expected. */ exports.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_MISMATCH = 3002;\n/** Failed to deserialize the account. */ exports.ANCHOR_ERROR__ACCOUNT_DID_NOT_DESERIALIZE = 3003;\n/** Failed to serialize the account. */ exports.ANCHOR_ERROR__ACCOUNT_DID_NOT_SERIALIZE = 3004;\n/** Not enough account keys given to the instruction. */ exports.ANCHOR_ERROR__ACCOUNT_NOT_ENOUGH_KEYS = 3005;\n/** The given account is not mutable. */ exports.ANCHOR_ERROR__ACCOUNT_NOT_MUTABLE = 3006;\n/** The given account is owned by a different program than expected. */ exports.ANCHOR_ERROR__ACCOUNT_OWNED_BY_WRONG_PROGRAM = 3007;\n/** Program ID was not as expected. */ exports.ANCHOR_ERROR__INVALID_PROGRAM_ID = 3008;\n/** Program account is not executable. */ exports.ANCHOR_ERROR__INVALID_PROGRAM_EXECUTABLE = 3009;\n/** The given account did not sign. */ exports.ANCHOR_ERROR__ACCOUNT_NOT_SIGNER = 3010;\n/** The given account is not owned by the system program. */ exports.ANCHOR_ERROR__ACCOUNT_NOT_SYSTEM_OWNED = 3011;\n/** The program expected this account to be already initialized. */ exports.ANCHOR_ERROR__ACCOUNT_NOT_INITIALIZED = 3012;\n/** The given account is not a program data account. */ exports.ANCHOR_ERROR__ACCOUNT_NOT_PROGRAM_DATA = 3013;\n/** The given account is not the associated token account. */ exports.ANCHOR_ERROR__ACCOUNT_NOT_ASSOCIATED_TOKEN_ACCOUNT = 3014;\n/** The given public key does not match the required sysvar. */ exports.ANCHOR_ERROR__ACCOUNT_SYSVAR_MISMATCH = 3015;\n/** The account reallocation exceeds the MAX_PERMITTED_DATA_INCREASE limit. */ exports.ANCHOR_ERROR__ACCOUNT_REALLOC_EXCEEDS_LIMIT = 3016;\n/** The account was duplicated for more than one reallocation. */ exports.ANCHOR_ERROR__ACCOUNT_DUPLICATE_REALLOCS = 3017;\n// Miscellaneous errors.\n/** The declared program id does not match the actual program id. */ exports.ANCHOR_ERROR__DECLARED_PROGRAM_ID_MISMATCH = 4100;\n/** You cannot/should not initialize the payer account as a program account. */ exports.ANCHOR_ERROR__TRYING_TO_INIT_PAYER_AS_PROGRAM_ACCOUNT = 4101;\n/** The program could not perform the numeric conversion, out of range integral type conversion attempted. */ exports.ANCHOR_ERROR__INVALID_NUMERIC_CONVERSION = 4102;\n// Deprecated errors.\n/** The API being used is deprecated and should no longer be used. */ exports.ANCHOR_ERROR__DEPRECATED = 5000; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yLWVycm9ycy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2Isc0JBQXNCO0FBQ3RCQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQseUNBQXlDLEdBQUdBLHNDQUFzQyxHQUFHQSx3RUFBd0UsR0FBR0EsdUVBQXVFLEdBQUdBLDZEQUE2RCxHQUFHQSwyRUFBMkUsR0FBR0Esa0VBQWtFLEdBQUdBLHlFQUF5RSxHQUFHQSwrREFBK0QsR0FBR0EsaUZBQWlGLEdBQUdBLDBFQUEwRSxHQUFHQSxnRUFBZ0UsR0FBR0EsbUZBQW1GLEdBQUdBLDhFQUE4RSxHQUFHQSxvRUFBb0UsR0FBR0EsMkVBQTJFLEdBQUdBLHVFQUF1RSxHQUFHQSw2REFBNkQsR0FBR0EsK0RBQStELEdBQUdBLG1EQUFtRCxHQUFHQSxvREFBb0QsR0FBR0EsZ0RBQWdELEdBQUdBLHNDQUFzQyxHQUFHQSw4Q0FBOEMsR0FBR0Esc0RBQXNELEdBQUdBLG9EQUFvRCxHQUFHQSw0Q0FBNEMsR0FBR0EsMkNBQTJDLEdBQUdBLHFDQUFxQyxHQUFHQSx3Q0FBd0MsR0FBR0Esc0NBQXNDLEdBQUdBLGdEQUFnRCxHQUFHQSwyQ0FBMkMsR0FBR0Esc0NBQXNDLEdBQUdBLDJDQUEyQyxHQUFHQSxzQ0FBc0MsR0FBR0EsNENBQTRDLEdBQUdBLHNDQUFzQyxHQUFHQSxvQ0FBb0MsR0FBR0EsdUNBQXVDLEdBQUdBLHdDQUF3QyxHQUFHQSxvQ0FBb0MsR0FBR0EsNENBQTRDLEdBQUdBLDJDQUEyQyxHQUFHQSxxREFBcUQsR0FBR0EsMENBQTBDLEdBQUdBLG1EQUFtRCxHQUFHQSxxREFBcUQsR0FBR0Esb0RBQW9ELEdBQUdBLHlDQUF5QyxHQUFHLEtBQUs7QUFDOXVGQSxnQ0FBZ0MsR0FBR0EsZ0RBQWdELEdBQUdBLDZEQUE2RCxHQUFHQSxrREFBa0QsR0FBR0EsZ0RBQWdELEdBQUdBLG1EQUFtRCxHQUFHQSw2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QWtFLEdBQ2xFQSxrREFBa0QsR0FBRztBQUNyRCw2RUFBNkUsR0FDN0VBLDZEQUE2RCxHQUFHO0FBQ2hFLDJHQUEyRyxHQUMzR0EsZ0RBQWdELEdBQUc7QUFDbkQscUJBQXFCO0FBQ3JCLG1FQUFtRSxHQUNuRUEsZ0NBQWdDLEdBQUcsTUFDbkMsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AY29yYWwteHl6L2FuY2hvci1lcnJvcnMvZGlzdC9pbmRleC5qcz82YjM5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gSW5zdHJ1Y3Rpb24gZXJyb3JzLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BTkNIT1JfRVJST1JfX1JFUVVJUkVfRVFfVklPTEFURUQgPSBleHBvcnRzLkFOQ0hPUl9FUlJPUl9fUkVRVUlSRV9WSU9MQVRFRCA9IGV4cG9ydHMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX01JTlRfVFJBTlNGRVJfSE9PS19FWFRFTlNJT05fUFJPR1JBTV9JRCA9IGV4cG9ydHMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX01JTlRfVFJBTlNGRVJfSE9PS19FWFRFTlNJT05fQVVUSE9SSVRZID0gZXhwb3J0cy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfTUlOVF9UUkFOU0ZFUl9IT09LX0VYVEVOU0lPTiA9IGV4cG9ydHMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX01JTlRfUEVSTUFORU5UX0RFTEVHQVRFX0VYVEVOU0lPTl9ERUxFR0FURSA9IGV4cG9ydHMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX01JTlRfUEVSTUFORU5UX0RFTEVHQVRFX0VYVEVOU0lPTiA9IGV4cG9ydHMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX01JTlRfQ0xPU0VfQVVUSE9SSVRZX0VYVEVOU0lPTl9BVVRIT1JJVFkgPSBleHBvcnRzLkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NSU5UX0NMT1NFX0FVVEhPUklUWV9FWFRFTlNJT04gPSBleHBvcnRzLkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NSU5UX01FVEFEQVRBX1BPSU5URVJfRVhURU5TSU9OX01FVEFEQVRBX0FERFJFU1MgPSBleHBvcnRzLkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NSU5UX01FVEFEQVRBX1BPSU5URVJfRVhURU5TSU9OX0FVVEhPUklUWSA9IGV4cG9ydHMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX01JTlRfTUVUQURBVEFfUE9JTlRFUl9FWFRFTlNJT04gPSBleHBvcnRzLkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NSU5UX0dST1VQX01FTUJFUl9QT0lOVEVSX0VYVEVOU0lPTl9NRU1CRVJfQUREUkVTUyA9IGV4cG9ydHMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX01JTlRfR1JPVVBfTUVNQkVSX1BPSU5URVJfRVhURU5TSU9OX0FVVEhPUklUWSA9IGV4cG9ydHMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX01JTlRfR1JPVVBfTUVNQkVSX1BPSU5URVJfRVhURU5TSU9OID0gZXhwb3J0cy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfTUlOVF9HUk9VUF9QT0lOVEVSX0VYVEVOU0lPTl9HUk9VUF9BRERSRVNTID0gZXhwb3J0cy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfTUlOVF9HUk9VUF9QT0lOVEVSX0VYVEVOU0lPTl9BVVRIT1JJVFkgPSBleHBvcnRzLkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NSU5UX0dST1VQX1BPSU5URVJfRVhURU5TSU9OID0gZXhwb3J0cy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfQVNTT0NJQVRFRF9UT0tFTl9UT0tFTl9QUk9HUkFNID0gZXhwb3J0cy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfTUlOVF9UT0tFTl9QUk9HUkFNID0gZXhwb3J0cy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfVE9LRU5fVE9LRU5fUFJPR1JBTSA9IGV4cG9ydHMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX0FDQ09VTlRfSVNfTk9ORSA9IGV4cG9ydHMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX1NQQUNFID0gZXhwb3J0cy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfTUlOVF9ERUNJTUFMUyA9IGV4cG9ydHMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX01JTlRfRlJFRVpFX0FVVEhPUklUWSA9IGV4cG9ydHMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX01JTlRfTUlOVF9BVVRIT1JJVFkgPSBleHBvcnRzLkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9UT0tFTl9PV05FUiA9IGV4cG9ydHMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX1RPS0VOX01JTlQgPSBleHBvcnRzLkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9aRVJPID0gZXhwb3J0cy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfQUREUkVTUyA9IGV4cG9ydHMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX0NMT1NFID0gZXhwb3J0cy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfQVNTT0NJQVRFRF9JTklUID0gZXhwb3J0cy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfQVNTT0NJQVRFRCA9IGV4cG9ydHMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX1NUQVRFID0gZXhwb3J0cy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfRVhFQ1VUQUJMRSA9IGV4cG9ydHMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX1NFRURTID0gZXhwb3J0cy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfUkVOVF9FWEVNUFQgPSBleHBvcnRzLkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9PV05FUiA9IGV4cG9ydHMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX1JBVyA9IGV4cG9ydHMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX1NJR05FUiA9IGV4cG9ydHMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX0hBU19PTkUgPSBleHBvcnRzLkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NVVQgPSBleHBvcnRzLkFOQ0hPUl9FUlJPUl9fRVZFTlRfSU5TVFJVQ1RJT05fU1RVQiA9IGV4cG9ydHMuQU5DSE9SX0VSUk9SX19JRExfQUNDT1VOVF9OT1RfRU1QVFkgPSBleHBvcnRzLkFOQ0hPUl9FUlJPUl9fSURMX0lOU1RSVUNUSU9OX0lOVkFMSURfUFJPR1JBTSA9IGV4cG9ydHMuQU5DSE9SX0VSUk9SX19JRExfSU5TVFJVQ1RJT05fU1RVQiA9IGV4cG9ydHMuQU5DSE9SX0VSUk9SX19JTlNUUlVDVElPTl9ESURfTk9UX1NFUklBTElaRSA9IGV4cG9ydHMuQU5DSE9SX0VSUk9SX19JTlNUUlVDVElPTl9ESURfTk9UX0RFU0VSSUFMSVpFID0gZXhwb3J0cy5BTkNIT1JfRVJST1JfX0lOU1RSVUNUSU9OX0ZBTExCQUNLX05PVF9GT1VORCA9IGV4cG9ydHMuQU5DSE9SX0VSUk9SX19JTlNUUlVDVElPTl9NSVNTSU5HID0gdm9pZCAwO1xuZXhwb3J0cy5BTkNIT1JfRVJST1JfX0RFUFJFQ0FURUQgPSBleHBvcnRzLkFOQ0hPUl9FUlJPUl9fSU5WQUxJRF9OVU1FUklDX0NPTlZFUlNJT04gPSBleHBvcnRzLkFOQ0hPUl9FUlJPUl9fVFJZSU5HX1RPX0lOSVRfUEFZRVJfQVNfUFJPR1JBTV9BQ0NPVU5UID0gZXhwb3J0cy5BTkNIT1JfRVJST1JfX0RFQ0xBUkVEX1BST0dSQU1fSURfTUlTTUFUQ0ggPSBleHBvcnRzLkFOQ0hPUl9FUlJPUl9fQUNDT1VOVF9EVVBMSUNBVEVfUkVBTExPQ1MgPSBleHBvcnRzLkFOQ0hPUl9FUlJPUl9fQUNDT1VOVF9SRUFMTE9DX0VYQ0VFRFNfTElNSVQgPSBleHBvcnRzLkFOQ0hPUl9FUlJPUl9fQUNDT1VOVF9TWVNWQVJfTUlTTUFUQ0ggPSBleHBvcnRzLkFOQ0hPUl9FUlJPUl9fQUNDT1VOVF9OT1RfQVNTT0NJQVRFRF9UT0tFTl9BQ0NPVU5UID0gZXhwb3J0cy5BTkNIT1JfRVJST1JfX0FDQ09VTlRfTk9UX1BST0dSQU1fREFUQSA9IGV4cG9ydHMuQU5DSE9SX0VSUk9SX19BQ0NPVU5UX05PVF9JTklUSUFMSVpFRCA9IGV4cG9ydHMuQU5DSE9SX0VSUk9SX19BQ0NPVU5UX05PVF9TWVNURU1fT1dORUQgPSBleHBvcnRzLkFOQ0hPUl9FUlJPUl9fQUNDT1VOVF9OT1RfU0lHTkVSID0gZXhwb3J0cy5BTkNIT1JfRVJST1JfX0lOVkFMSURfUFJPR1JBTV9FWEVDVVRBQkxFID0gZXhwb3J0cy5BTkNIT1JfRVJST1JfX0lOVkFMSURfUFJPR1JBTV9JRCA9IGV4cG9ydHMuQU5DSE9SX0VSUk9SX19BQ0NPVU5UX09XTkVEX0JZX1dST05HX1BST0dSQU0gPSBleHBvcnRzLkFOQ0hPUl9FUlJPUl9fQUNDT1VOVF9OT1RfTVVUQUJMRSA9IGV4cG9ydHMuQU5DSE9SX0VSUk9SX19BQ0NPVU5UX05PVF9FTk9VR0hfS0VZUyA9IGV4cG9ydHMuQU5DSE9SX0VSUk9SX19BQ0NPVU5UX0RJRF9OT1RfU0VSSUFMSVpFID0gZXhwb3J0cy5BTkNIT1JfRVJST1JfX0FDQ09VTlRfRElEX05PVF9ERVNFUklBTElaRSA9IGV4cG9ydHMuQU5DSE9SX0VSUk9SX19BQ0NPVU5UX0RJU0NSSU1JTkFUT1JfTUlTTUFUQ0ggPSBleHBvcnRzLkFOQ0hPUl9FUlJPUl9fQUNDT1VOVF9ESVNDUklNSU5BVE9SX05PVF9GT1VORCA9IGV4cG9ydHMuQU5DSE9SX0VSUk9SX19BQ0NPVU5UX0RJU0NSSU1JTkFUT1JfQUxSRUFEWV9TRVQgPSBleHBvcnRzLkFOQ0hPUl9FUlJPUl9fUkVRVUlSRV9HVEVfVklPTEFURUQgPSBleHBvcnRzLkFOQ0hPUl9FUlJPUl9fUkVRVUlSRV9HVF9WSU9MQVRFRCA9IGV4cG9ydHMuQU5DSE9SX0VSUk9SX19SRVFVSVJFX0tFWVNfTkVRX1ZJT0xBVEVEID0gZXhwb3J0cy5BTkNIT1JfRVJST1JfX1JFUVVJUkVfTkVRX1ZJT0xBVEVEID0gZXhwb3J0cy5BTkNIT1JfRVJST1JfX1JFUVVJUkVfS0VZU19FUV9WSU9MQVRFRCA9IHZvaWQgMDtcbi8qKiA4IGJ5dGUgaW5zdHJ1Y3Rpb24gaWRlbnRpZmllciBub3QgcHJvdmlkZWQuICovXG5leHBvcnRzLkFOQ0hPUl9FUlJPUl9fSU5TVFJVQ1RJT05fTUlTU0lORyA9IDEwMDtcbi8qKiBGYWxsYmFjayBmdW5jdGlvbnMgYXJlIG5vdCBzdXBwb3J0ZWQuICovXG5leHBvcnRzLkFOQ0hPUl9FUlJPUl9fSU5TVFJVQ1RJT05fRkFMTEJBQ0tfTk9UX0ZPVU5EID0gMTAxO1xuLyoqIFRoZSBwcm9ncmFtIGNvdWxkIG5vdCBkZXNlcmlhbGl6ZSB0aGUgZ2l2ZW4gaW5zdHJ1Y3Rpb24uICovXG5leHBvcnRzLkFOQ0hPUl9FUlJPUl9fSU5TVFJVQ1RJT05fRElEX05PVF9ERVNFUklBTElaRSA9IDEwMjtcbi8qKiBUaGUgcHJvZ3JhbSBjb3VsZCBub3Qgc2VyaWFsaXplIHRoZSBnaXZlbiBpbnN0cnVjdGlvbi4gKi9cbmV4cG9ydHMuQU5DSE9SX0VSUk9SX19JTlNUUlVDVElPTl9ESURfTk9UX1NFUklBTElaRSA9IDEwMztcbi8vIElETCBpbnN0cnVjdGlvbiBlcnJvcnMuXG4vKiogVGhlIHByb2dyYW0gd2FzIGNvbXBpbGVkIHdpdGhvdXQgaWRsIGluc3RydWN0aW9ucy4gKi9cbmV4cG9ydHMuQU5DSE9SX0VSUk9SX19JRExfSU5TVFJVQ1RJT05fU1RVQiA9IDEwMDA7XG4vKiogVGhlIHRyYW5zYWN0aW9uIHdhcyBnaXZlbiBhbiBpbnZhbGlkIHByb2dyYW0gZm9yIHRoZSBJREwgaW5zdHJ1Y3Rpb24uICovXG5leHBvcnRzLkFOQ0hPUl9FUlJPUl9fSURMX0lOU1RSVUNUSU9OX0lOVkFMSURfUFJPR1JBTSA9IDEwMDE7XG4vKiogSURMIGFjY291bnQgbXVzdCBiZSBlbXB0eSBpbiBvcmRlciB0byByZXNpemUsIHRyeSBjbG9zaW5nIGZpcnN0LiAqL1xuZXhwb3J0cy5BTkNIT1JfRVJST1JfX0lETF9BQ0NPVU5UX05PVF9FTVBUWSA9IDEwMDI7XG4vLyBFdmVudCBpbnN0cnVjdGlvbnMuXG4vKiogVGhlIHByb2dyYW0gd2FzIGNvbXBpbGVkIHdpdGhvdXQgYGV2ZW50LWNwaWAgZmVhdHVyZS4gKi9cbmV4cG9ydHMuQU5DSE9SX0VSUk9SX19FVkVOVF9JTlNUUlVDVElPTl9TVFVCID0gMTUwMDtcbi8vIENvbnN0cmFpbnQgZXJyb3JzLlxuLyoqIEEgbXV0IGNvbnN0cmFpbnQgd2FzIHZpb2xhdGVkLiAqL1xuZXhwb3J0cy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfTVVUID0gMjAwMDtcbi8qKiBBIGhhcyBvbmUgY29uc3RyYWludCB3YXMgdmlvbGF0ZWQuICovXG5leHBvcnRzLkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9IQVNfT05FID0gMjAwMTtcbi8qKiBBIHNpZ25lciBjb25zdHJhaW50IHdhcyB2aW9sYXRlZC4gKi9cbmV4cG9ydHMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX1NJR05FUiA9IDIwMDI7XG4vKiogQSByYXcgY29uc3RyYWludCB3YXMgdmlvbGF0ZWQuICovXG5leHBvcnRzLkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9SQVcgPSAyMDAzO1xuLyoqIEFuIG93bmVyIGNvbnN0cmFpbnQgd2FzIHZpb2xhdGVkLiAqL1xuZXhwb3J0cy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfT1dORVIgPSAyMDA0O1xuLyoqIEEgcmVudCBleGVtcHRpb24gY29uc3RyYWludCB3YXMgdmlvbGF0ZWQuICovXG5leHBvcnRzLkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9SRU5UX0VYRU1QVCA9IDIwMDU7XG4vKiogQSBzZWVkcyBjb25zdHJhaW50IHdhcyB2aW9sYXRlZC4gKi9cbmV4cG9ydHMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX1NFRURTID0gMjAwNjtcbi8qKiBBbiBleGVjdXRhYmxlIGNvbnN0cmFpbnQgd2FzIHZpb2xhdGVkLiAqL1xuZXhwb3J0cy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfRVhFQ1VUQUJMRSA9IDIwMDc7XG4vKiogRGVwcmVjYXRlZCBFcnJvciwgZmVlbCBmcmVlIHRvIHJlcGxhY2Ugd2l0aCBzb21ldGhpbmcgZWxzZS4gKi9cbmV4cG9ydHMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX1NUQVRFID0gMjAwODtcbi8qKiBBbiBhc3NvY2lhdGVkIGNvbnN0cmFpbnQgd2FzIHZpb2xhdGVkLiAqL1xuZXhwb3J0cy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfQVNTT0NJQVRFRCA9IDIwMDk7XG4vKiogQW4gYXNzb2NpYXRlZCBpbml0IGNvbnN0cmFpbnQgd2FzIHZpb2xhdGVkLiAqL1xuZXhwb3J0cy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfQVNTT0NJQVRFRF9JTklUID0gMjAxMDtcbi8qKiBBIGNsb3NlIGNvbnN0cmFpbnQgd2FzIHZpb2xhdGVkLiAqL1xuZXhwb3J0cy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfQ0xPU0UgPSAyMDExO1xuLyoqIEFuIGFkZHJlc3MgY29uc3RyYWludCB3YXMgdmlvbGF0ZWQuICovXG5leHBvcnRzLkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9BRERSRVNTID0gMjAxMjtcbi8qKiBFeHBlY3RlZCB6ZXJvIGFjY291bnQgZGlzY3JpbWluYW50LiAqL1xuZXhwb3J0cy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfWkVSTyA9IDIwMTM7XG4vKiogQSB0b2tlbiBtaW50IGNvbnN0cmFpbnQgd2FzIHZpb2xhdGVkLiAqL1xuZXhwb3J0cy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfVE9LRU5fTUlOVCA9IDIwMTQ7XG4vKiogQSB0b2tlbiBvd25lciBjb25zdHJhaW50IHdhcyB2aW9sYXRlZC4gKi9cbmV4cG9ydHMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX1RPS0VOX09XTkVSID0gMjAxNTtcbi8qKiBBIG1pbnQgbWludCBhdXRob3JpdHkgY29uc3RyYWludCB3YXMgdmlvbGF0ZWQuICovXG5leHBvcnRzLkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NSU5UX01JTlRfQVVUSE9SSVRZID0gMjAxNjtcbi8qKiBBIG1pbnQgZnJlZXplIGF1dGhvcml0eSBjb25zdHJhaW50IHdhcyB2aW9sYXRlZC4gKi9cbmV4cG9ydHMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX01JTlRfRlJFRVpFX0FVVEhPUklUWSA9IDIwMTc7XG4vKiogQSBtaW50IGRlY2ltYWxzIGNvbnN0cmFpbnQgd2FzIHZpb2xhdGVkLiAqL1xuZXhwb3J0cy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfTUlOVF9ERUNJTUFMUyA9IDIwMTg7XG4vKiogQSBzcGFjZSBjb25zdHJhaW50IHdhcyB2aW9sYXRlZC4gKi9cbmV4cG9ydHMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX1NQQUNFID0gMjAxOTtcbi8qKiBBIHJlcXVpcmVkIGFjY291bnQgZm9yIHRoZSBjb25zdHJhaW50IGlzIE5vbmUuICovXG5leHBvcnRzLkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9BQ0NPVU5UX0lTX05PTkUgPSAyMDIwO1xuLyoqIEEgdG9rZW4gYWNjb3VudCB0b2tlbiBwcm9ncmFtIGNvbnN0cmFpbnQgd2FzIHZpb2xhdGVkLiAqL1xuZXhwb3J0cy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfVE9LRU5fVE9LRU5fUFJPR1JBTSA9IDIwMjE7XG4vKiogQSBtaW50IHRva2VuIHByb2dyYW0gY29uc3RyYWludCB3YXMgdmlvbGF0ZWQuICovXG5leHBvcnRzLkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NSU5UX1RPS0VOX1BST0dSQU0gPSAyMDIyO1xuLyoqIEFuIGFzc29jaWF0ZWQgdG9rZW4gYWNjb3VudCB0b2tlbiBwcm9ncmFtIGNvbnN0cmFpbnQgd2FzIHZpb2xhdGVkLiAqL1xuZXhwb3J0cy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfQVNTT0NJQVRFRF9UT0tFTl9UT0tFTl9QUk9HUkFNID0gMjAyMztcbi8qKiBBIGdyb3VwIHBvaW50ZXIgZXh0ZW5zaW9uIGNvbnN0cmFpbnQgd2FzIHZpb2xhdGVkLiAqL1xuZXhwb3J0cy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfTUlOVF9HUk9VUF9QT0lOVEVSX0VYVEVOU0lPTiA9IDIwMjQ7XG4vKiogQSBncm91cCBwb2ludGVyIGV4dGVuc2lvbiBhdXRob3JpdHkgY29uc3RyYWludCB3YXMgdmlvbGF0ZWQuICovXG5leHBvcnRzLkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NSU5UX0dST1VQX1BPSU5URVJfRVhURU5TSU9OX0FVVEhPUklUWSA9IDIwMjU7XG4vKiogQSBncm91cCBwb2ludGVyIGV4dGVuc2lvbiBncm91cCBhZGRyZXNzIGNvbnN0cmFpbnQgd2FzIHZpb2xhdGVkLiAqL1xuZXhwb3J0cy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfTUlOVF9HUk9VUF9QT0lOVEVSX0VYVEVOU0lPTl9HUk9VUF9BRERSRVNTID0gMjAyNjtcbi8qKiBBIGdyb3VwIG1lbWJlciBwb2ludGVyIGV4dGVuc2lvbiBjb25zdHJhaW50IHdhcyB2aW9sYXRlZC4gKi9cbmV4cG9ydHMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX01JTlRfR1JPVVBfTUVNQkVSX1BPSU5URVJfRVhURU5TSU9OID0gMjAyNztcbi8qKiBBIGdyb3VwIG1lbWJlciBwb2ludGVyIGV4dGVuc2lvbiBhdXRob3JpdHkgY29uc3RyYWludCB3YXMgdmlvbGF0ZWQuICovXG5leHBvcnRzLkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NSU5UX0dST1VQX01FTUJFUl9QT0lOVEVSX0VYVEVOU0lPTl9BVVRIT1JJVFkgPSAyMDI4O1xuLyoqIEEgZ3JvdXAgbWVtYmVyIHBvaW50ZXIgZXh0ZW5zaW9uIGdyb3VwIGFkZHJlc3MgY29uc3RyYWludCB3YXMgdmlvbGF0ZWQuICovXG5leHBvcnRzLkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NSU5UX0dST1VQX01FTUJFUl9QT0lOVEVSX0VYVEVOU0lPTl9NRU1CRVJfQUREUkVTUyA9IDIwMjk7XG4vKiogQSBtZXRhZGF0YSBwb2ludGVyIGV4dGVuc2lvbiBjb25zdHJhaW50IHdhcyB2aW9sYXRlZC4gKi9cbmV4cG9ydHMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX01JTlRfTUVUQURBVEFfUE9JTlRFUl9FWFRFTlNJT04gPSAyMDMwO1xuLyoqIEEgbWV0YWRhdGEgcG9pbnRlciBleHRlbnNpb24gYXV0aG9yaXR5IGNvbnN0cmFpbnQgd2FzIHZpb2xhdGVkLiAqL1xuZXhwb3J0cy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfTUlOVF9NRVRBREFUQV9QT0lOVEVSX0VYVEVOU0lPTl9BVVRIT1JJVFkgPSAyMDMxO1xuLyoqIEEgbWV0YWRhdGEgcG9pbnRlciBleHRlbnNpb24gbWV0YWRhdGEgYWRkcmVzcyBjb25zdHJhaW50IHdhcyB2aW9sYXRlZC4gKi9cbmV4cG9ydHMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX01JTlRfTUVUQURBVEFfUE9JTlRFUl9FWFRFTlNJT05fTUVUQURBVEFfQUREUkVTUyA9IDIwMzI7XG4vKiogQSBjbG9zZSBhdXRob3JpdHkgY29uc3RyYWludCB3YXMgdmlvbGF0ZWQuICovXG5leHBvcnRzLkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NSU5UX0NMT1NFX0FVVEhPUklUWV9FWFRFTlNJT04gPSAyMDMzO1xuLyoqIEEgY2xvc2UgYXV0aG9yaXR5IGV4dGVuc2lvbiBhdXRob3JpdHkgY29uc3RyYWludCB3YXMgdmlvbGF0ZWQuICovXG5leHBvcnRzLkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NSU5UX0NMT1NFX0FVVEhPUklUWV9FWFRFTlNJT05fQVVUSE9SSVRZID0gMjAzNDtcbi8qKiBBIHBlcm1hbmVudCBkZWxlZ2F0ZSBleHRlbnNpb24gY29uc3RyYWludCB3YXMgdmlvbGF0ZWQuICovXG5leHBvcnRzLkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NSU5UX1BFUk1BTkVOVF9ERUxFR0FURV9FWFRFTlNJT04gPSAyMDM1O1xuLyoqIEEgcGVybWFuZW50IGRlbGVnYXRlIGV4dGVuc2lvbiBkZWxlZ2F0ZSBjb25zdHJhaW50IHdhcyB2aW9sYXRlZC4gKi9cbmV4cG9ydHMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX01JTlRfUEVSTUFORU5UX0RFTEVHQVRFX0VYVEVOU0lPTl9ERUxFR0FURSA9IDIwMzY7XG4vKiogQSB0cmFuc2ZlciBob29rIGV4dGVuc2lvbiBjb25zdHJhaW50IHdhcyB2aW9sYXRlZC4gKi9cbmV4cG9ydHMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX01JTlRfVFJBTlNGRVJfSE9PS19FWFRFTlNJT04gPSAyMDM3O1xuLyoqIEEgdHJhbnNmZXIgaG9vayBleHRlbnNpb24gYXV0aG9yaXR5IGNvbnN0cmFpbnQgd2FzIHZpb2xhdGVkLiAqL1xuZXhwb3J0cy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfTUlOVF9UUkFOU0ZFUl9IT09LX0VYVEVOU0lPTl9BVVRIT1JJVFkgPSAyMDM4O1xuLyoqIEEgdHJhbnNmZXIgaG9vayBleHRlbnNpb24gdHJhbnNmZXIgaG9vayBwcm9ncmFtIGlkIGNvbnN0cmFpbnQgd2FzIHZpb2xhdGVkLiAqL1xuZXhwb3J0cy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfTUlOVF9UUkFOU0ZFUl9IT09LX0VYVEVOU0lPTl9QUk9HUkFNX0lEID0gMjAzOTtcbi8vIFJlcXVpcmUgZXJyb3JzLlxuLyoqIEEgcmVxdWlyZSBleHByZXNzaW9uIHdhcyB2aW9sYXRlZC4gKi9cbmV4cG9ydHMuQU5DSE9SX0VSUk9SX19SRVFVSVJFX1ZJT0xBVEVEID0gMjUwMDtcbi8qKiBBIHJlcXVpcmVfZXEgZXhwcmVzc2lvbiB3YXMgdmlvbGF0ZWQuICovXG5leHBvcnRzLkFOQ0hPUl9FUlJPUl9fUkVRVUlSRV9FUV9WSU9MQVRFRCA9IDI1MDE7XG4vKiogQSByZXF1aXJlX2tleXNfZXEgZXhwcmVzc2lvbiB3YXMgdmlvbGF0ZWQuICovXG5leHBvcnRzLkFOQ0hPUl9FUlJPUl9fUkVRVUlSRV9LRVlTX0VRX1ZJT0xBVEVEID0gMjUwMjtcbi8qKiBBIHJlcXVpcmVfbmVxIGV4cHJlc3Npb24gd2FzIHZpb2xhdGVkLiAqL1xuZXhwb3J0cy5BTkNIT1JfRVJST1JfX1JFUVVJUkVfTkVRX1ZJT0xBVEVEID0gMjUwMztcbi8qKiBBIHJlcXVpcmVfa2V5c19uZXEgZXhwcmVzc2lvbiB3YXMgdmlvbGF0ZWQuICovXG5leHBvcnRzLkFOQ0hPUl9FUlJPUl9fUkVRVUlSRV9LRVlTX05FUV9WSU9MQVRFRCA9IDI1MDQ7XG4vKiogQSByZXF1aXJlX2d0IGV4cHJlc3Npb24gd2FzIHZpb2xhdGVkLiAqL1xuZXhwb3J0cy5BTkNIT1JfRVJST1JfX1JFUVVJUkVfR1RfVklPTEFURUQgPSAyNTA1O1xuLyoqIEEgcmVxdWlyZV9ndGUgZXhwcmVzc2lvbiB3YXMgdmlvbGF0ZWQuICovXG5leHBvcnRzLkFOQ0hPUl9FUlJPUl9fUkVRVUlSRV9HVEVfVklPTEFURUQgPSAyNTA2O1xuLy8gQWNjb3VudCBlcnJvcnMuXG4vKiogVGhlIGFjY291bnQgZGlzY3JpbWluYXRvciB3YXMgYWxyZWFkeSBzZXQgb24gdGhpcyBhY2NvdW50LiAqL1xuZXhwb3J0cy5BTkNIT1JfRVJST1JfX0FDQ09VTlRfRElTQ1JJTUlOQVRPUl9BTFJFQURZX1NFVCA9IDMwMDA7XG4vKiogTm8gOCBieXRlIGRpc2NyaW1pbmF0b3Igd2FzIGZvdW5kIG9uIHRoZSBhY2NvdW50LiAqL1xuZXhwb3J0cy5BTkNIT1JfRVJST1JfX0FDQ09VTlRfRElTQ1JJTUlOQVRPUl9OT1RfRk9VTkQgPSAzMDAxO1xuLyoqIDggYnl0ZSBkaXNjcmltaW5hdG9yIGRpZCBub3QgbWF0Y2ggd2hhdCB3YXMgZXhwZWN0ZWQuICovXG5leHBvcnRzLkFOQ0hPUl9FUlJPUl9fQUNDT1VOVF9ESVNDUklNSU5BVE9SX01JU01BVENIID0gMzAwMjtcbi8qKiBGYWlsZWQgdG8gZGVzZXJpYWxpemUgdGhlIGFjY291bnQuICovXG5leHBvcnRzLkFOQ0hPUl9FUlJPUl9fQUNDT1VOVF9ESURfTk9UX0RFU0VSSUFMSVpFID0gMzAwMztcbi8qKiBGYWlsZWQgdG8gc2VyaWFsaXplIHRoZSBhY2NvdW50LiAqL1xuZXhwb3J0cy5BTkNIT1JfRVJST1JfX0FDQ09VTlRfRElEX05PVF9TRVJJQUxJWkUgPSAzMDA0O1xuLyoqIE5vdCBlbm91Z2ggYWNjb3VudCBrZXlzIGdpdmVuIHRvIHRoZSBpbnN0cnVjdGlvbi4gKi9cbmV4cG9ydHMuQU5DSE9SX0VSUk9SX19BQ0NPVU5UX05PVF9FTk9VR0hfS0VZUyA9IDMwMDU7XG4vKiogVGhlIGdpdmVuIGFjY291bnQgaXMgbm90IG11dGFibGUuICovXG5leHBvcnRzLkFOQ0hPUl9FUlJPUl9fQUNDT1VOVF9OT1RfTVVUQUJMRSA9IDMwMDY7XG4vKiogVGhlIGdpdmVuIGFjY291bnQgaXMgb3duZWQgYnkgYSBkaWZmZXJlbnQgcHJvZ3JhbSB0aGFuIGV4cGVjdGVkLiAqL1xuZXhwb3J0cy5BTkNIT1JfRVJST1JfX0FDQ09VTlRfT1dORURfQllfV1JPTkdfUFJPR1JBTSA9IDMwMDc7XG4vKiogUHJvZ3JhbSBJRCB3YXMgbm90IGFzIGV4cGVjdGVkLiAqL1xuZXhwb3J0cy5BTkNIT1JfRVJST1JfX0lOVkFMSURfUFJPR1JBTV9JRCA9IDMwMDg7XG4vKiogUHJvZ3JhbSBhY2NvdW50IGlzIG5vdCBleGVjdXRhYmxlLiAqL1xuZXhwb3J0cy5BTkNIT1JfRVJST1JfX0lOVkFMSURfUFJPR1JBTV9FWEVDVVRBQkxFID0gMzAwOTtcbi8qKiBUaGUgZ2l2ZW4gYWNjb3VudCBkaWQgbm90IHNpZ24uICovXG5leHBvcnRzLkFOQ0hPUl9FUlJPUl9fQUNDT1VOVF9OT1RfU0lHTkVSID0gMzAxMDtcbi8qKiBUaGUgZ2l2ZW4gYWNjb3VudCBpcyBub3Qgb3duZWQgYnkgdGhlIHN5c3RlbSBwcm9ncmFtLiAqL1xuZXhwb3J0cy5BTkNIT1JfRVJST1JfX0FDQ09VTlRfTk9UX1NZU1RFTV9PV05FRCA9IDMwMTE7XG4vKiogVGhlIHByb2dyYW0gZXhwZWN0ZWQgdGhpcyBhY2NvdW50IHRvIGJlIGFscmVhZHkgaW5pdGlhbGl6ZWQuICovXG5leHBvcnRzLkFOQ0hPUl9FUlJPUl9fQUNDT1VOVF9OT1RfSU5JVElBTElaRUQgPSAzMDEyO1xuLyoqIFRoZSBnaXZlbiBhY2NvdW50IGlzIG5vdCBhIHByb2dyYW0gZGF0YSBhY2NvdW50LiAqL1xuZXhwb3J0cy5BTkNIT1JfRVJST1JfX0FDQ09VTlRfTk9UX1BST0dSQU1fREFUQSA9IDMwMTM7XG4vKiogVGhlIGdpdmVuIGFjY291bnQgaXMgbm90IHRoZSBhc3NvY2lhdGVkIHRva2VuIGFjY291bnQuICovXG5leHBvcnRzLkFOQ0hPUl9FUlJPUl9fQUNDT1VOVF9OT1RfQVNTT0NJQVRFRF9UT0tFTl9BQ0NPVU5UID0gMzAxNDtcbi8qKiBUaGUgZ2l2ZW4gcHVibGljIGtleSBkb2VzIG5vdCBtYXRjaCB0aGUgcmVxdWlyZWQgc3lzdmFyLiAqL1xuZXhwb3J0cy5BTkNIT1JfRVJST1JfX0FDQ09VTlRfU1lTVkFSX01JU01BVENIID0gMzAxNTtcbi8qKiBUaGUgYWNjb3VudCByZWFsbG9jYXRpb24gZXhjZWVkcyB0aGUgTUFYX1BFUk1JVFRFRF9EQVRBX0lOQ1JFQVNFIGxpbWl0LiAqL1xuZXhwb3J0cy5BTkNIT1JfRVJST1JfX0FDQ09VTlRfUkVBTExPQ19FWENFRURTX0xJTUlUID0gMzAxNjtcbi8qKiBUaGUgYWNjb3VudCB3YXMgZHVwbGljYXRlZCBmb3IgbW9yZSB0aGFuIG9uZSByZWFsbG9jYXRpb24uICovXG5leHBvcnRzLkFOQ0hPUl9FUlJPUl9fQUNDT1VOVF9EVVBMSUNBVEVfUkVBTExPQ1MgPSAzMDE3O1xuLy8gTWlzY2VsbGFuZW91cyBlcnJvcnMuXG4vKiogVGhlIGRlY2xhcmVkIHByb2dyYW0gaWQgZG9lcyBub3QgbWF0Y2ggdGhlIGFjdHVhbCBwcm9ncmFtIGlkLiAqL1xuZXhwb3J0cy5BTkNIT1JfRVJST1JfX0RFQ0xBUkVEX1BST0dSQU1fSURfTUlTTUFUQ0ggPSA0MTAwO1xuLyoqIFlvdSBjYW5ub3Qvc2hvdWxkIG5vdCBpbml0aWFsaXplIHRoZSBwYXllciBhY2NvdW50IGFzIGEgcHJvZ3JhbSBhY2NvdW50LiAqL1xuZXhwb3J0cy5BTkNIT1JfRVJST1JfX1RSWUlOR19UT19JTklUX1BBWUVSX0FTX1BST0dSQU1fQUNDT1VOVCA9IDQxMDE7XG4vKiogVGhlIHByb2dyYW0gY291bGQgbm90IHBlcmZvcm0gdGhlIG51bWVyaWMgY29udmVyc2lvbiwgb3V0IG9mIHJhbmdlIGludGVncmFsIHR5cGUgY29udmVyc2lvbiBhdHRlbXB0ZWQuICovXG5leHBvcnRzLkFOQ0hPUl9FUlJPUl9fSU5WQUxJRF9OVU1FUklDX0NPTlZFUlNJT04gPSA0MTAyO1xuLy8gRGVwcmVjYXRlZCBlcnJvcnMuXG4vKiogVGhlIEFQSSBiZWluZyB1c2VkIGlzIGRlcHJlY2F0ZWQgYW5kIHNob3VsZCBubyBsb25nZXIgYmUgdXNlZC4gKi9cbmV4cG9ydHMuQU5DSE9SX0VSUk9SX19ERVBSRUNBVEVEID0gNTAwMDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkFOQ0hPUl9FUlJPUl9fUkVRVUlSRV9FUV9WSU9MQVRFRCIsIkFOQ0hPUl9FUlJPUl9fUkVRVUlSRV9WSU9MQVRFRCIsIkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NSU5UX1RSQU5TRkVSX0hPT0tfRVhURU5TSU9OX1BST0dSQU1fSUQiLCJBTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfTUlOVF9UUkFOU0ZFUl9IT09LX0VYVEVOU0lPTl9BVVRIT1JJVFkiLCJBTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfTUlOVF9UUkFOU0ZFUl9IT09LX0VYVEVOU0lPTiIsIkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NSU5UX1BFUk1BTkVOVF9ERUxFR0FURV9FWFRFTlNJT05fREVMRUdBVEUiLCJBTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfTUlOVF9QRVJNQU5FTlRfREVMRUdBVEVfRVhURU5TSU9OIiwiQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX01JTlRfQ0xPU0VfQVVUSE9SSVRZX0VYVEVOU0lPTl9BVVRIT1JJVFkiLCJBTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfTUlOVF9DTE9TRV9BVVRIT1JJVFlfRVhURU5TSU9OIiwiQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX01JTlRfTUVUQURBVEFfUE9JTlRFUl9FWFRFTlNJT05fTUVUQURBVEFfQUREUkVTUyIsIkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NSU5UX01FVEFEQVRBX1BPSU5URVJfRVhURU5TSU9OX0FVVEhPUklUWSIsIkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NSU5UX01FVEFEQVRBX1BPSU5URVJfRVhURU5TSU9OIiwiQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX01JTlRfR1JPVVBfTUVNQkVSX1BPSU5URVJfRVhURU5TSU9OX01FTUJFUl9BRERSRVNTIiwiQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX01JTlRfR1JPVVBfTUVNQkVSX1BPSU5URVJfRVhURU5TSU9OX0FVVEhPUklUWSIsIkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NSU5UX0dST1VQX01FTUJFUl9QT0lOVEVSX0VYVEVOU0lPTiIsIkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NSU5UX0dST1VQX1BPSU5URVJfRVhURU5TSU9OX0dST1VQX0FERFJFU1MiLCJBTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfTUlOVF9HUk9VUF9QT0lOVEVSX0VYVEVOU0lPTl9BVVRIT1JJVFkiLCJBTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfTUlOVF9HUk9VUF9QT0lOVEVSX0VYVEVOU0lPTiIsIkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9BU1NPQ0lBVEVEX1RPS0VOX1RPS0VOX1BST0dSQU0iLCJBTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfTUlOVF9UT0tFTl9QUk9HUkFNIiwiQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX1RPS0VOX1RPS0VOX1BST0dSQU0iLCJBTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfQUNDT1VOVF9JU19OT05FIiwiQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX1NQQUNFIiwiQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX01JTlRfREVDSU1BTFMiLCJBTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfTUlOVF9GUkVFWkVfQVVUSE9SSVRZIiwiQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX01JTlRfTUlOVF9BVVRIT1JJVFkiLCJBTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfVE9LRU5fT1dORVIiLCJBTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfVE9LRU5fTUlOVCIsIkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9aRVJPIiwiQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX0FERFJFU1MiLCJBTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfQ0xPU0UiLCJBTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfQVNTT0NJQVRFRF9JTklUIiwiQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX0FTU09DSUFURUQiLCJBTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfU1RBVEUiLCJBTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfRVhFQ1VUQUJMRSIsIkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9TRUVEUyIsIkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9SRU5UX0VYRU1QVCIsIkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9PV05FUiIsIkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9SQVciLCJBTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfU0lHTkVSIiwiQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX0hBU19PTkUiLCJBTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfTVVUIiwiQU5DSE9SX0VSUk9SX19FVkVOVF9JTlNUUlVDVElPTl9TVFVCIiwiQU5DSE9SX0VSUk9SX19JRExfQUNDT1VOVF9OT1RfRU1QVFkiLCJBTkNIT1JfRVJST1JfX0lETF9JTlNUUlVDVElPTl9JTlZBTElEX1BST0dSQU0iLCJBTkNIT1JfRVJST1JfX0lETF9JTlNUUlVDVElPTl9TVFVCIiwiQU5DSE9SX0VSUk9SX19JTlNUUlVDVElPTl9ESURfTk9UX1NFUklBTElaRSIsIkFOQ0hPUl9FUlJPUl9fSU5TVFJVQ1RJT05fRElEX05PVF9ERVNFUklBTElaRSIsIkFOQ0hPUl9FUlJPUl9fSU5TVFJVQ1RJT05fRkFMTEJBQ0tfTk9UX0ZPVU5EIiwiQU5DSE9SX0VSUk9SX19JTlNUUlVDVElPTl9NSVNTSU5HIiwiQU5DSE9SX0VSUk9SX19ERVBSRUNBVEVEIiwiQU5DSE9SX0VSUk9SX19JTlZBTElEX05VTUVSSUNfQ09OVkVSU0lPTiIsIkFOQ0hPUl9FUlJPUl9fVFJZSU5HX1RPX0lOSVRfUEFZRVJfQVNfUFJPR1JBTV9BQ0NPVU5UIiwiQU5DSE9SX0VSUk9SX19ERUNMQVJFRF9QUk9HUkFNX0lEX01JU01BVENIIiwiQU5DSE9SX0VSUk9SX19BQ0NPVU5UX0RVUExJQ0FURV9SRUFMTE9DUyIsIkFOQ0hPUl9FUlJPUl9fQUNDT1VOVF9SRUFMTE9DX0VYQ0VFRFNfTElNSVQiLCJBTkNIT1JfRVJST1JfX0FDQ09VTlRfU1lTVkFSX01JU01BVENIIiwiQU5DSE9SX0VSUk9SX19BQ0NPVU5UX05PVF9BU1NPQ0lBVEVEX1RPS0VOX0FDQ09VTlQiLCJBTkNIT1JfRVJST1JfX0FDQ09VTlRfTk9UX1BST0dSQU1fREFUQSIsIkFOQ0hPUl9FUlJPUl9fQUNDT1VOVF9OT1RfSU5JVElBTElaRUQiLCJBTkNIT1JfRVJST1JfX0FDQ09VTlRfTk9UX1NZU1RFTV9PV05FRCIsIkFOQ0hPUl9FUlJPUl9fQUNDT1VOVF9OT1RfU0lHTkVSIiwiQU5DSE9SX0VSUk9SX19JTlZBTElEX1BST0dSQU1fRVhFQ1VUQUJMRSIsIkFOQ0hPUl9FUlJPUl9fSU5WQUxJRF9QUk9HUkFNX0lEIiwiQU5DSE9SX0VSUk9SX19BQ0NPVU5UX09XTkVEX0JZX1dST05HX1BST0dSQU0iLCJBTkNIT1JfRVJST1JfX0FDQ09VTlRfTk9UX01VVEFCTEUiLCJBTkNIT1JfRVJST1JfX0FDQ09VTlRfTk9UX0VOT1VHSF9LRVlTIiwiQU5DSE9SX0VSUk9SX19BQ0NPVU5UX0RJRF9OT1RfU0VSSUFMSVpFIiwiQU5DSE9SX0VSUk9SX19BQ0NPVU5UX0RJRF9OT1RfREVTRVJJQUxJWkUiLCJBTkNIT1JfRVJST1JfX0FDQ09VTlRfRElTQ1JJTUlOQVRPUl9NSVNNQVRDSCIsIkFOQ0hPUl9FUlJPUl9fQUNDT1VOVF9ESVNDUklNSU5BVE9SX05PVF9GT1VORCIsIkFOQ0hPUl9FUlJPUl9fQUNDT1VOVF9ESVNDUklNSU5BVE9SX0FMUkVBRFlfU0VUIiwiQU5DSE9SX0VSUk9SX19SRVFVSVJFX0dURV9WSU9MQVRFRCIsIkFOQ0hPUl9FUlJPUl9fUkVRVUlSRV9HVF9WSU9MQVRFRCIsIkFOQ0hPUl9FUlJPUl9fUkVRVUlSRV9LRVlTX05FUV9WSU9MQVRFRCIsIkFOQ0hPUl9FUlJPUl9fUkVRVUlSRV9ORVFfVklPTEFURUQiLCJBTkNIT1JfRVJST1JfX1JFUVVJUkVfS0VZU19FUV9WSU9MQVRFRCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor-errors/dist/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/borsh/accounts.js":
/*!**************************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/coder/borsh/accounts.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BorshAccountsCoder: () => (/* binding */ BorshAccountsCoder)\n/* harmony export */ });\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bs58 */ \"(ssr)/../node_modules/@coral-xyz/anchor/node_modules/bs58/index.js\");\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bs58__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(buffer__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _idl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./idl.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/borsh/idl.js\");\n/* harmony import */ var _discriminator_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./discriminator.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/borsh/discriminator.js\");\n\n\n\n\n/**\n * Encodes and decodes account objects.\n */ class BorshAccountsCoder {\n    constructor(idl){\n        this.idl = idl;\n        if (!idl.accounts) {\n            this.accountLayouts = new Map();\n            return;\n        }\n        const types = idl.types;\n        if (!types) {\n            throw new Error(\"Accounts require `idl.types`\");\n        }\n        const layouts = idl.accounts.map((acc)=>{\n            const typeDef = types.find((ty)=>ty.name === acc.name);\n            if (!typeDef) {\n                throw new Error(`Account not found: ${acc.name}`);\n            }\n            return [\n                acc.name,\n                _idl_js__WEBPACK_IMPORTED_MODULE_2__.IdlCoder.typeDefLayout({\n                    typeDef,\n                    types\n                })\n            ];\n        });\n        this.accountLayouts = new Map(layouts);\n    }\n    async encode(accountName, account) {\n        const buffer = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.alloc(1000); // TODO: use a tighter buffer.\n        const layout = this.accountLayouts.get(accountName);\n        if (!layout) {\n            throw new Error(`Unknown account: ${accountName}`);\n        }\n        const len = layout.encode(account, buffer);\n        const accountData = buffer.slice(0, len);\n        const discriminator = this.accountDiscriminator(accountName);\n        return buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([\n            discriminator,\n            accountData\n        ]);\n    }\n    decode(accountName, data) {\n        // Assert the account discriminator is correct.\n        const discriminator = this.accountDiscriminator(accountName);\n        if (discriminator.compare(data.slice(0, _discriminator_js__WEBPACK_IMPORTED_MODULE_3__.DISCRIMINATOR_SIZE))) {\n            throw new Error(\"Invalid account discriminator\");\n        }\n        return this.decodeUnchecked(accountName, data);\n    }\n    decodeAny(data) {\n        const discriminator = data.slice(0, _discriminator_js__WEBPACK_IMPORTED_MODULE_3__.DISCRIMINATOR_SIZE);\n        const accountName = Array.from(this.accountLayouts.keys()).find((key)=>this.accountDiscriminator(key).equals(discriminator));\n        if (!accountName) {\n            throw new Error(\"Account not found\");\n        }\n        return this.decodeUnchecked(accountName, data);\n    }\n    decodeUnchecked(accountName, acc) {\n        // Chop off the discriminator before decoding.\n        const data = acc.subarray(_discriminator_js__WEBPACK_IMPORTED_MODULE_3__.DISCRIMINATOR_SIZE);\n        const layout = this.accountLayouts.get(accountName);\n        if (!layout) {\n            throw new Error(`Unknown account: ${accountName}`);\n        }\n        return layout.decode(data);\n    }\n    memcmp(accountName, appendData) {\n        const discriminator = this.accountDiscriminator(accountName);\n        return {\n            offset: 0,\n            bytes: bs58__WEBPACK_IMPORTED_MODULE_0___default().encode(appendData ? buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([\n                discriminator,\n                appendData\n            ]) : discriminator)\n        };\n    }\n    size(accountName) {\n        return _discriminator_js__WEBPACK_IMPORTED_MODULE_3__.DISCRIMINATOR_SIZE + _idl_js__WEBPACK_IMPORTED_MODULE_2__.IdlCoder.typeSize({\n            defined: {\n                name: accountName\n            }\n        }, this.idl);\n    }\n    /**\n     * Calculates and returns a unique 8 byte discriminator prepended to all anchor accounts.\n     *\n     * @param name The name of the account to calculate the discriminator.\n     */ accountDiscriminator(name) {\n        var _a;\n        const account = (_a = this.idl.accounts) === null || _a === void 0 ? void 0 : _a.find((acc)=>acc.name === name);\n        if (!account) {\n            throw new Error(`Account not found: ${name}`);\n        }\n        return buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(account.discriminator);\n    }\n} //# sourceMappingURL=accounts.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL2NvZGVyL2JvcnNoL2FjY291bnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBd0I7QUFDUTtBQUNJO0FBQ29CO0FBQ3hEOztDQUVDLEdBQ00sTUFBTUk7SUFDVEMsWUFBWUMsR0FBRyxDQUFFO1FBQ2IsSUFBSSxDQUFDQSxHQUFHLEdBQUdBO1FBQ1gsSUFBSSxDQUFDQSxJQUFJQyxRQUFRLEVBQUU7WUFDZixJQUFJLENBQUNDLGNBQWMsR0FBRyxJQUFJQztZQUMxQjtRQUNKO1FBQ0EsTUFBTUMsUUFBUUosSUFBSUksS0FBSztRQUN2QixJQUFJLENBQUNBLE9BQU87WUFDUixNQUFNLElBQUlDLE1BQU07UUFDcEI7UUFDQSxNQUFNQyxVQUFVTixJQUFJQyxRQUFRLENBQUNNLEdBQUcsQ0FBQyxDQUFDQztZQUM5QixNQUFNQyxVQUFVTCxNQUFNTSxJQUFJLENBQUMsQ0FBQ0MsS0FBT0EsR0FBR0MsSUFBSSxLQUFLSixJQUFJSSxJQUFJO1lBQ3ZELElBQUksQ0FBQ0gsU0FBUztnQkFDVixNQUFNLElBQUlKLE1BQU0sQ0FBQyxtQkFBbUIsRUFBRUcsSUFBSUksSUFBSSxDQUFDLENBQUM7WUFDcEQ7WUFDQSxPQUFPO2dCQUFDSixJQUFJSSxJQUFJO2dCQUFFaEIsNkNBQVFBLENBQUNpQixhQUFhLENBQUM7b0JBQUVKO29CQUFTTDtnQkFBTTthQUFHO1FBQ2pFO1FBQ0EsSUFBSSxDQUFDRixjQUFjLEdBQUcsSUFBSUMsSUFBSUc7SUFDbEM7SUFDQSxNQUFNUSxPQUFPQyxXQUFXLEVBQUVDLE9BQU8sRUFBRTtRQUMvQixNQUFNQyxTQUFTdEIsMENBQU1BLENBQUN1QixLQUFLLENBQUMsT0FBTyw4QkFBOEI7UUFDakUsTUFBTUMsU0FBUyxJQUFJLENBQUNqQixjQUFjLENBQUNrQixHQUFHLENBQUNMO1FBQ3ZDLElBQUksQ0FBQ0ksUUFBUTtZQUNULE1BQU0sSUFBSWQsTUFBTSxDQUFDLGlCQUFpQixFQUFFVSxZQUFZLENBQUM7UUFDckQ7UUFDQSxNQUFNTSxNQUFNRixPQUFPTCxNQUFNLENBQUNFLFNBQVNDO1FBQ25DLE1BQU1LLGNBQWNMLE9BQU9NLEtBQUssQ0FBQyxHQUFHRjtRQUNwQyxNQUFNRyxnQkFBZ0IsSUFBSSxDQUFDQyxvQkFBb0IsQ0FBQ1Y7UUFDaEQsT0FBT3BCLDBDQUFNQSxDQUFDK0IsTUFBTSxDQUFDO1lBQUNGO1lBQWVGO1NBQVk7SUFDckQ7SUFDQUssT0FBT1osV0FBVyxFQUFFYSxJQUFJLEVBQUU7UUFDdEIsK0NBQStDO1FBQy9DLE1BQU1KLGdCQUFnQixJQUFJLENBQUNDLG9CQUFvQixDQUFDVjtRQUNoRCxJQUFJUyxjQUFjSyxPQUFPLENBQUNELEtBQUtMLEtBQUssQ0FBQyxHQUFHMUIsaUVBQWtCQSxJQUFJO1lBQzFELE1BQU0sSUFBSVEsTUFBTTtRQUNwQjtRQUNBLE9BQU8sSUFBSSxDQUFDeUIsZUFBZSxDQUFDZixhQUFhYTtJQUM3QztJQUNBRyxVQUFVSCxJQUFJLEVBQUU7UUFDWixNQUFNSixnQkFBZ0JJLEtBQUtMLEtBQUssQ0FBQyxHQUFHMUIsaUVBQWtCQTtRQUN0RCxNQUFNa0IsY0FBY2lCLE1BQU1DLElBQUksQ0FBQyxJQUFJLENBQUMvQixjQUFjLENBQUNnQyxJQUFJLElBQUl4QixJQUFJLENBQUMsQ0FBQ3lCLE1BQVEsSUFBSSxDQUFDVixvQkFBb0IsQ0FBQ1UsS0FBS0MsTUFBTSxDQUFDWjtRQUMvRyxJQUFJLENBQUNULGFBQWE7WUFDZCxNQUFNLElBQUlWLE1BQU07UUFDcEI7UUFDQSxPQUFPLElBQUksQ0FBQ3lCLGVBQWUsQ0FBQ2YsYUFBYWE7SUFDN0M7SUFDQUUsZ0JBQWdCZixXQUFXLEVBQUVQLEdBQUcsRUFBRTtRQUM5Qiw4Q0FBOEM7UUFDOUMsTUFBTW9CLE9BQU9wQixJQUFJNkIsUUFBUSxDQUFDeEMsaUVBQWtCQTtRQUM1QyxNQUFNc0IsU0FBUyxJQUFJLENBQUNqQixjQUFjLENBQUNrQixHQUFHLENBQUNMO1FBQ3ZDLElBQUksQ0FBQ0ksUUFBUTtZQUNULE1BQU0sSUFBSWQsTUFBTSxDQUFDLGlCQUFpQixFQUFFVSxZQUFZLENBQUM7UUFDckQ7UUFDQSxPQUFPSSxPQUFPUSxNQUFNLENBQUNDO0lBQ3pCO0lBQ0FVLE9BQU92QixXQUFXLEVBQUV3QixVQUFVLEVBQUU7UUFDNUIsTUFBTWYsZ0JBQWdCLElBQUksQ0FBQ0Msb0JBQW9CLENBQUNWO1FBQ2hELE9BQU87WUFDSHlCLFFBQVE7WUFDUkMsT0FBTy9DLGtEQUFXLENBQUM2QyxhQUFhNUMsMENBQU1BLENBQUMrQixNQUFNLENBQUM7Z0JBQUNGO2dCQUFlZTthQUFXLElBQUlmO1FBQ2pGO0lBQ0o7SUFDQWtCLEtBQUszQixXQUFXLEVBQUU7UUFDZCxPQUFRbEIsaUVBQWtCQSxHQUN0QkQsNkNBQVFBLENBQUMrQyxRQUFRLENBQUM7WUFBRUMsU0FBUztnQkFBRWhDLE1BQU1HO1lBQVk7UUFBRSxHQUFHLElBQUksQ0FBQ2YsR0FBRztJQUN0RTtJQUNBOzs7O0tBSUMsR0FDRHlCLHFCQUFxQmIsSUFBSSxFQUFFO1FBQ3ZCLElBQUlpQztRQUNKLE1BQU03QixVQUFVLENBQUM2QixLQUFLLElBQUksQ0FBQzdDLEdBQUcsQ0FBQ0MsUUFBUSxNQUFNLFFBQVE0QyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUduQyxJQUFJLENBQUMsQ0FBQ0YsTUFBUUEsSUFBSUksSUFBSSxLQUFLQTtRQUM1RyxJQUFJLENBQUNJLFNBQVM7WUFDVixNQUFNLElBQUlYLE1BQU0sQ0FBQyxtQkFBbUIsRUFBRU8sS0FBSyxDQUFDO1FBQ2hEO1FBQ0EsT0FBT2pCLDBDQUFNQSxDQUFDc0MsSUFBSSxDQUFDakIsUUFBUVEsYUFBYTtJQUM1QztBQUNKLEVBQ0Esb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AY29yYWwteHl6L2FuY2hvci9kaXN0L2VzbS9jb2Rlci9ib3JzaC9hY2NvdW50cy5qcz85ZmNiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBiczU4IGZyb20gXCJiczU4XCI7XG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tIFwiYnVmZmVyXCI7XG5pbXBvcnQgeyBJZGxDb2RlciB9IGZyb20gXCIuL2lkbC5qc1wiO1xuaW1wb3J0IHsgRElTQ1JJTUlOQVRPUl9TSVpFIH0gZnJvbSBcIi4vZGlzY3JpbWluYXRvci5qc1wiO1xuLyoqXG4gKiBFbmNvZGVzIGFuZCBkZWNvZGVzIGFjY291bnQgb2JqZWN0cy5cbiAqL1xuZXhwb3J0IGNsYXNzIEJvcnNoQWNjb3VudHNDb2RlciB7XG4gICAgY29uc3RydWN0b3IoaWRsKSB7XG4gICAgICAgIHRoaXMuaWRsID0gaWRsO1xuICAgICAgICBpZiAoIWlkbC5hY2NvdW50cykge1xuICAgICAgICAgICAgdGhpcy5hY2NvdW50TGF5b3V0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlcyA9IGlkbC50eXBlcztcbiAgICAgICAgaWYgKCF0eXBlcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWNjb3VudHMgcmVxdWlyZSBgaWRsLnR5cGVzYFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXlvdXRzID0gaWRsLmFjY291bnRzLm1hcCgoYWNjKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0eXBlRGVmID0gdHlwZXMuZmluZCgodHkpID0+IHR5Lm5hbWUgPT09IGFjYy5uYW1lKTtcbiAgICAgICAgICAgIGlmICghdHlwZURlZikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQWNjb3VudCBub3QgZm91bmQ6ICR7YWNjLm5hbWV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW2FjYy5uYW1lLCBJZGxDb2Rlci50eXBlRGVmTGF5b3V0KHsgdHlwZURlZiwgdHlwZXMgfSldO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hY2NvdW50TGF5b3V0cyA9IG5ldyBNYXAobGF5b3V0cyk7XG4gICAgfVxuICAgIGFzeW5jIGVuY29kZShhY2NvdW50TmFtZSwgYWNjb3VudCkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTAwMCk7IC8vIFRPRE86IHVzZSBhIHRpZ2h0ZXIgYnVmZmVyLlxuICAgICAgICBjb25zdCBsYXlvdXQgPSB0aGlzLmFjY291bnRMYXlvdXRzLmdldChhY2NvdW50TmFtZSk7XG4gICAgICAgIGlmICghbGF5b3V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gYWNjb3VudDogJHthY2NvdW50TmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW4gPSBsYXlvdXQuZW5jb2RlKGFjY291bnQsIGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IGFjY291bnREYXRhID0gYnVmZmVyLnNsaWNlKDAsIGxlbik7XG4gICAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3IgPSB0aGlzLmFjY291bnREaXNjcmltaW5hdG9yKGFjY291bnROYW1lKTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2Rpc2NyaW1pbmF0b3IsIGFjY291bnREYXRhXSk7XG4gICAgfVxuICAgIGRlY29kZShhY2NvdW50TmFtZSwgZGF0YSkge1xuICAgICAgICAvLyBBc3NlcnQgdGhlIGFjY291bnQgZGlzY3JpbWluYXRvciBpcyBjb3JyZWN0LlxuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yID0gdGhpcy5hY2NvdW50RGlzY3JpbWluYXRvcihhY2NvdW50TmFtZSk7XG4gICAgICAgIGlmIChkaXNjcmltaW5hdG9yLmNvbXBhcmUoZGF0YS5zbGljZSgwLCBESVNDUklNSU5BVE9SX1NJWkUpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhY2NvdW50IGRpc2NyaW1pbmF0b3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlVW5jaGVja2VkKGFjY291bnROYW1lLCBkYXRhKTtcbiAgICB9XG4gICAgZGVjb2RlQW55KGRhdGEpIHtcbiAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvciA9IGRhdGEuc2xpY2UoMCwgRElTQ1JJTUlOQVRPUl9TSVpFKTtcbiAgICAgICAgY29uc3QgYWNjb3VudE5hbWUgPSBBcnJheS5mcm9tKHRoaXMuYWNjb3VudExheW91dHMua2V5cygpKS5maW5kKChrZXkpID0+IHRoaXMuYWNjb3VudERpc2NyaW1pbmF0b3Ioa2V5KS5lcXVhbHMoZGlzY3JpbWluYXRvcikpO1xuICAgICAgICBpZiAoIWFjY291bnROYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBY2NvdW50IG5vdCBmb3VuZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVVbmNoZWNrZWQoYWNjb3VudE5hbWUsIGRhdGEpO1xuICAgIH1cbiAgICBkZWNvZGVVbmNoZWNrZWQoYWNjb3VudE5hbWUsIGFjYykge1xuICAgICAgICAvLyBDaG9wIG9mZiB0aGUgZGlzY3JpbWluYXRvciBiZWZvcmUgZGVjb2RpbmcuXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhY2Muc3ViYXJyYXkoRElTQ1JJTUlOQVRPUl9TSVpFKTtcbiAgICAgICAgY29uc3QgbGF5b3V0ID0gdGhpcy5hY2NvdW50TGF5b3V0cy5nZXQoYWNjb3VudE5hbWUpO1xuICAgICAgICBpZiAoIWxheW91dCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGFjY291bnQ6ICR7YWNjb3VudE5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxheW91dC5kZWNvZGUoZGF0YSk7XG4gICAgfVxuICAgIG1lbWNtcChhY2NvdW50TmFtZSwgYXBwZW5kRGF0YSkge1xuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yID0gdGhpcy5hY2NvdW50RGlzY3JpbWluYXRvcihhY2NvdW50TmFtZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgICBieXRlczogYnM1OC5lbmNvZGUoYXBwZW5kRGF0YSA/IEJ1ZmZlci5jb25jYXQoW2Rpc2NyaW1pbmF0b3IsIGFwcGVuZERhdGFdKSA6IGRpc2NyaW1pbmF0b3IpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzaXplKGFjY291bnROYW1lKSB7XG4gICAgICAgIHJldHVybiAoRElTQ1JJTUlOQVRPUl9TSVpFICtcbiAgICAgICAgICAgIElkbENvZGVyLnR5cGVTaXplKHsgZGVmaW5lZDogeyBuYW1lOiBhY2NvdW50TmFtZSB9IH0sIHRoaXMuaWRsKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgYW5kIHJldHVybnMgYSB1bmlxdWUgOCBieXRlIGRpc2NyaW1pbmF0b3IgcHJlcGVuZGVkIHRvIGFsbCBhbmNob3IgYWNjb3VudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgYWNjb3VudCB0byBjYWxjdWxhdGUgdGhlIGRpc2NyaW1pbmF0b3IuXG4gICAgICovXG4gICAgYWNjb3VudERpc2NyaW1pbmF0b3IobmFtZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGFjY291bnQgPSAoX2EgPSB0aGlzLmlkbC5hY2NvdW50cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbmQoKGFjYykgPT4gYWNjLm5hbWUgPT09IG5hbWUpO1xuICAgICAgICBpZiAoIWFjY291bnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQWNjb3VudCBub3QgZm91bmQ6ICR7bmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oYWNjb3VudC5kaXNjcmltaW5hdG9yKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY2NvdW50cy5qcy5tYXAiXSwibmFtZXMiOlsiYnM1OCIsIkJ1ZmZlciIsIklkbENvZGVyIiwiRElTQ1JJTUlOQVRPUl9TSVpFIiwiQm9yc2hBY2NvdW50c0NvZGVyIiwiY29uc3RydWN0b3IiLCJpZGwiLCJhY2NvdW50cyIsImFjY291bnRMYXlvdXRzIiwiTWFwIiwidHlwZXMiLCJFcnJvciIsImxheW91dHMiLCJtYXAiLCJhY2MiLCJ0eXBlRGVmIiwiZmluZCIsInR5IiwibmFtZSIsInR5cGVEZWZMYXlvdXQiLCJlbmNvZGUiLCJhY2NvdW50TmFtZSIsImFjY291bnQiLCJidWZmZXIiLCJhbGxvYyIsImxheW91dCIsImdldCIsImxlbiIsImFjY291bnREYXRhIiwic2xpY2UiLCJkaXNjcmltaW5hdG9yIiwiYWNjb3VudERpc2NyaW1pbmF0b3IiLCJjb25jYXQiLCJkZWNvZGUiLCJkYXRhIiwiY29tcGFyZSIsImRlY29kZVVuY2hlY2tlZCIsImRlY29kZUFueSIsIkFycmF5IiwiZnJvbSIsImtleXMiLCJrZXkiLCJlcXVhbHMiLCJzdWJhcnJheSIsIm1lbWNtcCIsImFwcGVuZERhdGEiLCJvZmZzZXQiLCJieXRlcyIsInNpemUiLCJ0eXBlU2l6ZSIsImRlZmluZWQiLCJfYSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/borsh/accounts.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/borsh/discriminator.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/coder/borsh/discriminator.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DISCRIMINATOR_SIZE: () => (/* binding */ DISCRIMINATOR_SIZE)\n/* harmony export */ });\n/**\n * Number of bytes in anchor discriminators\n */ const DISCRIMINATOR_SIZE = 8; //# sourceMappingURL=discriminator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL2NvZGVyL2JvcnNoL2Rpc2NyaW1pbmF0b3IuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOztDQUVDLEdBQ00sTUFBTUEscUJBQXFCLEVBQUUsQ0FDcEMseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AY29yYWwteHl6L2FuY2hvci9kaXN0L2VzbS9jb2Rlci9ib3JzaC9kaXNjcmltaW5hdG9yLmpzP2Y4MzAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBOdW1iZXIgb2YgYnl0ZXMgaW4gYW5jaG9yIGRpc2NyaW1pbmF0b3JzXG4gKi9cbmV4cG9ydCBjb25zdCBESVNDUklNSU5BVE9SX1NJWkUgPSA4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlzY3JpbWluYXRvci5qcy5tYXAiXSwibmFtZXMiOlsiRElTQ1JJTUlOQVRPUl9TSVpFIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/borsh/discriminator.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/borsh/event.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/coder/borsh/event.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BorshEventCoder: () => (/* binding */ BorshEventCoder)\n/* harmony export */ });\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(buffer__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_bytes_base64_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/bytes/base64.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/bytes/base64.js\");\n/* harmony import */ var _idl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./idl.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/borsh/idl.js\");\n\n\n\nclass BorshEventCoder {\n    constructor(idl){\n        var _a;\n        if (!idl.events) {\n            this.layouts = new Map();\n            return;\n        }\n        const types = idl.types;\n        if (!types) {\n            throw new Error(\"Events require `idl.types`\");\n        }\n        const layouts = idl.events.map((ev)=>{\n            const typeDef = types.find((ty)=>ty.name === ev.name);\n            if (!typeDef) {\n                throw new Error(`Event not found: ${ev.name}`);\n            }\n            return [\n                ev.name,\n                _idl_js__WEBPACK_IMPORTED_MODULE_2__.IdlCoder.typeDefLayout({\n                    typeDef,\n                    types\n                })\n            ];\n        });\n        this.layouts = new Map(layouts);\n        this.discriminators = new Map(((_a = idl.events) !== null && _a !== void 0 ? _a : []).map((ev)=>[\n                _utils_bytes_base64_js__WEBPACK_IMPORTED_MODULE_1__.encode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(ev.discriminator)),\n                ev.name\n            ]));\n    }\n    decode(log) {\n        let logArr;\n        // This will throw if log length is not a multiple of 4.\n        try {\n            logArr = _utils_bytes_base64_js__WEBPACK_IMPORTED_MODULE_1__.decode(log);\n        } catch (e) {\n            return null;\n        }\n        const disc = _utils_bytes_base64_js__WEBPACK_IMPORTED_MODULE_1__.encode(logArr.slice(0, 8));\n        // Only deserialize if the discriminator implies a proper event.\n        const eventName = this.discriminators.get(disc);\n        if (!eventName) {\n            return null;\n        }\n        const layout = this.layouts.get(eventName);\n        if (!layout) {\n            throw new Error(`Unknown event: ${eventName}`);\n        }\n        const data = layout.decode(logArr.slice(8));\n        return {\n            data,\n            name: eventName\n        };\n    }\n} //# sourceMappingURL=event.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL2NvZGVyL2JvcnNoL2V2ZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWdDO0FBQ3NCO0FBQ2xCO0FBQzdCLE1BQU1HO0lBQ1RDLFlBQVlDLEdBQUcsQ0FBRTtRQUNiLElBQUlDO1FBQ0osSUFBSSxDQUFDRCxJQUFJRSxNQUFNLEVBQUU7WUFDYixJQUFJLENBQUNDLE9BQU8sR0FBRyxJQUFJQztZQUNuQjtRQUNKO1FBQ0EsTUFBTUMsUUFBUUwsSUFBSUssS0FBSztRQUN2QixJQUFJLENBQUNBLE9BQU87WUFDUixNQUFNLElBQUlDLE1BQU07UUFDcEI7UUFDQSxNQUFNSCxVQUFVSCxJQUFJRSxNQUFNLENBQUNLLEdBQUcsQ0FBQyxDQUFDQztZQUM1QixNQUFNQyxVQUFVSixNQUFNSyxJQUFJLENBQUMsQ0FBQ0MsS0FBT0EsR0FBR0MsSUFBSSxLQUFLSixHQUFHSSxJQUFJO1lBQ3RELElBQUksQ0FBQ0gsU0FBUztnQkFDVixNQUFNLElBQUlILE1BQU0sQ0FBQyxpQkFBaUIsRUFBRUUsR0FBR0ksSUFBSSxDQUFDLENBQUM7WUFDakQ7WUFDQSxPQUFPO2dCQUFDSixHQUFHSSxJQUFJO2dCQUFFZiw2Q0FBUUEsQ0FBQ2dCLGFBQWEsQ0FBQztvQkFBRUo7b0JBQVNKO2dCQUFNO2FBQUc7UUFDaEU7UUFDQSxJQUFJLENBQUNGLE9BQU8sR0FBRyxJQUFJQyxJQUFJRDtRQUN2QixJQUFJLENBQUNXLGNBQWMsR0FBRyxJQUFJVixJQUFJLENBQUMsQ0FBQ0gsS0FBS0QsSUFBSUUsTUFBTSxNQUFNLFFBQVFELE9BQU8sS0FBSyxJQUFJQSxLQUFLLEVBQUUsRUFBRU0sR0FBRyxDQUFDLENBQUNDLEtBQU87Z0JBQzlGWiwwREFBYSxDQUFDRCwwQ0FBTUEsQ0FBQ3FCLElBQUksQ0FBQ1IsR0FBR1MsYUFBYTtnQkFDMUNULEdBQUdJLElBQUk7YUFDVjtJQUNMO0lBQ0FNLE9BQU9DLEdBQUcsRUFBRTtRQUNSLElBQUlDO1FBQ0osd0RBQXdEO1FBQ3hELElBQUk7WUFDQUEsU0FBU3hCLDBEQUFhLENBQUN1QjtRQUMzQixFQUNBLE9BQU9FLEdBQUc7WUFDTixPQUFPO1FBQ1g7UUFDQSxNQUFNQyxPQUFPMUIsMERBQWEsQ0FBQ3dCLE9BQU9HLEtBQUssQ0FBQyxHQUFHO1FBQzNDLGdFQUFnRTtRQUNoRSxNQUFNQyxZQUFZLElBQUksQ0FBQ1YsY0FBYyxDQUFDVyxHQUFHLENBQUNIO1FBQzFDLElBQUksQ0FBQ0UsV0FBVztZQUNaLE9BQU87UUFDWDtRQUNBLE1BQU1FLFNBQVMsSUFBSSxDQUFDdkIsT0FBTyxDQUFDc0IsR0FBRyxDQUFDRDtRQUNoQyxJQUFJLENBQUNFLFFBQVE7WUFDVCxNQUFNLElBQUlwQixNQUFNLENBQUMsZUFBZSxFQUFFa0IsVUFBVSxDQUFDO1FBQ2pEO1FBQ0EsTUFBTUcsT0FBT0QsT0FBT1IsTUFBTSxDQUFDRSxPQUFPRyxLQUFLLENBQUM7UUFDeEMsT0FBTztZQUFFSTtZQUFNZixNQUFNWTtRQUFVO0lBQ25DO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL2NvZGVyL2JvcnNoL2V2ZW50LmpzP2Q4YjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSBcImJ1ZmZlclwiO1xuaW1wb3J0ICogYXMgYmFzZTY0IGZyb20gXCIuLi8uLi91dGlscy9ieXRlcy9iYXNlNjQuanNcIjtcbmltcG9ydCB7IElkbENvZGVyIH0gZnJvbSBcIi4vaWRsLmpzXCI7XG5leHBvcnQgY2xhc3MgQm9yc2hFdmVudENvZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihpZGwpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIWlkbC5ldmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlcyA9IGlkbC50eXBlcztcbiAgICAgICAgaWYgKCF0eXBlcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRzIHJlcXVpcmUgYGlkbC50eXBlc2BcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGF5b3V0cyA9IGlkbC5ldmVudHMubWFwKChldikgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHlwZURlZiA9IHR5cGVzLmZpbmQoKHR5KSA9PiB0eS5uYW1lID09PSBldi5uYW1lKTtcbiAgICAgICAgICAgIGlmICghdHlwZURlZikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXZlbnQgbm90IGZvdW5kOiAke2V2Lm5hbWV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW2V2Lm5hbWUsIElkbENvZGVyLnR5cGVEZWZMYXlvdXQoeyB0eXBlRGVmLCB0eXBlcyB9KV07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxheW91dHMgPSBuZXcgTWFwKGxheW91dHMpO1xuICAgICAgICB0aGlzLmRpc2NyaW1pbmF0b3JzID0gbmV3IE1hcCgoKF9hID0gaWRsLmV2ZW50cykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pLm1hcCgoZXYpID0+IFtcbiAgICAgICAgICAgIGJhc2U2NC5lbmNvZGUoQnVmZmVyLmZyb20oZXYuZGlzY3JpbWluYXRvcikpLFxuICAgICAgICAgICAgZXYubmFtZSxcbiAgICAgICAgXSkpO1xuICAgIH1cbiAgICBkZWNvZGUobG9nKSB7XG4gICAgICAgIGxldCBsb2dBcnI7XG4gICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiBsb2cgbGVuZ3RoIGlzIG5vdCBhIG11bHRpcGxlIG9mIDQuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsb2dBcnIgPSBiYXNlNjQuZGVjb2RlKGxvZyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpc2MgPSBiYXNlNjQuZW5jb2RlKGxvZ0Fyci5zbGljZSgwLCA4KSk7XG4gICAgICAgIC8vIE9ubHkgZGVzZXJpYWxpemUgaWYgdGhlIGRpc2NyaW1pbmF0b3IgaW1wbGllcyBhIHByb3BlciBldmVudC5cbiAgICAgICAgY29uc3QgZXZlbnROYW1lID0gdGhpcy5kaXNjcmltaW5hdG9ycy5nZXQoZGlzYyk7XG4gICAgICAgIGlmICghZXZlbnROYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXlvdXQgPSB0aGlzLmxheW91dHMuZ2V0KGV2ZW50TmFtZSk7XG4gICAgICAgIGlmICghbGF5b3V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZXZlbnQ6ICR7ZXZlbnROYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBsYXlvdXQuZGVjb2RlKGxvZ0Fyci5zbGljZSg4KSk7XG4gICAgICAgIHJldHVybiB7IGRhdGEsIG5hbWU6IGV2ZW50TmFtZSB9O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50LmpzLm1hcCJdLCJuYW1lcyI6WyJCdWZmZXIiLCJiYXNlNjQiLCJJZGxDb2RlciIsIkJvcnNoRXZlbnRDb2RlciIsImNvbnN0cnVjdG9yIiwiaWRsIiwiX2EiLCJldmVudHMiLCJsYXlvdXRzIiwiTWFwIiwidHlwZXMiLCJFcnJvciIsIm1hcCIsImV2IiwidHlwZURlZiIsImZpbmQiLCJ0eSIsIm5hbWUiLCJ0eXBlRGVmTGF5b3V0IiwiZGlzY3JpbWluYXRvcnMiLCJlbmNvZGUiLCJmcm9tIiwiZGlzY3JpbWluYXRvciIsImRlY29kZSIsImxvZyIsImxvZ0FyciIsImUiLCJkaXNjIiwic2xpY2UiLCJldmVudE5hbWUiLCJnZXQiLCJsYXlvdXQiLCJkYXRhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/borsh/event.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/borsh/idl.js":
/*!*********************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/coder/borsh/idl.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IdlCoder: () => (/* binding */ IdlCoder)\n/* harmony export */ });\n/* harmony import */ var _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @coral-xyz/borsh */ \"(ssr)/../node_modules/@coral-xyz/anchor/node_modules/@coral-xyz/borsh/dist/index.js\");\n/* harmony import */ var _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _idl_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../idl.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/idl.js\");\n/* harmony import */ var _error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../error.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/error.js\");\n\n\n\nclass IdlCoder {\n    static fieldLayout(field, types = [], genericArgs) {\n        const fieldName = field.name;\n        switch(field.type){\n            case \"bool\":\n                {\n                    return _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_0__.bool(fieldName);\n                }\n            case \"u8\":\n                {\n                    return _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_0__.u8(fieldName);\n                }\n            case \"i8\":\n                {\n                    return _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_0__.i8(fieldName);\n                }\n            case \"u16\":\n                {\n                    return _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_0__.u16(fieldName);\n                }\n            case \"i16\":\n                {\n                    return _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_0__.i16(fieldName);\n                }\n            case \"u32\":\n                {\n                    return _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_0__.u32(fieldName);\n                }\n            case \"i32\":\n                {\n                    return _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_0__.i32(fieldName);\n                }\n            case \"f32\":\n                {\n                    return _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_0__.f32(fieldName);\n                }\n            case \"u64\":\n                {\n                    return _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_0__.u64(fieldName);\n                }\n            case \"i64\":\n                {\n                    return _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_0__.i64(fieldName);\n                }\n            case \"f64\":\n                {\n                    return _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_0__.f64(fieldName);\n                }\n            case \"u128\":\n                {\n                    return _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_0__.u128(fieldName);\n                }\n            case \"i128\":\n                {\n                    return _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_0__.i128(fieldName);\n                }\n            case \"u256\":\n                {\n                    return _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_0__.u256(fieldName);\n                }\n            case \"i256\":\n                {\n                    return _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_0__.i256(fieldName);\n                }\n            case \"bytes\":\n                {\n                    return _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_0__.vecU8(fieldName);\n                }\n            case \"string\":\n                {\n                    return _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_0__.str(fieldName);\n                }\n            case \"pubkey\":\n                {\n                    return _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_0__.publicKey(fieldName);\n                }\n            default:\n                {\n                    if (\"option\" in field.type) {\n                        return _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_0__.option(IdlCoder.fieldLayout({\n                            type: field.type.option\n                        }, types, genericArgs), fieldName);\n                    }\n                    if (\"vec\" in field.type) {\n                        return _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_0__.vec(IdlCoder.fieldLayout({\n                            type: field.type.vec\n                        }, types, genericArgs), fieldName);\n                    }\n                    if (\"array\" in field.type) {\n                        let [type, len] = field.type.array;\n                        len = IdlCoder.resolveArrayLen(len, genericArgs);\n                        return _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_0__.array(IdlCoder.fieldLayout({\n                            type\n                        }, types, genericArgs), len, fieldName);\n                    }\n                    if (\"defined\" in field.type) {\n                        if (!types) {\n                            throw new _error_js__WEBPACK_IMPORTED_MODULE_2__.IdlError(\"User defined types not provided\");\n                        }\n                        const definedName = field.type.defined.name;\n                        const typeDef = types.find((t)=>t.name === definedName);\n                        if (!typeDef) {\n                            throw new _error_js__WEBPACK_IMPORTED_MODULE_2__.IdlError(`Type not found: ${field.name}`);\n                        }\n                        return IdlCoder.typeDefLayout({\n                            typeDef,\n                            types,\n                            genericArgs: genericArgs !== null && genericArgs !== void 0 ? genericArgs : field.type.defined.generics,\n                            name: fieldName\n                        });\n                    }\n                    if (\"generic\" in field.type) {\n                        const genericArg = genericArgs === null || genericArgs === void 0 ? void 0 : genericArgs.at(0);\n                        if ((genericArg === null || genericArg === void 0 ? void 0 : genericArg.kind) !== \"type\") {\n                            throw new _error_js__WEBPACK_IMPORTED_MODULE_2__.IdlError(`Invalid generic field: ${field.name}`);\n                        }\n                        return IdlCoder.fieldLayout({\n                            ...field,\n                            type: genericArg.type\n                        }, types);\n                    }\n                    throw new _error_js__WEBPACK_IMPORTED_MODULE_2__.IdlError(`Not yet implemented: ${JSON.stringify(field.type)}`);\n                }\n        }\n    }\n    /**\n     * Get the type layout of the given defined type(struct or enum).\n     */ static typeDefLayout({ typeDef, types, name, genericArgs }) {\n        switch(typeDef.type.kind){\n            case \"struct\":\n                {\n                    const fieldLayouts = (0,_idl_js__WEBPACK_IMPORTED_MODULE_1__.handleDefinedFields)(typeDef.type.fields, ()=>[], (fields)=>fields.map((f)=>{\n                            const genArgs = genericArgs ? IdlCoder.resolveGenericArgs({\n                                type: f.type,\n                                typeDef,\n                                genericArgs\n                            }) : genericArgs;\n                            return IdlCoder.fieldLayout(f, types, genArgs);\n                        }), (fields)=>fields.map((f, i)=>{\n                            const genArgs = genericArgs ? IdlCoder.resolveGenericArgs({\n                                type: f,\n                                typeDef,\n                                genericArgs\n                            }) : genericArgs;\n                            return IdlCoder.fieldLayout({\n                                name: i.toString(),\n                                type: f\n                            }, types, genArgs);\n                        }));\n                    return _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_0__.struct(fieldLayouts, name);\n                }\n            case \"enum\":\n                {\n                    const variants = typeDef.type.variants.map((variant)=>{\n                        const fieldLayouts = (0,_idl_js__WEBPACK_IMPORTED_MODULE_1__.handleDefinedFields)(variant.fields, ()=>[], (fields)=>fields.map((f)=>{\n                                const genArgs = genericArgs ? IdlCoder.resolveGenericArgs({\n                                    type: f.type,\n                                    typeDef,\n                                    genericArgs\n                                }) : genericArgs;\n                                return IdlCoder.fieldLayout(f, types, genArgs);\n                            }), (fields)=>fields.map((f, i)=>{\n                                const genArgs = genericArgs ? IdlCoder.resolveGenericArgs({\n                                    type: f,\n                                    typeDef,\n                                    genericArgs\n                                }) : genericArgs;\n                                return IdlCoder.fieldLayout({\n                                    name: i.toString(),\n                                    type: f\n                                }, types, genArgs);\n                            }));\n                        return _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_0__.struct(fieldLayouts, variant.name);\n                    });\n                    if (name !== undefined) {\n                        // Buffer-layout lib requires the name to be null (on construction)\n                        // when used as a field.\n                        return _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_0__.rustEnum(variants).replicate(name);\n                    }\n                    return _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_0__.rustEnum(variants, name);\n                }\n            case \"type\":\n                {\n                    return IdlCoder.fieldLayout({\n                        type: typeDef.type.alias,\n                        name\n                    }, types);\n                }\n        }\n    }\n    /**\n     * Get the type of the size in bytes. Returns `1` for variable length types.\n     */ static typeSize(ty, idl, genericArgs) {\n        var _a;\n        switch(ty){\n            case \"bool\":\n                return 1;\n            case \"u8\":\n                return 1;\n            case \"i8\":\n                return 1;\n            case \"i16\":\n                return 2;\n            case \"u16\":\n                return 2;\n            case \"u32\":\n                return 4;\n            case \"i32\":\n                return 4;\n            case \"f32\":\n                return 4;\n            case \"u64\":\n                return 8;\n            case \"i64\":\n                return 8;\n            case \"f64\":\n                return 8;\n            case \"u128\":\n                return 16;\n            case \"i128\":\n                return 16;\n            case \"u256\":\n                return 32;\n            case \"i256\":\n                return 32;\n            case \"bytes\":\n                return 1;\n            case \"string\":\n                return 1;\n            case \"pubkey\":\n                return 32;\n            default:\n                if (\"option\" in ty) {\n                    return 1 + IdlCoder.typeSize(ty.option, idl, genericArgs);\n                }\n                if (\"coption\" in ty) {\n                    return 4 + IdlCoder.typeSize(ty.coption, idl, genericArgs);\n                }\n                if (\"vec\" in ty) {\n                    return 1;\n                }\n                if (\"array\" in ty) {\n                    let [type, len] = ty.array;\n                    len = IdlCoder.resolveArrayLen(len, genericArgs);\n                    return IdlCoder.typeSize(type, idl, genericArgs) * len;\n                }\n                if (\"defined\" in ty) {\n                    const typeDef = (_a = idl.types) === null || _a === void 0 ? void 0 : _a.find((t)=>t.name === ty.defined.name);\n                    if (!typeDef) {\n                        throw new _error_js__WEBPACK_IMPORTED_MODULE_2__.IdlError(`Type not found: ${JSON.stringify(ty)}`);\n                    }\n                    const typeSize = (type)=>{\n                        const genArgs = genericArgs !== null && genericArgs !== void 0 ? genericArgs : ty.defined.generics;\n                        const args = genArgs ? IdlCoder.resolveGenericArgs({\n                            type,\n                            typeDef,\n                            genericArgs: genArgs\n                        }) : genArgs;\n                        return IdlCoder.typeSize(type, idl, args);\n                    };\n                    switch(typeDef.type.kind){\n                        case \"struct\":\n                            {\n                                return (0,_idl_js__WEBPACK_IMPORTED_MODULE_1__.handleDefinedFields)(typeDef.type.fields, ()=>[\n                                        0\n                                    ], (fields)=>fields.map((f)=>typeSize(f.type)), (fields)=>fields.map((f)=>typeSize(f))).reduce((acc, size)=>acc + size, 0);\n                            }\n                        case \"enum\":\n                            {\n                                const variantSizes = typeDef.type.variants.map((variant)=>{\n                                    return (0,_idl_js__WEBPACK_IMPORTED_MODULE_1__.handleDefinedFields)(variant.fields, ()=>[\n                                            0\n                                        ], (fields)=>fields.map((f)=>typeSize(f.type)), (fields)=>fields.map((f)=>typeSize(f))).reduce((acc, size)=>acc + size, 0);\n                                });\n                                return Math.max(...variantSizes) + 1;\n                            }\n                        case \"type\":\n                            {\n                                return IdlCoder.typeSize(typeDef.type.alias, idl, genericArgs);\n                            }\n                    }\n                }\n                if (\"generic\" in ty) {\n                    const genericArg = genericArgs === null || genericArgs === void 0 ? void 0 : genericArgs.at(0);\n                    if ((genericArg === null || genericArg === void 0 ? void 0 : genericArg.kind) !== \"type\") {\n                        throw new _error_js__WEBPACK_IMPORTED_MODULE_2__.IdlError(`Invalid generic: ${ty.generic}`);\n                    }\n                    return IdlCoder.typeSize(genericArg.type, idl, genericArgs);\n                }\n                throw new Error(`Invalid type ${JSON.stringify(ty)}`);\n        }\n    }\n    /**\n     * Resolve the generic array length or return the constant-sized array length.\n     */ static resolveArrayLen(len, genericArgs) {\n        if (typeof len === \"number\") return len;\n        if (genericArgs) {\n            const genericLen = genericArgs.find((g)=>g.kind === \"const\");\n            if ((genericLen === null || genericLen === void 0 ? void 0 : genericLen.kind) === \"const\") {\n                len = +genericLen.value;\n            }\n        }\n        if (typeof len !== \"number\") {\n            throw new _error_js__WEBPACK_IMPORTED_MODULE_2__.IdlError(\"Generic array length did not resolve\");\n        }\n        return len;\n    }\n    /**\n     * Recursively resolve generic arguments i.e. replace all generics with the\n     * actual type that they hold based on the initial `genericArgs` given.\n     */ static resolveGenericArgs({ type, typeDef, genericArgs, isDefined }) {\n        if (typeof type !== \"object\") return null;\n        for(const index in typeDef.generics){\n            const defGeneric = typeDef.generics[index];\n            if (\"generic\" in type && defGeneric.name === type.generic) {\n                return [\n                    genericArgs[index]\n                ];\n            }\n            if (\"option\" in type) {\n                const args = IdlCoder.resolveGenericArgs({\n                    type: type.option,\n                    typeDef,\n                    genericArgs,\n                    isDefined\n                });\n                if (!args || !isDefined) return args;\n                if (args[0].kind === \"type\") {\n                    return [\n                        {\n                            kind: \"type\",\n                            type: {\n                                option: args[0].type\n                            }\n                        }\n                    ];\n                }\n            }\n            if (\"vec\" in type) {\n                const args = IdlCoder.resolveGenericArgs({\n                    type: type.vec,\n                    typeDef,\n                    genericArgs,\n                    isDefined\n                });\n                if (!args || !isDefined) return args;\n                if (args[0].kind === \"type\") {\n                    return [\n                        {\n                            kind: \"type\",\n                            type: {\n                                vec: args[0].type\n                            }\n                        }\n                    ];\n                }\n            }\n            if (\"array\" in type) {\n                const [elTy, len] = type.array;\n                const isGenericLen = typeof len === \"object\";\n                const args = IdlCoder.resolveGenericArgs({\n                    type: elTy,\n                    typeDef,\n                    genericArgs,\n                    isDefined\n                });\n                if (args) {\n                    // Has generic type, also check for generic length\n                    for(const i in typeDef.generics.slice(+index)){\n                        const curIndex = +index + +i;\n                        if (isGenericLen && typeDef.generics[curIndex].name === len.generic) {\n                            args.push(genericArgs[curIndex]);\n                        }\n                    }\n                    if (!isDefined) return args;\n                    if (args[0].kind === \"type\" && args[1].kind === \"const\") {\n                        return [\n                            {\n                                kind: \"type\",\n                                type: {\n                                    array: [\n                                        args[0].type,\n                                        +args[1].value\n                                    ]\n                                }\n                            }\n                        ];\n                    }\n                }\n                // Only generic len\n                if (isGenericLen && defGeneric.name === len.generic) {\n                    const arg = genericArgs[index];\n                    if (!isDefined) return [\n                        arg\n                    ];\n                    return [\n                        {\n                            kind: \"type\",\n                            type: {\n                                array: [\n                                    elTy,\n                                    +arg.value\n                                ]\n                            }\n                        }\n                    ];\n                }\n                // Non-generic\n                return null;\n            }\n            if (\"defined\" in type) {\n                if (!type.defined.generics) return null;\n                return type.defined.generics.flatMap((g)=>{\n                    switch(g.kind){\n                        case \"type\":\n                            return IdlCoder.resolveGenericArgs({\n                                type: g.type,\n                                typeDef,\n                                genericArgs,\n                                isDefined: true\n                            });\n                        case \"const\":\n                            return [\n                                g\n                            ];\n                    }\n                }).filter((g)=>g !== null);\n            }\n        }\n        return null;\n    }\n} //# sourceMappingURL=idl.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL2NvZGVyL2JvcnNoL2lkbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEwQztBQUNVO0FBQ1Y7QUFDbkMsTUFBTUc7SUFDVCxPQUFPQyxZQUFZQyxLQUFLLEVBQUVDLFFBQVEsRUFBRSxFQUFFQyxXQUFXLEVBQUU7UUFDL0MsTUFBTUMsWUFBWUgsTUFBTUksSUFBSTtRQUM1QixPQUFRSixNQUFNSyxJQUFJO1lBQ2QsS0FBSztnQkFBUTtvQkFDVCxPQUFPVixrREFBVSxDQUFDUTtnQkFDdEI7WUFDQSxLQUFLO2dCQUFNO29CQUNQLE9BQU9SLGdEQUFRLENBQUNRO2dCQUNwQjtZQUNBLEtBQUs7Z0JBQU07b0JBQ1AsT0FBT1IsZ0RBQVEsQ0FBQ1E7Z0JBQ3BCO1lBQ0EsS0FBSztnQkFBTztvQkFDUixPQUFPUixpREFBUyxDQUFDUTtnQkFDckI7WUFDQSxLQUFLO2dCQUFPO29CQUNSLE9BQU9SLGlEQUFTLENBQUNRO2dCQUNyQjtZQUNBLEtBQUs7Z0JBQU87b0JBQ1IsT0FBT1IsaURBQVMsQ0FBQ1E7Z0JBQ3JCO1lBQ0EsS0FBSztnQkFBTztvQkFDUixPQUFPUixpREFBUyxDQUFDUTtnQkFDckI7WUFDQSxLQUFLO2dCQUFPO29CQUNSLE9BQU9SLGlEQUFTLENBQUNRO2dCQUNyQjtZQUNBLEtBQUs7Z0JBQU87b0JBQ1IsT0FBT1IsaURBQVMsQ0FBQ1E7Z0JBQ3JCO1lBQ0EsS0FBSztnQkFBTztvQkFDUixPQUFPUixpREFBUyxDQUFDUTtnQkFDckI7WUFDQSxLQUFLO2dCQUFPO29CQUNSLE9BQU9SLGlEQUFTLENBQUNRO2dCQUNyQjtZQUNBLEtBQUs7Z0JBQVE7b0JBQ1QsT0FBT1Isa0RBQVUsQ0FBQ1E7Z0JBQ3RCO1lBQ0EsS0FBSztnQkFBUTtvQkFDVCxPQUFPUixrREFBVSxDQUFDUTtnQkFDdEI7WUFDQSxLQUFLO2dCQUFRO29CQUNULE9BQU9SLGtEQUFVLENBQUNRO2dCQUN0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LGFBQWFuRSxNQUFNO2dCQUNuQixJQUFJLENBQUNBLEtBQUt5QixPQUFPLENBQUNLLFFBQVEsRUFDdEIsT0FBTztnQkFDWCxPQUFPOUIsS0FBS3lCLE9BQU8sQ0FBQ0ssUUFBUSxDQUN2QitDLE9BQU8sQ0FBQyxDQUFDWDtvQkFDVixPQUFRQSxFQUFFakMsSUFBSTt3QkFDVixLQUFLOzRCQUNELE9BQU94QyxTQUFTZ0Qsa0JBQWtCLENBQUM7Z0NBQy9CekMsTUFBTWtFLEVBQUVsRSxJQUFJO2dDQUNaMEI7Z0NBQ0E3QjtnQ0FDQXVFLFdBQVc7NEJBQ2Y7d0JBQ0osS0FBSzs0QkFDRCxPQUFPO2dDQUFDRjs2QkFBRTtvQkFDbEI7Z0JBQ0osR0FDS1ksTUFBTSxDQUFDLENBQUNaLElBQU1BLE1BQU07WUFDN0I7UUFDSjtRQUNBLE9BQU87SUFDWDtBQUNKLEVBQ0EsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AY29yYWwteHl6L2FuY2hvci9kaXN0L2VzbS9jb2Rlci9ib3JzaC9pZGwuanM/MDFmNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBib3JzaCBmcm9tIFwiQGNvcmFsLXh5ei9ib3JzaFwiO1xuaW1wb3J0IHsgaGFuZGxlRGVmaW5lZEZpZWxkcywgfSBmcm9tIFwiLi4vLi4vaWRsLmpzXCI7XG5pbXBvcnQgeyBJZGxFcnJvciB9IGZyb20gXCIuLi8uLi9lcnJvci5qc1wiO1xuZXhwb3J0IGNsYXNzIElkbENvZGVyIHtcbiAgICBzdGF0aWMgZmllbGRMYXlvdXQoZmllbGQsIHR5cGVzID0gW10sIGdlbmVyaWNBcmdzKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZSA9IGZpZWxkLm5hbWU7XG4gICAgICAgIHN3aXRjaCAoZmllbGQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImJvb2xcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiBib3JzaC5ib29sKGZpZWxkTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidThcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiBib3JzaC51OChmaWVsZE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImk4XCI6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYm9yc2guaTgoZmllbGROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ1MTZcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiBib3JzaC51MTYoZmllbGROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJpMTZcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiBib3JzaC5pMTYoZmllbGROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ1MzJcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiBib3JzaC51MzIoZmllbGROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJpMzJcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiBib3JzaC5pMzIoZmllbGROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJmMzJcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiBib3JzaC5mMzIoZmllbGROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ1NjRcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiBib3JzaC51NjQoZmllbGROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJpNjRcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiBib3JzaC5pNjQoZmllbGROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJmNjRcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiBib3JzaC5mNjQoZmllbGROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ1MTI4XCI6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYm9yc2gudTEyOChmaWVsZE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImkxMjhcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiBib3JzaC5pMTI4KGZpZWxkTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidTI1NlwiOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJvcnNoLnUyNTYoZmllbGROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJpMjU2XCI6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYm9yc2guaTI1NihmaWVsZE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImJ5dGVzXCI6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYm9yc2gudmVjVTgoZmllbGROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiBib3JzaC5zdHIoZmllbGROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJwdWJrZXlcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiBib3JzaC5wdWJsaWNLZXkoZmllbGROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBpZiAoXCJvcHRpb25cIiBpbiBmaWVsZC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBib3JzaC5vcHRpb24oSWRsQ29kZXIuZmllbGRMYXlvdXQoeyB0eXBlOiBmaWVsZC50eXBlLm9wdGlvbiB9LCB0eXBlcywgZ2VuZXJpY0FyZ3MpLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoXCJ2ZWNcIiBpbiBmaWVsZC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBib3JzaC52ZWMoSWRsQ29kZXIuZmllbGRMYXlvdXQoeyB0eXBlOiBmaWVsZC50eXBlLnZlYyB9LCB0eXBlcywgZ2VuZXJpY0FyZ3MpLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoXCJhcnJheVwiIGluIGZpZWxkLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IFt0eXBlLCBsZW5dID0gZmllbGQudHlwZS5hcnJheTtcbiAgICAgICAgICAgICAgICAgICAgbGVuID0gSWRsQ29kZXIucmVzb2x2ZUFycmF5TGVuKGxlbiwgZ2VuZXJpY0FyZ3MpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm9yc2guYXJyYXkoSWRsQ29kZXIuZmllbGRMYXlvdXQoeyB0eXBlIH0sIHR5cGVzLCBnZW5lcmljQXJncyksIGxlbiwgZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKFwiZGVmaW5lZFwiIGluIGZpZWxkLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0eXBlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IElkbEVycm9yKFwiVXNlciBkZWZpbmVkIHR5cGVzIG5vdCBwcm92aWRlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWZpbmVkTmFtZSA9IGZpZWxkLnR5cGUuZGVmaW5lZC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlRGVmID0gdHlwZXMuZmluZCgodCkgPT4gdC5uYW1lID09PSBkZWZpbmVkTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHlwZURlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IElkbEVycm9yKGBUeXBlIG5vdCBmb3VuZDogJHtmaWVsZC5uYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJZGxDb2Rlci50eXBlRGVmTGF5b3V0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVEZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyaWNBcmdzOiBnZW5lcmljQXJncyAhPT0gbnVsbCAmJiBnZW5lcmljQXJncyAhPT0gdm9pZCAwID8gZ2VuZXJpY0FyZ3MgOiBmaWVsZC50eXBlLmRlZmluZWQuZ2VuZXJpY3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBmaWVsZE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoXCJnZW5lcmljXCIgaW4gZmllbGQudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBnZW5lcmljQXJnID0gZ2VuZXJpY0FyZ3MgPT09IG51bGwgfHwgZ2VuZXJpY0FyZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdlbmVyaWNBcmdzLmF0KDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGdlbmVyaWNBcmcgPT09IG51bGwgfHwgZ2VuZXJpY0FyZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2VuZXJpY0FyZy5raW5kKSAhPT0gXCJ0eXBlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJZGxFcnJvcihgSW52YWxpZCBnZW5lcmljIGZpZWxkOiAke2ZpZWxkLm5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElkbENvZGVyLmZpZWxkTGF5b3V0KHsgLi4uZmllbGQsIHR5cGU6IGdlbmVyaWNBcmcudHlwZSB9LCB0eXBlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJZGxFcnJvcihgTm90IHlldCBpbXBsZW1lbnRlZDogJHtKU09OLnN0cmluZ2lmeShmaWVsZC50eXBlKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHR5cGUgbGF5b3V0IG9mIHRoZSBnaXZlbiBkZWZpbmVkIHR5cGUoc3RydWN0IG9yIGVudW0pLlxuICAgICAqL1xuICAgIHN0YXRpYyB0eXBlRGVmTGF5b3V0KHsgdHlwZURlZiwgdHlwZXMsIG5hbWUsIGdlbmVyaWNBcmdzLCB9KSB7XG4gICAgICAgIHN3aXRjaCAodHlwZURlZi50eXBlLmtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzdHJ1Y3RcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkTGF5b3V0cyA9IGhhbmRsZURlZmluZWRGaWVsZHModHlwZURlZi50eXBlLmZpZWxkcywgKCkgPT4gW10sIChmaWVsZHMpID0+IGZpZWxkcy5tYXAoKGYpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2VuQXJncyA9IGdlbmVyaWNBcmdzXG4gICAgICAgICAgICAgICAgICAgICAgICA/IElkbENvZGVyLnJlc29sdmVHZW5lcmljQXJncyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogZi50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVEZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJpY0FyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBnZW5lcmljQXJncztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElkbENvZGVyLmZpZWxkTGF5b3V0KGYsIHR5cGVzLCBnZW5BcmdzKTtcbiAgICAgICAgICAgICAgICB9KSwgKGZpZWxkcykgPT4gZmllbGRzLm1hcCgoZiwgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBnZW5BcmdzID0gZ2VuZXJpY0FyZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgID8gSWRsQ29kZXIucmVzb2x2ZUdlbmVyaWNBcmdzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVEZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJpY0FyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBnZW5lcmljQXJncztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElkbENvZGVyLmZpZWxkTGF5b3V0KHsgbmFtZTogaS50b1N0cmluZygpLCB0eXBlOiBmIH0sIHR5cGVzLCBnZW5BcmdzKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJvcnNoLnN0cnVjdChmaWVsZExheW91dHMsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImVudW1cIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhcmlhbnRzID0gdHlwZURlZi50eXBlLnZhcmlhbnRzLm1hcCgodmFyaWFudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZExheW91dHMgPSBoYW5kbGVEZWZpbmVkRmllbGRzKHZhcmlhbnQuZmllbGRzLCAoKSA9PiBbXSwgKGZpZWxkcykgPT4gZmllbGRzLm1hcCgoZikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2VuQXJncyA9IGdlbmVyaWNBcmdzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBJZGxDb2Rlci5yZXNvbHZlR2VuZXJpY0FyZ3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBmLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVEZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyaWNBcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBnZW5lcmljQXJncztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJZGxDb2Rlci5maWVsZExheW91dChmLCB0eXBlcywgZ2VuQXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH0pLCAoZmllbGRzKSA9PiBmaWVsZHMubWFwKChmLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnZW5BcmdzID0gZ2VuZXJpY0FyZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IElkbENvZGVyLnJlc29sdmVHZW5lcmljQXJncyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVEZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyaWNBcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBnZW5lcmljQXJncztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJZGxDb2Rlci5maWVsZExheW91dCh7IG5hbWU6IGkudG9TdHJpbmcoKSwgdHlwZTogZiB9LCB0eXBlcywgZ2VuQXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJvcnNoLnN0cnVjdChmaWVsZExheW91dHMsIHZhcmlhbnQubmFtZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBCdWZmZXItbGF5b3V0IGxpYiByZXF1aXJlcyB0aGUgbmFtZSB0byBiZSBudWxsIChvbiBjb25zdHJ1Y3Rpb24pXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gdXNlZCBhcyBhIGZpZWxkLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm9yc2gucnVzdEVudW0odmFyaWFudHMpLnJlcGxpY2F0ZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJvcnNoLnJ1c3RFbnVtKHZhcmlhbnRzLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0eXBlXCI6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSWRsQ29kZXIuZmllbGRMYXlvdXQoeyB0eXBlOiB0eXBlRGVmLnR5cGUuYWxpYXMsIG5hbWUgfSwgdHlwZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdHlwZSBvZiB0aGUgc2l6ZSBpbiBieXRlcy4gUmV0dXJucyBgMWAgZm9yIHZhcmlhYmxlIGxlbmd0aCB0eXBlcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgdHlwZVNpemUodHksIGlkbCwgZ2VuZXJpY0FyZ3MpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzd2l0Y2ggKHR5KSB7XG4gICAgICAgICAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgY2FzZSBcInU4XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICBjYXNlIFwiaThcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIGNhc2UgXCJpMTZcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgIGNhc2UgXCJ1MTZcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgIGNhc2UgXCJ1MzJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gNDtcbiAgICAgICAgICAgIGNhc2UgXCJpMzJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gNDtcbiAgICAgICAgICAgIGNhc2UgXCJmMzJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gNDtcbiAgICAgICAgICAgIGNhc2UgXCJ1NjRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgICAgIGNhc2UgXCJpNjRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgICAgIGNhc2UgXCJmNjRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgICAgIGNhc2UgXCJ1MTI4XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE2O1xuICAgICAgICAgICAgY2FzZSBcImkxMjhcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gMTY7XG4gICAgICAgICAgICBjYXNlIFwidTI1NlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiAzMjtcbiAgICAgICAgICAgIGNhc2UgXCJpMjU2XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDMyO1xuICAgICAgICAgICAgY2FzZSBcImJ5dGVzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICBjYXNlIFwicHVia2V5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDMyO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoXCJvcHRpb25cIiBpbiB0eSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMSArIElkbENvZGVyLnR5cGVTaXplKHR5Lm9wdGlvbiwgaWRsLCBnZW5lcmljQXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChcImNvcHRpb25cIiBpbiB0eSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gNCArIElkbENvZGVyLnR5cGVTaXplKHR5LmNvcHRpb24sIGlkbCwgZ2VuZXJpY0FyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoXCJ2ZWNcIiBpbiB0eSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKFwiYXJyYXlcIiBpbiB0eSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgW3R5cGUsIGxlbl0gPSB0eS5hcnJheTtcbiAgICAgICAgICAgICAgICAgICAgbGVuID0gSWRsQ29kZXIucmVzb2x2ZUFycmF5TGVuKGxlbiwgZ2VuZXJpY0FyZ3MpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSWRsQ29kZXIudHlwZVNpemUodHlwZSwgaWRsLCBnZW5lcmljQXJncykgKiBsZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChcImRlZmluZWRcIiBpbiB0eSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlRGVmID0gKF9hID0gaWRsLnR5cGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmluZCgodCkgPT4gdC5uYW1lID09PSB0eS5kZWZpbmVkLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXR5cGVEZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJZGxFcnJvcihgVHlwZSBub3QgZm91bmQ6ICR7SlNPTi5zdHJpbmdpZnkodHkpfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVTaXplID0gKHR5cGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdlbkFyZ3MgPSBnZW5lcmljQXJncyAhPT0gbnVsbCAmJiBnZW5lcmljQXJncyAhPT0gdm9pZCAwID8gZ2VuZXJpY0FyZ3MgOiB0eS5kZWZpbmVkLmdlbmVyaWNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IGdlbkFyZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IElkbENvZGVyLnJlc29sdmVHZW5lcmljQXJncyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVEZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyaWNBcmdzOiBnZW5BcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBnZW5BcmdzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElkbENvZGVyLnR5cGVTaXplKHR5cGUsIGlkbCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZURlZi50eXBlLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJ1Y3RcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVEZWZpbmVkRmllbGRzKHR5cGVEZWYudHlwZS5maWVsZHMsICgpID0+IFswXSwgKGZpZWxkcykgPT4gZmllbGRzLm1hcCgoZikgPT4gdHlwZVNpemUoZi50eXBlKSksIChmaWVsZHMpID0+IGZpZWxkcy5tYXAoKGYpID0+IHR5cGVTaXplKGYpKSkucmVkdWNlKChhY2MsIHNpemUpID0+IGFjYyArIHNpemUsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhcmlhbnRTaXplcyA9IHR5cGVEZWYudHlwZS52YXJpYW50cy5tYXAoKHZhcmlhbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZURlZmluZWRGaWVsZHModmFyaWFudC5maWVsZHMsICgpID0+IFswXSwgKGZpZWxkcykgPT4gZmllbGRzLm1hcCgoZikgPT4gdHlwZVNpemUoZi50eXBlKSksIChmaWVsZHMpID0+IGZpZWxkcy5tYXAoKGYpID0+IHR5cGVTaXplKGYpKSkucmVkdWNlKChhY2MsIHNpemUpID0+IGFjYyArIHNpemUsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCguLi52YXJpYW50U2l6ZXMpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0eXBlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSWRsQ29kZXIudHlwZVNpemUodHlwZURlZi50eXBlLmFsaWFzLCBpZGwsIGdlbmVyaWNBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoXCJnZW5lcmljXCIgaW4gdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJpY0FyZyA9IGdlbmVyaWNBcmdzID09PSBudWxsIHx8IGdlbmVyaWNBcmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnZW5lcmljQXJncy5hdCgwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChnZW5lcmljQXJnID09PSBudWxsIHx8IGdlbmVyaWNBcmcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdlbmVyaWNBcmcua2luZCkgIT09IFwidHlwZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWRsRXJyb3IoYEludmFsaWQgZ2VuZXJpYzogJHt0eS5nZW5lcmljfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJZGxDb2Rlci50eXBlU2l6ZShnZW5lcmljQXJnLnR5cGUsIGlkbCwgZ2VuZXJpY0FyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdHlwZSAke0pTT04uc3RyaW5naWZ5KHR5KX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlIHRoZSBnZW5lcmljIGFycmF5IGxlbmd0aCBvciByZXR1cm4gdGhlIGNvbnN0YW50LXNpemVkIGFycmF5IGxlbmd0aC5cbiAgICAgKi9cbiAgICBzdGF0aWMgcmVzb2x2ZUFycmF5TGVuKGxlbiwgZ2VuZXJpY0FyZ3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsZW4gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICByZXR1cm4gbGVuO1xuICAgICAgICBpZiAoZ2VuZXJpY0FyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGdlbmVyaWNMZW4gPSBnZW5lcmljQXJncy5maW5kKChnKSA9PiBnLmtpbmQgPT09IFwiY29uc3RcIik7XG4gICAgICAgICAgICBpZiAoKGdlbmVyaWNMZW4gPT09IG51bGwgfHwgZ2VuZXJpY0xlbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2VuZXJpY0xlbi5raW5kKSA9PT0gXCJjb25zdFwiKSB7XG4gICAgICAgICAgICAgICAgbGVuID0gK2dlbmVyaWNMZW4udmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBsZW4gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJZGxFcnJvcihcIkdlbmVyaWMgYXJyYXkgbGVuZ3RoIGRpZCBub3QgcmVzb2x2ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSByZXNvbHZlIGdlbmVyaWMgYXJndW1lbnRzIGkuZS4gcmVwbGFjZSBhbGwgZ2VuZXJpY3Mgd2l0aCB0aGVcbiAgICAgKiBhY3R1YWwgdHlwZSB0aGF0IHRoZXkgaG9sZCBiYXNlZCBvbiB0aGUgaW5pdGlhbCBgZ2VuZXJpY0FyZ3NgIGdpdmVuLlxuICAgICAqL1xuICAgIHN0YXRpYyByZXNvbHZlR2VuZXJpY0FyZ3MoeyB0eXBlLCB0eXBlRGVmLCBnZW5lcmljQXJncywgaXNEZWZpbmVkLCB9KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGluZGV4IGluIHR5cGVEZWYuZ2VuZXJpY3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZkdlbmVyaWMgPSB0eXBlRGVmLmdlbmVyaWNzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChcImdlbmVyaWNcIiBpbiB0eXBlICYmIGRlZkdlbmVyaWMubmFtZSA9PT0gdHlwZS5nZW5lcmljKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtnZW5lcmljQXJnc1tpbmRleF1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFwib3B0aW9uXCIgaW4gdHlwZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBJZGxDb2Rlci5yZXNvbHZlR2VuZXJpY0FyZ3Moe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLm9wdGlvbixcbiAgICAgICAgICAgICAgICAgICAgdHlwZURlZixcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJpY0FyZ3MsXG4gICAgICAgICAgICAgICAgICAgIGlzRGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWFyZ3MgfHwgIWlzRGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3NbMF0ua2luZCA9PT0gXCJ0eXBlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcInR5cGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB7IG9wdGlvbjogYXJnc1swXS50eXBlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChcInZlY1wiIGluIHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gSWRsQ29kZXIucmVzb2x2ZUdlbmVyaWNBcmdzKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZS52ZWMsXG4gICAgICAgICAgICAgICAgICAgIHR5cGVEZWYsXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyaWNBcmdzLFxuICAgICAgICAgICAgICAgICAgICBpc0RlZmluZWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFhcmdzIHx8ICFpc0RlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICAgICAgICAgIGlmIChhcmdzWzBdLmtpbmQgPT09IFwidHlwZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJ0eXBlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogeyB2ZWM6IGFyZ3NbMF0udHlwZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXCJhcnJheVwiIGluIHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbZWxUeSwgbGVuXSA9IHR5cGUuYXJyYXk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNHZW5lcmljTGVuID0gdHlwZW9mIGxlbiA9PT0gXCJvYmplY3RcIjtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gSWRsQ29kZXIucmVzb2x2ZUdlbmVyaWNBcmdzKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogZWxUeSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZURlZixcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJpY0FyZ3MsXG4gICAgICAgICAgICAgICAgICAgIGlzRGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoYXJncykge1xuICAgICAgICAgICAgICAgICAgICAvLyBIYXMgZ2VuZXJpYyB0eXBlLCBhbHNvIGNoZWNrIGZvciBnZW5lcmljIGxlbmd0aFxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGkgaW4gdHlwZURlZi5nZW5lcmljcy5zbGljZSgraW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJJbmRleCA9ICtpbmRleCArICtpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzR2VuZXJpY0xlbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVEZWYuZ2VuZXJpY3NbY3VySW5kZXhdLm5hbWUgPT09IGxlbi5nZW5lcmljKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGdlbmVyaWNBcmdzW2N1ckluZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0RlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJncztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3NbMF0ua2luZCA9PT0gXCJ0eXBlXCIgJiYgYXJnc1sxXS5raW5kID09PSBcImNvbnN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcInR5cGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogeyBhcnJheTogW2FyZ3NbMF0udHlwZSwgK2FyZ3NbMV0udmFsdWVdIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gT25seSBnZW5lcmljIGxlblxuICAgICAgICAgICAgICAgIGlmIChpc0dlbmVyaWNMZW4gJiYgZGVmR2VuZXJpYy5uYW1lID09PSBsZW4uZ2VuZXJpYykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmcgPSBnZW5lcmljQXJnc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNEZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFthcmddO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwidHlwZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHsgYXJyYXk6IFtlbFR5LCArYXJnLnZhbHVlXSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTm9uLWdlbmVyaWNcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChcImRlZmluZWRcIiBpbiB0eXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0eXBlLmRlZmluZWQuZ2VuZXJpY3MpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlLmRlZmluZWQuZ2VuZXJpY3NcbiAgICAgICAgICAgICAgICAgICAgLmZsYXRNYXAoKGcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChnLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0eXBlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElkbENvZGVyLnJlc29sdmVHZW5lcmljQXJncyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGcudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZURlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJpY0FyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRGVmaW5lZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjb25zdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbZ107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChnKSA9PiBnICE9PSBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pZGwuanMubWFwIl0sIm5hbWVzIjpbImJvcnNoIiwiaGFuZGxlRGVmaW5lZEZpZWxkcyIsIklkbEVycm9yIiwiSWRsQ29kZXIiLCJmaWVsZExheW91dCIsImZpZWxkIiwidHlwZXMiLCJnZW5lcmljQXJncyIsImZpZWxkTmFtZSIsIm5hbWUiLCJ0eXBlIiwiYm9vbCIsInU4IiwiaTgiLCJ1MTYiLCJpMTYiLCJ1MzIiLCJpMzIiLCJmMzIiLCJ1NjQiLCJpNjQiLCJmNjQiLCJ1MTI4IiwiaTEyOCIsInUyNTYiLCJpMjU2IiwidmVjVTgiLCJzdHIiLCJwdWJsaWNLZXkiLCJvcHRpb24iLCJ2ZWMiLCJsZW4iLCJhcnJheSIsInJlc29sdmVBcnJheUxlbiIsImRlZmluZWROYW1lIiwiZGVmaW5lZCIsInR5cGVEZWYiLCJmaW5kIiwidCIsInR5cGVEZWZMYXlvdXQiLCJnZW5lcmljcyIsImdlbmVyaWNBcmciLCJhdCIsImtpbmQiLCJKU09OIiwic3RyaW5naWZ5IiwiZmllbGRMYXlvdXRzIiwiZmllbGRzIiwibWFwIiwiZiIsImdlbkFyZ3MiLCJyZXNvbHZlR2VuZXJpY0FyZ3MiLCJpIiwidG9TdHJpbmciLCJzdHJ1Y3QiLCJ2YXJpYW50cyIsInZhcmlhbnQiLCJ1bmRlZmluZWQiLCJydXN0RW51bSIsInJlcGxpY2F0ZSIsImFsaWFzIiwidHlwZVNpemUiLCJ0eSIsImlkbCIsIl9hIiwiY29wdGlvbiIsImFyZ3MiLCJyZWR1Y2UiLCJhY2MiLCJzaXplIiwidmFyaWFudFNpemVzIiwiTWF0aCIsIm1heCIsImdlbmVyaWMiLCJFcnJvciIsImdlbmVyaWNMZW4iLCJnIiwidmFsdWUiLCJpc0RlZmluZWQiLCJpbmRleCIsImRlZkdlbmVyaWMiLCJlbFR5IiwiaXNHZW5lcmljTGVuIiwic2xpY2UiLCJjdXJJbmRleCIsInB1c2giLCJhcmciLCJmbGF0TWFwIiwiZmlsdGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/borsh/idl.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/borsh/index.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/coder/borsh/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BorshAccountsCoder: () => (/* reexport safe */ _accounts_js__WEBPACK_IMPORTED_MODULE_1__.BorshAccountsCoder),\n/* harmony export */   BorshCoder: () => (/* binding */ BorshCoder),\n/* harmony export */   BorshEventCoder: () => (/* reexport safe */ _event_js__WEBPACK_IMPORTED_MODULE_2__.BorshEventCoder),\n/* harmony export */   BorshInstructionCoder: () => (/* reexport safe */ _instruction_js__WEBPACK_IMPORTED_MODULE_0__.BorshInstructionCoder),\n/* harmony export */   DISCRIMINATOR_SIZE: () => (/* reexport safe */ _discriminator_js__WEBPACK_IMPORTED_MODULE_4__.DISCRIMINATOR_SIZE)\n/* harmony export */ });\n/* harmony import */ var _instruction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instruction.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/borsh/instruction.js\");\n/* harmony import */ var _accounts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./accounts.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/borsh/accounts.js\");\n/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./event.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/borsh/event.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/borsh/types.js\");\n/* harmony import */ var _discriminator_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./discriminator.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/borsh/discriminator.js\");\n\n\n\n\n\n\n\n\n/**\n * BorshCoder is the default Coder for Anchor programs implementing the\n * borsh based serialization interface.\n */ class BorshCoder {\n    constructor(idl){\n        this.instruction = new _instruction_js__WEBPACK_IMPORTED_MODULE_0__.BorshInstructionCoder(idl);\n        this.accounts = new _accounts_js__WEBPACK_IMPORTED_MODULE_1__.BorshAccountsCoder(idl);\n        this.events = new _event_js__WEBPACK_IMPORTED_MODULE_2__.BorshEventCoder(idl);\n        this.types = new _types_js__WEBPACK_IMPORTED_MODULE_3__.BorshTypesCoder(idl);\n    }\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL2NvZGVyL2JvcnNoL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBeUQ7QUFDTjtBQUNOO0FBQ0E7QUFDWTtBQUNOO0FBQ0s7QUFDWDtBQUM3Qzs7O0NBR0MsR0FDTSxNQUFNSztJQUNUQyxZQUFZQyxHQUFHLENBQUU7UUFDYixJQUFJLENBQUNDLFdBQVcsR0FBRyxJQUFJUixrRUFBcUJBLENBQUNPO1FBQzdDLElBQUksQ0FBQ0UsUUFBUSxHQUFHLElBQUlSLDREQUFrQkEsQ0FBQ007UUFDdkMsSUFBSSxDQUFDRyxNQUFNLEdBQUcsSUFBSVIsc0RBQWVBLENBQUNLO1FBQ2xDLElBQUksQ0FBQ0ksS0FBSyxHQUFHLElBQUlSLHNEQUFlQSxDQUFDSTtJQUNyQztBQUNKLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AY29yYWwteHl6L2FuY2hvci9kaXN0L2VzbS9jb2Rlci9ib3JzaC9pbmRleC5qcz9lNmU3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJvcnNoSW5zdHJ1Y3Rpb25Db2RlciB9IGZyb20gXCIuL2luc3RydWN0aW9uLmpzXCI7XG5pbXBvcnQgeyBCb3JzaEFjY291bnRzQ29kZXIgfSBmcm9tIFwiLi9hY2NvdW50cy5qc1wiO1xuaW1wb3J0IHsgQm9yc2hFdmVudENvZGVyIH0gZnJvbSBcIi4vZXZlbnQuanNcIjtcbmltcG9ydCB7IEJvcnNoVHlwZXNDb2RlciB9IGZyb20gXCIuL3R5cGVzLmpzXCI7XG5leHBvcnQgeyBCb3JzaEluc3RydWN0aW9uQ29kZXIgfSBmcm9tIFwiLi9pbnN0cnVjdGlvbi5qc1wiO1xuZXhwb3J0IHsgQm9yc2hBY2NvdW50c0NvZGVyIH0gZnJvbSBcIi4vYWNjb3VudHMuanNcIjtcbmV4cG9ydCB7IERJU0NSSU1JTkFUT1JfU0laRSB9IGZyb20gXCIuL2Rpc2NyaW1pbmF0b3IuanNcIjtcbmV4cG9ydCB7IEJvcnNoRXZlbnRDb2RlciB9IGZyb20gXCIuL2V2ZW50LmpzXCI7XG4vKipcbiAqIEJvcnNoQ29kZXIgaXMgdGhlIGRlZmF1bHQgQ29kZXIgZm9yIEFuY2hvciBwcm9ncmFtcyBpbXBsZW1lbnRpbmcgdGhlXG4gKiBib3JzaCBiYXNlZCBzZXJpYWxpemF0aW9uIGludGVyZmFjZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEJvcnNoQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGlkbCkge1xuICAgICAgICB0aGlzLmluc3RydWN0aW9uID0gbmV3IEJvcnNoSW5zdHJ1Y3Rpb25Db2RlcihpZGwpO1xuICAgICAgICB0aGlzLmFjY291bnRzID0gbmV3IEJvcnNoQWNjb3VudHNDb2RlcihpZGwpO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IG5ldyBCb3JzaEV2ZW50Q29kZXIoaWRsKTtcbiAgICAgICAgdGhpcy50eXBlcyA9IG5ldyBCb3JzaFR5cGVzQ29kZXIoaWRsKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiQm9yc2hJbnN0cnVjdGlvbkNvZGVyIiwiQm9yc2hBY2NvdW50c0NvZGVyIiwiQm9yc2hFdmVudENvZGVyIiwiQm9yc2hUeXBlc0NvZGVyIiwiRElTQ1JJTUlOQVRPUl9TSVpFIiwiQm9yc2hDb2RlciIsImNvbnN0cnVjdG9yIiwiaWRsIiwiaW5zdHJ1Y3Rpb24iLCJhY2NvdW50cyIsImV2ZW50cyIsInR5cGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/borsh/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/borsh/instruction.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/coder/borsh/instruction.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BorshInstructionCoder: () => (/* binding */ BorshInstructionCoder)\n/* harmony export */ });\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bs58 */ \"(ssr)/../node_modules/@coral-xyz/anchor/node_modules/bs58/index.js\");\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bs58__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(buffer__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @coral-xyz/borsh */ \"(ssr)/../node_modules/@coral-xyz/anchor/node_modules/@coral-xyz/borsh/dist/index.js\");\n/* harmony import */ var _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _idl_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../idl.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/idl.js\");\n/* harmony import */ var _idl_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./idl.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/borsh/idl.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../index.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/index.js\");\n\n\n\n\n\n\n/**\n * Encodes and decodes program instructions.\n */ class BorshInstructionCoder {\n    constructor(idl){\n        this.idl = idl;\n        const ixLayouts = idl.instructions.map((ix)=>{\n            const name = ix.name;\n            const fieldLayouts = ix.args.map((arg)=>_idl_js__WEBPACK_IMPORTED_MODULE_4__.IdlCoder.fieldLayout(arg, idl.types));\n            const layout = _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_2__.struct(fieldLayouts, name);\n            return [\n                name,\n                {\n                    discriminator: ix.discriminator,\n                    layout\n                }\n            ];\n        });\n        this.ixLayouts = new Map(ixLayouts);\n        const sighashLayouts = ixLayouts.map(([name, { discriminator, layout }])=>{\n            return [\n                bs58__WEBPACK_IMPORTED_MODULE_0___default().encode(discriminator),\n                {\n                    name,\n                    layout\n                }\n            ];\n        });\n        this.sighashLayouts = new Map(sighashLayouts);\n    }\n    /**\n     * Encodes a program instruction.\n     */ encode(ixName, ix) {\n        const buffer = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.alloc(1000); // TODO: use a tighter buffer.\n        const encoder = this.ixLayouts.get(ixName);\n        if (!encoder) {\n            throw new Error(`Unknown method: ${ixName}`);\n        }\n        const len = encoder.layout.encode(ix, buffer);\n        const data = buffer.slice(0, len);\n        return buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([\n            buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(encoder.discriminator),\n            data\n        ]);\n    }\n    /**\n     * Decodes a program instruction.\n     */ decode(ix, encoding = \"hex\") {\n        if (typeof ix === \"string\") {\n            ix = encoding === \"hex\" ? buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(ix, \"hex\") : bs58__WEBPACK_IMPORTED_MODULE_0___default().decode(ix);\n        }\n        const disc = ix.slice(0, _index_js__WEBPACK_IMPORTED_MODULE_5__.DISCRIMINATOR_SIZE);\n        const data = ix.slice(_index_js__WEBPACK_IMPORTED_MODULE_5__.DISCRIMINATOR_SIZE);\n        const decoder = this.sighashLayouts.get(bs58__WEBPACK_IMPORTED_MODULE_0___default().encode(disc));\n        if (!decoder) {\n            return null;\n        }\n        return {\n            name: decoder.name,\n            data: decoder.layout.decode(data)\n        };\n    }\n    /**\n     * Returns a formatted table of all the fields in the given instruction data.\n     */ format(ix, accountMetas) {\n        return InstructionFormatter.format(ix, accountMetas, this.idl);\n    }\n}\nclass InstructionFormatter {\n    static format(ix, accountMetas, idl) {\n        const idlIx = idl.instructions.find((i)=>ix.name === i.name);\n        if (!idlIx) {\n            console.error(\"Invalid instruction given\");\n            return null;\n        }\n        const args = idlIx.args.map((idlField)=>{\n            return {\n                name: idlField.name,\n                type: InstructionFormatter.formatIdlType(idlField.type),\n                data: InstructionFormatter.formatIdlData(idlField, ix.data[idlField.name], idl.types)\n            };\n        });\n        const flatIdlAccounts = InstructionFormatter.flattenIdlAccounts(idlIx.accounts);\n        const accounts = accountMetas.map((meta, idx)=>{\n            if (idx < flatIdlAccounts.length) {\n                return {\n                    name: flatIdlAccounts[idx].name,\n                    ...meta\n                };\n            } else {\n                return {\n                    name: undefined,\n                    ...meta\n                };\n            }\n        });\n        return {\n            args,\n            accounts\n        };\n    }\n    static formatIdlType(idlType) {\n        if (typeof idlType === \"string\") {\n            return idlType;\n        }\n        if (\"option\" in idlType) {\n            return `Option<${this.formatIdlType(idlType.option)}>`;\n        }\n        if (\"coption\" in idlType) {\n            return `COption<${this.formatIdlType(idlType.coption)}>`;\n        }\n        if (\"vec\" in idlType) {\n            return `Vec<${this.formatIdlType(idlType.vec)}>`;\n        }\n        if (\"array\" in idlType) {\n            return `Array<${idlType.array[0]}; ${idlType.array[1]}>`;\n        }\n        if (\"defined\" in idlType) {\n            const name = idlType.defined.name;\n            if (idlType.defined.generics) {\n                const generics = idlType.defined.generics.map((g)=>{\n                    switch(g.kind){\n                        case \"type\":\n                            return InstructionFormatter.formatIdlType(g.type);\n                        case \"const\":\n                            return g.value;\n                    }\n                }).join(\", \");\n                return `${name}<${generics}>`;\n            }\n            return name;\n        }\n        throw new Error(`Unknown IDL type: ${idlType}`);\n    }\n    static formatIdlData(idlField, data, types) {\n        if (typeof idlField.type === \"string\") {\n            return data.toString();\n        }\n        if (\"vec\" in idlField.type) {\n            return \"[\" + data.map((d)=>this.formatIdlData({\n                    name: \"\",\n                    type: idlField.type.vec\n                }, d, types)).join(\", \") + \"]\";\n        }\n        if (\"option\" in idlField.type) {\n            return data === null ? \"null\" : this.formatIdlData({\n                name: \"\",\n                type: idlField.type.option\n            }, data, types);\n        }\n        if (\"defined\" in idlField.type) {\n            if (!types) {\n                throw new Error(\"User defined types not provided\");\n            }\n            const definedName = idlField.type.defined.name;\n            const typeDef = types.find((t)=>t.name === definedName);\n            if (!typeDef) {\n                throw new Error(`Type not found: ${definedName}`);\n            }\n            return InstructionFormatter.formatIdlDataDefined(typeDef, data, types);\n        }\n        return \"unknown\";\n    }\n    static formatIdlDataDefined(typeDef, data, types) {\n        switch(typeDef.type.kind){\n            case \"struct\":\n                {\n                    return \"{ \" + (0,_idl_js__WEBPACK_IMPORTED_MODULE_3__.handleDefinedFields)(typeDef.type.fields, ()=>\"\", (fields)=>{\n                        return Object.entries(data).map(([key, val])=>{\n                            const field = fields.find((f)=>f.name === key);\n                            if (!field) {\n                                throw new Error(`Field not found: ${key}`);\n                            }\n                            return key + \": \" + InstructionFormatter.formatIdlData(field, val, types);\n                        }).join(\", \");\n                    }, (fields)=>{\n                        return Object.entries(data).map(([key, val])=>{\n                            return key + \": \" + InstructionFormatter.formatIdlData({\n                                name: \"\",\n                                type: fields[key]\n                            }, val, types);\n                        }).join(\", \");\n                    }) + \" }\";\n                }\n            case \"enum\":\n                {\n                    const variantName = Object.keys(data)[0];\n                    const variant = typeDef.type.variants.find((v)=>v.name === variantName);\n                    if (!variant) {\n                        throw new Error(`Unable to find variant: ${variantName}`);\n                    }\n                    const enumValue = data[variantName];\n                    return (0,_idl_js__WEBPACK_IMPORTED_MODULE_3__.handleDefinedFields)(variant.fields, ()=>variantName, (fields)=>{\n                        const namedFields = Object.keys(enumValue).map((f)=>{\n                            const fieldData = enumValue[f];\n                            const idlField = fields.find((v)=>v.name === f);\n                            if (!idlField) {\n                                throw new Error(`Field not found: ${f}`);\n                            }\n                            return f + \": \" + InstructionFormatter.formatIdlData(idlField, fieldData, types);\n                        }).join(\", \");\n                        return `${variantName} { ${namedFields} }`;\n                    }, (fields)=>{\n                        const tupleFields = Object.entries(enumValue).map(([key, val])=>{\n                            return key + \": \" + InstructionFormatter.formatIdlData({\n                                name: \"\",\n                                type: fields[key]\n                            }, val, types);\n                        }).join(\", \");\n                        return `${variantName} { ${tupleFields} }`;\n                    });\n                }\n            case \"type\":\n                {\n                    return InstructionFormatter.formatIdlType(typeDef.type.alias);\n                }\n        }\n    }\n    static flattenIdlAccounts(accounts, prefix) {\n        return accounts.map((account)=>{\n            const accName = sentenceCase(account.name);\n            if (account.hasOwnProperty(\"accounts\")) {\n                const newPrefix = prefix ? `${prefix} > ${accName}` : accName;\n                return InstructionFormatter.flattenIdlAccounts(account.accounts, newPrefix);\n            } else {\n                return {\n                    ...account,\n                    name: prefix ? `${prefix} > ${accName}` : accName\n                };\n            }\n        }).flat();\n    }\n}\nfunction sentenceCase(field) {\n    const result = field.replace(/([A-Z])/g, \" $1\");\n    return result.charAt(0).toUpperCase() + result.slice(1);\n} //# sourceMappingURL=instruction.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL2NvZGVyL2JvcnNoL2luc3RydWN0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBd0I7QUFDUTtBQUNVO0FBQ1U7QUFDaEI7QUFDYTtBQUNqRDs7Q0FFQyxHQUNNLE1BQU1NO0lBQ1RDLFlBQVlDLEdBQUcsQ0FBRTtRQUNiLElBQUksQ0FBQ0EsR0FBRyxHQUFHQTtRQUNYLE1BQU1DLFlBQVlELElBQUlFLFlBQVksQ0FBQ0MsR0FBRyxDQUFDLENBQUNDO1lBQ3BDLE1BQU1DLE9BQU9ELEdBQUdDLElBQUk7WUFDcEIsTUFBTUMsZUFBZUYsR0FBR0csSUFBSSxDQUFDSixHQUFHLENBQUMsQ0FBQ0ssTUFBUVosNkNBQVFBLENBQUNhLFdBQVcsQ0FBQ0QsS0FBS1IsSUFBSVUsS0FBSztZQUM3RSxNQUFNQyxTQUFTakIsb0RBQVksQ0FBQ1ksY0FBY0Q7WUFDMUMsT0FBTztnQkFBQ0E7Z0JBQU07b0JBQUVRLGVBQWVULEdBQUdTLGFBQWE7b0JBQUVGO2dCQUFPO2FBQUU7UUFDOUQ7UUFDQSxJQUFJLENBQUNWLFNBQVMsR0FBRyxJQUFJYSxJQUFJYjtRQUN6QixNQUFNYyxpQkFBaUJkLFVBQVVFLEdBQUcsQ0FBQyxDQUFDLENBQUNFLE1BQU0sRUFBRVEsYUFBYSxFQUFFRixNQUFNLEVBQUUsQ0FBQztZQUNuRSxPQUFPO2dCQUFDbkIsa0RBQVcsQ0FBQ3FCO2dCQUFnQjtvQkFBRVI7b0JBQU1NO2dCQUFPO2FBQUU7UUFDekQ7UUFDQSxJQUFJLENBQUNJLGNBQWMsR0FBRyxJQUFJRCxJQUFJQztJQUNsQztJQUNBOztLQUVDLEdBQ0RDLE9BQU9DLE1BQU0sRUFBRWIsRUFBRSxFQUFFO1FBQ2YsTUFBTWMsU0FBU3pCLDBDQUFNQSxDQUFDMEIsS0FBSyxDQUFDLE9BQU8sOEJBQThCO1FBQ2pFLE1BQU1DLFVBQVUsSUFBSSxDQUFDbkIsU0FBUyxDQUFDb0IsR0FBRyxDQUFDSjtR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LEdBQUcsRUFBRUUsUUFBUSxDQUFDLEdBQUdBO2dCQUN0RCxPQUFPckQscUJBQXFCVyxrQkFBa0IsQ0FBQ3lDLFFBQVF4QyxRQUFRLEVBQUU0QztZQUNyRSxPQUNLO2dCQUNELE9BQU87b0JBQ0gsR0FBR0osT0FBTztvQkFDVmpGLE1BQU1nRixTQUFTLENBQUMsRUFBRUEsT0FBTyxHQUFHLEVBQUVFLFFBQVEsQ0FBQyxHQUFHQTtnQkFDOUM7WUFDSjtRQUNKLEdBQ0tJLElBQUk7SUFDYjtBQUNKO0FBQ0EsU0FBU0gsYUFBYWYsS0FBSztJQUN2QixNQUFNbUIsU0FBU25CLE1BQU1vQixPQUFPLENBQUMsWUFBWTtJQUN6QyxPQUFPRCxPQUFPRSxNQUFNLENBQUMsR0FBR0MsV0FBVyxLQUFLSCxPQUFPbkUsS0FBSyxDQUFDO0FBQ3pELEVBQ0EsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AY29yYWwteHl6L2FuY2hvci9kaXN0L2VzbS9jb2Rlci9ib3JzaC9pbnN0cnVjdGlvbi5qcz8wZmZjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBiczU4IGZyb20gXCJiczU4XCI7XG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tIFwiYnVmZmVyXCI7XG5pbXBvcnQgKiBhcyBib3JzaCBmcm9tIFwiQGNvcmFsLXh5ei9ib3JzaFwiO1xuaW1wb3J0IHsgaGFuZGxlRGVmaW5lZEZpZWxkcywgfSBmcm9tIFwiLi4vLi4vaWRsLmpzXCI7XG5pbXBvcnQgeyBJZGxDb2RlciB9IGZyb20gXCIuL2lkbC5qc1wiO1xuaW1wb3J0IHsgRElTQ1JJTUlOQVRPUl9TSVpFIH0gZnJvbSBcIi4uL2luZGV4LmpzXCI7XG4vKipcbiAqIEVuY29kZXMgYW5kIGRlY29kZXMgcHJvZ3JhbSBpbnN0cnVjdGlvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBCb3JzaEluc3RydWN0aW9uQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGlkbCkge1xuICAgICAgICB0aGlzLmlkbCA9IGlkbDtcbiAgICAgICAgY29uc3QgaXhMYXlvdXRzID0gaWRsLmluc3RydWN0aW9ucy5tYXAoKGl4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gaXgubmFtZTtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkTGF5b3V0cyA9IGl4LmFyZ3MubWFwKChhcmcpID0+IElkbENvZGVyLmZpZWxkTGF5b3V0KGFyZywgaWRsLnR5cGVzKSk7XG4gICAgICAgICAgICBjb25zdCBsYXlvdXQgPSBib3JzaC5zdHJ1Y3QoZmllbGRMYXlvdXRzLCBuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBbbmFtZSwgeyBkaXNjcmltaW5hdG9yOiBpeC5kaXNjcmltaW5hdG9yLCBsYXlvdXQgfV07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLml4TGF5b3V0cyA9IG5ldyBNYXAoaXhMYXlvdXRzKTtcbiAgICAgICAgY29uc3Qgc2lnaGFzaExheW91dHMgPSBpeExheW91dHMubWFwKChbbmFtZSwgeyBkaXNjcmltaW5hdG9yLCBsYXlvdXQgfV0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbYnM1OC5lbmNvZGUoZGlzY3JpbWluYXRvciksIHsgbmFtZSwgbGF5b3V0IH1dO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zaWdoYXNoTGF5b3V0cyA9IG5ldyBNYXAoc2lnaGFzaExheW91dHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIGEgcHJvZ3JhbSBpbnN0cnVjdGlvbi5cbiAgICAgKi9cbiAgICBlbmNvZGUoaXhOYW1lLCBpeCkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTAwMCk7IC8vIFRPRE86IHVzZSBhIHRpZ2h0ZXIgYnVmZmVyLlxuICAgICAgICBjb25zdCBlbmNvZGVyID0gdGhpcy5peExheW91dHMuZ2V0KGl4TmFtZSk7XG4gICAgICAgIGlmICghZW5jb2Rlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG1ldGhvZDogJHtpeE5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuID0gZW5jb2Rlci5sYXlvdXQuZW5jb2RlKGl4LCBidWZmZXIpO1xuICAgICAgICBjb25zdCBkYXRhID0gYnVmZmVyLnNsaWNlKDAsIGxlbik7XG4gICAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShlbmNvZGVyLmRpc2NyaW1pbmF0b3IpLCBkYXRhXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY29kZXMgYSBwcm9ncmFtIGluc3RydWN0aW9uLlxuICAgICAqL1xuICAgIGRlY29kZShpeCwgZW5jb2RpbmcgPSBcImhleFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaXggPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGl4ID0gZW5jb2RpbmcgPT09IFwiaGV4XCIgPyBCdWZmZXIuZnJvbShpeCwgXCJoZXhcIikgOiBiczU4LmRlY29kZShpeCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlzYyA9IGl4LnNsaWNlKDAsIERJU0NSSU1JTkFUT1JfU0laRSk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBpeC5zbGljZShESVNDUklNSU5BVE9SX1NJWkUpO1xuICAgICAgICBjb25zdCBkZWNvZGVyID0gdGhpcy5zaWdoYXNoTGF5b3V0cy5nZXQoYnM1OC5lbmNvZGUoZGlzYykpO1xuICAgICAgICBpZiAoIWRlY29kZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBkZWNvZGVyLm5hbWUsXG4gICAgICAgICAgICBkYXRhOiBkZWNvZGVyLmxheW91dC5kZWNvZGUoZGF0YSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmb3JtYXR0ZWQgdGFibGUgb2YgYWxsIHRoZSBmaWVsZHMgaW4gdGhlIGdpdmVuIGluc3RydWN0aW9uIGRhdGEuXG4gICAgICovXG4gICAgZm9ybWF0KGl4LCBhY2NvdW50TWV0YXMpIHtcbiAgICAgICAgcmV0dXJuIEluc3RydWN0aW9uRm9ybWF0dGVyLmZvcm1hdChpeCwgYWNjb3VudE1ldGFzLCB0aGlzLmlkbCk7XG4gICAgfVxufVxuY2xhc3MgSW5zdHJ1Y3Rpb25Gb3JtYXR0ZXIge1xuICAgIHN0YXRpYyBmb3JtYXQoaXgsIGFjY291bnRNZXRhcywgaWRsKSB7XG4gICAgICAgIGNvbnN0IGlkbEl4ID0gaWRsLmluc3RydWN0aW9ucy5maW5kKChpKSA9PiBpeC5uYW1lID09PSBpLm5hbWUpO1xuICAgICAgICBpZiAoIWlkbEl4KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBpbnN0cnVjdGlvbiBnaXZlblwiKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBpZGxJeC5hcmdzLm1hcCgoaWRsRmllbGQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogaWRsRmllbGQubmFtZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnN0cnVjdGlvbkZvcm1hdHRlci5mb3JtYXRJZGxUeXBlKGlkbEZpZWxkLnR5cGUpLFxuICAgICAgICAgICAgICAgIGRhdGE6IEluc3RydWN0aW9uRm9ybWF0dGVyLmZvcm1hdElkbERhdGEoaWRsRmllbGQsIGl4LmRhdGFbaWRsRmllbGQubmFtZV0sIGlkbC50eXBlcyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZmxhdElkbEFjY291bnRzID0gSW5zdHJ1Y3Rpb25Gb3JtYXR0ZXIuZmxhdHRlbklkbEFjY291bnRzKGlkbEl4LmFjY291bnRzKTtcbiAgICAgICAgY29uc3QgYWNjb3VudHMgPSBhY2NvdW50TWV0YXMubWFwKChtZXRhLCBpZHgpID0+IHtcbiAgICAgICAgICAgIGlmIChpZHggPCBmbGF0SWRsQWNjb3VudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZmxhdElkbEFjY291bnRzW2lkeF0ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgLi4ubWV0YSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gXCJSZW1haW5pbmcgYWNjb3VudHNcIiBhcmUgdW5uYW1lZCBpbiBBbmNob3IuXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIC4uLm1ldGEsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgYWNjb3VudHMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBmb3JtYXRJZGxUeXBlKGlkbFR5cGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpZGxUeXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gaWRsVHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJvcHRpb25cIiBpbiBpZGxUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gYE9wdGlvbjwke3RoaXMuZm9ybWF0SWRsVHlwZShpZGxUeXBlLm9wdGlvbil9PmA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwiY29wdGlvblwiIGluIGlkbFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBgQ09wdGlvbjwke3RoaXMuZm9ybWF0SWRsVHlwZShpZGxUeXBlLmNvcHRpb24pfT5gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcInZlY1wiIGluIGlkbFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBgVmVjPCR7dGhpcy5mb3JtYXRJZGxUeXBlKGlkbFR5cGUudmVjKX0+YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJhcnJheVwiIGluIGlkbFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBgQXJyYXk8JHtpZGxUeXBlLmFycmF5WzBdfTsgJHtpZGxUeXBlLmFycmF5WzFdfT5gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcImRlZmluZWRcIiBpbiBpZGxUeXBlKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gaWRsVHlwZS5kZWZpbmVkLm5hbWU7XG4gICAgICAgICAgICBpZiAoaWRsVHlwZS5kZWZpbmVkLmdlbmVyaWNzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJpY3MgPSBpZGxUeXBlLmRlZmluZWQuZ2VuZXJpY3NcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGcua2luZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInR5cGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSW5zdHJ1Y3Rpb25Gb3JtYXR0ZXIuZm9ybWF0SWRsVHlwZShnLnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNvbnN0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGcudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHtuYW1lfTwke2dlbmVyaWNzfT5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIElETCB0eXBlOiAke2lkbFR5cGV9YCk7XG4gICAgfVxuICAgIHN0YXRpYyBmb3JtYXRJZGxEYXRhKGlkbEZpZWxkLCBkYXRhLCB0eXBlcykge1xuICAgICAgICBpZiAodHlwZW9mIGlkbEZpZWxkLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwidmVjXCIgaW4gaWRsRmllbGQudHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIChcIltcIiArXG4gICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgICAgICAgICAubWFwKChkKSA9PiB0aGlzLmZvcm1hdElkbERhdGEoeyBuYW1lOiBcIlwiLCB0eXBlOiBpZGxGaWVsZC50eXBlLnZlYyB9LCBkLCB0eXBlcykpXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKFwiLCBcIikgK1xuICAgICAgICAgICAgICAgIFwiXVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJvcHRpb25cIiBpbiBpZGxGaWVsZC50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YSA9PT0gbnVsbFxuICAgICAgICAgICAgICAgID8gXCJudWxsXCJcbiAgICAgICAgICAgICAgICA6IHRoaXMuZm9ybWF0SWRsRGF0YSh7IG5hbWU6IFwiXCIsIHR5cGU6IGlkbEZpZWxkLnR5cGUub3B0aW9uIH0sIGRhdGEsIHR5cGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJkZWZpbmVkXCIgaW4gaWRsRmllbGQudHlwZSkge1xuICAgICAgICAgICAgaWYgKCF0eXBlcykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVzZXIgZGVmaW5lZCB0eXBlcyBub3QgcHJvdmlkZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZWZpbmVkTmFtZSA9IGlkbEZpZWxkLnR5cGUuZGVmaW5lZC5uYW1lO1xuICAgICAgICAgICAgY29uc3QgdHlwZURlZiA9IHR5cGVzLmZpbmQoKHQpID0+IHQubmFtZSA9PT0gZGVmaW5lZE5hbWUpO1xuICAgICAgICAgICAgaWYgKCF0eXBlRGVmKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUeXBlIG5vdCBmb3VuZDogJHtkZWZpbmVkTmFtZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBJbnN0cnVjdGlvbkZvcm1hdHRlci5mb3JtYXRJZGxEYXRhRGVmaW5lZCh0eXBlRGVmLCBkYXRhLCB0eXBlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwidW5rbm93blwiO1xuICAgIH1cbiAgICBzdGF0aWMgZm9ybWF0SWRsRGF0YURlZmluZWQodHlwZURlZiwgZGF0YSwgdHlwZXMpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlRGVmLnR5cGUua2luZCkge1xuICAgICAgICAgICAgY2FzZSBcInN0cnVjdFwiOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcInsgXCIgK1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVEZWZpbmVkRmllbGRzKHR5cGVEZWYudHlwZS5maWVsZHMsICgpID0+IFwiXCIsIChmaWVsZHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyhkYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKFtrZXksIHZhbF0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZCA9IGZpZWxkcy5maW5kKChmKSA9PiBmLm5hbWUgPT09IGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpZWxkIG5vdCBmb3VuZDogJHtrZXl9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoa2V5ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5zdHJ1Y3Rpb25Gb3JtYXR0ZXIuZm9ybWF0SWRsRGF0YShmaWVsZCwgdmFsLCB0eXBlcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgICAgICAgICB9LCAoZmllbGRzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKChba2V5LCB2YWxdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChrZXkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbnN0cnVjdGlvbkZvcm1hdHRlci5mb3JtYXRJZGxEYXRhKHsgbmFtZTogXCJcIiwgdHlwZTogZmllbGRzW2tleV0gfSwgdmFsLCB0eXBlcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgICAgICAgICB9KSArXG4gICAgICAgICAgICAgICAgICAgIFwiIH1cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZW51bVwiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFyaWFudE5hbWUgPSBPYmplY3Qua2V5cyhkYXRhKVswXTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YXJpYW50ID0gdHlwZURlZi50eXBlLnZhcmlhbnRzLmZpbmQoKHYpID0+IHYubmFtZSA9PT0gdmFyaWFudE5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICghdmFyaWFudCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmaW5kIHZhcmlhbnQ6ICR7dmFyaWFudE5hbWV9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGVudW1WYWx1ZSA9IGRhdGFbdmFyaWFudE5hbWVdO1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVEZWZpbmVkRmllbGRzKHZhcmlhbnQuZmllbGRzLCAoKSA9PiB2YXJpYW50TmFtZSwgKGZpZWxkcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lZEZpZWxkcyA9IE9iamVjdC5rZXlzKGVudW1WYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKGYpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkRGF0YSA9IGVudW1WYWx1ZVtmXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkbEZpZWxkID0gZmllbGRzLmZpbmQoKHYpID0+IHYubmFtZSA9PT0gZik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlkbEZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGaWVsZCBub3QgZm91bmQ6ICR7Zn1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbnN0cnVjdGlvbkZvcm1hdHRlci5mb3JtYXRJZGxEYXRhKGlkbEZpZWxkLCBmaWVsZERhdGEsIHR5cGVzKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCR7dmFyaWFudE5hbWV9IHsgJHtuYW1lZEZpZWxkc30gfWA7XG4gICAgICAgICAgICAgICAgfSwgKGZpZWxkcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0dXBsZUZpZWxkcyA9IE9iamVjdC5lbnRyaWVzKGVudW1WYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKFtrZXksIHZhbF0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoa2V5ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEluc3RydWN0aW9uRm9ybWF0dGVyLmZvcm1hdElkbERhdGEoeyBuYW1lOiBcIlwiLCB0eXBlOiBmaWVsZHNba2V5XSB9LCB2YWwsIHR5cGVzKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCR7dmFyaWFudE5hbWV9IHsgJHt0dXBsZUZpZWxkc30gfWA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidHlwZVwiOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEluc3RydWN0aW9uRm9ybWF0dGVyLmZvcm1hdElkbFR5cGUodHlwZURlZi50eXBlLmFsaWFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZmxhdHRlbklkbEFjY291bnRzKGFjY291bnRzLCBwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIGFjY291bnRzXG4gICAgICAgICAgICAubWFwKChhY2NvdW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhY2NOYW1lID0gc2VudGVuY2VDYXNlKGFjY291bnQubmFtZSk7XG4gICAgICAgICAgICBpZiAoYWNjb3VudC5oYXNPd25Qcm9wZXJ0eShcImFjY291bnRzXCIpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3UHJlZml4ID0gcHJlZml4ID8gYCR7cHJlZml4fSA+ICR7YWNjTmFtZX1gIDogYWNjTmFtZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gSW5zdHJ1Y3Rpb25Gb3JtYXR0ZXIuZmxhdHRlbklkbEFjY291bnRzKGFjY291bnQuYWNjb3VudHMsIG5ld1ByZWZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5hY2NvdW50LFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBwcmVmaXggPyBgJHtwcmVmaXh9ID4gJHthY2NOYW1lfWAgOiBhY2NOYW1lLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZmxhdCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNlbnRlbmNlQ2FzZShmaWVsZCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGZpZWxkLnJlcGxhY2UoLyhbQS1aXSkvZywgXCIgJDFcIik7XG4gICAgcmV0dXJuIHJlc3VsdC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHJlc3VsdC5zbGljZSgxKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluc3RydWN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJiczU4IiwiQnVmZmVyIiwiYm9yc2giLCJoYW5kbGVEZWZpbmVkRmllbGRzIiwiSWRsQ29kZXIiLCJESVNDUklNSU5BVE9SX1NJWkUiLCJCb3JzaEluc3RydWN0aW9uQ29kZXIiLCJjb25zdHJ1Y3RvciIsImlkbCIsIml4TGF5b3V0cyIsImluc3RydWN0aW9ucyIsIm1hcCIsIml4IiwibmFtZSIsImZpZWxkTGF5b3V0cyIsImFyZ3MiLCJhcmciLCJmaWVsZExheW91dCIsInR5cGVzIiwibGF5b3V0Iiwic3RydWN0IiwiZGlzY3JpbWluYXRvciIsIk1hcCIsInNpZ2hhc2hMYXlvdXRzIiwiZW5jb2RlIiwiaXhOYW1lIiwiYnVmZmVyIiwiYWxsb2MiLCJlbmNvZGVyIiwiZ2V0IiwiRXJyb3IiLCJsZW4iLCJkYXRhIiwic2xpY2UiLCJjb25jYXQiLCJmcm9tIiwiZGVjb2RlIiwiZW5jb2RpbmciLCJkaXNjIiwiZGVjb2RlciIsImZvcm1hdCIsImFjY291bnRNZXRhcyIsIkluc3RydWN0aW9uRm9ybWF0dGVyIiwiaWRsSXgiLCJmaW5kIiwiaSIsImNvbnNvbGUiLCJlcnJvciIsImlkbEZpZWxkIiwidHlwZSIsImZvcm1hdElkbFR5cGUiLCJmb3JtYXRJZGxEYXRhIiwiZmxhdElkbEFjY291bnRzIiwiZmxhdHRlbklkbEFjY291bnRzIiwiYWNjb3VudHMiLCJtZXRhIiwiaWR4IiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiaWRsVHlwZSIsIm9wdGlvbiIsImNvcHRpb24iLCJ2ZWMiLCJhcnJheSIsImRlZmluZWQiLCJnZW5lcmljcyIsImciLCJraW5kIiwidmFsdWUiLCJqb2luIiwidG9TdHJpbmciLCJkIiwiZGVmaW5lZE5hbWUiLCJ0eXBlRGVmIiwidCIsImZvcm1hdElkbERhdGFEZWZpbmVkIiwiZmllbGRzIiwiT2JqZWN0IiwiZW50cmllcyIsImtleSIsInZhbCIsImZpZWxkIiwiZiIsInZhcmlhbnROYW1lIiwia2V5cyIsInZhcmlhbnQiLCJ2YXJpYW50cyIsInYiLCJlbnVtVmFsdWUiLCJuYW1lZEZpZWxkcyIsImZpZWxkRGF0YSIsInR1cGxlRmllbGRzIiwiYWxpYXMiLCJwcmVmaXgiLCJhY2NvdW50IiwiYWNjTmFtZSIsInNlbnRlbmNlQ2FzZSIsImhhc093blByb3BlcnR5IiwibmV3UHJlZml4IiwiZmxhdCIsInJlc3VsdCIsInJlcGxhY2UiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/borsh/instruction.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/borsh/types.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/coder/borsh/types.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BorshTypesCoder: () => (/* binding */ BorshTypesCoder)\n/* harmony export */ });\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(buffer__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _idl_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./idl.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/borsh/idl.js\");\n\n\n/**\n * Encodes and decodes user-defined types.\n */ class BorshTypesCoder {\n    constructor(idl){\n        const types = idl.types;\n        if (!types) {\n            this.typeLayouts = new Map();\n            return;\n        }\n        const layouts = types.filter((ty)=>!ty.generics).map((ty)=>[\n                ty.name,\n                _idl_js__WEBPACK_IMPORTED_MODULE_1__.IdlCoder.typeDefLayout({\n                    typeDef: ty,\n                    types\n                })\n            ]);\n        this.typeLayouts = new Map(layouts);\n    }\n    encode(name, type) {\n        const buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(1000); // TODO: use a tighter buffer.\n        const layout = this.typeLayouts.get(name);\n        if (!layout) {\n            throw new Error(`Unknown type: ${name}`);\n        }\n        const len = layout.encode(type, buffer);\n        return buffer.slice(0, len);\n    }\n    decode(name, data) {\n        const layout = this.typeLayouts.get(name);\n        if (!layout) {\n            throw new Error(`Unknown type: ${name}`);\n        }\n        return layout.decode(data);\n    }\n} //# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL2NvZGVyL2JvcnNoL3R5cGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBZ0M7QUFDSTtBQUNwQzs7Q0FFQyxHQUNNLE1BQU1FO0lBQ1RDLFlBQVlDLEdBQUcsQ0FBRTtRQUNiLE1BQU1DLFFBQVFELElBQUlDLEtBQUs7UUFDdkIsSUFBSSxDQUFDQSxPQUFPO1lBQ1IsSUFBSSxDQUFDQyxXQUFXLEdBQUcsSUFBSUM7WUFDdkI7UUFDSjtRQUNBLE1BQU1DLFVBQVVILE1BQ1hJLE1BQU0sQ0FBQyxDQUFDQyxLQUFPLENBQUNBLEdBQUdDLFFBQVEsRUFDM0JDLEdBQUcsQ0FBQyxDQUFDRixLQUFPO2dCQUNiQSxHQUFHRyxJQUFJO2dCQUNQWiw2Q0FBUUEsQ0FBQ2EsYUFBYSxDQUFDO29CQUFFQyxTQUFTTDtvQkFBSUw7Z0JBQU07YUFDL0M7UUFDRCxJQUFJLENBQUNDLFdBQVcsR0FBRyxJQUFJQyxJQUFJQztJQUMvQjtJQUNBUSxPQUFPSCxJQUFJLEVBQUVJLElBQUksRUFBRTtRQUNmLE1BQU1DLFNBQVNsQiwwQ0FBTUEsQ0FBQ21CLEtBQUssQ0FBQyxPQUFPLDhCQUE4QjtRQUNqRSxNQUFNQyxTQUFTLElBQUksQ0FBQ2QsV0FBVyxDQUFDZSxHQUFHLENBQUNSO1FBQ3BDLElBQUksQ0FBQ08sUUFBUTtZQUNULE1BQU0sSUFBSUUsTUFBTSxDQUFDLGNBQWMsRUFBRVQsS0FBSyxDQUFDO1FBQzNDO1FBQ0EsTUFBTVUsTUFBTUgsT0FBT0osTUFBTSxDQUFDQyxNQUFNQztRQUNoQyxPQUFPQSxPQUFPTSxLQUFLLENBQUMsR0FBR0Q7SUFDM0I7SUFDQUUsT0FBT1osSUFBSSxFQUFFYSxJQUFJLEVBQUU7UUFDZixNQUFNTixTQUFTLElBQUksQ0FBQ2QsV0FBVyxDQUFDZSxHQUFHLENBQUNSO1FBQ3BDLElBQUksQ0FBQ08sUUFBUTtZQUNULE1BQU0sSUFBSUUsTUFBTSxDQUFDLGNBQWMsRUFBRVQsS0FBSyxDQUFDO1FBQzNDO1FBQ0EsT0FBT08sT0FBT0ssTUFBTSxDQUFDQztJQUN6QjtBQUNKLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AY29yYWwteHl6L2FuY2hvci9kaXN0L2VzbS9jb2Rlci9ib3JzaC90eXBlcy5qcz9hODQzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1ZmZlciB9IGZyb20gXCJidWZmZXJcIjtcbmltcG9ydCB7IElkbENvZGVyIH0gZnJvbSBcIi4vaWRsLmpzXCI7XG4vKipcbiAqIEVuY29kZXMgYW5kIGRlY29kZXMgdXNlci1kZWZpbmVkIHR5cGVzLlxuICovXG5leHBvcnQgY2xhc3MgQm9yc2hUeXBlc0NvZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihpZGwpIHtcbiAgICAgICAgY29uc3QgdHlwZXMgPSBpZGwudHlwZXM7XG4gICAgICAgIGlmICghdHlwZXMpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZUxheW91dHMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGF5b3V0cyA9IHR5cGVzXG4gICAgICAgICAgICAuZmlsdGVyKCh0eSkgPT4gIXR5LmdlbmVyaWNzKVxuICAgICAgICAgICAgLm1hcCgodHkpID0+IFtcbiAgICAgICAgICAgIHR5Lm5hbWUsXG4gICAgICAgICAgICBJZGxDb2Rlci50eXBlRGVmTGF5b3V0KHsgdHlwZURlZjogdHksIHR5cGVzIH0pLFxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy50eXBlTGF5b3V0cyA9IG5ldyBNYXAobGF5b3V0cyk7XG4gICAgfVxuICAgIGVuY29kZShuYW1lLCB0eXBlKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMDAwKTsgLy8gVE9ETzogdXNlIGEgdGlnaHRlciBidWZmZXIuXG4gICAgICAgIGNvbnN0IGxheW91dCA9IHRoaXMudHlwZUxheW91dHMuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoIWxheW91dCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHR5cGU6ICR7bmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW4gPSBsYXlvdXQuZW5jb2RlKHR5cGUsIGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiBidWZmZXIuc2xpY2UoMCwgbGVuKTtcbiAgICB9XG4gICAgZGVjb2RlKG5hbWUsIGRhdGEpIHtcbiAgICAgICAgY29uc3QgbGF5b3V0ID0gdGhpcy50eXBlTGF5b3V0cy5nZXQobmFtZSk7XG4gICAgICAgIGlmICghbGF5b3V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gdHlwZTogJHtuYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYXlvdXQuZGVjb2RlKGRhdGEpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJCdWZmZXIiLCJJZGxDb2RlciIsIkJvcnNoVHlwZXNDb2RlciIsImNvbnN0cnVjdG9yIiwiaWRsIiwidHlwZXMiLCJ0eXBlTGF5b3V0cyIsIk1hcCIsImxheW91dHMiLCJmaWx0ZXIiLCJ0eSIsImdlbmVyaWNzIiwibWFwIiwibmFtZSIsInR5cGVEZWZMYXlvdXQiLCJ0eXBlRGVmIiwiZW5jb2RlIiwidHlwZSIsImJ1ZmZlciIsImFsbG9jIiwibGF5b3V0IiwiZ2V0IiwiRXJyb3IiLCJsZW4iLCJzbGljZSIsImRlY29kZSIsImRhdGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/borsh/types.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/index.js":
/*!*****************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/coder/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BorshAccountsCoder: () => (/* reexport safe */ _borsh_index_js__WEBPACK_IMPORTED_MODULE_0__.BorshAccountsCoder),\n/* harmony export */   BorshCoder: () => (/* reexport safe */ _borsh_index_js__WEBPACK_IMPORTED_MODULE_0__.BorshCoder),\n/* harmony export */   BorshEventCoder: () => (/* reexport safe */ _borsh_index_js__WEBPACK_IMPORTED_MODULE_0__.BorshEventCoder),\n/* harmony export */   BorshInstructionCoder: () => (/* reexport safe */ _borsh_index_js__WEBPACK_IMPORTED_MODULE_0__.BorshInstructionCoder),\n/* harmony export */   DISCRIMINATOR_SIZE: () => (/* reexport safe */ _borsh_index_js__WEBPACK_IMPORTED_MODULE_0__.DISCRIMINATOR_SIZE),\n/* harmony export */   SystemCoder: () => (/* reexport safe */ _system_index_js__WEBPACK_IMPORTED_MODULE_1__.SystemCoder)\n/* harmony export */ });\n/* harmony import */ var _borsh_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./borsh/index.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/borsh/index.js\");\n/* harmony import */ var _system_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./system/index.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/system/index.js\");\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL2NvZGVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWlDO0FBQ0MsQ0FDbEMsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AY29yYWwteHl6L2FuY2hvci9kaXN0L2VzbS9jb2Rlci9pbmRleC5qcz81MmUwIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gXCIuL2JvcnNoL2luZGV4LmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zeXN0ZW0vaW5kZXguanNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/system/accounts.js":
/*!***************************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/coder/system/accounts.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SystemAccountsCoder: () => (/* binding */ SystemAccountsCoder)\n/* harmony export */ });\n/* harmony import */ var buffer_layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer-layout */ \"(ssr)/../node_modules/buffer-layout/lib/Layout.js\");\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/node_modules/@solana/web3.js/lib/index.esm.js\");\n/* harmony import */ var _borsh_idl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../borsh/idl.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/borsh/idl.js\");\n\n\n\nclass SystemAccountsCoder {\n    constructor(idl){\n        this.idl = idl;\n    }\n    async encode(accountName, account) {\n        switch(accountName){\n            case \"nonce\":\n                {\n                    const buffer = Buffer.alloc(_solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.NONCE_ACCOUNT_LENGTH);\n                    const len = NONCE_ACCOUNT_LAYOUT.encode(account, buffer);\n                    return buffer.slice(0, len);\n                }\n            default:\n                {\n                    throw new Error(`Invalid account name: ${accountName}`);\n                }\n        }\n    }\n    decode(accountName, ix) {\n        return this.decodeUnchecked(accountName, ix);\n    }\n    decodeUnchecked(accountName, ix) {\n        switch(accountName){\n            case \"nonce\":\n                {\n                    return decodeNonceAccount(ix);\n                }\n            default:\n                {\n                    throw new Error(`Invalid account name: ${accountName}`);\n                }\n        }\n    }\n    // TODO: this won't use the appendData.\n    memcmp(accountName, _appendData) {\n        switch(accountName){\n            case \"nonce\":\n                {\n                    return {\n                        dataSize: _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.NONCE_ACCOUNT_LENGTH\n                    };\n                }\n            default:\n                {\n                    throw new Error(`Invalid account name: ${accountName}`);\n                }\n        }\n    }\n    size(accountName) {\n        return _borsh_idl_js__WEBPACK_IMPORTED_MODULE_2__.IdlCoder.typeSize({\n            defined: {\n                name: accountName\n            }\n        }, this.idl);\n    }\n}\nfunction decodeNonceAccount(ix) {\n    return NONCE_ACCOUNT_LAYOUT.decode(ix);\n}\nclass WrappedLayout extends buffer_layout__WEBPACK_IMPORTED_MODULE_0__.Layout {\n    constructor(layout, decoder, encoder, property){\n        super(layout.span, property);\n        this.layout = layout;\n        this.decoder = decoder;\n        this.encoder = encoder;\n    }\n    decode(b, offset) {\n        return this.decoder(this.layout.decode(b, offset));\n    }\n    encode(src, b, offset) {\n        return this.layout.encode(this.encoder(src), b, offset);\n    }\n    getSpan(b, offset) {\n        return this.layout.getSpan(b, offset);\n    }\n}\nfunction publicKey(property) {\n    return new WrappedLayout(buffer_layout__WEBPACK_IMPORTED_MODULE_0__.blob(32), (b)=>new _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.PublicKey(b), (key)=>key.toBuffer(), property);\n}\nconst NONCE_ACCOUNT_LAYOUT = buffer_layout__WEBPACK_IMPORTED_MODULE_0__.struct([\n    buffer_layout__WEBPACK_IMPORTED_MODULE_0__.u32(\"version\"),\n    buffer_layout__WEBPACK_IMPORTED_MODULE_0__.u32(\"state\"),\n    publicKey(\"authorizedPubkey\"),\n    publicKey(\"nonce\"),\n    buffer_layout__WEBPACK_IMPORTED_MODULE_0__.struct([\n        buffer_layout__WEBPACK_IMPORTED_MODULE_0__.nu64(\"lamportsPerSignature\")\n    ], \"feeCalculator\")\n]); //# sourceMappingURL=accounts.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL2NvZGVyL3N5c3RlbS9hY2NvdW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQThDO0FBQ29CO0FBQ3ZCO0FBQ3BDLE1BQU1JO0lBQ1RDLFlBQVlDLEdBQUcsQ0FBRTtRQUNiLElBQUksQ0FBQ0EsR0FBRyxHQUFHQTtJQUNmO0lBQ0EsTUFBTUMsT0FBT0MsV0FBVyxFQUFFQyxPQUFPLEVBQUU7UUFDL0IsT0FBUUQ7WUFDSixLQUFLO2dCQUFTO29CQUNWLE1BQU1FLFNBQVNDLE9BQU9DLEtBQUssQ0FBQ1gsaUVBQW9CQTtvQkFDaEQsTUFBTVksTUFBTUMscUJBQXFCUCxNQUFNLENBQUNFLFNBQVNDO29CQUNqRCxPQUFPQSxPQUFPSyxLQUFLLENBQUMsR0FBR0Y7Z0JBQzNCO1lBQ0E7Z0JBQVM7b0JBQ0wsTUFBTSxJQUFJRyxNQUFNLENBQUMsc0JBQXNCLEVBQUVSLFlBQVksQ0FBQztnQkFDMUQ7UUFDSjtJQUNKO0lBQ0FTLE9BQU9ULFdBQVcsRUFBRVUsRUFBRSxFQUFFO1FBQ3BCLE9BQU8sSUFBSSxDQUFDQyxlQUFlLENBQUNYLGFBQWFVO0lBQzdDO0lBQ0FDLGdCQUFnQlgsV0FBVyxFQUFFVSxFQUFFLEVBQUU7UUFDN0IsT0FBUVY7WUFDSixLQUFLO2dCQUFTO29CQUNWLE9BQU9ZLG1CQUFtQkY7Z0JBQzlCO1lBQ0E7Z0JBQVM7b0JBQ0wsTUFBTSxJQUFJRixNQUFNLENBQUMsc0JBQXNCLEVBQUVSLFlBQVksQ0FBQztnQkFDMUQ7UUFDSjtJQUNKO0lBQ0EsdUNBQXVDO0lBQ3ZDYSxPQUFPYixXQUFXLEVBQUVjLFdBQVcsRUFBRTtRQUM3QixPQUFRZDtZQUNKLEtBQUs7Z0JBQVM7b0JBQ1YsT0FBTzt3QkFDSGUsVUFBVXRCLGlFQUFvQkE7b0JBQ2xDO2dCQUNKO1lBQ0E7Z0JBQVM7b0JBQ0wsTUFBTSxJQUFJZSxNQUFNLENBQUMsc0JBQXNCLEVBQUVSLFlBQVksQ0FBQztnQkFDMUQ7UUFDSjtJQUNKO0lBQ0FnQixLQUFLaEIsV0FBVyxFQUFFO1FBQ2QsT0FBT0wsbURBQVFBLENBQUNzQixRQUFRLENBQUM7WUFBRUMsU0FBUztnQkFBRUMsTUFBTW5CO1lBQVk7UUFBRSxHQUFHLElBQUksQ0FBQ0YsR0FBRztJQUN6RTtBQUNKO0FBQ0EsU0FBU2MsbUJBQW1CRixFQUFFO0lBQzFCLE9BQU9KLHFCQUFxQkcsTUFBTSxDQUFDQztBQUN2QztBQUNBLE1BQU1VLHNCQUFzQjVCLGlEQUFtQjtJQUMzQ0ssWUFBWXlCLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxPQUFPLEVBQUVDLFFBQVEsQ0FBRTtRQUM1QyxLQUFLLENBQUNILE9BQU9JLElBQUksRUFBRUQ7UUFDbkIsSUFBSSxDQUFDSCxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDQyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxPQUFPLEdBQUdBO0lBQ25CO0lBQ0FmLE9BQU9rQixDQUFDLEVBQUVDLE1BQU0sRUFBRTtRQUNkLE9BQU8sSUFBSSxDQUFDTCxPQUFPLENBQUMsSUFBSSxDQUFDRCxNQUFNLENBQUNiLE1BQU0sQ0FBQ2tCLEdBQUdDO0lBQzlDO0lBQ0E3QixPQUFPOEIsR0FBRyxFQUFFRixDQUFDLEVBQUVDLE1BQU0sRUFBRTtRQUNuQixPQUFPLElBQUksQ0FBQ04sTUFBTSxDQUFDdkIsTUFBTSxDQUFDLElBQUksQ0FBQ3lCLE9BQU8sQ0FBQ0ssTUFBTUYsR0FBR0M7SUFDcEQ7SUFDQUUsUUFBUUgsQ0FBQyxFQUFFQyxNQUFNLEVBQUU7UUFDZixPQUFPLElBQUksQ0FBQ04sTUFBTSxDQUFDUSxPQUFPLENBQUNILEdBQUdDO0lBQ2xDO0FBQ0o7QUFDQSxTQUFTRyxVQUFVTixRQUFRO0lBQ3ZCLE9BQU8sSUFBSUwsY0FBYzVCLCtDQUFpQixDQUFDLEtBQUssQ0FBQ21DLElBQU0sSUFBSWpDLHNEQUFTQSxDQUFDaUMsSUFBSSxDQUFDTSxNQUFRQSxJQUFJQyxRQUFRLElBQUlUO0FBQ3RHO0FBQ0EsTUFBTW5CLHVCQUF1QmQsaURBQW1CLENBQUM7SUFDN0NBLDhDQUFnQixDQUFDO0lBQ2pCQSw4Q0FBZ0IsQ0FBQztJQUNqQnVDLFVBQVU7SUFDVkEsVUFBVTtJQUNWdkMsaURBQW1CLENBQUM7UUFBQ0EsK0NBQWlCLENBQUM7S0FBd0IsRUFBRTtDQUNwRSxHQUNELG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGNvcmFsLXh5ei9hbmNob3IvZGlzdC9lc20vY29kZXIvc3lzdGVtL2FjY291bnRzLmpzPzM4NDEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQnVmZmVyTGF5b3V0IGZyb20gXCJidWZmZXItbGF5b3V0XCI7XG5pbXBvcnQgeyBOT05DRV9BQ0NPVU5UX0xFTkdUSCwgUHVibGljS2V5IH0gZnJvbSBcIkBzb2xhbmEvd2ViMy5qc1wiO1xuaW1wb3J0IHsgSWRsQ29kZXIgfSBmcm9tIFwiLi4vYm9yc2gvaWRsLmpzXCI7XG5leHBvcnQgY2xhc3MgU3lzdGVtQWNjb3VudHNDb2RlciB7XG4gICAgY29uc3RydWN0b3IoaWRsKSB7XG4gICAgICAgIHRoaXMuaWRsID0gaWRsO1xuICAgIH1cbiAgICBhc3luYyBlbmNvZGUoYWNjb3VudE5hbWUsIGFjY291bnQpIHtcbiAgICAgICAgc3dpdGNoIChhY2NvdW50TmFtZSkge1xuICAgICAgICAgICAgY2FzZSBcIm5vbmNlXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoTk9OQ0VfQUNDT1VOVF9MRU5HVEgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbiA9IE5PTkNFX0FDQ09VTlRfTEFZT1VULmVuY29kZShhY2NvdW50LCBidWZmZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIuc2xpY2UoMCwgbGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYWNjb3VudCBuYW1lOiAke2FjY291bnROYW1lfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRlY29kZShhY2NvdW50TmFtZSwgaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlVW5jaGVja2VkKGFjY291bnROYW1lLCBpeCk7XG4gICAgfVxuICAgIGRlY29kZVVuY2hlY2tlZChhY2NvdW50TmFtZSwgaXgpIHtcbiAgICAgICAgc3dpdGNoIChhY2NvdW50TmFtZSkge1xuICAgICAgICAgICAgY2FzZSBcIm5vbmNlXCI6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlTm9uY2VBY2NvdW50KGl4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYWNjb3VudCBuYW1lOiAke2FjY291bnROYW1lfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRPRE86IHRoaXMgd29uJ3QgdXNlIHRoZSBhcHBlbmREYXRhLlxuICAgIG1lbWNtcChhY2NvdW50TmFtZSwgX2FwcGVuZERhdGEpIHtcbiAgICAgICAgc3dpdGNoIChhY2NvdW50TmFtZSkge1xuICAgICAgICAgICAgY2FzZSBcIm5vbmNlXCI6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhU2l6ZTogTk9OQ0VfQUNDT1VOVF9MRU5HVEgsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYWNjb3VudCBuYW1lOiAke2FjY291bnROYW1lfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNpemUoYWNjb3VudE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIElkbENvZGVyLnR5cGVTaXplKHsgZGVmaW5lZDogeyBuYW1lOiBhY2NvdW50TmFtZSB9IH0sIHRoaXMuaWRsKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZWNvZGVOb25jZUFjY291bnQoaXgpIHtcbiAgICByZXR1cm4gTk9OQ0VfQUNDT1VOVF9MQVlPVVQuZGVjb2RlKGl4KTtcbn1cbmNsYXNzIFdyYXBwZWRMYXlvdXQgZXh0ZW5kcyBCdWZmZXJMYXlvdXQuTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihsYXlvdXQsIGRlY29kZXIsIGVuY29kZXIsIHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKGxheW91dC5zcGFuLCBwcm9wZXJ0eSk7XG4gICAgICAgIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICAgICAgICB0aGlzLmRlY29kZXIgPSBkZWNvZGVyO1xuICAgICAgICB0aGlzLmVuY29kZXIgPSBlbmNvZGVyO1xuICAgIH1cbiAgICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlY29kZXIodGhpcy5sYXlvdXQuZGVjb2RlKGIsIG9mZnNldCkpO1xuICAgIH1cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0LmVuY29kZSh0aGlzLmVuY29kZXIoc3JjKSwgYiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgZ2V0U3BhbihiLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0LmdldFNwYW4oYiwgb2Zmc2V0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBwdWJsaWNLZXkocHJvcGVydHkpIHtcbiAgICByZXR1cm4gbmV3IFdyYXBwZWRMYXlvdXQoQnVmZmVyTGF5b3V0LmJsb2IoMzIpLCAoYikgPT4gbmV3IFB1YmxpY0tleShiKSwgKGtleSkgPT4ga2V5LnRvQnVmZmVyKCksIHByb3BlcnR5KTtcbn1cbmNvbnN0IE5PTkNFX0FDQ09VTlRfTEFZT1VUID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbXG4gICAgQnVmZmVyTGF5b3V0LnUzMihcInZlcnNpb25cIiksXG4gICAgQnVmZmVyTGF5b3V0LnUzMihcInN0YXRlXCIpLFxuICAgIHB1YmxpY0tleShcImF1dGhvcml6ZWRQdWJrZXlcIiksXG4gICAgcHVibGljS2V5KFwibm9uY2VcIiksXG4gICAgQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0Lm51NjQoXCJsYW1wb3J0c1BlclNpZ25hdHVyZVwiKV0sIFwiZmVlQ2FsY3VsYXRvclwiKSxcbl0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWNjb3VudHMuanMubWFwIl0sIm5hbWVzIjpbIkJ1ZmZlckxheW91dCIsIk5PTkNFX0FDQ09VTlRfTEVOR1RIIiwiUHVibGljS2V5IiwiSWRsQ29kZXIiLCJTeXN0ZW1BY2NvdW50c0NvZGVyIiwiY29uc3RydWN0b3IiLCJpZGwiLCJlbmNvZGUiLCJhY2NvdW50TmFtZSIsImFjY291bnQiLCJidWZmZXIiLCJCdWZmZXIiLCJhbGxvYyIsImxlbiIsIk5PTkNFX0FDQ09VTlRfTEFZT1VUIiwic2xpY2UiLCJFcnJvciIsImRlY29kZSIsIml4IiwiZGVjb2RlVW5jaGVja2VkIiwiZGVjb2RlTm9uY2VBY2NvdW50IiwibWVtY21wIiwiX2FwcGVuZERhdGEiLCJkYXRhU2l6ZSIsInNpemUiLCJ0eXBlU2l6ZSIsImRlZmluZWQiLCJuYW1lIiwiV3JhcHBlZExheW91dCIsIkxheW91dCIsImxheW91dCIsImRlY29kZXIiLCJlbmNvZGVyIiwicHJvcGVydHkiLCJzcGFuIiwiYiIsIm9mZnNldCIsInNyYyIsImdldFNwYW4iLCJwdWJsaWNLZXkiLCJibG9iIiwia2V5IiwidG9CdWZmZXIiLCJzdHJ1Y3QiLCJ1MzIiLCJudTY0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/system/accounts.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/system/events.js":
/*!*************************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/coder/system/events.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SystemEventsCoder: () => (/* binding */ SystemEventsCoder)\n/* harmony export */ });\nclass SystemEventsCoder {\n    constructor(_idl){}\n    decode(_log) {\n        throw new Error(\"System program does not have events\");\n    }\n} //# sourceMappingURL=events.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL2NvZGVyL3N5c3RlbS9ldmVudHMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU1BO0lBQ1RDLFlBQVlDLElBQUksQ0FBRSxDQUFFO0lBQ3BCQyxPQUFPQyxJQUFJLEVBQUU7UUFDVCxNQUFNLElBQUlDLE1BQU07SUFDcEI7QUFDSixFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGNvcmFsLXh5ei9hbmNob3IvZGlzdC9lc20vY29kZXIvc3lzdGVtL2V2ZW50cy5qcz82NWYzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBTeXN0ZW1FdmVudHNDb2RlciB7XG4gICAgY29uc3RydWN0b3IoX2lkbCkgeyB9XG4gICAgZGVjb2RlKF9sb2cpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3lzdGVtIHByb2dyYW0gZG9lcyBub3QgaGF2ZSBldmVudHNcIik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXZlbnRzLmpzLm1hcCJdLCJuYW1lcyI6WyJTeXN0ZW1FdmVudHNDb2RlciIsImNvbnN0cnVjdG9yIiwiX2lkbCIsImRlY29kZSIsIl9sb2ciLCJFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/system/events.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/system/index.js":
/*!************************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/coder/system/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SystemCoder: () => (/* binding */ SystemCoder)\n/* harmony export */ });\n/* harmony import */ var _instruction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instruction.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/system/instruction.js\");\n/* harmony import */ var _accounts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./accounts.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/system/accounts.js\");\n/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/system/events.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/system/types.js\");\n\n\n\n\n/**\n * Coder for the System program.\n */ class SystemCoder {\n    constructor(idl){\n        this.instruction = new _instruction_js__WEBPACK_IMPORTED_MODULE_0__.SystemInstructionCoder(idl);\n        this.accounts = new _accounts_js__WEBPACK_IMPORTED_MODULE_1__.SystemAccountsCoder(idl);\n        this.events = new _events_js__WEBPACK_IMPORTED_MODULE_2__.SystemEventsCoder(idl);\n        this.types = new _types_js__WEBPACK_IMPORTED_MODULE_3__.SystemTypesCoder(idl);\n    }\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL2NvZGVyL3N5c3RlbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEwRDtBQUNOO0FBQ0o7QUFDRjtBQUM5Qzs7Q0FFQyxHQUNNLE1BQU1JO0lBQ1RDLFlBQVlDLEdBQUcsQ0FBRTtRQUNiLElBQUksQ0FBQ0MsV0FBVyxHQUFHLElBQUlQLG1FQUFzQkEsQ0FBQ007UUFDOUMsSUFBSSxDQUFDRSxRQUFRLEdBQUcsSUFBSVAsNkRBQW1CQSxDQUFDSztRQUN4QyxJQUFJLENBQUNHLE1BQU0sR0FBRyxJQUFJUCx5REFBaUJBLENBQUNJO1FBQ3BDLElBQUksQ0FBQ0ksS0FBSyxHQUFHLElBQUlQLHVEQUFnQkEsQ0FBQ0c7SUFDdEM7QUFDSixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGNvcmFsLXh5ei9hbmNob3IvZGlzdC9lc20vY29kZXIvc3lzdGVtL2luZGV4LmpzPzNjNTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU3lzdGVtSW5zdHJ1Y3Rpb25Db2RlciB9IGZyb20gXCIuL2luc3RydWN0aW9uLmpzXCI7XG5pbXBvcnQgeyBTeXN0ZW1BY2NvdW50c0NvZGVyIH0gZnJvbSBcIi4vYWNjb3VudHMuanNcIjtcbmltcG9ydCB7IFN5c3RlbUV2ZW50c0NvZGVyIH0gZnJvbSBcIi4vZXZlbnRzLmpzXCI7XG5pbXBvcnQgeyBTeXN0ZW1UeXBlc0NvZGVyIH0gZnJvbSBcIi4vdHlwZXMuanNcIjtcbi8qKlxuICogQ29kZXIgZm9yIHRoZSBTeXN0ZW0gcHJvZ3JhbS5cbiAqL1xuZXhwb3J0IGNsYXNzIFN5c3RlbUNvZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihpZGwpIHtcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbiA9IG5ldyBTeXN0ZW1JbnN0cnVjdGlvbkNvZGVyKGlkbCk7XG4gICAgICAgIHRoaXMuYWNjb3VudHMgPSBuZXcgU3lzdGVtQWNjb3VudHNDb2RlcihpZGwpO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IG5ldyBTeXN0ZW1FdmVudHNDb2RlcihpZGwpO1xuICAgICAgICB0aGlzLnR5cGVzID0gbmV3IFN5c3RlbVR5cGVzQ29kZXIoaWRsKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiU3lzdGVtSW5zdHJ1Y3Rpb25Db2RlciIsIlN5c3RlbUFjY291bnRzQ29kZXIiLCJTeXN0ZW1FdmVudHNDb2RlciIsIlN5c3RlbVR5cGVzQ29kZXIiLCJTeXN0ZW1Db2RlciIsImNvbnN0cnVjdG9yIiwiaWRsIiwiaW5zdHJ1Y3Rpb24iLCJhY2NvdW50cyIsImV2ZW50cyIsInR5cGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/system/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/system/instruction.js":
/*!******************************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/coder/system/instruction.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SystemInstructionCoder: () => (/* binding */ SystemInstructionCoder)\n/* harmony export */ });\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bn.js */ \"(ssr)/../node_modules/bn.js/lib/bn.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bn_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var buffer_layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! buffer-layout */ \"(ssr)/../node_modules/buffer-layout/lib/Layout.js\");\n\n\nclass SystemInstructionCoder {\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    constructor(_){}\n    encode(ixName, ix) {\n        switch(ixName){\n            case \"createAccount\":\n                {\n                    return encodeCreateAccount(ix);\n                }\n            case \"assign\":\n                {\n                    return encodeAssign(ix);\n                }\n            case \"transfer\":\n                {\n                    return encodeTransfer(ix);\n                }\n            case \"createAccountWithSeed\":\n                {\n                    return encodeCreateAccountWithSeed(ix);\n                }\n            case \"advanceNonceAccount\":\n                {\n                    return encodeAdvanceNonceAccount(ix);\n                }\n            case \"withdrawNonceAccount\":\n                {\n                    return encodeWithdrawNonceAccount(ix);\n                }\n            case \"initializeNonceAccount\":\n                {\n                    return encodeInitializeNonceAccount(ix);\n                }\n            case \"authorizeNonceAccount\":\n                {\n                    return encodeAuthorizeNonceAccount(ix);\n                }\n            case \"allocate\":\n                {\n                    return encodeAllocate(ix);\n                }\n            case \"allocateWithSeed\":\n                {\n                    return encodeAllocateWithSeed(ix);\n                }\n            case \"assignWithSeed\":\n                {\n                    return encodeAssignWithSeed(ix);\n                }\n            case \"transferWithSeed\":\n                {\n                    return encodeTransferWithSeed(ix);\n                }\n            default:\n                {\n                    throw new Error(`Invalid instruction: ${ixName}`);\n                }\n        }\n    }\n    encodeState(_ixName, _ix) {\n        throw new Error(\"System does not have state\");\n    }\n}\nclass RustStringLayout extends buffer_layout__WEBPACK_IMPORTED_MODULE_1__.Layout {\n    constructor(property){\n        super(-1, property);\n        this.property = property;\n        this.layout = buffer_layout__WEBPACK_IMPORTED_MODULE_1__.struct([\n            buffer_layout__WEBPACK_IMPORTED_MODULE_1__.u32(\"length\"),\n            buffer_layout__WEBPACK_IMPORTED_MODULE_1__.u32(\"lengthPadding\"),\n            buffer_layout__WEBPACK_IMPORTED_MODULE_1__.blob(buffer_layout__WEBPACK_IMPORTED_MODULE_1__.offset(buffer_layout__WEBPACK_IMPORTED_MODULE_1__.u32(), -8), \"chars\")\n        ], this.property);\n    }\n    encode(src, b, offset = 0) {\n        if (src === null || src === undefined) {\n            return this.layout.span;\n        }\n        const data = {\n            chars: Buffer.from(src, \"utf8\")\n        };\n        return this.layout.encode(data, b, offset);\n    }\n    decode(b, offset = 0) {\n        const data = this.layout.decode(b, offset);\n        return data[\"chars\"].toString();\n    }\n    getSpan(b, offset = 0) {\n        return buffer_layout__WEBPACK_IMPORTED_MODULE_1__.u32().span + buffer_layout__WEBPACK_IMPORTED_MODULE_1__.u32().span + new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(new Uint8Array(b).slice(offset, offset + 4), 10, \"le\").toNumber();\n    }\n}\nfunction rustStringLayout(property) {\n    return new RustStringLayout(property);\n}\nfunction publicKey(property) {\n    return buffer_layout__WEBPACK_IMPORTED_MODULE_1__.blob(32, property);\n}\nfunction encodeCreateAccount({ lamports, space, owner }) {\n    return encodeData({\n        createAccount: {\n            lamports,\n            space,\n            owner: owner.toBuffer()\n        }\n    });\n}\nfunction encodeAssign({ owner }) {\n    return encodeData({\n        assign: {\n            owner: owner.toBuffer()\n        }\n    });\n}\nfunction encodeTransfer({ lamports }) {\n    return encodeData({\n        transfer: {\n            lamports\n        }\n    });\n}\nfunction encodeCreateAccountWithSeed({ base, seed, lamports, space, owner }) {\n    return encodeData({\n        createAccountWithSeed: {\n            base: base.toBuffer(),\n            seed,\n            lamports,\n            space,\n            owner: owner.toBuffer()\n        }\n    }, LAYOUT.getVariant(3).span + seed.length);\n}\nfunction encodeInitializeNonceAccount({ authorized }) {\n    return encodeData({\n        initializeNonceAccount: {\n            authorized: authorized.toBuffer()\n        }\n    });\n}\nfunction encodeAdvanceNonceAccount({ authorized }) {\n    return encodeData({\n        advanceNonceAccount: {\n            authorized: authorized.toBuffer()\n        }\n    });\n}\nfunction encodeWithdrawNonceAccount({ lamports }) {\n    return encodeData({\n        withdrawNonceAccount: {\n            lamports\n        }\n    });\n}\nfunction encodeAuthorizeNonceAccount({ authorized }) {\n    return encodeData({\n        authorizeNonceAccount: {\n            authorized: authorized.toBuffer()\n        }\n    });\n}\nfunction encodeAllocate({ space }) {\n    return encodeData({\n        allocate: {\n            space\n        }\n    });\n}\nfunction encodeAllocateWithSeed({ base, seed, space, owner }) {\n    return encodeData({\n        allocateWithSeed: {\n            base: base.toBuffer(),\n            seed,\n            space,\n            owner: owner.toBuffer()\n        }\n    }, LAYOUT.getVariant(9).span + seed.length);\n}\nfunction encodeAssignWithSeed({ base, seed, owner }) {\n    return encodeData({\n        assignWithSeed: {\n            base: base.toBuffer(),\n            seed,\n            owner: owner.toBuffer()\n        }\n    }, LAYOUT.getVariant(10).span + seed.length);\n}\nfunction encodeTransferWithSeed({ lamports, seed, owner }) {\n    return encodeData({\n        transferWithSeed: {\n            lamports,\n            seed,\n            owner: owner.toBuffer()\n        }\n    }, LAYOUT.getVariant(11).span + seed.length);\n}\nconst LAYOUT = buffer_layout__WEBPACK_IMPORTED_MODULE_1__.union(buffer_layout__WEBPACK_IMPORTED_MODULE_1__.u32(\"instruction\"));\nLAYOUT.addVariant(0, buffer_layout__WEBPACK_IMPORTED_MODULE_1__.struct([\n    buffer_layout__WEBPACK_IMPORTED_MODULE_1__.ns64(\"lamports\"),\n    buffer_layout__WEBPACK_IMPORTED_MODULE_1__.ns64(\"space\"),\n    publicKey(\"owner\")\n]), \"createAccount\");\nLAYOUT.addVariant(1, buffer_layout__WEBPACK_IMPORTED_MODULE_1__.struct([\n    publicKey(\"owner\")\n]), \"assign\");\nLAYOUT.addVariant(2, buffer_layout__WEBPACK_IMPORTED_MODULE_1__.struct([\n    buffer_layout__WEBPACK_IMPORTED_MODULE_1__.ns64(\"lamports\")\n]), \"transfer\");\nLAYOUT.addVariant(3, buffer_layout__WEBPACK_IMPORTED_MODULE_1__.struct([\n    publicKey(\"base\"),\n    rustStringLayout(\"seed\"),\n    buffer_layout__WEBPACK_IMPORTED_MODULE_1__.ns64(\"lamports\"),\n    buffer_layout__WEBPACK_IMPORTED_MODULE_1__.ns64(\"space\"),\n    publicKey(\"owner\")\n]), \"createAccountWithSeed\");\nLAYOUT.addVariant(4, buffer_layout__WEBPACK_IMPORTED_MODULE_1__.struct([\n    publicKey(\"authorized\")\n]), \"advanceNonceAccount\");\nLAYOUT.addVariant(5, buffer_layout__WEBPACK_IMPORTED_MODULE_1__.struct([\n    buffer_layout__WEBPACK_IMPORTED_MODULE_1__.ns64(\"lamports\")\n]), \"withdrawNonceAccount\");\nLAYOUT.addVariant(6, buffer_layout__WEBPACK_IMPORTED_MODULE_1__.struct([\n    publicKey(\"authorized\")\n]), \"initializeNonceAccount\");\nLAYOUT.addVariant(7, buffer_layout__WEBPACK_IMPORTED_MODULE_1__.struct([\n    publicKey(\"authorized\")\n]), \"authorizeNonceAccount\");\nLAYOUT.addVariant(8, buffer_layout__WEBPACK_IMPORTED_MODULE_1__.struct([\n    buffer_layout__WEBPACK_IMPORTED_MODULE_1__.ns64(\"space\")\n]), \"allocate\");\nLAYOUT.addVariant(9, buffer_layout__WEBPACK_IMPORTED_MODULE_1__.struct([\n    publicKey(\"base\"),\n    rustStringLayout(\"seed\"),\n    buffer_layout__WEBPACK_IMPORTED_MODULE_1__.ns64(\"space\"),\n    publicKey(\"owner\")\n]), \"allocateWithSeed\");\nLAYOUT.addVariant(10, buffer_layout__WEBPACK_IMPORTED_MODULE_1__.struct([\n    publicKey(\"base\"),\n    rustStringLayout(\"seed\"),\n    publicKey(\"owner\")\n]), \"assignWithSeed\");\nLAYOUT.addVariant(11, buffer_layout__WEBPACK_IMPORTED_MODULE_1__.struct([\n    buffer_layout__WEBPACK_IMPORTED_MODULE_1__.ns64(\"lamports\"),\n    rustStringLayout(\"seed\"),\n    publicKey(\"owner\")\n]), \"transferWithSeed\");\nfunction encodeData(instruction, maxSpan) {\n    const b = Buffer.alloc(maxSpan !== null && maxSpan !== void 0 ? maxSpan : instructionMaxSpan);\n    const span = LAYOUT.encode(instruction, b);\n    if (maxSpan === undefined) {\n        return b.slice(0, span);\n    }\n    return b;\n}\nconst instructionMaxSpan = Math.max(...Object.values(LAYOUT.registry).map((r)=>r.span)); //# sourceMappingURL=instruction.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL2NvZGVyL3N5c3RlbS9pbnN0cnVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXVCO0FBQ3VCO0FBQ3ZDLE1BQU1FO0lBQ1QsZ0VBQWdFO0lBQ2hFQyxZQUFZQyxDQUFDLENBQUUsQ0FBRTtJQUNqQkMsT0FBT0MsTUFBTSxFQUFFQyxFQUFFLEVBQUU7UUFDZixPQUFRRDtZQUNKLEtBQUs7Z0JBQWlCO29CQUNsQixPQUFPRSxvQkFBb0JEO2dCQUMvQjtZQUNBLEtBQUs7Z0JBQVU7b0JBQ1gsT0FBT0UsYUFBYUY7Z0JBQ3hCO1lBQ0EsS0FBSztnQkFBWTtvQkFDYixPQUFPRyxlQUFlSDtnQkFDMUI7WUFDQSxLQUFLO2dCQUF5QjtvQkFDMUIsT0FBT0ksNEJBQTRCSjtnQkFDdkM7WUFDQSxLQUFLO2dCQUF1QjtvQkFDeEIsT0FBT0ssMEJBQTBCTDtnQkFDckM7WUFDQSxLQUFLO2dCQUF3QjtvQkFDekIsT0FBT00sMkJBQTJCTjtnQkFDdEM7WUFDQSxLQUFLO2dCQUEwQjtvQkFDM0IsT0FBT08sNkJBQTZCUDtnQkFDeEM7WUFDQSxLQUFLO2dCQUF5QjtvQkFDMUIsT0FBT1EsNEJBQTRCUjtnQkFDdkM7WUFDQSxLQUFLO2dCQUFZO29CQUNiLE9BQU9TLGVBQWVUO2dCQUMxQjtZQUNBLEtBQUs7Z0JBQW9CO29CQUNyQixPQUFPVSx1QkFBdUJWO2dCQUNsQztZQUNBLEtBQUs7Z0JBQWtCO29CQUNuQixPQUFPVyxxQkFBcUJYO2dCQUNoQztZQUNBLEtBQUs7Z0JBQW9CO29CQUNyQixPQUFPWSx1QkFBdUJaO2dCQUNsQztZQUNBO2dCQUFTO29CQUNMLE1BQU0sSUFBSWEsTUFBTSxDQUFDLHFCQUFxQixFQUFFZCxPQUFPLENBQUM7Z0JBQ3BEO1FBQ0o7SUFDSjtJQUNBZSxZQUFZQyxPQUFPLEVBQUVDLEdBQUcsRUFBRTtRQUN0QixNQUFNLElBQUlILE1BQU07SUFDcEI7QUFDSjtB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R0FBRztBQUNKWSxPQUFPYSxVQUFVLENBQUMsSUFBSXZFLGlEQUFtQixDQUFDO0lBQ3RDQSwrQ0FBaUIsQ0FBQztJQUNsQjZDLGlCQUFpQjtJQUNqQkMsVUFBVTtDQUNiLEdBQUc7QUFDSixTQUFTSSxXQUFXdUIsV0FBVyxFQUFFQyxPQUFPO0lBQ3BDLE1BQU0xQyxJQUFJSyxPQUFPc0MsS0FBSyxDQUFDRCxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJQSxVQUFVRTtJQUMxRSxNQUFNMUMsT0FBT3dCLE9BQU90RCxNQUFNLENBQUNxRSxhQUFhekM7SUFDeEMsSUFBSTBDLFlBQVl6QyxXQUFXO1FBQ3ZCLE9BQU9ELEVBQUVXLEtBQUssQ0FBQyxHQUFHVDtJQUN0QjtJQUNBLE9BQU9GO0FBQ1g7QUFDQSxNQUFNNEMscUJBQXFCQyxLQUFLQyxHQUFHLElBQUlDLE9BQU9DLE1BQU0sQ0FBQ3RCLE9BQU91QixRQUFRLEVBQUVDLEdBQUcsQ0FBQyxDQUFDQyxJQUFNQSxFQUFFakQsSUFBSSxJQUN2Rix1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL2NvZGVyL3N5c3RlbS9pbnN0cnVjdGlvbi5qcz84MjkwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCTiBmcm9tIFwiYm4uanNcIjtcbmltcG9ydCAqIGFzIEJ1ZmZlckxheW91dCBmcm9tIFwiYnVmZmVyLWxheW91dFwiO1xuZXhwb3J0IGNsYXNzIFN5c3RlbUluc3RydWN0aW9uQ29kZXIge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cbiAgICBjb25zdHJ1Y3RvcihfKSB7IH1cbiAgICBlbmNvZGUoaXhOYW1lLCBpeCkge1xuICAgICAgICBzd2l0Y2ggKGl4TmFtZSkge1xuICAgICAgICAgICAgY2FzZSBcImNyZWF0ZUFjY291bnRcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGVDcmVhdGVBY2NvdW50KGl4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJhc3NpZ25cIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGVBc3NpZ24oaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRyYW5zZmVyXCI6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5jb2RlVHJhbnNmZXIoaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImNyZWF0ZUFjY291bnRXaXRoU2VlZFwiOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZUNyZWF0ZUFjY291bnRXaXRoU2VlZChpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiYWR2YW5jZU5vbmNlQWNjb3VudFwiOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZUFkdmFuY2VOb25jZUFjY291bnQoaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIndpdGhkcmF3Tm9uY2VBY2NvdW50XCI6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5jb2RlV2l0aGRyYXdOb25jZUFjY291bnQoaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImluaXRpYWxpemVOb25jZUFjY291bnRcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGVJbml0aWFsaXplTm9uY2VBY2NvdW50KGl4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJhdXRob3JpemVOb25jZUFjY291bnRcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGVBdXRob3JpemVOb25jZUFjY291bnQoaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImFsbG9jYXRlXCI6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5jb2RlQWxsb2NhdGUoaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImFsbG9jYXRlV2l0aFNlZWRcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGVBbGxvY2F0ZVdpdGhTZWVkKGl4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJhc3NpZ25XaXRoU2VlZFwiOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZUFzc2lnbldpdGhTZWVkKGl4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0cmFuc2ZlcldpdGhTZWVkXCI6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5jb2RlVHJhbnNmZXJXaXRoU2VlZChpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGluc3RydWN0aW9uOiAke2l4TmFtZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbmNvZGVTdGF0ZShfaXhOYW1lLCBfaXgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3lzdGVtIGRvZXMgbm90IGhhdmUgc3RhdGVcIik7XG4gICAgfVxufVxuY2xhc3MgUnVzdFN0cmluZ0xheW91dCBleHRlbmRzIEJ1ZmZlckxheW91dC5MYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKC0xLCBwcm9wZXJ0eSk7XG4gICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICAgICAgdGhpcy5sYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtcbiAgICAgICAgICAgIEJ1ZmZlckxheW91dC51MzIoXCJsZW5ndGhcIiksXG4gICAgICAgICAgICBCdWZmZXJMYXlvdXQudTMyKFwibGVuZ3RoUGFkZGluZ1wiKSxcbiAgICAgICAgICAgIEJ1ZmZlckxheW91dC5ibG9iKEJ1ZmZlckxheW91dC5vZmZzZXQoQnVmZmVyTGF5b3V0LnUzMigpLCAtOCksIFwiY2hhcnNcIiksXG4gICAgICAgIF0sIHRoaXMucHJvcGVydHkpO1xuICAgIH1cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGlmIChzcmMgPT09IG51bGwgfHwgc3JjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxheW91dC5zcGFuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBjaGFyczogQnVmZmVyLmZyb20oc3JjLCBcInV0ZjhcIiksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmxheW91dC5lbmNvZGUoZGF0YSwgYiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMubGF5b3V0LmRlY29kZShiLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gZGF0YVtcImNoYXJzXCJdLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGdldFNwYW4oYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gKEJ1ZmZlckxheW91dC51MzIoKS5zcGFuICtcbiAgICAgICAgICAgIEJ1ZmZlckxheW91dC51MzIoKS5zcGFuICtcbiAgICAgICAgICAgIG5ldyBCTihuZXcgVWludDhBcnJheShiKS5zbGljZShvZmZzZXQsIG9mZnNldCArIDQpLCAxMCwgXCJsZVwiKS50b051bWJlcigpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBydXN0U3RyaW5nTGF5b3V0KHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIG5ldyBSdXN0U3RyaW5nTGF5b3V0KHByb3BlcnR5KTtcbn1cbmZ1bmN0aW9uIHB1YmxpY0tleShwcm9wZXJ0eSkge1xuICAgIHJldHVybiBCdWZmZXJMYXlvdXQuYmxvYigzMiwgcHJvcGVydHkpO1xufVxuZnVuY3Rpb24gZW5jb2RlQ3JlYXRlQWNjb3VudCh7IGxhbXBvcnRzLCBzcGFjZSwgb3duZXIgfSkge1xuICAgIHJldHVybiBlbmNvZGVEYXRhKHtcbiAgICAgICAgY3JlYXRlQWNjb3VudDogeyBsYW1wb3J0cywgc3BhY2UsIG93bmVyOiBvd25lci50b0J1ZmZlcigpIH0sXG4gICAgfSk7XG59XG5mdW5jdGlvbiBlbmNvZGVBc3NpZ24oeyBvd25lciB9KSB7XG4gICAgcmV0dXJuIGVuY29kZURhdGEoe1xuICAgICAgICBhc3NpZ246IHsgb3duZXI6IG93bmVyLnRvQnVmZmVyKCkgfSxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGVuY29kZVRyYW5zZmVyKHsgbGFtcG9ydHMgfSkge1xuICAgIHJldHVybiBlbmNvZGVEYXRhKHtcbiAgICAgICAgdHJhbnNmZXI6IHsgbGFtcG9ydHMgfSxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGVuY29kZUNyZWF0ZUFjY291bnRXaXRoU2VlZCh7IGJhc2UsIHNlZWQsIGxhbXBvcnRzLCBzcGFjZSwgb3duZXIsIH0pIHtcbiAgICByZXR1cm4gZW5jb2RlRGF0YSh7XG4gICAgICAgIGNyZWF0ZUFjY291bnRXaXRoU2VlZDoge1xuICAgICAgICAgICAgYmFzZTogYmFzZS50b0J1ZmZlcigpLFxuICAgICAgICAgICAgc2VlZCxcbiAgICAgICAgICAgIGxhbXBvcnRzLFxuICAgICAgICAgICAgc3BhY2UsXG4gICAgICAgICAgICBvd25lcjogb3duZXIudG9CdWZmZXIoKSxcbiAgICAgICAgfSxcbiAgICB9LCBMQVlPVVQuZ2V0VmFyaWFudCgzKS5zcGFuICsgc2VlZC5sZW5ndGgpO1xufVxuZnVuY3Rpb24gZW5jb2RlSW5pdGlhbGl6ZU5vbmNlQWNjb3VudCh7IGF1dGhvcml6ZWQgfSkge1xuICAgIHJldHVybiBlbmNvZGVEYXRhKHtcbiAgICAgICAgaW5pdGlhbGl6ZU5vbmNlQWNjb3VudDogeyBhdXRob3JpemVkOiBhdXRob3JpemVkLnRvQnVmZmVyKCkgfSxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGVuY29kZUFkdmFuY2VOb25jZUFjY291bnQoeyBhdXRob3JpemVkIH0pIHtcbiAgICByZXR1cm4gZW5jb2RlRGF0YSh7XG4gICAgICAgIGFkdmFuY2VOb25jZUFjY291bnQ6IHsgYXV0aG9yaXplZDogYXV0aG9yaXplZC50b0J1ZmZlcigpIH0sXG4gICAgfSk7XG59XG5mdW5jdGlvbiBlbmNvZGVXaXRoZHJhd05vbmNlQWNjb3VudCh7IGxhbXBvcnRzIH0pIHtcbiAgICByZXR1cm4gZW5jb2RlRGF0YSh7XG4gICAgICAgIHdpdGhkcmF3Tm9uY2VBY2NvdW50OiB7IGxhbXBvcnRzIH0sXG4gICAgfSk7XG59XG5mdW5jdGlvbiBlbmNvZGVBdXRob3JpemVOb25jZUFjY291bnQoeyBhdXRob3JpemVkIH0pIHtcbiAgICByZXR1cm4gZW5jb2RlRGF0YSh7XG4gICAgICAgIGF1dGhvcml6ZU5vbmNlQWNjb3VudDogeyBhdXRob3JpemVkOiBhdXRob3JpemVkLnRvQnVmZmVyKCkgfSxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGVuY29kZUFsbG9jYXRlKHsgc3BhY2UgfSkge1xuICAgIHJldHVybiBlbmNvZGVEYXRhKHtcbiAgICAgICAgYWxsb2NhdGU6IHsgc3BhY2UgfSxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGVuY29kZUFsbG9jYXRlV2l0aFNlZWQoeyBiYXNlLCBzZWVkLCBzcGFjZSwgb3duZXIgfSkge1xuICAgIHJldHVybiBlbmNvZGVEYXRhKHtcbiAgICAgICAgYWxsb2NhdGVXaXRoU2VlZDoge1xuICAgICAgICAgICAgYmFzZTogYmFzZS50b0J1ZmZlcigpLFxuICAgICAgICAgICAgc2VlZCxcbiAgICAgICAgICAgIHNwYWNlLFxuICAgICAgICAgICAgb3duZXI6IG93bmVyLnRvQnVmZmVyKCksXG4gICAgICAgIH0sXG4gICAgfSwgTEFZT1VULmdldFZhcmlhbnQoOSkuc3BhbiArIHNlZWQubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGVuY29kZUFzc2lnbldpdGhTZWVkKHsgYmFzZSwgc2VlZCwgb3duZXIgfSkge1xuICAgIHJldHVybiBlbmNvZGVEYXRhKHtcbiAgICAgICAgYXNzaWduV2l0aFNlZWQ6IHtcbiAgICAgICAgICAgIGJhc2U6IGJhc2UudG9CdWZmZXIoKSxcbiAgICAgICAgICAgIHNlZWQsXG4gICAgICAgICAgICBvd25lcjogb3duZXIudG9CdWZmZXIoKSxcbiAgICAgICAgfSxcbiAgICB9LCBMQVlPVVQuZ2V0VmFyaWFudCgxMCkuc3BhbiArIHNlZWQubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGVuY29kZVRyYW5zZmVyV2l0aFNlZWQoeyBsYW1wb3J0cywgc2VlZCwgb3duZXIgfSkge1xuICAgIHJldHVybiBlbmNvZGVEYXRhKHtcbiAgICAgICAgdHJhbnNmZXJXaXRoU2VlZDoge1xuICAgICAgICAgICAgbGFtcG9ydHMsXG4gICAgICAgICAgICBzZWVkLFxuICAgICAgICAgICAgb3duZXI6IG93bmVyLnRvQnVmZmVyKCksXG4gICAgICAgIH0sXG4gICAgfSwgTEFZT1VULmdldFZhcmlhbnQoMTEpLnNwYW4gKyBzZWVkLmxlbmd0aCk7XG59XG5jb25zdCBMQVlPVVQgPSBCdWZmZXJMYXlvdXQudW5pb24oQnVmZmVyTGF5b3V0LnUzMihcImluc3RydWN0aW9uXCIpKTtcbkxBWU9VVC5hZGRWYXJpYW50KDAsIEJ1ZmZlckxheW91dC5zdHJ1Y3QoW1xuICAgIEJ1ZmZlckxheW91dC5uczY0KFwibGFtcG9ydHNcIiksXG4gICAgQnVmZmVyTGF5b3V0Lm5zNjQoXCJzcGFjZVwiKSxcbiAgICBwdWJsaWNLZXkoXCJvd25lclwiKSxcbl0pLCBcImNyZWF0ZUFjY291bnRcIik7XG5MQVlPVVQuYWRkVmFyaWFudCgxLCBCdWZmZXJMYXlvdXQuc3RydWN0KFtwdWJsaWNLZXkoXCJvd25lclwiKV0pLCBcImFzc2lnblwiKTtcbkxBWU9VVC5hZGRWYXJpYW50KDIsIEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC5uczY0KFwibGFtcG9ydHNcIildKSwgXCJ0cmFuc2ZlclwiKTtcbkxBWU9VVC5hZGRWYXJpYW50KDMsIEJ1ZmZlckxheW91dC5zdHJ1Y3QoW1xuICAgIHB1YmxpY0tleShcImJhc2VcIiksXG4gICAgcnVzdFN0cmluZ0xheW91dChcInNlZWRcIiksXG4gICAgQnVmZmVyTGF5b3V0Lm5zNjQoXCJsYW1wb3J0c1wiKSxcbiAgICBCdWZmZXJMYXlvdXQubnM2NChcInNwYWNlXCIpLFxuICAgIHB1YmxpY0tleShcIm93bmVyXCIpLFxuXSksIFwiY3JlYXRlQWNjb3VudFdpdGhTZWVkXCIpO1xuTEFZT1VULmFkZFZhcmlhbnQoNCwgQnVmZmVyTGF5b3V0LnN0cnVjdChbcHVibGljS2V5KFwiYXV0aG9yaXplZFwiKV0pLCBcImFkdmFuY2VOb25jZUFjY291bnRcIik7XG5MQVlPVVQuYWRkVmFyaWFudCg1LCBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQubnM2NChcImxhbXBvcnRzXCIpXSksIFwid2l0aGRyYXdOb25jZUFjY291bnRcIik7XG5MQVlPVVQuYWRkVmFyaWFudCg2LCBCdWZmZXJMYXlvdXQuc3RydWN0KFtwdWJsaWNLZXkoXCJhdXRob3JpemVkXCIpXSksIFwiaW5pdGlhbGl6ZU5vbmNlQWNjb3VudFwiKTtcbkxBWU9VVC5hZGRWYXJpYW50KDcsIEJ1ZmZlckxheW91dC5zdHJ1Y3QoW3B1YmxpY0tleShcImF1dGhvcml6ZWRcIildKSwgXCJhdXRob3JpemVOb25jZUFjY291bnRcIik7XG5MQVlPVVQuYWRkVmFyaWFudCg4LCBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQubnM2NChcInNwYWNlXCIpXSksIFwiYWxsb2NhdGVcIik7XG5MQVlPVVQuYWRkVmFyaWFudCg5LCBCdWZmZXJMYXlvdXQuc3RydWN0KFtcbiAgICBwdWJsaWNLZXkoXCJiYXNlXCIpLFxuICAgIHJ1c3RTdHJpbmdMYXlvdXQoXCJzZWVkXCIpLFxuICAgIEJ1ZmZlckxheW91dC5uczY0KFwic3BhY2VcIiksXG4gICAgcHVibGljS2V5KFwib3duZXJcIiksXG5dKSwgXCJhbGxvY2F0ZVdpdGhTZWVkXCIpO1xuTEFZT1VULmFkZFZhcmlhbnQoMTAsIEJ1ZmZlckxheW91dC5zdHJ1Y3QoW1xuICAgIHB1YmxpY0tleShcImJhc2VcIiksXG4gICAgcnVzdFN0cmluZ0xheW91dChcInNlZWRcIiksXG4gICAgcHVibGljS2V5KFwib3duZXJcIiksXG5dKSwgXCJhc3NpZ25XaXRoU2VlZFwiKTtcbkxBWU9VVC5hZGRWYXJpYW50KDExLCBCdWZmZXJMYXlvdXQuc3RydWN0KFtcbiAgICBCdWZmZXJMYXlvdXQubnM2NChcImxhbXBvcnRzXCIpLFxuICAgIHJ1c3RTdHJpbmdMYXlvdXQoXCJzZWVkXCIpLFxuICAgIHB1YmxpY0tleShcIm93bmVyXCIpLFxuXSksIFwidHJhbnNmZXJXaXRoU2VlZFwiKTtcbmZ1bmN0aW9uIGVuY29kZURhdGEoaW5zdHJ1Y3Rpb24sIG1heFNwYW4pIHtcbiAgICBjb25zdCBiID0gQnVmZmVyLmFsbG9jKG1heFNwYW4gIT09IG51bGwgJiYgbWF4U3BhbiAhPT0gdm9pZCAwID8gbWF4U3BhbiA6IGluc3RydWN0aW9uTWF4U3Bhbik7XG4gICAgY29uc3Qgc3BhbiA9IExBWU9VVC5lbmNvZGUoaW5zdHJ1Y3Rpb24sIGIpO1xuICAgIGlmIChtYXhTcGFuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGIuc2xpY2UoMCwgc3Bhbik7XG4gICAgfVxuICAgIHJldHVybiBiO1xufVxuY29uc3QgaW5zdHJ1Y3Rpb25NYXhTcGFuID0gTWF0aC5tYXgoLi4uT2JqZWN0LnZhbHVlcyhMQVlPVVQucmVnaXN0cnkpLm1hcCgocikgPT4gci5zcGFuKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnN0cnVjdGlvbi5qcy5tYXAiXSwibmFtZXMiOlsiQk4iLCJCdWZmZXJMYXlvdXQiLCJTeXN0ZW1JbnN0cnVjdGlvbkNvZGVyIiwiY29uc3RydWN0b3IiLCJfIiwiZW5jb2RlIiwiaXhOYW1lIiwiaXgiLCJlbmNvZGVDcmVhdGVBY2NvdW50IiwiZW5jb2RlQXNzaWduIiwiZW5jb2RlVHJhbnNmZXIiLCJlbmNvZGVDcmVhdGVBY2NvdW50V2l0aFNlZWQiLCJlbmNvZGVBZHZhbmNlTm9uY2VBY2NvdW50IiwiZW5jb2RlV2l0aGRyYXdOb25jZUFjY291bnQiLCJlbmNvZGVJbml0aWFsaXplTm9uY2VBY2NvdW50IiwiZW5jb2RlQXV0aG9yaXplTm9uY2VBY2NvdW50IiwiZW5jb2RlQWxsb2NhdGUiLCJlbmNvZGVBbGxvY2F0ZVdpdGhTZWVkIiwiZW5jb2RlQXNzaWduV2l0aFNlZWQiLCJlbmNvZGVUcmFuc2ZlcldpdGhTZWVkIiwiRXJyb3IiLCJlbmNvZGVTdGF0ZSIsIl9peE5hbWUiLCJfaXgiLCJSdXN0U3RyaW5nTGF5b3V0IiwiTGF5b3V0IiwicHJvcGVydHkiLCJsYXlvdXQiLCJzdHJ1Y3QiLCJ1MzIiLCJibG9iIiwib2Zmc2V0Iiwic3JjIiwiYiIsInVuZGVmaW5lZCIsInNwYW4iLCJkYXRhIiwiY2hhcnMiLCJCdWZmZXIiLCJmcm9tIiwiZGVjb2RlIiwidG9TdHJpbmciLCJnZXRTcGFuIiwiVWludDhBcnJheSIsInNsaWNlIiwidG9OdW1iZXIiLCJydXN0U3RyaW5nTGF5b3V0IiwicHVibGljS2V5IiwibGFtcG9ydHMiLCJzcGFjZSIsIm93bmVyIiwiZW5jb2RlRGF0YSIsImNyZWF0ZUFjY291bnQiLCJ0b0J1ZmZlciIsImFzc2lnbiIsInRyYW5zZmVyIiwiYmFzZSIsInNlZWQiLCJjcmVhdGVBY2NvdW50V2l0aFNlZWQiLCJMQVlPVVQiLCJnZXRWYXJpYW50IiwibGVuZ3RoIiwiYXV0aG9yaXplZCIsImluaXRpYWxpemVOb25jZUFjY291bnQiLCJhZHZhbmNlTm9uY2VBY2NvdW50Iiwid2l0aGRyYXdOb25jZUFjY291bnQiLCJhdXRob3JpemVOb25jZUFjY291bnQiLCJhbGxvY2F0ZSIsImFsbG9jYXRlV2l0aFNlZWQiLCJhc3NpZ25XaXRoU2VlZCIsInRyYW5zZmVyV2l0aFNlZWQiLCJ1bmlvbiIsImFkZFZhcmlhbnQiLCJuczY0IiwiaW5zdHJ1Y3Rpb24iLCJtYXhTcGFuIiwiYWxsb2MiLCJpbnN0cnVjdGlvbk1heFNwYW4iLCJNYXRoIiwibWF4IiwiT2JqZWN0IiwidmFsdWVzIiwicmVnaXN0cnkiLCJtYXAiLCJyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/system/instruction.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/system/types.js":
/*!************************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/coder/system/types.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SystemTypesCoder: () => (/* binding */ SystemTypesCoder)\n/* harmony export */ });\nclass SystemTypesCoder {\n    constructor(_idl){}\n    encode(_name, _type) {\n        throw new Error(\"System does not have user-defined types\");\n    }\n    decode(_name, _typeData) {\n        throw new Error(\"System does not have user-defined types\");\n    }\n} //# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL2NvZGVyL3N5c3RlbS90eXBlcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUE7SUFDVEMsWUFBWUMsSUFBSSxDQUFFLENBQUU7SUFDcEJDLE9BQU9DLEtBQUssRUFBRUMsS0FBSyxFQUFFO1FBQ2pCLE1BQU0sSUFBSUMsTUFBTTtJQUNwQjtJQUNBQyxPQUFPSCxLQUFLLEVBQUVJLFNBQVMsRUFBRTtRQUNyQixNQUFNLElBQUlGLE1BQU07SUFDcEI7QUFDSixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGNvcmFsLXh5ei9hbmNob3IvZGlzdC9lc20vY29kZXIvc3lzdGVtL3R5cGVzLmpzP2Q3N2UiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIFN5c3RlbVR5cGVzQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKF9pZGwpIHsgfVxuICAgIGVuY29kZShfbmFtZSwgX3R5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3lzdGVtIGRvZXMgbm90IGhhdmUgdXNlci1kZWZpbmVkIHR5cGVzXCIpO1xuICAgIH1cbiAgICBkZWNvZGUoX25hbWUsIF90eXBlRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTeXN0ZW0gZG9lcyBub3QgaGF2ZSB1c2VyLWRlZmluZWQgdHlwZXNcIik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sIm5hbWVzIjpbIlN5c3RlbVR5cGVzQ29kZXIiLCJjb25zdHJ1Y3RvciIsIl9pZGwiLCJlbmNvZGUiLCJfbmFtZSIsIl90eXBlIiwiRXJyb3IiLCJkZWNvZGUiLCJfdHlwZURhdGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/system/types.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/error.js":
/*!***********************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/error.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnchorError: () => (/* binding */ AnchorError),\n/* harmony export */   IdlError: () => (/* binding */ IdlError),\n/* harmony export */   LangErrorCode: () => (/* binding */ LangErrorCode),\n/* harmony export */   LangErrorMessage: () => (/* binding */ LangErrorMessage),\n/* harmony export */   ProgramError: () => (/* binding */ ProgramError),\n/* harmony export */   ProgramErrorStack: () => (/* binding */ ProgramErrorStack),\n/* harmony export */   translateError: () => (/* binding */ translateError)\n/* harmony export */ });\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/node_modules/@solana/web3.js/lib/index.esm.js\");\n/* harmony import */ var _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @coral-xyz/anchor-errors */ \"(ssr)/../node_modules/@coral-xyz/anchor-errors/dist/index.js\");\n/* harmony import */ var _utils_features_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/features.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/features.js\");\n\n\n\nclass IdlError extends Error {\n    constructor(message){\n        super(message);\n        this.name = \"IdlError\";\n    }\n}\nclass ProgramErrorStack {\n    constructor(stack){\n        this.stack = stack;\n    }\n    static parse(logs) {\n        var _a;\n        const programKeyRegex = /^Program (\\w*) invoke/;\n        const successRegex = /^Program \\w* success/;\n        const programStack = [];\n        for(let i = 0; i < logs.length; i++){\n            if (successRegex.exec(logs[i])) {\n                programStack.pop();\n                continue;\n            }\n            const programKey = (_a = programKeyRegex.exec(logs[i])) === null || _a === void 0 ? void 0 : _a[1];\n            if (!programKey) {\n                continue;\n            }\n            programStack.push(new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(programKey));\n        }\n        return new ProgramErrorStack(programStack);\n    }\n}\nclass AnchorError extends Error {\n    constructor(errorCode, errorMessage, errorLogs, logs, origin, comparedValues){\n        super(errorLogs.join(\"\\n\").replace(\"Program log: \", \"\"));\n        this.errorLogs = errorLogs;\n        this.logs = logs;\n        this.error = {\n            errorCode,\n            errorMessage,\n            comparedValues,\n            origin\n        };\n        this._programErrorStack = ProgramErrorStack.parse(logs);\n    }\n    static parse(logs) {\n        if (!logs) {\n            return null;\n        }\n        const anchorErrorLogIndex = logs.findIndex((log)=>log.startsWith(\"Program log: AnchorError\"));\n        if (anchorErrorLogIndex === -1) {\n            return null;\n        }\n        const anchorErrorLog = logs[anchorErrorLogIndex];\n        const errorLogs = [\n            anchorErrorLog\n        ];\n        let comparedValues;\n        if (anchorErrorLogIndex + 1 < logs.length) {\n            // This catches the comparedValues where the following is logged\n            // <AnchorError>\n            // Left:\n            // <Pubkey>\n            // Right:\n            // <Pubkey>\n            if (logs[anchorErrorLogIndex + 1] === \"Program log: Left:\") {\n                const pubkeyRegex = /^Program log: (.*)$/;\n                const leftPubkey = pubkeyRegex.exec(logs[anchorErrorLogIndex + 2])[1];\n                const rightPubkey = pubkeyRegex.exec(logs[anchorErrorLogIndex + 4])[1];\n                comparedValues = [\n                    new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(leftPubkey),\n                    new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(rightPubkey)\n                ];\n                errorLogs.push(...logs.slice(anchorErrorLogIndex + 1, anchorErrorLogIndex + 5));\n            } else if (logs[anchorErrorLogIndex + 1].startsWith(\"Program log: Left:\")) {\n                const valueRegex = /^Program log: (Left|Right): (.*)$/;\n                const leftValue = valueRegex.exec(logs[anchorErrorLogIndex + 1])[2];\n                const rightValue = valueRegex.exec(logs[anchorErrorLogIndex + 2])[2];\n                errorLogs.push(...logs.slice(anchorErrorLogIndex + 1, anchorErrorLogIndex + 3));\n                comparedValues = [\n                    leftValue,\n                    rightValue\n                ];\n            }\n        }\n        const regexNoInfo = /^Program log: AnchorError occurred\\. Error Code: (.*)\\. Error Number: (\\d*)\\. Error Message: (.*)\\./;\n        const noInfoAnchorErrorLog = regexNoInfo.exec(anchorErrorLog);\n        const regexFileLine = /^Program log: AnchorError thrown in (.*):(\\d*)\\. Error Code: (.*)\\. Error Number: (\\d*)\\. Error Message: (.*)\\./;\n        const fileLineAnchorErrorLog = regexFileLine.exec(anchorErrorLog);\n        const regexAccountName = /^Program log: AnchorError caused by account: (.*)\\. Error Code: (.*)\\. Error Number: (\\d*)\\. Error Message: (.*)\\./;\n        const accountNameAnchorErrorLog = regexAccountName.exec(anchorErrorLog);\n        if (noInfoAnchorErrorLog) {\n            const [errorCodeString, errorNumber, errorMessage] = noInfoAnchorErrorLog.slice(1, 4);\n            const errorCode = {\n                code: errorCodeString,\n                number: parseInt(errorNumber)\n            };\n            return new AnchorError(errorCode, errorMessage, errorLogs, logs, undefined, comparedValues);\n        } else if (fileLineAnchorErrorLog) {\n            const [file, line, errorCodeString, errorNumber, errorMessage] = fileLineAnchorErrorLog.slice(1, 6);\n            const errorCode = {\n                code: errorCodeString,\n                number: parseInt(errorNumber)\n            };\n            const fileLine = {\n                file,\n                line: parseInt(line)\n            };\n            return new AnchorError(errorCode, errorMessage, errorLogs, logs, fileLine, comparedValues);\n        } else if (accountNameAnchorErrorLog) {\n            const [accountName, errorCodeString, errorNumber, errorMessage] = accountNameAnchorErrorLog.slice(1, 5);\n            const origin = accountName;\n            const errorCode = {\n                code: errorCodeString,\n                number: parseInt(errorNumber)\n            };\n            return new AnchorError(errorCode, errorMessage, errorLogs, logs, origin, comparedValues);\n        } else {\n            return null;\n        }\n    }\n    get program() {\n        return this._programErrorStack.stack[this._programErrorStack.stack.length - 1];\n    }\n    get programErrorStack() {\n        return this._programErrorStack.stack;\n    }\n    toString() {\n        return this.message;\n    }\n}\n// An error from a user defined program.\nclass ProgramError extends Error {\n    constructor(code, msg, logs){\n        super();\n        this.code = code;\n        this.msg = msg;\n        this.logs = logs;\n        if (logs) {\n            this._programErrorStack = ProgramErrorStack.parse(logs);\n        }\n    }\n    static parse(err, idlErrors) {\n        const errString = err.toString();\n        // TODO: don't rely on the error string. web3.js should preserve the error\n        //       code information instead of giving us an untyped string.\n        let unparsedErrorCode;\n        if (errString.includes(\"custom program error:\")) {\n            let components = errString.split(\"custom program error: \");\n            if (components.length !== 2) {\n                return null;\n            } else {\n                unparsedErrorCode = components[1];\n            }\n        } else {\n            const matches = errString.match(/\"Custom\":([0-9]+)}/g);\n            if (!matches || matches.length > 1) {\n                return null;\n            }\n            unparsedErrorCode = matches[0].match(/([0-9]+)/g)[0];\n        }\n        let errorCode;\n        try {\n            errorCode = parseInt(unparsedErrorCode);\n        } catch (parseErr) {\n            return null;\n        }\n        // Parse user error.\n        let errorMsg = idlErrors.get(errorCode);\n        if (errorMsg !== undefined) {\n            return new ProgramError(errorCode, errorMsg, err.logs);\n        }\n        // Parse framework internal error.\n        errorMsg = LangErrorMessage.get(errorCode);\n        if (errorMsg !== undefined) {\n            return new ProgramError(errorCode, errorMsg, err.logs);\n        }\n        // Unable to parse the error. Just return the untranslated error.\n        return null;\n    }\n    get program() {\n        var _a;\n        return (_a = this._programErrorStack) === null || _a === void 0 ? void 0 : _a.stack[this._programErrorStack.stack.length - 1];\n    }\n    get programErrorStack() {\n        var _a;\n        return (_a = this._programErrorStack) === null || _a === void 0 ? void 0 : _a.stack;\n    }\n    toString() {\n        return this.msg;\n    }\n}\nfunction translateError(err, idlErrors) {\n    if (_utils_features_js__WEBPACK_IMPORTED_MODULE_2__.isSet(\"debug-logs\")) {\n        console.log(\"Translating error:\", err);\n    }\n    const anchorError = AnchorError.parse(err.logs);\n    if (anchorError) {\n        return anchorError;\n    }\n    const programError = ProgramError.parse(err, idlErrors);\n    if (programError) {\n        return programError;\n    }\n    if (err.logs) {\n        const handler = {\n            get: function(target, prop) {\n                if (prop === \"programErrorStack\") {\n                    return target.programErrorStack.stack;\n                } else if (prop === \"program\") {\n                    return target.programErrorStack.stack[err.programErrorStack.stack.length - 1];\n                } else {\n                    // this is the normal way to return all other props\n                    // without modifying them.\n                    // @ts-expect-error\n                    return Reflect.get(...arguments);\n                }\n            }\n        };\n        err.programErrorStack = ProgramErrorStack.parse(err.logs);\n        return new Proxy(err, handler);\n    }\n    return err;\n}\nconst LangErrorCode = {\n    // Instructions.\n    InstructionMissing: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__INSTRUCTION_MISSING,\n    InstructionFallbackNotFound: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__INSTRUCTION_FALLBACK_NOT_FOUND,\n    InstructionDidNotDeserialize: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__INSTRUCTION_DID_NOT_DESERIALIZE,\n    InstructionDidNotSerialize: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__INSTRUCTION_DID_NOT_SERIALIZE,\n    // IDL instructions.\n    IdlInstructionStub: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__IDL_INSTRUCTION_STUB,\n    IdlInstructionInvalidProgram: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__IDL_INSTRUCTION_INVALID_PROGRAM,\n    IdlAccountNotEmpty: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__IDL_ACCOUNT_NOT_EMPTY,\n    // Event instructions.\n    EventInstructionStub: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__EVENT_INSTRUCTION_STUB,\n    // Constraints.\n    ConstraintMut: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_MUT,\n    ConstraintHasOne: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_HAS_ONE,\n    ConstraintSigner: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_SIGNER,\n    ConstraintRaw: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_RAW,\n    ConstraintOwner: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_OWNER,\n    ConstraintRentExempt: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_RENT_EXEMPT,\n    ConstraintSeeds: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_SEEDS,\n    ConstraintExecutable: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_EXECUTABLE,\n    ConstraintState: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_STATE,\n    ConstraintAssociated: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED,\n    ConstraintAssociatedInit: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_INIT,\n    ConstraintClose: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_CLOSE,\n    ConstraintAddress: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_ADDRESS,\n    ConstraintZero: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_ZERO,\n    ConstraintTokenMint: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_TOKEN_MINT,\n    ConstraintTokenOwner: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_TOKEN_OWNER,\n    ConstraintMintMintAuthority: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_MINT_MINT_AUTHORITY,\n    ConstraintMintFreezeAuthority: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_MINT_FREEZE_AUTHORITY,\n    ConstraintMintDecimals: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_MINT_DECIMALS,\n    ConstraintSpace: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_SPACE,\n    ConstraintAccountIsNone: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_ACCOUNT_IS_NONE,\n    ConstraintTokenTokenProgram: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_TOKEN_TOKEN_PROGRAM,\n    ConstraintMintTokenProgram: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_MINT_TOKEN_PROGRAM,\n    ConstraintAssociatedTokenTokenProgram: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_TOKEN_TOKEN_PROGRAM,\n    ConstraintMintGroupPointerExtension: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION,\n    ConstraintMintGroupPointerExtensionAuthority: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_AUTHORITY,\n    ConstraintMintGroupPointerExtensionGroupAddress: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_GROUP_ADDRESS,\n    ConstraintMintGroupMemberPointerExtension: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION,\n    ConstraintMintGroupMemberPointerExtensionAuthority: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_AUTHORITY,\n    ConstraintMintGroupMemberPointerExtensionMemberAddress: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_MEMBER_ADDRESS,\n    ConstraintMintMetadataPointerExtension: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION,\n    ConstraintMintMetadataPointerExtensionAuthority: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_AUTHORITY,\n    ConstraintMintMetadataPointerExtensionMetadataAddress: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_METADATA_ADDRESS,\n    ConstraintMintCloseAuthorityExtension: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION,\n    ConstraintMintCloseAuthorityExtensionAuthority: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION_AUTHORITY,\n    ConstraintMintPermanentDelegateExtension: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION,\n    ConstraintMintPermanentDelegateExtensionDelegate: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION_DELEGATE,\n    ConstraintMintTransferHookExtension: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION,\n    ConstraintMintTransferHookExtensionAuthority: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_AUTHORITY,\n    ConstraintMintTransferHookExtensionProgramId: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_PROGRAM_ID,\n    // Require.\n    RequireViolated: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__REQUIRE_VIOLATED,\n    RequireEqViolated: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__REQUIRE_EQ_VIOLATED,\n    RequireKeysEqViolated: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__REQUIRE_KEYS_EQ_VIOLATED,\n    RequireNeqViolated: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__REQUIRE_NEQ_VIOLATED,\n    RequireKeysNeqViolated: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__REQUIRE_KEYS_NEQ_VIOLATED,\n    RequireGtViolated: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__REQUIRE_GT_VIOLATED,\n    RequireGteViolated: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__REQUIRE_GTE_VIOLATED,\n    // Accounts.\n    AccountDiscriminatorAlreadySet: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_ALREADY_SET,\n    AccountDiscriminatorNotFound: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_NOT_FOUND,\n    AccountDiscriminatorMismatch: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_MISMATCH,\n    AccountDidNotDeserialize: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__ACCOUNT_DID_NOT_DESERIALIZE,\n    AccountDidNotSerialize: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__ACCOUNT_DID_NOT_SERIALIZE,\n    AccountNotEnoughKeys: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__ACCOUNT_NOT_ENOUGH_KEYS,\n    AccountNotMutable: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__ACCOUNT_NOT_MUTABLE,\n    AccountOwnedByWrongProgram: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__ACCOUNT_OWNED_BY_WRONG_PROGRAM,\n    InvalidProgramId: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__INVALID_PROGRAM_ID,\n    InvalidProgramExecutable: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__INVALID_PROGRAM_EXECUTABLE,\n    AccountNotSigner: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__ACCOUNT_NOT_SIGNER,\n    AccountNotSystemOwned: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__ACCOUNT_NOT_SYSTEM_OWNED,\n    AccountNotInitialized: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__ACCOUNT_NOT_INITIALIZED,\n    AccountNotProgramData: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__ACCOUNT_NOT_PROGRAM_DATA,\n    AccountNotAssociatedTokenAccount: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__ACCOUNT_NOT_ASSOCIATED_TOKEN_ACCOUNT,\n    AccountSysvarMismatch: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__ACCOUNT_SYSVAR_MISMATCH,\n    AccountReallocExceedsLimit: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__ACCOUNT_REALLOC_EXCEEDS_LIMIT,\n    AccountDuplicateReallocs: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__ACCOUNT_DUPLICATE_REALLOCS,\n    // Miscellaneous\n    DeclaredProgramIdMismatch: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__DECLARED_PROGRAM_ID_MISMATCH,\n    TryingToInitPayerAsProgramAccount: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__TRYING_TO_INIT_PAYER_AS_PROGRAM_ACCOUNT,\n    InvalidNumericConversion: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__INVALID_NUMERIC_CONVERSION,\n    // Used for APIs that shouldn't be used anymore.\n    Deprecated: _coral_xyz_anchor_errors__WEBPACK_IMPORTED_MODULE_1__.ANCHOR_ERROR__DEPRECATED\n};\nconst LangErrorMessage = new Map([\n    // Instructions.\n    [\n        LangErrorCode.InstructionMissing,\n        \"8 byte instruction identifier not provided\"\n    ],\n    [\n        LangErrorCode.InstructionFallbackNotFound,\n        \"Fallback functions are not supported\"\n    ],\n    [\n        LangErrorCode.InstructionDidNotDeserialize,\n        \"The program could not deserialize the given instruction\"\n    ],\n    [\n        LangErrorCode.InstructionDidNotSerialize,\n        \"The program could not serialize the given instruction\"\n    ],\n    // Idl instructions.\n    [\n        LangErrorCode.IdlInstructionStub,\n        \"The program was compiled without idl instructions\"\n    ],\n    [\n        LangErrorCode.IdlInstructionInvalidProgram,\n        \"The transaction was given an invalid program for the IDL instruction\"\n    ],\n    [\n        LangErrorCode.IdlAccountNotEmpty,\n        \"IDL account must be empty in order to resize, try closing first\"\n    ],\n    // Event instructions.\n    [\n        LangErrorCode.EventInstructionStub,\n        \"The program was compiled without `event-cpi` feature\"\n    ],\n    // Constraints.\n    [\n        LangErrorCode.ConstraintMut,\n        \"A mut constraint was violated\"\n    ],\n    [\n        LangErrorCode.ConstraintHasOne,\n        \"A has one constraint was violated\"\n    ],\n    [\n        LangErrorCode.ConstraintSigner,\n        \"A signer constraint was violated\"\n    ],\n    [\n        LangErrorCode.ConstraintRaw,\n        \"A raw constraint was violated\"\n    ],\n    [\n        LangErrorCode.ConstraintOwner,\n        \"An owner constraint was violated\"\n    ],\n    [\n        LangErrorCode.ConstraintRentExempt,\n        \"A rent exemption constraint was violated\"\n    ],\n    [\n        LangErrorCode.ConstraintSeeds,\n        \"A seeds constraint was violated\"\n    ],\n    [\n        LangErrorCode.ConstraintExecutable,\n        \"An executable constraint was violated\"\n    ],\n    [\n        LangErrorCode.ConstraintState,\n        \"Deprecated Error, feel free to replace with something else\"\n    ],\n    [\n        LangErrorCode.ConstraintAssociated,\n        \"An associated constraint was violated\"\n    ],\n    [\n        LangErrorCode.ConstraintAssociatedInit,\n        \"An associated init constraint was violated\"\n    ],\n    [\n        LangErrorCode.ConstraintClose,\n        \"A close constraint was violated\"\n    ],\n    [\n        LangErrorCode.ConstraintAddress,\n        \"An address constraint was violated\"\n    ],\n    [\n        LangErrorCode.ConstraintZero,\n        \"Expected zero account discriminant\"\n    ],\n    [\n        LangErrorCode.ConstraintTokenMint,\n        \"A token mint constraint was violated\"\n    ],\n    [\n        LangErrorCode.ConstraintTokenOwner,\n        \"A token owner constraint was violated\"\n    ],\n    [\n        LangErrorCode.ConstraintMintMintAuthority,\n        \"A mint mint authority constraint was violated\"\n    ],\n    [\n        LangErrorCode.ConstraintMintFreezeAuthority,\n        \"A mint freeze authority constraint was violated\"\n    ],\n    [\n        LangErrorCode.ConstraintMintDecimals,\n        \"A mint decimals constraint was violated\"\n    ],\n    [\n        LangErrorCode.ConstraintSpace,\n        \"A space constraint was violated\"\n    ],\n    [\n        LangErrorCode.ConstraintAccountIsNone,\n        \"A required account for the constraint is None\"\n    ],\n    [\n        LangErrorCode.ConstraintTokenTokenProgram,\n        \"A token account token program constraint was violated\"\n    ],\n    [\n        LangErrorCode.ConstraintMintTokenProgram,\n        \"A mint token program constraint was violated\"\n    ],\n    [\n        LangErrorCode.ConstraintAssociatedTokenTokenProgram,\n        \"An associated token account token program constraint was violated\"\n    ],\n    [\n        LangErrorCode.ConstraintMintGroupPointerExtension,\n        \"A group pointer extension constraint was violated\"\n    ],\n    [\n        LangErrorCode.ConstraintMintGroupPointerExtensionAuthority,\n        \"A group pointer extension authority constraint was violated\"\n    ],\n    [\n        LangErrorCode.ConstraintMintGroupPointerExtensionGroupAddress,\n        \"A group pointer extension group address constraint was violated\"\n    ],\n    [\n        LangErrorCode.ConstraintMintGroupMemberPointerExtension,\n        \"A group member pointer extension constraint was violated\"\n    ],\n    [\n        LangErrorCode.ConstraintMintGroupMemberPointerExtensionAuthority,\n        \"A group member pointer extension authority constraint was violated\"\n    ],\n    [\n        LangErrorCode.ConstraintMintGroupMemberPointerExtensionMemberAddress,\n        \"A group member pointer extension group address constraint was violated\"\n    ],\n    [\n        LangErrorCode.ConstraintMintMetadataPointerExtension,\n        \"A metadata pointer extension constraint was violated\"\n    ],\n    [\n        LangErrorCode.ConstraintMintMetadataPointerExtensionAuthority,\n        \"A metadata pointer extension authority constraint was violated\"\n    ],\n    [\n        LangErrorCode.ConstraintMintMetadataPointerExtensionMetadataAddress,\n        \"A metadata pointer extension metadata address constraint was violated\"\n    ],\n    [\n        LangErrorCode.ConstraintMintCloseAuthorityExtension,\n        \"A close authority constraint was violated\"\n    ],\n    [\n        LangErrorCode.ConstraintMintCloseAuthorityExtensionAuthority,\n        \"A close authority extension authority constraint was violated\"\n    ],\n    [\n        LangErrorCode.ConstraintMintPermanentDelegateExtension,\n        \"A permanent delegate extension constraint was violated\"\n    ],\n    [\n        LangErrorCode.ConstraintMintPermanentDelegateExtensionDelegate,\n        \"A permanent delegate extension delegate constraint was violated\"\n    ],\n    [\n        LangErrorCode.ConstraintMintTransferHookExtension,\n        \"A transfer hook extension constraint was violated\"\n    ],\n    [\n        LangErrorCode.ConstraintMintTransferHookExtensionAuthority,\n        \"A transfer hook extension authority constraint was violated\"\n    ],\n    [\n        LangErrorCode.ConstraintMintTransferHookExtensionProgramId,\n        \"A transfer hook extension transfer hook program id constraint was violated\"\n    ],\n    // Require.\n    [\n        LangErrorCode.RequireViolated,\n        \"A require expression was violated\"\n    ],\n    [\n        LangErrorCode.RequireEqViolated,\n        \"A require_eq expression was violated\"\n    ],\n    [\n        LangErrorCode.RequireKeysEqViolated,\n        \"A require_keys_eq expression was violated\"\n    ],\n    [\n        LangErrorCode.RequireNeqViolated,\n        \"A require_neq expression was violated\"\n    ],\n    [\n        LangErrorCode.RequireKeysNeqViolated,\n        \"A require_keys_neq expression was violated\"\n    ],\n    [\n        LangErrorCode.RequireGtViolated,\n        \"A require_gt expression was violated\"\n    ],\n    [\n        LangErrorCode.RequireGteViolated,\n        \"A require_gte expression was violated\"\n    ],\n    // Accounts.\n    [\n        LangErrorCode.AccountDiscriminatorAlreadySet,\n        \"The account discriminator was already set on this account\"\n    ],\n    [\n        LangErrorCode.AccountDiscriminatorNotFound,\n        \"No 8 byte discriminator was found on the account\"\n    ],\n    [\n        LangErrorCode.AccountDiscriminatorMismatch,\n        \"8 byte discriminator did not match what was expected\"\n    ],\n    [\n        LangErrorCode.AccountDidNotDeserialize,\n        \"Failed to deserialize the account\"\n    ],\n    [\n        LangErrorCode.AccountDidNotSerialize,\n        \"Failed to serialize the account\"\n    ],\n    [\n        LangErrorCode.AccountNotEnoughKeys,\n        \"Not enough account keys given to the instruction\"\n    ],\n    [\n        LangErrorCode.AccountNotMutable,\n        \"The given account is not mutable\"\n    ],\n    [\n        LangErrorCode.AccountOwnedByWrongProgram,\n        \"The given account is owned by a different program than expected\"\n    ],\n    [\n        LangErrorCode.InvalidProgramId,\n        \"Program ID was not as expected\"\n    ],\n    [\n        LangErrorCode.InvalidProgramExecutable,\n        \"Program account is not executable\"\n    ],\n    [\n        LangErrorCode.AccountNotSigner,\n        \"The given account did not sign\"\n    ],\n    [\n        LangErrorCode.AccountNotSystemOwned,\n        \"The given account is not owned by the system program\"\n    ],\n    [\n        LangErrorCode.AccountNotInitialized,\n        \"The program expected this account to be already initialized\"\n    ],\n    [\n        LangErrorCode.AccountNotProgramData,\n        \"The given account is not a program data account\"\n    ],\n    [\n        LangErrorCode.AccountNotAssociatedTokenAccount,\n        \"The given account is not the associated token account\"\n    ],\n    [\n        LangErrorCode.AccountSysvarMismatch,\n        \"The given public key does not match the required sysvar\"\n    ],\n    [\n        LangErrorCode.AccountReallocExceedsLimit,\n        \"The account reallocation exceeds the MAX_PERMITTED_DATA_INCREASE limit\"\n    ],\n    [\n        LangErrorCode.AccountDuplicateReallocs,\n        \"The account was duplicated for more than one reallocation\"\n    ],\n    // Miscellaneous\n    [\n        LangErrorCode.DeclaredProgramIdMismatch,\n        \"The declared program id does not match the actual program id\"\n    ],\n    [\n        LangErrorCode.TryingToInitPayerAsProgramAccount,\n        \"You cannot/should not initialize the payer account as a program account\"\n    ],\n    [\n        LangErrorCode.InvalidNumericConversion,\n        \"The program could not perform the numeric conversion, out of range integral type conversion attempted\"\n    ],\n    // Deprecated\n    [\n        LangErrorCode.Deprecated,\n        \"The API being used is deprecated and should no longer be used\"\n    ]\n]); //# sourceMappingURL=error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL2Vycm9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBNEM7QUFDTztBQUNIO0FBQ3pDLE1BQU1HLGlCQUFpQkM7SUFDMUJDLFlBQVlDLE9BQU8sQ0FBRTtRQUNqQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDaEI7QUFDSjtBQUNPLE1BQU1DO0lBQ1RILFlBQVlJLEtBQUssQ0FBRTtRQUNmLElBQUksQ0FBQ0EsS0FBSyxHQUFHQTtJQUNqQjtJQUNBLE9BQU9DLE1BQU1DLElBQUksRUFBRTtRQUNmLElBQUlDO1FBQ0osTUFBTUMsa0JBQWtCO1FBQ3hCLE1BQU1DLGVBQWU7UUFDckIsTUFBTUMsZUFBZSxFQUFFO1FBQ3ZCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJTCxLQUFLTSxNQUFNLEVBQUVELElBQUs7WUFDbEMsSUFBSUYsYUFBYUksSUFBSSxDQUFDUCxJQUFJLENBQUNLLEVBQUUsR0FBRztnQkFDNUJELGFBQWFJLEdBQUc7Z0JBQ2hCO1lBQ0o7WUFDQSxNQUFNQyxhQUFhLENBQUNSLEtBQUtDLGdCQUFnQkssSUFBSSxDQUFDUCxJQUFJLENBQUNLLEVBQUUsT0FBTyxRQUFRSixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEVBQUUsQ0FBQyxFQUFFO1lBQ2xHLElBQUksQ0FBQ1EsWUFBWTtnQkFDYjtZQUNKO1lBQ0FMLGFBQWFNLElBQUksQ0FBQyxJQUFJckIsc0RBQVNBLENBQUNvQjtRQUNwQztRQUNBLE9BQU8sSUFBSVosa0JBQWtCTztJQUNqQztBQUNKO0FBQ08sTUFBTU8sb0JBQW9CbEI7SUFDN0JDLFlBQVlrQixTQUFTLEVBQUVDLFlBQVksRUFBRUMsU0FBUyxFQUFFZCxJQUFJLEVBQUVlLE1BQU0sRUFBRUMsY0FBYyxDQUFFO1FBQzFFLEtBQUssQ0FBQ0YsVUFBVUcsSUFBSSxDQUFDLE1BQU1DLE9BQU8sQ0FBQyxpQkFB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QUFFO0tBQWlDO0lBQ2xFO1FBQ0luSSxjQUFjcUkscUJBQXFCO1FBQ25DO0tBQ0g7SUFDRDtRQUNJckksY0FBY3VJLHFCQUFxQjtRQUNuQztLQUNIO0lBQ0Q7UUFDSXZJLGNBQWN5SSxxQkFBcUI7UUFDbkM7S0FDSDtJQUNEO1FBQ0l6SSxjQUFjMkksZ0NBQWdDO1FBQzlDO0tBQ0g7SUFDRDtRQUNJM0ksY0FBYzZJLHFCQUFxQjtRQUNuQztLQUNIO0lBQ0Q7UUFDSTdJLGNBQWMrSSwwQkFBMEI7UUFDeEM7S0FDSDtJQUNEO1FBQ0kvSSxjQUFjaUosd0JBQXdCO1FBQ3RDO0tBQ0g7SUFDRCxnQkFBZ0I7SUFDaEI7UUFDSWpKLGNBQWNtSix5QkFBeUI7UUFDdkM7S0FDSDtJQUNEO1FBQ0luSixjQUFjcUosaUNBQWlDO1FBQy9DO0tBQ0g7SUFDRDtRQUNJckosY0FBY3VKLHdCQUF3QjtRQUN0QztLQUNIO0lBQ0QsYUFBYTtJQUNiO1FBQ0l2SixjQUFjeUosVUFBVTtRQUN4QjtLQUNIO0NBQ0osRUFBRSxDQUNILGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGNvcmFsLXh5ei9hbmNob3IvZGlzdC9lc20vZXJyb3IuanM/YzlkOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tIFwiQHNvbGFuYS93ZWIzLmpzXCI7XG5pbXBvcnQgKiBhcyBlcnJvcnMgZnJvbSBcIkBjb3JhbC14eXovYW5jaG9yLWVycm9yc1wiO1xuaW1wb3J0ICogYXMgZmVhdHVyZXMgZnJvbSBcIi4vdXRpbHMvZmVhdHVyZXMuanNcIjtcbmV4cG9ydCBjbGFzcyBJZGxFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIklkbEVycm9yXCI7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFByb2dyYW1FcnJvclN0YWNrIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFjaykge1xuICAgICAgICB0aGlzLnN0YWNrID0gc3RhY2s7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZShsb2dzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgcHJvZ3JhbUtleVJlZ2V4ID0gL15Qcm9ncmFtIChcXHcqKSBpbnZva2UvO1xuICAgICAgICBjb25zdCBzdWNjZXNzUmVnZXggPSAvXlByb2dyYW0gXFx3KiBzdWNjZXNzLztcbiAgICAgICAgY29uc3QgcHJvZ3JhbVN0YWNrID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3NSZWdleC5leGVjKGxvZ3NbaV0pKSB7XG4gICAgICAgICAgICAgICAgcHJvZ3JhbVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHJvZ3JhbUtleSA9IChfYSA9IHByb2dyYW1LZXlSZWdleC5leGVjKGxvZ3NbaV0pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMV07XG4gICAgICAgICAgICBpZiAoIXByb2dyYW1LZXkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb2dyYW1TdGFjay5wdXNoKG5ldyBQdWJsaWNLZXkocHJvZ3JhbUtleSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvZ3JhbUVycm9yU3RhY2socHJvZ3JhbVN0YWNrKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQW5jaG9yRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoZXJyb3JDb2RlLCBlcnJvck1lc3NhZ2UsIGVycm9yTG9ncywgbG9ncywgb3JpZ2luLCBjb21wYXJlZFZhbHVlcykge1xuICAgICAgICBzdXBlcihlcnJvckxvZ3Muam9pbihcIlxcblwiKS5yZXBsYWNlKFwiUHJvZ3JhbSBsb2c6IFwiLCBcIlwiKSk7XG4gICAgICAgIHRoaXMuZXJyb3JMb2dzID0gZXJyb3JMb2dzO1xuICAgICAgICB0aGlzLmxvZ3MgPSBsb2dzO1xuICAgICAgICB0aGlzLmVycm9yID0geyBlcnJvckNvZGUsIGVycm9yTWVzc2FnZSwgY29tcGFyZWRWYWx1ZXMsIG9yaWdpbiB9O1xuICAgICAgICB0aGlzLl9wcm9ncmFtRXJyb3JTdGFjayA9IFByb2dyYW1FcnJvclN0YWNrLnBhcnNlKGxvZ3MpO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UobG9ncykge1xuICAgICAgICBpZiAoIWxvZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFuY2hvckVycm9yTG9nSW5kZXggPSBsb2dzLmZpbmRJbmRleCgobG9nKSA9PiBsb2cuc3RhcnRzV2l0aChcIlByb2dyYW0gbG9nOiBBbmNob3JFcnJvclwiKSk7XG4gICAgICAgIGlmIChhbmNob3JFcnJvckxvZ0luZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYW5jaG9yRXJyb3JMb2cgPSBsb2dzW2FuY2hvckVycm9yTG9nSW5kZXhdO1xuICAgICAgICBjb25zdCBlcnJvckxvZ3MgPSBbYW5jaG9yRXJyb3JMb2ddO1xuICAgICAgICBsZXQgY29tcGFyZWRWYWx1ZXM7XG4gICAgICAgIGlmIChhbmNob3JFcnJvckxvZ0luZGV4ICsgMSA8IGxvZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGNhdGNoZXMgdGhlIGNvbXBhcmVkVmFsdWVzIHdoZXJlIHRoZSBmb2xsb3dpbmcgaXMgbG9nZ2VkXG4gICAgICAgICAgICAvLyA8QW5jaG9yRXJyb3I+XG4gICAgICAgICAgICAvLyBMZWZ0OlxuICAgICAgICAgICAgLy8gPFB1YmtleT5cbiAgICAgICAgICAgIC8vIFJpZ2h0OlxuICAgICAgICAgICAgLy8gPFB1YmtleT5cbiAgICAgICAgICAgIGlmIChsb2dzW2FuY2hvckVycm9yTG9nSW5kZXggKyAxXSA9PT0gXCJQcm9ncmFtIGxvZzogTGVmdDpcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHB1YmtleVJlZ2V4ID0gL15Qcm9ncmFtIGxvZzogKC4qKSQvO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRQdWJrZXkgPSBwdWJrZXlSZWdleC5leGVjKGxvZ3NbYW5jaG9yRXJyb3JMb2dJbmRleCArIDJdKVsxXTtcbiAgICAgICAgICAgICAgICBjb25zdCByaWdodFB1YmtleSA9IHB1YmtleVJlZ2V4LmV4ZWMobG9nc1thbmNob3JFcnJvckxvZ0luZGV4ICsgNF0pWzFdO1xuICAgICAgICAgICAgICAgIGNvbXBhcmVkVmFsdWVzID0gW1xuICAgICAgICAgICAgICAgICAgICBuZXcgUHVibGljS2V5KGxlZnRQdWJrZXkpLFxuICAgICAgICAgICAgICAgICAgICBuZXcgUHVibGljS2V5KHJpZ2h0UHVia2V5KSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGVycm9yTG9ncy5wdXNoKC4uLmxvZ3Muc2xpY2UoYW5jaG9yRXJyb3JMb2dJbmRleCArIDEsIGFuY2hvckVycm9yTG9nSW5kZXggKyA1KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGlzIGNhdGNoZXMgdGhlIGNvbXBhcmVkVmFsdWVzIHdoZXJlIHRoZSBmb2xsb3dpbmcgaXMgbG9nZ2VkXG4gICAgICAgICAgICAvLyA8QW5jaG9yRXJyb3I+XG4gICAgICAgICAgICAvLyBMZWZ0OiA8dmFsdWU+XG4gICAgICAgICAgICAvLyBSaWdodDogPHZhbHVlPlxuICAgICAgICAgICAgZWxzZSBpZiAobG9nc1thbmNob3JFcnJvckxvZ0luZGV4ICsgMV0uc3RhcnRzV2l0aChcIlByb2dyYW0gbG9nOiBMZWZ0OlwiKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlUmVnZXggPSAvXlByb2dyYW0gbG9nOiAoTGVmdHxSaWdodCk6ICguKikkLztcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0VmFsdWUgPSB2YWx1ZVJlZ2V4LmV4ZWMobG9nc1thbmNob3JFcnJvckxvZ0luZGV4ICsgMV0pWzJdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0VmFsdWUgPSB2YWx1ZVJlZ2V4LmV4ZWMobG9nc1thbmNob3JFcnJvckxvZ0luZGV4ICsgMl0pWzJdO1xuICAgICAgICAgICAgICAgIGVycm9yTG9ncy5wdXNoKC4uLmxvZ3Muc2xpY2UoYW5jaG9yRXJyb3JMb2dJbmRleCArIDEsIGFuY2hvckVycm9yTG9nSW5kZXggKyAzKSk7XG4gICAgICAgICAgICAgICAgY29tcGFyZWRWYWx1ZXMgPSBbbGVmdFZhbHVlLCByaWdodFZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWdleE5vSW5mbyA9IC9eUHJvZ3JhbSBsb2c6IEFuY2hvckVycm9yIG9jY3VycmVkXFwuIEVycm9yIENvZGU6ICguKilcXC4gRXJyb3IgTnVtYmVyOiAoXFxkKilcXC4gRXJyb3IgTWVzc2FnZTogKC4qKVxcLi87XG4gICAgICAgIGNvbnN0IG5vSW5mb0FuY2hvckVycm9yTG9nID0gcmVnZXhOb0luZm8uZXhlYyhhbmNob3JFcnJvckxvZyk7XG4gICAgICAgIGNvbnN0IHJlZ2V4RmlsZUxpbmUgPSAvXlByb2dyYW0gbG9nOiBBbmNob3JFcnJvciB0aHJvd24gaW4gKC4qKTooXFxkKilcXC4gRXJyb3IgQ29kZTogKC4qKVxcLiBFcnJvciBOdW1iZXI6IChcXGQqKVxcLiBFcnJvciBNZXNzYWdlOiAoLiopXFwuLztcbiAgICAgICAgY29uc3QgZmlsZUxpbmVBbmNob3JFcnJvckxvZyA9IHJlZ2V4RmlsZUxpbmUuZXhlYyhhbmNob3JFcnJvckxvZyk7XG4gICAgICAgIGNvbnN0IHJlZ2V4QWNjb3VudE5hbWUgPSAvXlByb2dyYW0gbG9nOiBBbmNob3JFcnJvciBjYXVzZWQgYnkgYWNjb3VudDogKC4qKVxcLiBFcnJvciBDb2RlOiAoLiopXFwuIEVycm9yIE51bWJlcjogKFxcZCopXFwuIEVycm9yIE1lc3NhZ2U6ICguKilcXC4vO1xuICAgICAgICBjb25zdCBhY2NvdW50TmFtZUFuY2hvckVycm9yTG9nID0gcmVnZXhBY2NvdW50TmFtZS5leGVjKGFuY2hvckVycm9yTG9nKTtcbiAgICAgICAgaWYgKG5vSW5mb0FuY2hvckVycm9yTG9nKSB7XG4gICAgICAgICAgICBjb25zdCBbZXJyb3JDb2RlU3RyaW5nLCBlcnJvck51bWJlciwgZXJyb3JNZXNzYWdlXSA9IG5vSW5mb0FuY2hvckVycm9yTG9nLnNsaWNlKDEsIDQpO1xuICAgICAgICAgICAgY29uc3QgZXJyb3JDb2RlID0ge1xuICAgICAgICAgICAgICAgIGNvZGU6IGVycm9yQ29kZVN0cmluZyxcbiAgICAgICAgICAgICAgICBudW1iZXI6IHBhcnNlSW50KGVycm9yTnVtYmVyKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFuY2hvckVycm9yKGVycm9yQ29kZSwgZXJyb3JNZXNzYWdlLCBlcnJvckxvZ3MsIGxvZ3MsIHVuZGVmaW5lZCwgY29tcGFyZWRWYWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpbGVMaW5lQW5jaG9yRXJyb3JMb2cpIHtcbiAgICAgICAgICAgIGNvbnN0IFtmaWxlLCBsaW5lLCBlcnJvckNvZGVTdHJpbmcsIGVycm9yTnVtYmVyLCBlcnJvck1lc3NhZ2VdID0gZmlsZUxpbmVBbmNob3JFcnJvckxvZy5zbGljZSgxLCA2KTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBlcnJvckNvZGVTdHJpbmcsXG4gICAgICAgICAgICAgICAgbnVtYmVyOiBwYXJzZUludChlcnJvck51bWJlciksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZmlsZUxpbmUgPSB7IGZpbGUsIGxpbmU6IHBhcnNlSW50KGxpbmUpIH07XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFuY2hvckVycm9yKGVycm9yQ29kZSwgZXJyb3JNZXNzYWdlLCBlcnJvckxvZ3MsIGxvZ3MsIGZpbGVMaW5lLCBjb21wYXJlZFZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWNjb3VudE5hbWVBbmNob3JFcnJvckxvZykge1xuICAgICAgICAgICAgY29uc3QgW2FjY291bnROYW1lLCBlcnJvckNvZGVTdHJpbmcsIGVycm9yTnVtYmVyLCBlcnJvck1lc3NhZ2VdID0gYWNjb3VudE5hbWVBbmNob3JFcnJvckxvZy5zbGljZSgxLCA1KTtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbiA9IGFjY291bnROYW1lO1xuICAgICAgICAgICAgY29uc3QgZXJyb3JDb2RlID0ge1xuICAgICAgICAgICAgICAgIGNvZGU6IGVycm9yQ29kZVN0cmluZyxcbiAgICAgICAgICAgICAgICBudW1iZXI6IHBhcnNlSW50KGVycm9yTnVtYmVyKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFuY2hvckVycm9yKGVycm9yQ29kZSwgZXJyb3JNZXNzYWdlLCBlcnJvckxvZ3MsIGxvZ3MsIG9yaWdpbiwgY29tcGFyZWRWYWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHByb2dyYW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9ncmFtRXJyb3JTdGFjay5zdGFja1t0aGlzLl9wcm9ncmFtRXJyb3JTdGFjay5zdGFjay5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgZ2V0IHByb2dyYW1FcnJvclN0YWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvZ3JhbUVycm9yU3RhY2suc3RhY2s7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlO1xuICAgIH1cbn1cbi8vIEFuIGVycm9yIGZyb20gYSB1c2VyIGRlZmluZWQgcHJvZ3JhbS5cbmV4cG9ydCBjbGFzcyBQcm9ncmFtRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY29kZSwgbXNnLCBsb2dzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHRoaXMubXNnID0gbXNnO1xuICAgICAgICB0aGlzLmxvZ3MgPSBsb2dzO1xuICAgICAgICBpZiAobG9ncykge1xuICAgICAgICAgICAgdGhpcy5fcHJvZ3JhbUVycm9yU3RhY2sgPSBQcm9ncmFtRXJyb3JTdGFjay5wYXJzZShsb2dzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UoZXJyLCBpZGxFcnJvcnMpIHtcbiAgICAgICAgY29uc3QgZXJyU3RyaW5nID0gZXJyLnRvU3RyaW5nKCk7XG4gICAgICAgIC8vIFRPRE86IGRvbid0IHJlbHkgb24gdGhlIGVycm9yIHN0cmluZy4gd2ViMy5qcyBzaG91bGQgcHJlc2VydmUgdGhlIGVycm9yXG4gICAgICAgIC8vICAgICAgIGNvZGUgaW5mb3JtYXRpb24gaW5zdGVhZCBvZiBnaXZpbmcgdXMgYW4gdW50eXBlZCBzdHJpbmcuXG4gICAgICAgIGxldCB1bnBhcnNlZEVycm9yQ29kZTtcbiAgICAgICAgaWYgKGVyclN0cmluZy5pbmNsdWRlcyhcImN1c3RvbSBwcm9ncmFtIGVycm9yOlwiKSkge1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudHMgPSBlcnJTdHJpbmcuc3BsaXQoXCJjdXN0b20gcHJvZ3JhbSBlcnJvcjogXCIpO1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1bnBhcnNlZEVycm9yQ29kZSA9IGNvbXBvbmVudHNbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gZXJyU3RyaW5nLm1hdGNoKC9cIkN1c3RvbVwiOihbMC05XSspfS9nKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVucGFyc2VkRXJyb3JDb2RlID0gbWF0Y2hlc1swXS5tYXRjaCgvKFswLTldKykvZylbMF07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVycm9yQ29kZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGVycm9yQ29kZSA9IHBhcnNlSW50KHVucGFyc2VkRXJyb3JDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAocGFyc2VFcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhcnNlIHVzZXIgZXJyb3IuXG4gICAgICAgIGxldCBlcnJvck1zZyA9IGlkbEVycm9ycy5nZXQoZXJyb3JDb2RlKTtcbiAgICAgICAgaWYgKGVycm9yTXNnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvZ3JhbUVycm9yKGVycm9yQ29kZSwgZXJyb3JNc2csIGVyci5sb2dzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYXJzZSBmcmFtZXdvcmsgaW50ZXJuYWwgZXJyb3IuXG4gICAgICAgIGVycm9yTXNnID0gTGFuZ0Vycm9yTWVzc2FnZS5nZXQoZXJyb3JDb2RlKTtcbiAgICAgICAgaWYgKGVycm9yTXNnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvZ3JhbUVycm9yKGVycm9yQ29kZSwgZXJyb3JNc2csIGVyci5sb2dzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVbmFibGUgdG8gcGFyc2UgdGhlIGVycm9yLiBKdXN0IHJldHVybiB0aGUgdW50cmFuc2xhdGVkIGVycm9yLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0IHByb2dyYW0oKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuX3Byb2dyYW1FcnJvclN0YWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhY2tbdGhpcy5fcHJvZ3JhbUVycm9yU3RhY2suc3RhY2subGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIGdldCBwcm9ncmFtRXJyb3JTdGFjaygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5fcHJvZ3JhbUVycm9yU3RhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGFjaztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1zZztcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gdHJhbnNsYXRlRXJyb3IoZXJyLCBpZGxFcnJvcnMpIHtcbiAgICBpZiAoZmVhdHVyZXMuaXNTZXQoXCJkZWJ1Zy1sb2dzXCIpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVHJhbnNsYXRpbmcgZXJyb3I6XCIsIGVycik7XG4gICAgfVxuICAgIGNvbnN0IGFuY2hvckVycm9yID0gQW5jaG9yRXJyb3IucGFyc2UoZXJyLmxvZ3MpO1xuICAgIGlmIChhbmNob3JFcnJvcikge1xuICAgICAgICByZXR1cm4gYW5jaG9yRXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IHByb2dyYW1FcnJvciA9IFByb2dyYW1FcnJvci5wYXJzZShlcnIsIGlkbEVycm9ycyk7XG4gICAgaWYgKHByb2dyYW1FcnJvcikge1xuICAgICAgICByZXR1cm4gcHJvZ3JhbUVycm9yO1xuICAgIH1cbiAgICBpZiAoZXJyLmxvZ3MpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKHRhcmdldCwgcHJvcCkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wID09PSBcInByb2dyYW1FcnJvclN0YWNrXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5wcm9ncmFtRXJyb3JTdGFjay5zdGFjaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvcCA9PT0gXCJwcm9ncmFtXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5wcm9ncmFtRXJyb3JTdGFjay5zdGFja1tlcnIucHJvZ3JhbUVycm9yU3RhY2suc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBub3JtYWwgd2F5IHRvIHJldHVybiBhbGwgb3RoZXIgcHJvcHNcbiAgICAgICAgICAgICAgICAgICAgLy8gd2l0aG91dCBtb2RpZnlpbmcgdGhlbS5cbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBlcnIucHJvZ3JhbUVycm9yU3RhY2sgPSBQcm9ncmFtRXJyb3JTdGFjay5wYXJzZShlcnIubG9ncyk7XG4gICAgICAgIHJldHVybiBuZXcgUHJveHkoZXJyLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycjtcbn1cbmV4cG9ydCBjb25zdCBMYW5nRXJyb3JDb2RlID0ge1xuICAgIC8vIEluc3RydWN0aW9ucy5cbiAgICBJbnN0cnVjdGlvbk1pc3Npbmc6IGVycm9ycy5BTkNIT1JfRVJST1JfX0lOU1RSVUNUSU9OX01JU1NJTkcsXG4gICAgSW5zdHJ1Y3Rpb25GYWxsYmFja05vdEZvdW5kOiBlcnJvcnMuQU5DSE9SX0VSUk9SX19JTlNUUlVDVElPTl9GQUxMQkFDS19OT1RfRk9VTkQsXG4gICAgSW5zdHJ1Y3Rpb25EaWROb3REZXNlcmlhbGl6ZTogZXJyb3JzLkFOQ0hPUl9FUlJPUl9fSU5TVFJVQ1RJT05fRElEX05PVF9ERVNFUklBTElaRSxcbiAgICBJbnN0cnVjdGlvbkRpZE5vdFNlcmlhbGl6ZTogZXJyb3JzLkFOQ0hPUl9FUlJPUl9fSU5TVFJVQ1RJT05fRElEX05PVF9TRVJJQUxJWkUsXG4gICAgLy8gSURMIGluc3RydWN0aW9ucy5cbiAgICBJZGxJbnN0cnVjdGlvblN0dWI6IGVycm9ycy5BTkNIT1JfRVJST1JfX0lETF9JTlNUUlVDVElPTl9TVFVCLFxuICAgIElkbEluc3RydWN0aW9uSW52YWxpZFByb2dyYW06IGVycm9ycy5BTkNIT1JfRVJST1JfX0lETF9JTlNUUlVDVElPTl9JTlZBTElEX1BST0dSQU0sXG4gICAgSWRsQWNjb3VudE5vdEVtcHR5OiBlcnJvcnMuQU5DSE9SX0VSUk9SX19JRExfQUNDT1VOVF9OT1RfRU1QVFksXG4gICAgLy8gRXZlbnQgaW5zdHJ1Y3Rpb25zLlxuICAgIEV2ZW50SW5zdHJ1Y3Rpb25TdHViOiBlcnJvcnMuQU5DSE9SX0VSUk9SX19FVkVOVF9JTlNUUlVDVElPTl9TVFVCLFxuICAgIC8vIENvbnN0cmFpbnRzLlxuICAgIENvbnN0cmFpbnRNdXQ6IGVycm9ycy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfTVVULFxuICAgIENvbnN0cmFpbnRIYXNPbmU6IGVycm9ycy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfSEFTX09ORSxcbiAgICBDb25zdHJhaW50U2lnbmVyOiBlcnJvcnMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX1NJR05FUixcbiAgICBDb25zdHJhaW50UmF3OiBlcnJvcnMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX1JBVyxcbiAgICBDb25zdHJhaW50T3duZXI6IGVycm9ycy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfT1dORVIsXG4gICAgQ29uc3RyYWludFJlbnRFeGVtcHQ6IGVycm9ycy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfUkVOVF9FWEVNUFQsXG4gICAgQ29uc3RyYWludFNlZWRzOiBlcnJvcnMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX1NFRURTLFxuICAgIENvbnN0cmFpbnRFeGVjdXRhYmxlOiBlcnJvcnMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX0VYRUNVVEFCTEUsXG4gICAgQ29uc3RyYWludFN0YXRlOiBlcnJvcnMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX1NUQVRFLFxuICAgIENvbnN0cmFpbnRBc3NvY2lhdGVkOiBlcnJvcnMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX0FTU09DSUFURUQsXG4gICAgQ29uc3RyYWludEFzc29jaWF0ZWRJbml0OiBlcnJvcnMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX0FTU09DSUFURURfSU5JVCxcbiAgICBDb25zdHJhaW50Q2xvc2U6IGVycm9ycy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfQ0xPU0UsXG4gICAgQ29uc3RyYWludEFkZHJlc3M6IGVycm9ycy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfQUREUkVTUyxcbiAgICBDb25zdHJhaW50WmVybzogZXJyb3JzLkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9aRVJPLFxuICAgIENvbnN0cmFpbnRUb2tlbk1pbnQ6IGVycm9ycy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfVE9LRU5fTUlOVCxcbiAgICBDb25zdHJhaW50VG9rZW5Pd25lcjogZXJyb3JzLkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9UT0tFTl9PV05FUixcbiAgICBDb25zdHJhaW50TWludE1pbnRBdXRob3JpdHk6IGVycm9ycy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfTUlOVF9NSU5UX0FVVEhPUklUWSxcbiAgICBDb25zdHJhaW50TWludEZyZWV6ZUF1dGhvcml0eTogZXJyb3JzLkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NSU5UX0ZSRUVaRV9BVVRIT1JJVFksXG4gICAgQ29uc3RyYWludE1pbnREZWNpbWFsczogZXJyb3JzLkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NSU5UX0RFQ0lNQUxTLFxuICAgIENvbnN0cmFpbnRTcGFjZTogZXJyb3JzLkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9TUEFDRSxcbiAgICBDb25zdHJhaW50QWNjb3VudElzTm9uZTogZXJyb3JzLkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9BQ0NPVU5UX0lTX05PTkUsXG4gICAgQ29uc3RyYWludFRva2VuVG9rZW5Qcm9ncmFtOiBlcnJvcnMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX1RPS0VOX1RPS0VOX1BST0dSQU0sXG4gICAgQ29uc3RyYWludE1pbnRUb2tlblByb2dyYW06IGVycm9ycy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfTUlOVF9UT0tFTl9QUk9HUkFNLFxuICAgIENvbnN0cmFpbnRBc3NvY2lhdGVkVG9rZW5Ub2tlblByb2dyYW06IGVycm9ycy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfQVNTT0NJQVRFRF9UT0tFTl9UT0tFTl9QUk9HUkFNLFxuICAgIENvbnN0cmFpbnRNaW50R3JvdXBQb2ludGVyRXh0ZW5zaW9uOiBlcnJvcnMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX01JTlRfR1JPVVBfUE9JTlRFUl9FWFRFTlNJT04sXG4gICAgQ29uc3RyYWludE1pbnRHcm91cFBvaW50ZXJFeHRlbnNpb25BdXRob3JpdHk6IGVycm9ycy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfTUlOVF9HUk9VUF9QT0lOVEVSX0VYVEVOU0lPTl9BVVRIT1JJVFksXG4gICAgQ29uc3RyYWludE1pbnRHcm91cFBvaW50ZXJFeHRlbnNpb25Hcm91cEFkZHJlc3M6IGVycm9ycy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfTUlOVF9HUk9VUF9QT0lOVEVSX0VYVEVOU0lPTl9HUk9VUF9BRERSRVNTLFxuICAgIENvbnN0cmFpbnRNaW50R3JvdXBNZW1iZXJQb2ludGVyRXh0ZW5zaW9uOiBlcnJvcnMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX01JTlRfR1JPVVBfTUVNQkVSX1BPSU5URVJfRVhURU5TSU9OLFxuICAgIENvbnN0cmFpbnRNaW50R3JvdXBNZW1iZXJQb2ludGVyRXh0ZW5zaW9uQXV0aG9yaXR5OiBlcnJvcnMuQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX01JTlRfR1JPVVBfTUVNQkVSX1BPSU5URVJfRVhURU5TSU9OX0FVVEhPUklUWSxcbiAgICBDb25zdHJhaW50TWludEdyb3VwTWVtYmVyUG9pbnRlckV4dGVuc2lvbk1lbWJlckFkZHJlc3M6IGVycm9ycy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfTUlOVF9HUk9VUF9NRU1CRVJfUE9JTlRFUl9FWFRFTlNJT05fTUVNQkVSX0FERFJFU1MsXG4gICAgQ29uc3RyYWludE1pbnRNZXRhZGF0YVBvaW50ZXJFeHRlbnNpb246IGVycm9ycy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfTUlOVF9NRVRBREFUQV9QT0lOVEVSX0VYVEVOU0lPTixcbiAgICBDb25zdHJhaW50TWludE1ldGFkYXRhUG9pbnRlckV4dGVuc2lvbkF1dGhvcml0eTogZXJyb3JzLkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NSU5UX01FVEFEQVRBX1BPSU5URVJfRVhURU5TSU9OX0FVVEhPUklUWSxcbiAgICBDb25zdHJhaW50TWludE1ldGFkYXRhUG9pbnRlckV4dGVuc2lvbk1ldGFkYXRhQWRkcmVzczogZXJyb3JzLkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NSU5UX01FVEFEQVRBX1BPSU5URVJfRVhURU5TSU9OX01FVEFEQVRBX0FERFJFU1MsXG4gICAgQ29uc3RyYWludE1pbnRDbG9zZUF1dGhvcml0eUV4dGVuc2lvbjogZXJyb3JzLkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NSU5UX0NMT1NFX0FVVEhPUklUWV9FWFRFTlNJT04sXG4gICAgQ29uc3RyYWludE1pbnRDbG9zZUF1dGhvcml0eUV4dGVuc2lvbkF1dGhvcml0eTogZXJyb3JzLkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NSU5UX0NMT1NFX0FVVEhPUklUWV9FWFRFTlNJT05fQVVUSE9SSVRZLFxuICAgIENvbnN0cmFpbnRNaW50UGVybWFuZW50RGVsZWdhdGVFeHRlbnNpb246IGVycm9ycy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfTUlOVF9QRVJNQU5FTlRfREVMRUdBVEVfRVhURU5TSU9OLFxuICAgIENvbnN0cmFpbnRNaW50UGVybWFuZW50RGVsZWdhdGVFeHRlbnNpb25EZWxlZ2F0ZTogZXJyb3JzLkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NSU5UX1BFUk1BTkVOVF9ERUxFR0FURV9FWFRFTlNJT05fREVMRUdBVEUsXG4gICAgQ29uc3RyYWludE1pbnRUcmFuc2Zlckhvb2tFeHRlbnNpb246IGVycm9ycy5BTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfTUlOVF9UUkFOU0ZFUl9IT09LX0VYVEVOU0lPTixcbiAgICBDb25zdHJhaW50TWludFRyYW5zZmVySG9va0V4dGVuc2lvbkF1dGhvcml0eTogZXJyb3JzLkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NSU5UX1RSQU5TRkVSX0hPT0tfRVhURU5TSU9OX0FVVEhPUklUWSxcbiAgICBDb25zdHJhaW50TWludFRyYW5zZmVySG9va0V4dGVuc2lvblByb2dyYW1JZDogZXJyb3JzLkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NSU5UX1RSQU5TRkVSX0hPT0tfRVhURU5TSU9OX1BST0dSQU1fSUQsXG4gICAgLy8gUmVxdWlyZS5cbiAgICBSZXF1aXJlVmlvbGF0ZWQ6IGVycm9ycy5BTkNIT1JfRVJST1JfX1JFUVVJUkVfVklPTEFURUQsXG4gICAgUmVxdWlyZUVxVmlvbGF0ZWQ6IGVycm9ycy5BTkNIT1JfRVJST1JfX1JFUVVJUkVfRVFfVklPTEFURUQsXG4gICAgUmVxdWlyZUtleXNFcVZpb2xhdGVkOiBlcnJvcnMuQU5DSE9SX0VSUk9SX19SRVFVSVJFX0tFWVNfRVFfVklPTEFURUQsXG4gICAgUmVxdWlyZU5lcVZpb2xhdGVkOiBlcnJvcnMuQU5DSE9SX0VSUk9SX19SRVFVSVJFX05FUV9WSU9MQVRFRCxcbiAgICBSZXF1aXJlS2V5c05lcVZpb2xhdGVkOiBlcnJvcnMuQU5DSE9SX0VSUk9SX19SRVFVSVJFX0tFWVNfTkVRX1ZJT0xBVEVELFxuICAgIFJlcXVpcmVHdFZpb2xhdGVkOiBlcnJvcnMuQU5DSE9SX0VSUk9SX19SRVFVSVJFX0dUX1ZJT0xBVEVELFxuICAgIFJlcXVpcmVHdGVWaW9sYXRlZDogZXJyb3JzLkFOQ0hPUl9FUlJPUl9fUkVRVUlSRV9HVEVfVklPTEFURUQsXG4gICAgLy8gQWNjb3VudHMuXG4gICAgQWNjb3VudERpc2NyaW1pbmF0b3JBbHJlYWR5U2V0OiBlcnJvcnMuQU5DSE9SX0VSUk9SX19BQ0NPVU5UX0RJU0NSSU1JTkFUT1JfQUxSRUFEWV9TRVQsXG4gICAgQWNjb3VudERpc2NyaW1pbmF0b3JOb3RGb3VuZDogZXJyb3JzLkFOQ0hPUl9FUlJPUl9fQUNDT1VOVF9ESVNDUklNSU5BVE9SX05PVF9GT1VORCxcbiAgICBBY2NvdW50RGlzY3JpbWluYXRvck1pc21hdGNoOiBlcnJvcnMuQU5DSE9SX0VSUk9SX19BQ0NPVU5UX0RJU0NSSU1JTkFUT1JfTUlTTUFUQ0gsXG4gICAgQWNjb3VudERpZE5vdERlc2VyaWFsaXplOiBlcnJvcnMuQU5DSE9SX0VSUk9SX19BQ0NPVU5UX0RJRF9OT1RfREVTRVJJQUxJWkUsXG4gICAgQWNjb3VudERpZE5vdFNlcmlhbGl6ZTogZXJyb3JzLkFOQ0hPUl9FUlJPUl9fQUNDT1VOVF9ESURfTk9UX1NFUklBTElaRSxcbiAgICBBY2NvdW50Tm90RW5vdWdoS2V5czogZXJyb3JzLkFOQ0hPUl9FUlJPUl9fQUNDT1VOVF9OT1RfRU5PVUdIX0tFWVMsXG4gICAgQWNjb3VudE5vdE11dGFibGU6IGVycm9ycy5BTkNIT1JfRVJST1JfX0FDQ09VTlRfTk9UX01VVEFCTEUsXG4gICAgQWNjb3VudE93bmVkQnlXcm9uZ1Byb2dyYW06IGVycm9ycy5BTkNIT1JfRVJST1JfX0FDQ09VTlRfT1dORURfQllfV1JPTkdfUFJPR1JBTSxcbiAgICBJbnZhbGlkUHJvZ3JhbUlkOiBlcnJvcnMuQU5DSE9SX0VSUk9SX19JTlZBTElEX1BST0dSQU1fSUQsXG4gICAgSW52YWxpZFByb2dyYW1FeGVjdXRhYmxlOiBlcnJvcnMuQU5DSE9SX0VSUk9SX19JTlZBTElEX1BST0dSQU1fRVhFQ1VUQUJMRSxcbiAgICBBY2NvdW50Tm90U2lnbmVyOiBlcnJvcnMuQU5DSE9SX0VSUk9SX19BQ0NPVU5UX05PVF9TSUdORVIsXG4gICAgQWNjb3VudE5vdFN5c3RlbU93bmVkOiBlcnJvcnMuQU5DSE9SX0VSUk9SX19BQ0NPVU5UX05PVF9TWVNURU1fT1dORUQsXG4gICAgQWNjb3VudE5vdEluaXRpYWxpemVkOiBlcnJvcnMuQU5DSE9SX0VSUk9SX19BQ0NPVU5UX05PVF9JTklUSUFMSVpFRCxcbiAgICBBY2NvdW50Tm90UHJvZ3JhbURhdGE6IGVycm9ycy5BTkNIT1JfRVJST1JfX0FDQ09VTlRfTk9UX1BST0dSQU1fREFUQSxcbiAgICBBY2NvdW50Tm90QXNzb2NpYXRlZFRva2VuQWNjb3VudDogZXJyb3JzLkFOQ0hPUl9FUlJPUl9fQUNDT1VOVF9OT1RfQVNTT0NJQVRFRF9UT0tFTl9BQ0NPVU5ULFxuICAgIEFjY291bnRTeXN2YXJNaXNtYXRjaDogZXJyb3JzLkFOQ0hPUl9FUlJPUl9fQUNDT1VOVF9TWVNWQVJfTUlTTUFUQ0gsXG4gICAgQWNjb3VudFJlYWxsb2NFeGNlZWRzTGltaXQ6IGVycm9ycy5BTkNIT1JfRVJST1JfX0FDQ09VTlRfUkVBTExPQ19FWENFRURTX0xJTUlULFxuICAgIEFjY291bnREdXBsaWNhdGVSZWFsbG9jczogZXJyb3JzLkFOQ0hPUl9FUlJPUl9fQUNDT1VOVF9EVVBMSUNBVEVfUkVBTExPQ1MsXG4gICAgLy8gTWlzY2VsbGFuZW91c1xuICAgIERlY2xhcmVkUHJvZ3JhbUlkTWlzbWF0Y2g6IGVycm9ycy5BTkNIT1JfRVJST1JfX0RFQ0xBUkVEX1BST0dSQU1fSURfTUlTTUFUQ0gsXG4gICAgVHJ5aW5nVG9Jbml0UGF5ZXJBc1Byb2dyYW1BY2NvdW50OiBlcnJvcnMuQU5DSE9SX0VSUk9SX19UUllJTkdfVE9fSU5JVF9QQVlFUl9BU19QUk9HUkFNX0FDQ09VTlQsXG4gICAgSW52YWxpZE51bWVyaWNDb252ZXJzaW9uOiBlcnJvcnMuQU5DSE9SX0VSUk9SX19JTlZBTElEX05VTUVSSUNfQ09OVkVSU0lPTixcbiAgICAvLyBVc2VkIGZvciBBUElzIHRoYXQgc2hvdWxkbid0IGJlIHVzZWQgYW55bW9yZS5cbiAgICBEZXByZWNhdGVkOiBlcnJvcnMuQU5DSE9SX0VSUk9SX19ERVBSRUNBVEVELFxufTtcbmV4cG9ydCBjb25zdCBMYW5nRXJyb3JNZXNzYWdlID0gbmV3IE1hcChbXG4gICAgLy8gSW5zdHJ1Y3Rpb25zLlxuICAgIFtcbiAgICAgICAgTGFuZ0Vycm9yQ29kZS5JbnN0cnVjdGlvbk1pc3NpbmcsXG4gICAgICAgIFwiOCBieXRlIGluc3RydWN0aW9uIGlkZW50aWZpZXIgbm90IHByb3ZpZGVkXCIsXG4gICAgXSxcbiAgICBbXG4gICAgICAgIExhbmdFcnJvckNvZGUuSW5zdHJ1Y3Rpb25GYWxsYmFja05vdEZvdW5kLFxuICAgICAgICBcIkZhbGxiYWNrIGZ1bmN0aW9ucyBhcmUgbm90IHN1cHBvcnRlZFwiLFxuICAgIF0sXG4gICAgW1xuICAgICAgICBMYW5nRXJyb3JDb2RlLkluc3RydWN0aW9uRGlkTm90RGVzZXJpYWxpemUsXG4gICAgICAgIFwiVGhlIHByb2dyYW0gY291bGQgbm90IGRlc2VyaWFsaXplIHRoZSBnaXZlbiBpbnN0cnVjdGlvblwiLFxuICAgIF0sXG4gICAgW1xuICAgICAgICBMYW5nRXJyb3JDb2RlLkluc3RydWN0aW9uRGlkTm90U2VyaWFsaXplLFxuICAgICAgICBcIlRoZSBwcm9ncmFtIGNvdWxkIG5vdCBzZXJpYWxpemUgdGhlIGdpdmVuIGluc3RydWN0aW9uXCIsXG4gICAgXSxcbiAgICAvLyBJZGwgaW5zdHJ1Y3Rpb25zLlxuICAgIFtcbiAgICAgICAgTGFuZ0Vycm9yQ29kZS5JZGxJbnN0cnVjdGlvblN0dWIsXG4gICAgICAgIFwiVGhlIHByb2dyYW0gd2FzIGNvbXBpbGVkIHdpdGhvdXQgaWRsIGluc3RydWN0aW9uc1wiLFxuICAgIF0sXG4gICAgW1xuICAgICAgICBMYW5nRXJyb3JDb2RlLklkbEluc3RydWN0aW9uSW52YWxpZFByb2dyYW0sXG4gICAgICAgIFwiVGhlIHRyYW5zYWN0aW9uIHdhcyBnaXZlbiBhbiBpbnZhbGlkIHByb2dyYW0gZm9yIHRoZSBJREwgaW5zdHJ1Y3Rpb25cIixcbiAgICBdLFxuICAgIFtcbiAgICAgICAgTGFuZ0Vycm9yQ29kZS5JZGxBY2NvdW50Tm90RW1wdHksXG4gICAgICAgIFwiSURMIGFjY291bnQgbXVzdCBiZSBlbXB0eSBpbiBvcmRlciB0byByZXNpemUsIHRyeSBjbG9zaW5nIGZpcnN0XCIsXG4gICAgXSxcbiAgICAvLyBFdmVudCBpbnN0cnVjdGlvbnMuXG4gICAgW1xuICAgICAgICBMYW5nRXJyb3JDb2RlLkV2ZW50SW5zdHJ1Y3Rpb25TdHViLFxuICAgICAgICBcIlRoZSBwcm9ncmFtIHdhcyBjb21waWxlZCB3aXRob3V0IGBldmVudC1jcGlgIGZlYXR1cmVcIixcbiAgICBdLFxuICAgIC8vIENvbnN0cmFpbnRzLlxuICAgIFtMYW5nRXJyb3JDb2RlLkNvbnN0cmFpbnRNdXQsIFwiQSBtdXQgY29uc3RyYWludCB3YXMgdmlvbGF0ZWRcIl0sXG4gICAgW0xhbmdFcnJvckNvZGUuQ29uc3RyYWludEhhc09uZSwgXCJBIGhhcyBvbmUgY29uc3RyYWludCB3YXMgdmlvbGF0ZWRcIl0sXG4gICAgW0xhbmdFcnJvckNvZGUuQ29uc3RyYWludFNpZ25lciwgXCJBIHNpZ25lciBjb25zdHJhaW50IHdhcyB2aW9sYXRlZFwiXSxcbiAgICBbTGFuZ0Vycm9yQ29kZS5Db25zdHJhaW50UmF3LCBcIkEgcmF3IGNvbnN0cmFpbnQgd2FzIHZpb2xhdGVkXCJdLFxuICAgIFtMYW5nRXJyb3JDb2RlLkNvbnN0cmFpbnRPd25lciwgXCJBbiBvd25lciBjb25zdHJhaW50IHdhcyB2aW9sYXRlZFwiXSxcbiAgICBbXG4gICAgICAgIExhbmdFcnJvckNvZGUuQ29uc3RyYWludFJlbnRFeGVtcHQsXG4gICAgICAgIFwiQSByZW50IGV4ZW1wdGlvbiBjb25zdHJhaW50IHdhcyB2aW9sYXRlZFwiLFxuICAgIF0sXG4gICAgW0xhbmdFcnJvckNvZGUuQ29uc3RyYWludFNlZWRzLCBcIkEgc2VlZHMgY29uc3RyYWludCB3YXMgdmlvbGF0ZWRcIl0sXG4gICAgW0xhbmdFcnJvckNvZGUuQ29uc3RyYWludEV4ZWN1dGFibGUsIFwiQW4gZXhlY3V0YWJsZSBjb25zdHJhaW50IHdhcyB2aW9sYXRlZFwiXSxcbiAgICBbXG4gICAgICAgIExhbmdFcnJvckNvZGUuQ29uc3RyYWludFN0YXRlLFxuICAgICAgICBcIkRlcHJlY2F0ZWQgRXJyb3IsIGZlZWwgZnJlZSB0byByZXBsYWNlIHdpdGggc29tZXRoaW5nIGVsc2VcIixcbiAgICBdLFxuICAgIFtMYW5nRXJyb3JDb2RlLkNvbnN0cmFpbnRBc3NvY2lhdGVkLCBcIkFuIGFzc29jaWF0ZWQgY29uc3RyYWludCB3YXMgdmlvbGF0ZWRcIl0sXG4gICAgW1xuICAgICAgICBMYW5nRXJyb3JDb2RlLkNvbnN0cmFpbnRBc3NvY2lhdGVkSW5pdCxcbiAgICAgICAgXCJBbiBhc3NvY2lhdGVkIGluaXQgY29uc3RyYWludCB3YXMgdmlvbGF0ZWRcIixcbiAgICBdLFxuICAgIFtMYW5nRXJyb3JDb2RlLkNvbnN0cmFpbnRDbG9zZSwgXCJBIGNsb3NlIGNvbnN0cmFpbnQgd2FzIHZpb2xhdGVkXCJdLFxuICAgIFtMYW5nRXJyb3JDb2RlLkNvbnN0cmFpbnRBZGRyZXNzLCBcIkFuIGFkZHJlc3MgY29uc3RyYWludCB3YXMgdmlvbGF0ZWRcIl0sXG4gICAgW0xhbmdFcnJvckNvZGUuQ29uc3RyYWludFplcm8sIFwiRXhwZWN0ZWQgemVybyBhY2NvdW50IGRpc2NyaW1pbmFudFwiXSxcbiAgICBbTGFuZ0Vycm9yQ29kZS5Db25zdHJhaW50VG9rZW5NaW50LCBcIkEgdG9rZW4gbWludCBjb25zdHJhaW50IHdhcyB2aW9sYXRlZFwiXSxcbiAgICBbTGFuZ0Vycm9yQ29kZS5Db25zdHJhaW50VG9rZW5Pd25lciwgXCJBIHRva2VuIG93bmVyIGNvbnN0cmFpbnQgd2FzIHZpb2xhdGVkXCJdLFxuICAgIFtcbiAgICAgICAgTGFuZ0Vycm9yQ29kZS5Db25zdHJhaW50TWludE1pbnRBdXRob3JpdHksXG4gICAgICAgIFwiQSBtaW50IG1pbnQgYXV0aG9yaXR5IGNvbnN0cmFpbnQgd2FzIHZpb2xhdGVkXCIsXG4gICAgXSxcbiAgICBbXG4gICAgICAgIExhbmdFcnJvckNvZGUuQ29uc3RyYWludE1pbnRGcmVlemVBdXRob3JpdHksXG4gICAgICAgIFwiQSBtaW50IGZyZWV6ZSBhdXRob3JpdHkgY29uc3RyYWludCB3YXMgdmlvbGF0ZWRcIixcbiAgICBdLFxuICAgIFtcbiAgICAgICAgTGFuZ0Vycm9yQ29kZS5Db25zdHJhaW50TWludERlY2ltYWxzLFxuICAgICAgICBcIkEgbWludCBkZWNpbWFscyBjb25zdHJhaW50IHdhcyB2aW9sYXRlZFwiLFxuICAgIF0sXG4gICAgW0xhbmdFcnJvckNvZGUuQ29uc3RyYWludFNwYWNlLCBcIkEgc3BhY2UgY29uc3RyYWludCB3YXMgdmlvbGF0ZWRcIl0sXG4gICAgW1xuICAgICAgICBMYW5nRXJyb3JDb2RlLkNvbnN0cmFpbnRBY2NvdW50SXNOb25lLFxuICAgICAgICBcIkEgcmVxdWlyZWQgYWNjb3VudCBmb3IgdGhlIGNvbnN0cmFpbnQgaXMgTm9uZVwiLFxuICAgIF0sXG4gICAgW1xuICAgICAgICBMYW5nRXJyb3JDb2RlLkNvbnN0cmFpbnRUb2tlblRva2VuUHJvZ3JhbSxcbiAgICAgICAgXCJBIHRva2VuIGFjY291bnQgdG9rZW4gcHJvZ3JhbSBjb25zdHJhaW50IHdhcyB2aW9sYXRlZFwiLFxuICAgIF0sXG4gICAgW1xuICAgICAgICBMYW5nRXJyb3JDb2RlLkNvbnN0cmFpbnRNaW50VG9rZW5Qcm9ncmFtLFxuICAgICAgICBcIkEgbWludCB0b2tlbiBwcm9ncmFtIGNvbnN0cmFpbnQgd2FzIHZpb2xhdGVkXCIsXG4gICAgXSxcbiAgICBbXG4gICAgICAgIExhbmdFcnJvckNvZGUuQ29uc3RyYWludEFzc29jaWF0ZWRUb2tlblRva2VuUHJvZ3JhbSxcbiAgICAgICAgXCJBbiBhc3NvY2lhdGVkIHRva2VuIGFjY291bnQgdG9rZW4gcHJvZ3JhbSBjb25zdHJhaW50IHdhcyB2aW9sYXRlZFwiLFxuICAgIF0sXG4gICAgW1xuICAgICAgICBMYW5nRXJyb3JDb2RlLkNvbnN0cmFpbnRNaW50R3JvdXBQb2ludGVyRXh0ZW5zaW9uLFxuICAgICAgICBcIkEgZ3JvdXAgcG9pbnRlciBleHRlbnNpb24gY29uc3RyYWludCB3YXMgdmlvbGF0ZWRcIixcbiAgICBdLFxuICAgIFtcbiAgICAgICAgTGFuZ0Vycm9yQ29kZS5Db25zdHJhaW50TWludEdyb3VwUG9pbnRlckV4dGVuc2lvbkF1dGhvcml0eSxcbiAgICAgICAgXCJBIGdyb3VwIHBvaW50ZXIgZXh0ZW5zaW9uIGF1dGhvcml0eSBjb25zdHJhaW50IHdhcyB2aW9sYXRlZFwiLFxuICAgIF0sXG4gICAgW1xuICAgICAgICBMYW5nRXJyb3JDb2RlLkNvbnN0cmFpbnRNaW50R3JvdXBQb2ludGVyRXh0ZW5zaW9uR3JvdXBBZGRyZXNzLFxuICAgICAgICBcIkEgZ3JvdXAgcG9pbnRlciBleHRlbnNpb24gZ3JvdXAgYWRkcmVzcyBjb25zdHJhaW50IHdhcyB2aW9sYXRlZFwiLFxuICAgIF0sXG4gICAgW1xuICAgICAgICBMYW5nRXJyb3JDb2RlLkNvbnN0cmFpbnRNaW50R3JvdXBNZW1iZXJQb2ludGVyRXh0ZW5zaW9uLFxuICAgICAgICBcIkEgZ3JvdXAgbWVtYmVyIHBvaW50ZXIgZXh0ZW5zaW9uIGNvbnN0cmFpbnQgd2FzIHZpb2xhdGVkXCIsXG4gICAgXSxcbiAgICBbXG4gICAgICAgIExhbmdFcnJvckNvZGUuQ29uc3RyYWludE1pbnRHcm91cE1lbWJlclBvaW50ZXJFeHRlbnNpb25BdXRob3JpdHksXG4gICAgICAgIFwiQSBncm91cCBtZW1iZXIgcG9pbnRlciBleHRlbnNpb24gYXV0aG9yaXR5IGNvbnN0cmFpbnQgd2FzIHZpb2xhdGVkXCIsXG4gICAgXSxcbiAgICBbXG4gICAgICAgIExhbmdFcnJvckNvZGUuQ29uc3RyYWludE1pbnRHcm91cE1lbWJlclBvaW50ZXJFeHRlbnNpb25NZW1iZXJBZGRyZXNzLFxuICAgICAgICBcIkEgZ3JvdXAgbWVtYmVyIHBvaW50ZXIgZXh0ZW5zaW9uIGdyb3VwIGFkZHJlc3MgY29uc3RyYWludCB3YXMgdmlvbGF0ZWRcIixcbiAgICBdLFxuICAgIFtcbiAgICAgICAgTGFuZ0Vycm9yQ29kZS5Db25zdHJhaW50TWludE1ldGFkYXRhUG9pbnRlckV4dGVuc2lvbixcbiAgICAgICAgXCJBIG1ldGFkYXRhIHBvaW50ZXIgZXh0ZW5zaW9uIGNvbnN0cmFpbnQgd2FzIHZpb2xhdGVkXCIsXG4gICAgXSxcbiAgICBbXG4gICAgICAgIExhbmdFcnJvckNvZGUuQ29uc3RyYWludE1pbnRNZXRhZGF0YVBvaW50ZXJFeHRlbnNpb25BdXRob3JpdHksXG4gICAgICAgIFwiQSBtZXRhZGF0YSBwb2ludGVyIGV4dGVuc2lvbiBhdXRob3JpdHkgY29uc3RyYWludCB3YXMgdmlvbGF0ZWRcIixcbiAgICBdLFxuICAgIFtcbiAgICAgICAgTGFuZ0Vycm9yQ29kZS5Db25zdHJhaW50TWludE1ldGFkYXRhUG9pbnRlckV4dGVuc2lvbk1ldGFkYXRhQWRkcmVzcyxcbiAgICAgICAgXCJBIG1ldGFkYXRhIHBvaW50ZXIgZXh0ZW5zaW9uIG1ldGFkYXRhIGFkZHJlc3MgY29uc3RyYWludCB3YXMgdmlvbGF0ZWRcIixcbiAgICBdLFxuICAgIFtcbiAgICAgICAgTGFuZ0Vycm9yQ29kZS5Db25zdHJhaW50TWludENsb3NlQXV0aG9yaXR5RXh0ZW5zaW9uLFxuICAgICAgICBcIkEgY2xvc2UgYXV0aG9yaXR5IGNvbnN0cmFpbnQgd2FzIHZpb2xhdGVkXCIsXG4gICAgXSxcbiAgICBbXG4gICAgICAgIExhbmdFcnJvckNvZGUuQ29uc3RyYWludE1pbnRDbG9zZUF1dGhvcml0eUV4dGVuc2lvbkF1dGhvcml0eSxcbiAgICAgICAgXCJBIGNsb3NlIGF1dGhvcml0eSBleHRlbnNpb24gYXV0aG9yaXR5IGNvbnN0cmFpbnQgd2FzIHZpb2xhdGVkXCIsXG4gICAgXSxcbiAgICBbXG4gICAgICAgIExhbmdFcnJvckNvZGUuQ29uc3RyYWludE1pbnRQZXJtYW5lbnREZWxlZ2F0ZUV4dGVuc2lvbixcbiAgICAgICAgXCJBIHBlcm1hbmVudCBkZWxlZ2F0ZSBleHRlbnNpb24gY29uc3RyYWludCB3YXMgdmlvbGF0ZWRcIixcbiAgICBdLFxuICAgIFtcbiAgICAgICAgTGFuZ0Vycm9yQ29kZS5Db25zdHJhaW50TWludFBlcm1hbmVudERlbGVnYXRlRXh0ZW5zaW9uRGVsZWdhdGUsXG4gICAgICAgIFwiQSBwZXJtYW5lbnQgZGVsZWdhdGUgZXh0ZW5zaW9uIGRlbGVnYXRlIGNvbnN0cmFpbnQgd2FzIHZpb2xhdGVkXCIsXG4gICAgXSxcbiAgICBbXG4gICAgICAgIExhbmdFcnJvckNvZGUuQ29uc3RyYWludE1pbnRUcmFuc2Zlckhvb2tFeHRlbnNpb24sXG4gICAgICAgIFwiQSB0cmFuc2ZlciBob29rIGV4dGVuc2lvbiBjb25zdHJhaW50IHdhcyB2aW9sYXRlZFwiLFxuICAgIF0sXG4gICAgW1xuICAgICAgICBMYW5nRXJyb3JDb2RlLkNvbnN0cmFpbnRNaW50VHJhbnNmZXJIb29rRXh0ZW5zaW9uQXV0aG9yaXR5LFxuICAgICAgICBcIkEgdHJhbnNmZXIgaG9vayBleHRlbnNpb24gYXV0aG9yaXR5IGNvbnN0cmFpbnQgd2FzIHZpb2xhdGVkXCIsXG4gICAgXSxcbiAgICBbXG4gICAgICAgIExhbmdFcnJvckNvZGUuQ29uc3RyYWludE1pbnRUcmFuc2Zlckhvb2tFeHRlbnNpb25Qcm9ncmFtSWQsXG4gICAgICAgIFwiQSB0cmFuc2ZlciBob29rIGV4dGVuc2lvbiB0cmFuc2ZlciBob29rIHByb2dyYW0gaWQgY29uc3RyYWludCB3YXMgdmlvbGF0ZWRcIixcbiAgICBdLFxuICAgIC8vIFJlcXVpcmUuXG4gICAgW0xhbmdFcnJvckNvZGUuUmVxdWlyZVZpb2xhdGVkLCBcIkEgcmVxdWlyZSBleHByZXNzaW9uIHdhcyB2aW9sYXRlZFwiXSxcbiAgICBbTGFuZ0Vycm9yQ29kZS5SZXF1aXJlRXFWaW9sYXRlZCwgXCJBIHJlcXVpcmVfZXEgZXhwcmVzc2lvbiB3YXMgdmlvbGF0ZWRcIl0sXG4gICAgW1xuICAgICAgICBMYW5nRXJyb3JDb2RlLlJlcXVpcmVLZXlzRXFWaW9sYXRlZCxcbiAgICAgICAgXCJBIHJlcXVpcmVfa2V5c19lcSBleHByZXNzaW9uIHdhcyB2aW9sYXRlZFwiLFxuICAgIF0sXG4gICAgW0xhbmdFcnJvckNvZGUuUmVxdWlyZU5lcVZpb2xhdGVkLCBcIkEgcmVxdWlyZV9uZXEgZXhwcmVzc2lvbiB3YXMgdmlvbGF0ZWRcIl0sXG4gICAgW1xuICAgICAgICBMYW5nRXJyb3JDb2RlLlJlcXVpcmVLZXlzTmVxVmlvbGF0ZWQsXG4gICAgICAgIFwiQSByZXF1aXJlX2tleXNfbmVxIGV4cHJlc3Npb24gd2FzIHZpb2xhdGVkXCIsXG4gICAgXSxcbiAgICBbTGFuZ0Vycm9yQ29kZS5SZXF1aXJlR3RWaW9sYXRlZCwgXCJBIHJlcXVpcmVfZ3QgZXhwcmVzc2lvbiB3YXMgdmlvbGF0ZWRcIl0sXG4gICAgW0xhbmdFcnJvckNvZGUuUmVxdWlyZUd0ZVZpb2xhdGVkLCBcIkEgcmVxdWlyZV9ndGUgZXhwcmVzc2lvbiB3YXMgdmlvbGF0ZWRcIl0sXG4gICAgLy8gQWNjb3VudHMuXG4gICAgW1xuICAgICAgICBMYW5nRXJyb3JDb2RlLkFjY291bnREaXNjcmltaW5hdG9yQWxyZWFkeVNldCxcbiAgICAgICAgXCJUaGUgYWNjb3VudCBkaXNjcmltaW5hdG9yIHdhcyBhbHJlYWR5IHNldCBvbiB0aGlzIGFjY291bnRcIixcbiAgICBdLFxuICAgIFtcbiAgICAgICAgTGFuZ0Vycm9yQ29kZS5BY2NvdW50RGlzY3JpbWluYXRvck5vdEZvdW5kLFxuICAgICAgICBcIk5vIDggYnl0ZSBkaXNjcmltaW5hdG9yIHdhcyBmb3VuZCBvbiB0aGUgYWNjb3VudFwiLFxuICAgIF0sXG4gICAgW1xuICAgICAgICBMYW5nRXJyb3JDb2RlLkFjY291bnREaXNjcmltaW5hdG9yTWlzbWF0Y2gsXG4gICAgICAgIFwiOCBieXRlIGRpc2NyaW1pbmF0b3IgZGlkIG5vdCBtYXRjaCB3aGF0IHdhcyBleHBlY3RlZFwiLFxuICAgIF0sXG4gICAgW0xhbmdFcnJvckNvZGUuQWNjb3VudERpZE5vdERlc2VyaWFsaXplLCBcIkZhaWxlZCB0byBkZXNlcmlhbGl6ZSB0aGUgYWNjb3VudFwiXSxcbiAgICBbTGFuZ0Vycm9yQ29kZS5BY2NvdW50RGlkTm90U2VyaWFsaXplLCBcIkZhaWxlZCB0byBzZXJpYWxpemUgdGhlIGFjY291bnRcIl0sXG4gICAgW1xuICAgICAgICBMYW5nRXJyb3JDb2RlLkFjY291bnROb3RFbm91Z2hLZXlzLFxuICAgICAgICBcIk5vdCBlbm91Z2ggYWNjb3VudCBrZXlzIGdpdmVuIHRvIHRoZSBpbnN0cnVjdGlvblwiLFxuICAgIF0sXG4gICAgW0xhbmdFcnJvckNvZGUuQWNjb3VudE5vdE11dGFibGUsIFwiVGhlIGdpdmVuIGFjY291bnQgaXMgbm90IG11dGFibGVcIl0sXG4gICAgW1xuICAgICAgICBMYW5nRXJyb3JDb2RlLkFjY291bnRPd25lZEJ5V3JvbmdQcm9ncmFtLFxuICAgICAgICBcIlRoZSBnaXZlbiBhY2NvdW50IGlzIG93bmVkIGJ5IGEgZGlmZmVyZW50IHByb2dyYW0gdGhhbiBleHBlY3RlZFwiLFxuICAgIF0sXG4gICAgW0xhbmdFcnJvckNvZGUuSW52YWxpZFByb2dyYW1JZCwgXCJQcm9ncmFtIElEIHdhcyBub3QgYXMgZXhwZWN0ZWRcIl0sXG4gICAgW0xhbmdFcnJvckNvZGUuSW52YWxpZFByb2dyYW1FeGVjdXRhYmxlLCBcIlByb2dyYW0gYWNjb3VudCBpcyBub3QgZXhlY3V0YWJsZVwiXSxcbiAgICBbTGFuZ0Vycm9yQ29kZS5BY2NvdW50Tm90U2lnbmVyLCBcIlRoZSBnaXZlbiBhY2NvdW50IGRpZCBub3Qgc2lnblwiXSxcbiAgICBbXG4gICAgICAgIExhbmdFcnJvckNvZGUuQWNjb3VudE5vdFN5c3RlbU93bmVkLFxuICAgICAgICBcIlRoZSBnaXZlbiBhY2NvdW50IGlzIG5vdCBvd25lZCBieSB0aGUgc3lzdGVtIHByb2dyYW1cIixcbiAgICBdLFxuICAgIFtcbiAgICAgICAgTGFuZ0Vycm9yQ29kZS5BY2NvdW50Tm90SW5pdGlhbGl6ZWQsXG4gICAgICAgIFwiVGhlIHByb2dyYW0gZXhwZWN0ZWQgdGhpcyBhY2NvdW50IHRvIGJlIGFscmVhZHkgaW5pdGlhbGl6ZWRcIixcbiAgICBdLFxuICAgIFtcbiAgICAgICAgTGFuZ0Vycm9yQ29kZS5BY2NvdW50Tm90UHJvZ3JhbURhdGEsXG4gICAgICAgIFwiVGhlIGdpdmVuIGFjY291bnQgaXMgbm90IGEgcHJvZ3JhbSBkYXRhIGFjY291bnRcIixcbiAgICBdLFxuICAgIFtcbiAgICAgICAgTGFuZ0Vycm9yQ29kZS5BY2NvdW50Tm90QXNzb2NpYXRlZFRva2VuQWNjb3VudCxcbiAgICAgICAgXCJUaGUgZ2l2ZW4gYWNjb3VudCBpcyBub3QgdGhlIGFzc29jaWF0ZWQgdG9rZW4gYWNjb3VudFwiLFxuICAgIF0sXG4gICAgW1xuICAgICAgICBMYW5nRXJyb3JDb2RlLkFjY291bnRTeXN2YXJNaXNtYXRjaCxcbiAgICAgICAgXCJUaGUgZ2l2ZW4gcHVibGljIGtleSBkb2VzIG5vdCBtYXRjaCB0aGUgcmVxdWlyZWQgc3lzdmFyXCIsXG4gICAgXSxcbiAgICBbXG4gICAgICAgIExhbmdFcnJvckNvZGUuQWNjb3VudFJlYWxsb2NFeGNlZWRzTGltaXQsXG4gICAgICAgIFwiVGhlIGFjY291bnQgcmVhbGxvY2F0aW9uIGV4Y2VlZHMgdGhlIE1BWF9QRVJNSVRURURfREFUQV9JTkNSRUFTRSBsaW1pdFwiLFxuICAgIF0sXG4gICAgW1xuICAgICAgICBMYW5nRXJyb3JDb2RlLkFjY291bnREdXBsaWNhdGVSZWFsbG9jcyxcbiAgICAgICAgXCJUaGUgYWNjb3VudCB3YXMgZHVwbGljYXRlZCBmb3IgbW9yZSB0aGFuIG9uZSByZWFsbG9jYXRpb25cIixcbiAgICBdLFxuICAgIC8vIE1pc2NlbGxhbmVvdXNcbiAgICBbXG4gICAgICAgIExhbmdFcnJvckNvZGUuRGVjbGFyZWRQcm9ncmFtSWRNaXNtYXRjaCxcbiAgICAgICAgXCJUaGUgZGVjbGFyZWQgcHJvZ3JhbSBpZCBkb2VzIG5vdCBtYXRjaCB0aGUgYWN0dWFsIHByb2dyYW0gaWRcIixcbiAgICBdLFxuICAgIFtcbiAgICAgICAgTGFuZ0Vycm9yQ29kZS5UcnlpbmdUb0luaXRQYXllckFzUHJvZ3JhbUFjY291bnQsXG4gICAgICAgIFwiWW91IGNhbm5vdC9zaG91bGQgbm90IGluaXRpYWxpemUgdGhlIHBheWVyIGFjY291bnQgYXMgYSBwcm9ncmFtIGFjY291bnRcIixcbiAgICBdLFxuICAgIFtcbiAgICAgICAgTGFuZ0Vycm9yQ29kZS5JbnZhbGlkTnVtZXJpY0NvbnZlcnNpb24sXG4gICAgICAgIFwiVGhlIHByb2dyYW0gY291bGQgbm90IHBlcmZvcm0gdGhlIG51bWVyaWMgY29udmVyc2lvbiwgb3V0IG9mIHJhbmdlIGludGVncmFsIHR5cGUgY29udmVyc2lvbiBhdHRlbXB0ZWRcIixcbiAgICBdLFxuICAgIC8vIERlcHJlY2F0ZWRcbiAgICBbXG4gICAgICAgIExhbmdFcnJvckNvZGUuRGVwcmVjYXRlZCxcbiAgICAgICAgXCJUaGUgQVBJIGJlaW5nIHVzZWQgaXMgZGVwcmVjYXRlZCBhbmQgc2hvdWxkIG5vIGxvbmdlciBiZSB1c2VkXCIsXG4gICAgXSxcbl0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3IuanMubWFwIl0sIm5hbWVzIjpbIlB1YmxpY0tleSIsImVycm9ycyIsImZlYXR1cmVzIiwiSWRsRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsIm5hbWUiLCJQcm9ncmFtRXJyb3JTdGFjayIsInN0YWNrIiwicGFyc2UiLCJsb2dzIiwiX2EiLCJwcm9ncmFtS2V5UmVnZXgiLCJzdWNjZXNzUmVnZXgiLCJwcm9ncmFtU3RhY2siLCJpIiwibGVuZ3RoIiwiZXhlYyIsInBvcCIsInByb2dyYW1LZXkiLCJwdXNoIiwiQW5jaG9yRXJyb3IiLCJlcnJvckNvZGUiLCJlcnJvck1lc3NhZ2UiLCJlcnJvckxvZ3MiLCJvcmlnaW4iLCJjb21wYXJlZFZhbHVlcyIsImpvaW4iLCJyZXBsYWNlIiwiZXJyb3IiLCJfcHJvZ3JhbUVycm9yU3RhY2siLCJhbmNob3JFcnJvckxvZ0luZGV4IiwiZmluZEluZGV4IiwibG9nIiwic3RhcnRzV2l0aCIsImFuY2hvckVycm9yTG9nIiwicHVia2V5UmVnZXgiLCJsZWZ0UHVia2V5IiwicmlnaHRQdWJrZXkiLCJzbGljZSIsInZhbHVlUmVnZXgiLCJsZWZ0VmFsdWUiLCJyaWdodFZhbHVlIiwicmVnZXhOb0luZm8iLCJub0luZm9BbmNob3JFcnJvckxvZyIsInJlZ2V4RmlsZUxpbmUiLCJmaWxlTGluZUFuY2hvckVycm9yTG9nIiwicmVnZXhBY2NvdW50TmFtZSIsImFjY291bnROYW1lQW5jaG9yRXJyb3JMb2ciLCJlcnJvckNvZGVTdHJpbmciLCJlcnJvck51bWJlciIsImNvZGUiLCJudW1iZXIiLCJwYXJzZUludCIsInVuZGVmaW5lZCIsImZpbGUiLCJsaW5lIiwiZmlsZUxpbmUiLCJhY2NvdW50TmFtZSIsInByb2dyYW0iLCJwcm9ncmFtRXJyb3JTdGFjayIsInRvU3RyaW5nIiwiUHJvZ3JhbUVycm9yIiwibXNnIiwiZXJyIiwiaWRsRXJyb3JzIiwiZXJyU3RyaW5nIiwidW5wYXJzZWRFcnJvckNvZGUiLCJpbmNsdWRlcyIsImNvbXBvbmVudHMiLCJzcGxpdCIsIm1hdGNoZXMiLCJtYXRjaCIsInBhcnNlRXJyIiwiZXJyb3JNc2ciLCJnZXQiLCJMYW5nRXJyb3JNZXNzYWdlIiwidHJhbnNsYXRlRXJyb3IiLCJpc1NldCIsImNvbnNvbGUiLCJhbmNob3JFcnJvciIsInByb2dyYW1FcnJvciIsImhhbmRsZXIiLCJ0YXJnZXQiLCJwcm9wIiwiUmVmbGVjdCIsImFyZ3VtZW50cyIsIlByb3h5IiwiTGFuZ0Vycm9yQ29kZSIsIkluc3RydWN0aW9uTWlzc2luZyIsIkFOQ0hPUl9FUlJPUl9fSU5TVFJVQ1RJT05fTUlTU0lORyIsIkluc3RydWN0aW9uRmFsbGJhY2tOb3RGb3VuZCIsIkFOQ0hPUl9FUlJPUl9fSU5TVFJVQ1RJT05fRkFMTEJBQ0tfTk9UX0ZPVU5EIiwiSW5zdHJ1Y3Rpb25EaWROb3REZXNlcmlhbGl6ZSIsIkFOQ0hPUl9FUlJPUl9fSU5TVFJVQ1RJT05fRElEX05PVF9ERVNFUklBTElaRSIsIkluc3RydWN0aW9uRGlkTm90U2VyaWFsaXplIiwiQU5DSE9SX0VSUk9SX19JTlNUUlVDVElPTl9ESURfTk9UX1NFUklBTElaRSIsIklkbEluc3RydWN0aW9uU3R1YiIsIkFOQ0hPUl9FUlJPUl9fSURMX0lOU1RSVUNUSU9OX1NUVUIiLCJJZGxJbnN0cnVjdGlvbkludmFsaWRQcm9ncmFtIiwiQU5DSE9SX0VSUk9SX19JRExfSU5TVFJVQ1RJT05fSU5WQUxJRF9QUk9HUkFNIiwiSWRsQWNjb3VudE5vdEVtcHR5IiwiQU5DSE9SX0VSUk9SX19JRExfQUNDT1VOVF9OT1RfRU1QVFkiLCJFdmVudEluc3RydWN0aW9uU3R1YiIsIkFOQ0hPUl9FUlJPUl9fRVZFTlRfSU5TVFJVQ1RJT05fU1RVQiIsIkNvbnN0cmFpbnRNdXQiLCJBTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfTVVUIiwiQ29uc3RyYWludEhhc09uZSIsIkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9IQVNfT05FIiwiQ29uc3RyYWludFNpZ25lciIsIkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9TSUdORVIiLCJDb25zdHJhaW50UmF3IiwiQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX1JBVyIsIkNvbnN0cmFpbnRPd25lciIsIkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9PV05FUiIsIkNvbnN0cmFpbnRSZW50RXhlbXB0IiwiQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX1JFTlRfRVhFTVBUIiwiQ29uc3RyYWludFNlZWRzIiwiQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX1NFRURTIiwiQ29uc3RyYWludEV4ZWN1dGFibGUiLCJBTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfRVhFQ1VUQUJMRSIsIkNvbnN0cmFpbnRTdGF0ZSIsIkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9TVEFURSIsIkNvbnN0cmFpbnRBc3NvY2lhdGVkIiwiQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX0FTU09DSUFURUQiLCJDb25zdHJhaW50QXNzb2NpYXRlZEluaXQiLCJBTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfQVNTT0NJQVRFRF9JTklUIiwiQ29uc3RyYWludENsb3NlIiwiQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX0NMT1NFIiwiQ29uc3RyYWludEFkZHJlc3MiLCJBTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfQUREUkVTUyIsIkNvbnN0cmFpbnRaZXJvIiwiQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX1pFUk8iLCJDb25zdHJhaW50VG9rZW5NaW50IiwiQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX1RPS0VOX01JTlQiLCJDb25zdHJhaW50VG9rZW5Pd25lciIsIkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9UT0tFTl9PV05FUiIsIkNvbnN0cmFpbnRNaW50TWludEF1dGhvcml0eSIsIkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NSU5UX01JTlRfQVVUSE9SSVRZIiwiQ29uc3RyYWludE1pbnRGcmVlemVBdXRob3JpdHkiLCJBTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfTUlOVF9GUkVFWkVfQVVUSE9SSVRZIiwiQ29uc3RyYWludE1pbnREZWNpbWFscyIsIkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NSU5UX0RFQ0lNQUxTIiwiQ29uc3RyYWludFNwYWNlIiwiQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX1NQQUNFIiwiQ29uc3RyYWludEFjY291bnRJc05vbmUiLCJBTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfQUNDT1VOVF9JU19OT05FIiwiQ29uc3RyYWludFRva2VuVG9rZW5Qcm9ncmFtIiwiQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX1RPS0VOX1RPS0VOX1BST0dSQU0iLCJDb25zdHJhaW50TWludFRva2VuUHJvZ3JhbSIsIkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NSU5UX1RPS0VOX1BST0dSQU0iLCJDb25zdHJhaW50QXNzb2NpYXRlZFRva2VuVG9rZW5Qcm9ncmFtIiwiQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX0FTU09DSUFURURfVE9LRU5fVE9LRU5fUFJPR1JBTSIsIkNvbnN0cmFpbnRNaW50R3JvdXBQb2ludGVyRXh0ZW5zaW9uIiwiQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX01JTlRfR1JPVVBfUE9JTlRFUl9FWFRFTlNJT04iLCJDb25zdHJhaW50TWludEdyb3VwUG9pbnRlckV4dGVuc2lvbkF1dGhvcml0eSIsIkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NSU5UX0dST1VQX1BPSU5URVJfRVhURU5TSU9OX0FVVEhPUklUWSIsIkNvbnN0cmFpbnRNaW50R3JvdXBQb2ludGVyRXh0ZW5zaW9uR3JvdXBBZGRyZXNzIiwiQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX01JTlRfR1JPVVBfUE9JTlRFUl9FWFRFTlNJT05fR1JPVVBfQUREUkVTUyIsIkNvbnN0cmFpbnRNaW50R3JvdXBNZW1iZXJQb2ludGVyRXh0ZW5zaW9uIiwiQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX01JTlRfR1JPVVBfTUVNQkVSX1BPSU5URVJfRVhURU5TSU9OIiwiQ29uc3RyYWludE1pbnRHcm91cE1lbWJlclBvaW50ZXJFeHRlbnNpb25BdXRob3JpdHkiLCJBTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfTUlOVF9HUk9VUF9NRU1CRVJfUE9JTlRFUl9FWFRFTlNJT05fQVVUSE9SSVRZIiwiQ29uc3RyYWludE1pbnRHcm91cE1lbWJlclBvaW50ZXJFeHRlbnNpb25NZW1iZXJBZGRyZXNzIiwiQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX01JTlRfR1JPVVBfTUVNQkVSX1BPSU5URVJfRVhURU5TSU9OX01FTUJFUl9BRERSRVNTIiwiQ29uc3RyYWludE1pbnRNZXRhZGF0YVBvaW50ZXJFeHRlbnNpb24iLCJBTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfTUlOVF9NRVRBREFUQV9QT0lOVEVSX0VYVEVOU0lPTiIsIkNvbnN0cmFpbnRNaW50TWV0YWRhdGFQb2ludGVyRXh0ZW5zaW9uQXV0aG9yaXR5IiwiQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX01JTlRfTUVUQURBVEFfUE9JTlRFUl9FWFRFTlNJT05fQVVUSE9SSVRZIiwiQ29uc3RyYWludE1pbnRNZXRhZGF0YVBvaW50ZXJFeHRlbnNpb25NZXRhZGF0YUFkZHJlc3MiLCJBTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfTUlOVF9NRVRBREFUQV9QT0lOVEVSX0VYVEVOU0lPTl9NRVRBREFUQV9BRERSRVNTIiwiQ29uc3RyYWludE1pbnRDbG9zZUF1dGhvcml0eUV4dGVuc2lvbiIsIkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NSU5UX0NMT1NFX0FVVEhPUklUWV9FWFRFTlNJT04iLCJDb25zdHJhaW50TWludENsb3NlQXV0aG9yaXR5RXh0ZW5zaW9uQXV0aG9yaXR5IiwiQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX01JTlRfQ0xPU0VfQVVUSE9SSVRZX0VYVEVOU0lPTl9BVVRIT1JJVFkiLCJDb25zdHJhaW50TWludFBlcm1hbmVudERlbGVnYXRlRXh0ZW5zaW9uIiwiQU5DSE9SX0VSUk9SX19DT05TVFJBSU5UX01JTlRfUEVSTUFORU5UX0RFTEVHQVRFX0VYVEVOU0lPTiIsIkNvbnN0cmFpbnRNaW50UGVybWFuZW50RGVsZWdhdGVFeHRlbnNpb25EZWxlZ2F0ZSIsIkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NSU5UX1BFUk1BTkVOVF9ERUxFR0FURV9FWFRFTlNJT05fREVMRUdBVEUiLCJDb25zdHJhaW50TWludFRyYW5zZmVySG9va0V4dGVuc2lvbiIsIkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NSU5UX1RSQU5TRkVSX0hPT0tfRVhURU5TSU9OIiwiQ29uc3RyYWludE1pbnRUcmFuc2Zlckhvb2tFeHRlbnNpb25BdXRob3JpdHkiLCJBTkNIT1JfRVJST1JfX0NPTlNUUkFJTlRfTUlOVF9UUkFOU0ZFUl9IT09LX0VYVEVOU0lPTl9BVVRIT1JJVFkiLCJDb25zdHJhaW50TWludFRyYW5zZmVySG9va0V4dGVuc2lvblByb2dyYW1JZCIsIkFOQ0hPUl9FUlJPUl9fQ09OU1RSQUlOVF9NSU5UX1RSQU5TRkVSX0hPT0tfRVhURU5TSU9OX1BST0dSQU1fSUQiLCJSZXF1aXJlVmlvbGF0ZWQiLCJBTkNIT1JfRVJST1JfX1JFUVVJUkVfVklPTEFURUQiLCJSZXF1aXJlRXFWaW9sYXRlZCIsIkFOQ0hPUl9FUlJPUl9fUkVRVUlSRV9FUV9WSU9MQVRFRCIsIlJlcXVpcmVLZXlzRXFWaW9sYXRlZCIsIkFOQ0hPUl9FUlJPUl9fUkVRVUlSRV9LRVlTX0VRX1ZJT0xBVEVEIiwiUmVxdWlyZU5lcVZpb2xhdGVkIiwiQU5DSE9SX0VSUk9SX19SRVFVSVJFX05FUV9WSU9MQVRFRCIsIlJlcXVpcmVLZXlzTmVxVmlvbGF0ZWQiLCJBTkNIT1JfRVJST1JfX1JFUVVJUkVfS0VZU19ORVFfVklPTEFURUQiLCJSZXF1aXJlR3RWaW9sYXRlZCIsIkFOQ0hPUl9FUlJPUl9fUkVRVUlSRV9HVF9WSU9MQVRFRCIsIlJlcXVpcmVHdGVWaW9sYXRlZCIsIkFOQ0hPUl9FUlJPUl9fUkVRVUlSRV9HVEVfVklPTEFURUQiLCJBY2NvdW50RGlzY3JpbWluYXRvckFscmVhZHlTZXQiLCJBTkNIT1JfRVJST1JfX0FDQ09VTlRfRElTQ1JJTUlOQVRPUl9BTFJFQURZX1NFVCIsIkFjY291bnREaXNjcmltaW5hdG9yTm90Rm91bmQiLCJBTkNIT1JfRVJST1JfX0FDQ09VTlRfRElTQ1JJTUlOQVRPUl9OT1RfRk9VTkQiLCJBY2NvdW50RGlzY3JpbWluYXRvck1pc21hdGNoIiwiQU5DSE9SX0VSUk9SX19BQ0NPVU5UX0RJU0NSSU1JTkFUT1JfTUlTTUFUQ0giLCJBY2NvdW50RGlkTm90RGVzZXJpYWxpemUiLCJBTkNIT1JfRVJST1JfX0FDQ09VTlRfRElEX05PVF9ERVNFUklBTElaRSIsIkFjY291bnREaWROb3RTZXJpYWxpemUiLCJBTkNIT1JfRVJST1JfX0FDQ09VTlRfRElEX05PVF9TRVJJQUxJWkUiLCJBY2NvdW50Tm90RW5vdWdoS2V5cyIsIkFOQ0hPUl9FUlJPUl9fQUNDT1VOVF9OT1RfRU5PVUdIX0tFWVMiLCJBY2NvdW50Tm90TXV0YWJsZSIsIkFOQ0hPUl9FUlJPUl9fQUNDT1VOVF9OT1RfTVVUQUJMRSIsIkFjY291bnRPd25lZEJ5V3JvbmdQcm9ncmFtIiwiQU5DSE9SX0VSUk9SX19BQ0NPVU5UX09XTkVEX0JZX1dST05HX1BST0dSQU0iLCJJbnZhbGlkUHJvZ3JhbUlkIiwiQU5DSE9SX0VSUk9SX19JTlZBTElEX1BST0dSQU1fSUQiLCJJbnZhbGlkUHJvZ3JhbUV4ZWN1dGFibGUiLCJBTkNIT1JfRVJST1JfX0lOVkFMSURfUFJPR1JBTV9FWEVDVVRBQkxFIiwiQWNjb3VudE5vdFNpZ25lciIsIkFOQ0hPUl9FUlJPUl9fQUNDT1VOVF9OT1RfU0lHTkVSIiwiQWNjb3VudE5vdFN5c3RlbU93bmVkIiwiQU5DSE9SX0VSUk9SX19BQ0NPVU5UX05PVF9TWVNURU1fT1dORUQiLCJBY2NvdW50Tm90SW5pdGlhbGl6ZWQiLCJBTkNIT1JfRVJST1JfX0FDQ09VTlRfTk9UX0lOSVRJQUxJWkVEIiwiQWNjb3VudE5vdFByb2dyYW1EYXRhIiwiQU5DSE9SX0VSUk9SX19BQ0NPVU5UX05PVF9QUk9HUkFNX0RBVEEiLCJBY2NvdW50Tm90QXNzb2NpYXRlZFRva2VuQWNjb3VudCIsIkFOQ0hPUl9FUlJPUl9fQUNDT1VOVF9OT1RfQVNTT0NJQVRFRF9UT0tFTl9BQ0NPVU5UIiwiQWNjb3VudFN5c3Zhck1pc21hdGNoIiwiQU5DSE9SX0VSUk9SX19BQ0NPVU5UX1NZU1ZBUl9NSVNNQVRDSCIsIkFjY291bnRSZWFsbG9jRXhjZWVkc0xpbWl0IiwiQU5DSE9SX0VSUk9SX19BQ0NPVU5UX1JFQUxMT0NfRVhDRUVEU19MSU1JVCIsIkFjY291bnREdXBsaWNhdGVSZWFsbG9jcyIsIkFOQ0hPUl9FUlJPUl9fQUNDT1VOVF9EVVBMSUNBVEVfUkVBTExPQ1MiLCJEZWNsYXJlZFByb2dyYW1JZE1pc21hdGNoIiwiQU5DSE9SX0VSUk9SX19ERUNMQVJFRF9QUk9HUkFNX0lEX01JU01BVENIIiwiVHJ5aW5nVG9Jbml0UGF5ZXJBc1Byb2dyYW1BY2NvdW50IiwiQU5DSE9SX0VSUk9SX19UUllJTkdfVE9fSU5JVF9QQVlFUl9BU19QUk9HUkFNX0FDQ09VTlQiLCJJbnZhbGlkTnVtZXJpY0NvbnZlcnNpb24iLCJBTkNIT1JfRVJST1JfX0lOVkFMSURfTlVNRVJJQ19DT05WRVJTSU9OIiwiRGVwcmVjYXRlZCIsIkFOQ0hPUl9FUlJPUl9fREVQUkVDQVRFRCIsIk1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/error.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/idl.js":
/*!*********************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/idl.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertIdlToCamelCase: () => (/* binding */ convertIdlToCamelCase),\n/* harmony export */   decodeIdlAccount: () => (/* binding */ decodeIdlAccount),\n/* harmony export */   encodeIdlAccount: () => (/* binding */ encodeIdlAccount),\n/* harmony export */   handleDefinedFields: () => (/* binding */ handleDefinedFields),\n/* harmony export */   idlAddress: () => (/* binding */ idlAddress),\n/* harmony export */   isCompositeAccounts: () => (/* binding */ isCompositeAccounts),\n/* harmony export */   seed: () => (/* binding */ seed)\n/* harmony export */ });\n/* harmony import */ var camelcase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! camelcase */ \"(ssr)/../node_modules/camelcase/index.js\");\n/* harmony import */ var camelcase__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(camelcase__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(buffer__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/node_modules/@solana/web3.js/lib/index.esm.js\");\n/* harmony import */ var _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @coral-xyz/borsh */ \"(ssr)/../node_modules/@coral-xyz/anchor/node_modules/@coral-xyz/borsh/dist/index.js\");\n/* harmony import */ var _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\nfunction isCompositeAccounts(accountItem) {\n    return \"accounts\" in accountItem;\n}\n// Deterministic IDL address as a function of the program id.\nasync function idlAddress(programId) {\n    const base = (await _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.PublicKey.findProgramAddress([], programId))[0];\n    return await _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.PublicKey.createWithSeed(base, seed(), programId);\n}\n// Seed for generating the idlAddress.\nfunction seed() {\n    return \"anchor:idl\";\n}\nconst IDL_ACCOUNT_LAYOUT = _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_3__.struct([\n    _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_3__.publicKey(\"authority\"),\n    _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_3__.vecU8(\"data\")\n]);\nfunction decodeIdlAccount(data) {\n    return IDL_ACCOUNT_LAYOUT.decode(data);\n}\nfunction encodeIdlAccount(acc) {\n    const buffer = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.alloc(1000); // TODO: use a tighter buffer.\n    const len = IDL_ACCOUNT_LAYOUT.encode(acc, buffer);\n    return buffer.slice(0, len);\n}\n/**\n * Convert the given IDL to camelCase.\n *\n * The IDL is generated from Rust which has different conventions compared to\n * JS/TS, e.g. instruction names in Rust are snake_case.\n *\n * The conversion happens automatically for programs, however, if you are using\n * internals such as `BorshInstructionCoder` and you only have the original\n * (not camelCase) IDL, you might need to use this function.\n *\n * @param idl IDL to convert to camelCase\n * @returns camelCase version of the IDL\n */ function convertIdlToCamelCase(idl) {\n    const KEYS_TO_CONVERT = [\n        \"name\",\n        \"path\",\n        \"account\",\n        \"relations\",\n        \"generic\"\n    ];\n    // `my_account.field` is getting converted to `myAccountField` but we\n    // need `myAccount.field`.\n    const toCamelCase = (s)=>s.split(\".\").map((camelcase__WEBPACK_IMPORTED_MODULE_0___default())).join(\".\");\n    const recursivelyConvertNamesToCamelCase = (obj)=>{\n        for(const key in obj){\n            const val = obj[key];\n            if (KEYS_TO_CONVERT.includes(key)) {\n                obj[key] = Array.isArray(val) ? val.map(toCamelCase) : toCamelCase(val);\n            } else if (typeof val === \"object\") {\n                recursivelyConvertNamesToCamelCase(val);\n            }\n        }\n    };\n    const camelCasedIdl = structuredClone(idl);\n    recursivelyConvertNamesToCamelCase(camelCasedIdl);\n    return camelCasedIdl;\n}\n/** Conveniently handle all defined field kinds with proper type support. */ function handleDefinedFields(fields, unitCb, namedCb, tupleCb) {\n    // Unit\n    if (!(fields === null || fields === void 0 ? void 0 : fields.length)) return unitCb();\n    // Named\n    if (fields[0].name) {\n        return namedCb(fields);\n    }\n    // Tuple\n    return tupleCb(fields);\n} //# sourceMappingURL=idl.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL2lkbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFrQztBQUNGO0FBQ1k7QUFDRjtBQUNuQyxTQUFTSSxvQkFBb0JDLFdBQVc7SUFDM0MsT0FBTyxjQUFjQTtBQUN6QjtBQUNBLDZEQUE2RDtBQUN0RCxlQUFlQyxXQUFXQyxTQUFTO0lBQ3RDLE1BQU1DLE9BQU8sQ0FBQyxNQUFNTixzREFBU0EsQ0FBQ08sa0JBQWtCLENBQUMsRUFBRSxFQUFFRixVQUFTLENBQUUsQ0FBQyxFQUFFO0lBQ25FLE9BQU8sTUFBTUwsc0RBQVNBLENBQUNRLGNBQWMsQ0FBQ0YsTUFBTUcsUUFBUUo7QUFDeEQ7QUFDQSxzQ0FBc0M7QUFDL0IsU0FBU0k7SUFDWixPQUFPO0FBQ1g7QUFDQSxNQUFNQyxxQkFBcUJULG9EQUFZLENBQUM7SUFDcENBLHVEQUFlLENBQUM7SUFDaEJBLG1EQUFXLENBQUM7Q0FDZjtBQUNNLFNBQVNhLGlCQUFpQkMsSUFBSTtJQUNqQyxPQUFPTCxtQkFBbUJNLE1BQU0sQ0FBQ0Q7QUFDckM7QUFDTyxTQUFTRSxpQkFBaUJDLEdBQUc7SUFDaEMsTUFBTUMsU0FBU3BCLDBDQUFNQSxDQUFDcUIsS0FBSyxDQUFDLE9BQU8sOEJBQThCO0lBQ2pFLE1BQU1DLE1BQU1YLG1CQUFtQlksTUFBTSxDQUFDSixLQUFLQztJQUMzQyxPQUFPQSxPQUFPSSxLQUFLLENBQUMsR0FBR0Y7QUFDM0I7QUFDQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDTSxTQUFTRyxzQkFBc0JDLEdBQUc7SUFDckMsTUFBTUMsa0JBQWtCO1FBQUM7UUFBUTtRQUFRO1FBQVc7UUFBYTtLQUFVO0lBQzNFLHFFQUFxRTtJQUNyRSwwQkFBMEI7SUFDMUIsTUFBTUMsY0FBYyxDQUFDQyxJQUFNQSxFQUFFQyxLQUFLLENBQUMsS0FBS0MsR0FBRyxDQUFDaEMsa0RBQVNBLEVBQUVpQyxJQUFJLENBQUM7SUFDNUQsTUFBTUMscUNBQXFDLENBQUNDO1FBQ3hDLElBQUssTUFBTUMsT0FBT0QsSUFBSztZQUNuQixNQUFNRSxNQUFNRixHQUFHLENBQUNDLElBQUk7WUFDcEIsSUFBSVIsZ0JBQWdCVSxRQUFRLENBQUNGLE1BQU07Z0JBQy9CRCxHQUFHLENBQUNDLElBQUksR0FBR0csTUFBTUMsT0FBTyxDQUFDSCxPQUFPQSxJQUFJTCxHQUFHLENBQUNILGVBQWVBLFlBQVlRO1lBQ3ZFLE9BQ0ssSUFBSSxPQUFPQSxRQUFRLFVBQVU7Z0JBQzlCSCxtQ0FBbUNHO1lBQ3ZDO1FBQ0o7SUFDSjtJQUNBLE1BQU1JLGdCQUFnQkMsZ0JBQWdCZjtJQUN0Q08sbUNBQW1DTztJQUNuQyxPQUFPQTtBQUNYO0FBQ0EsMEVBQTBFLEdBQ25FLFNBQVNFLG9CQUFvQkMsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsT0FBTztJQUNoRSxPQUFPO0lBQ1AsSUFBSSxDQUFFSCxDQUFBQSxXQUFXLFFBQVFBLFdBQVcsS0FBSyxJQUFJLEtBQUssSUFBSUEsT0FBT0ksTUFBTSxHQUMvRCxPQUFPSDtJQUNYLFFBQVE7SUFDUixJQUFJRCxNQUFNLENBQUMsRUFBRSxDQUFDSyxJQUFJLEVBQUU7UUFDaEIsT0FBT0gsUUFBUUY7SUFDbkI7SUFDQSxRQUFRO0lBQ1IsT0FBT0csUUFBUUg7QUFDbkIsRUFDQSwrQkFBK0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL2lkbC5qcz82M2I0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjYW1lbENhc2UgZnJvbSBcImNhbWVsY2FzZVwiO1xuaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSBcImJ1ZmZlclwiO1xuaW1wb3J0IHsgUHVibGljS2V5IH0gZnJvbSBcIkBzb2xhbmEvd2ViMy5qc1wiO1xuaW1wb3J0ICogYXMgYm9yc2ggZnJvbSBcIkBjb3JhbC14eXovYm9yc2hcIjtcbmV4cG9ydCBmdW5jdGlvbiBpc0NvbXBvc2l0ZUFjY291bnRzKGFjY291bnRJdGVtKSB7XG4gICAgcmV0dXJuIFwiYWNjb3VudHNcIiBpbiBhY2NvdW50SXRlbTtcbn1cbi8vIERldGVybWluaXN0aWMgSURMIGFkZHJlc3MgYXMgYSBmdW5jdGlvbiBvZiB0aGUgcHJvZ3JhbSBpZC5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpZGxBZGRyZXNzKHByb2dyYW1JZCkge1xuICAgIGNvbnN0IGJhc2UgPSAoYXdhaXQgUHVibGljS2V5LmZpbmRQcm9ncmFtQWRkcmVzcyhbXSwgcHJvZ3JhbUlkKSlbMF07XG4gICAgcmV0dXJuIGF3YWl0IFB1YmxpY0tleS5jcmVhdGVXaXRoU2VlZChiYXNlLCBzZWVkKCksIHByb2dyYW1JZCk7XG59XG4vLyBTZWVkIGZvciBnZW5lcmF0aW5nIHRoZSBpZGxBZGRyZXNzLlxuZXhwb3J0IGZ1bmN0aW9uIHNlZWQoKSB7XG4gICAgcmV0dXJuIFwiYW5jaG9yOmlkbFwiO1xufVxuY29uc3QgSURMX0FDQ09VTlRfTEFZT1VUID0gYm9yc2guc3RydWN0KFtcbiAgICBib3JzaC5wdWJsaWNLZXkoXCJhdXRob3JpdHlcIiksXG4gICAgYm9yc2gudmVjVTgoXCJkYXRhXCIpLFxuXSk7XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlSWRsQWNjb3VudChkYXRhKSB7XG4gICAgcmV0dXJuIElETF9BQ0NPVU5UX0xBWU9VVC5kZWNvZGUoZGF0YSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlSWRsQWNjb3VudChhY2MpIHtcbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTAwMCk7IC8vIFRPRE86IHVzZSBhIHRpZ2h0ZXIgYnVmZmVyLlxuICAgIGNvbnN0IGxlbiA9IElETF9BQ0NPVU5UX0xBWU9VVC5lbmNvZGUoYWNjLCBidWZmZXIpO1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoMCwgbGVuKTtcbn1cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gSURMIHRvIGNhbWVsQ2FzZS5cbiAqXG4gKiBUaGUgSURMIGlzIGdlbmVyYXRlZCBmcm9tIFJ1c3Qgd2hpY2ggaGFzIGRpZmZlcmVudCBjb252ZW50aW9ucyBjb21wYXJlZCB0b1xuICogSlMvVFMsIGUuZy4gaW5zdHJ1Y3Rpb24gbmFtZXMgaW4gUnVzdCBhcmUgc25ha2VfY2FzZS5cbiAqXG4gKiBUaGUgY29udmVyc2lvbiBoYXBwZW5zIGF1dG9tYXRpY2FsbHkgZm9yIHByb2dyYW1zLCBob3dldmVyLCBpZiB5b3UgYXJlIHVzaW5nXG4gKiBpbnRlcm5hbHMgc3VjaCBhcyBgQm9yc2hJbnN0cnVjdGlvbkNvZGVyYCBhbmQgeW91IG9ubHkgaGF2ZSB0aGUgb3JpZ2luYWxcbiAqIChub3QgY2FtZWxDYXNlKSBJREwsIHlvdSBtaWdodCBuZWVkIHRvIHVzZSB0aGlzIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSBpZGwgSURMIHRvIGNvbnZlcnQgdG8gY2FtZWxDYXNlXG4gKiBAcmV0dXJucyBjYW1lbENhc2UgdmVyc2lvbiBvZiB0aGUgSURMXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0SWRsVG9DYW1lbENhc2UoaWRsKSB7XG4gICAgY29uc3QgS0VZU19UT19DT05WRVJUID0gW1wibmFtZVwiLCBcInBhdGhcIiwgXCJhY2NvdW50XCIsIFwicmVsYXRpb25zXCIsIFwiZ2VuZXJpY1wiXTtcbiAgICAvLyBgbXlfYWNjb3VudC5maWVsZGAgaXMgZ2V0dGluZyBjb252ZXJ0ZWQgdG8gYG15QWNjb3VudEZpZWxkYCBidXQgd2VcbiAgICAvLyBuZWVkIGBteUFjY291bnQuZmllbGRgLlxuICAgIGNvbnN0IHRvQ2FtZWxDYXNlID0gKHMpID0+IHMuc3BsaXQoXCIuXCIpLm1hcChjYW1lbENhc2UpLmpvaW4oXCIuXCIpO1xuICAgIGNvbnN0IHJlY3Vyc2l2ZWx5Q29udmVydE5hbWVzVG9DYW1lbENhc2UgPSAob2JqKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgICAgICAgY29uc3QgdmFsID0gb2JqW2tleV07XG4gICAgICAgICAgICBpZiAoS0VZU19UT19DT05WRVJULmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IEFycmF5LmlzQXJyYXkodmFsKSA/IHZhbC5tYXAodG9DYW1lbENhc2UpIDogdG9DYW1lbENhc2UodmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICByZWN1cnNpdmVseUNvbnZlcnROYW1lc1RvQ2FtZWxDYXNlKHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGNhbWVsQ2FzZWRJZGwgPSBzdHJ1Y3R1cmVkQ2xvbmUoaWRsKTtcbiAgICByZWN1cnNpdmVseUNvbnZlcnROYW1lc1RvQ2FtZWxDYXNlKGNhbWVsQ2FzZWRJZGwpO1xuICAgIHJldHVybiBjYW1lbENhc2VkSWRsO1xufVxuLyoqIENvbnZlbmllbnRseSBoYW5kbGUgYWxsIGRlZmluZWQgZmllbGQga2luZHMgd2l0aCBwcm9wZXIgdHlwZSBzdXBwb3J0LiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZURlZmluZWRGaWVsZHMoZmllbGRzLCB1bml0Q2IsIG5hbWVkQ2IsIHR1cGxlQ2IpIHtcbiAgICAvLyBVbml0XG4gICAgaWYgKCEoZmllbGRzID09PSBudWxsIHx8IGZpZWxkcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmllbGRzLmxlbmd0aCkpXG4gICAgICAgIHJldHVybiB1bml0Q2IoKTtcbiAgICAvLyBOYW1lZFxuICAgIGlmIChmaWVsZHNbMF0ubmFtZSkge1xuICAgICAgICByZXR1cm4gbmFtZWRDYihmaWVsZHMpO1xuICAgIH1cbiAgICAvLyBUdXBsZVxuICAgIHJldHVybiB0dXBsZUNiKGZpZWxkcyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pZGwuanMubWFwIl0sIm5hbWVzIjpbImNhbWVsQ2FzZSIsIkJ1ZmZlciIsIlB1YmxpY0tleSIsImJvcnNoIiwiaXNDb21wb3NpdGVBY2NvdW50cyIsImFjY291bnRJdGVtIiwiaWRsQWRkcmVzcyIsInByb2dyYW1JZCIsImJhc2UiLCJmaW5kUHJvZ3JhbUFkZHJlc3MiLCJjcmVhdGVXaXRoU2VlZCIsInNlZWQiLCJJRExfQUNDT1VOVF9MQVlPVVQiLCJzdHJ1Y3QiLCJwdWJsaWNLZXkiLCJ2ZWNVOCIsImRlY29kZUlkbEFjY291bnQiLCJkYXRhIiwiZGVjb2RlIiwiZW5jb2RlSWRsQWNjb3VudCIsImFjYyIsImJ1ZmZlciIsImFsbG9jIiwibGVuIiwiZW5jb2RlIiwic2xpY2UiLCJjb252ZXJ0SWRsVG9DYW1lbENhc2UiLCJpZGwiLCJLRVlTX1RPX0NPTlZFUlQiLCJ0b0NhbWVsQ2FzZSIsInMiLCJzcGxpdCIsIm1hcCIsImpvaW4iLCJyZWN1cnNpdmVseUNvbnZlcnROYW1lc1RvQ2FtZWxDYXNlIiwib2JqIiwia2V5IiwidmFsIiwiaW5jbHVkZXMiLCJBcnJheSIsImlzQXJyYXkiLCJjYW1lbENhc2VkSWRsIiwic3RydWN0dXJlZENsb25lIiwiaGFuZGxlRGVmaW5lZEZpZWxkcyIsImZpZWxkcyIsInVuaXRDYiIsIm5hbWVkQ2IiLCJ0dXBsZUNiIiwibGVuZ3RoIiwibmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/idl.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/index.js":
/*!***********************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AccountClient: () => (/* reexport safe */ _program_index_js__WEBPACK_IMPORTED_MODULE_8__.AccountClient),\n/* harmony export */   AnchorError: () => (/* reexport safe */ _error_js__WEBPACK_IMPORTED_MODULE_5__.AnchorError),\n/* harmony export */   AnchorProvider: () => (/* reexport safe */ _provider_js__WEBPACK_IMPORTED_MODULE_4__.AnchorProvider),\n/* harmony export */   BN: () => (/* reexport default from dynamic */ bn_js__WEBPACK_IMPORTED_MODULE_2___default.a),\n/* harmony export */   BorshAccountsCoder: () => (/* reexport safe */ _coder_index_js__WEBPACK_IMPORTED_MODULE_6__.BorshAccountsCoder),\n/* harmony export */   BorshCoder: () => (/* reexport safe */ _coder_index_js__WEBPACK_IMPORTED_MODULE_6__.BorshCoder),\n/* harmony export */   BorshEventCoder: () => (/* reexport safe */ _coder_index_js__WEBPACK_IMPORTED_MODULE_6__.BorshEventCoder),\n/* harmony export */   BorshInstructionCoder: () => (/* reexport safe */ _coder_index_js__WEBPACK_IMPORTED_MODULE_6__.BorshInstructionCoder),\n/* harmony export */   DISCRIMINATOR_SIZE: () => (/* reexport safe */ _coder_index_js__WEBPACK_IMPORTED_MODULE_6__.DISCRIMINATOR_SIZE),\n/* harmony export */   EventManager: () => (/* reexport safe */ _program_index_js__WEBPACK_IMPORTED_MODULE_8__.EventManager),\n/* harmony export */   EventParser: () => (/* reexport safe */ _program_index_js__WEBPACK_IMPORTED_MODULE_8__.EventParser),\n/* harmony export */   IdlError: () => (/* reexport safe */ _error_js__WEBPACK_IMPORTED_MODULE_5__.IdlError),\n/* harmony export */   LangErrorCode: () => (/* reexport safe */ _error_js__WEBPACK_IMPORTED_MODULE_5__.LangErrorCode),\n/* harmony export */   LangErrorMessage: () => (/* reexport safe */ _error_js__WEBPACK_IMPORTED_MODULE_5__.LangErrorMessage),\n/* harmony export */   MethodsBuilderFactory: () => (/* reexport safe */ _program_index_js__WEBPACK_IMPORTED_MODULE_8__.MethodsBuilderFactory),\n/* harmony export */   Native: () => (/* reexport safe */ _native_index_js__WEBPACK_IMPORTED_MODULE_9__.Native),\n/* harmony export */   Program: () => (/* reexport safe */ _program_index_js__WEBPACK_IMPORTED_MODULE_8__.Program),\n/* harmony export */   ProgramError: () => (/* reexport safe */ _error_js__WEBPACK_IMPORTED_MODULE_5__.ProgramError),\n/* harmony export */   ProgramErrorStack: () => (/* reexport safe */ _error_js__WEBPACK_IMPORTED_MODULE_5__.ProgramErrorStack),\n/* harmony export */   SystemCoder: () => (/* reexport safe */ _coder_index_js__WEBPACK_IMPORTED_MODULE_6__.SystemCoder),\n/* harmony export */   getProvider: () => (/* reexport safe */ _provider_js__WEBPACK_IMPORTED_MODULE_4__.getProvider),\n/* harmony export */   parseIdlErrors: () => (/* reexport safe */ _program_index_js__WEBPACK_IMPORTED_MODULE_8__.parseIdlErrors),\n/* harmony export */   setProvider: () => (/* reexport safe */ _provider_js__WEBPACK_IMPORTED_MODULE_4__.setProvider),\n/* harmony export */   splitArgsAndCtx: () => (/* reexport safe */ _program_index_js__WEBPACK_IMPORTED_MODULE_8__.splitArgsAndCtx),\n/* harmony export */   toInstruction: () => (/* reexport safe */ _program_index_js__WEBPACK_IMPORTED_MODULE_8__.toInstruction),\n/* harmony export */   translateAddress: () => (/* reexport safe */ _program_index_js__WEBPACK_IMPORTED_MODULE_8__.translateAddress),\n/* harmony export */   translateError: () => (/* reexport safe */ _error_js__WEBPACK_IMPORTED_MODULE_5__.translateError),\n/* harmony export */   utils: () => (/* reexport module object */ _utils_index_js__WEBPACK_IMPORTED_MODULE_7__),\n/* harmony export */   validateAccounts: () => (/* reexport safe */ _program_index_js__WEBPACK_IMPORTED_MODULE_8__.validateAccounts),\n/* harmony export */   web3: () => (/* reexport module object */ _solana_web3_js__WEBPACK_IMPORTED_MODULE_3__)\n/* harmony export */ });\n/* harmony import */ var _nodewallet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nodewallet */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/nodewallet.js\");\n/* harmony import */ var _utils_common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/common.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/common.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bn.js */ \"(ssr)/../node_modules/bn.js/lib/bn.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(bn_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/node_modules/@solana/web3.js/lib/index.esm.js\");\n/* harmony import */ var _provider_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./provider.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/provider.js\");\n/* harmony import */ var _error_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./error.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/error.js\");\n/* harmony import */ var _coder_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./coder/index.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/index.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/index.js\");\n/* harmony import */ var _program_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./program/index.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/index.js\");\n/* harmony import */ var _native_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./native/index.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/native/index.js\");\n\n\n\n\n\n\n\n\n\n\nif (!_utils_common_js__WEBPACK_IMPORTED_MODULE_1__.isBrowser) {\n    exports.workspace = (__webpack_require__(/*! ./workspace.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/workspace.js\")[\"default\"]);\n    exports.Wallet = (__webpack_require__(/*! ./nodewallet.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/nodewallet.js\")[\"default\"]);\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXNDO0FBQ1E7QUFDUjtBQUNFO0FBQ2tDO0FBQy9DO0FBQ007QUFDUztBQUNQO0FBQ0Q7QUFDbEMsSUFBSSxDQUFDQyx1REFBU0EsRUFBRTtJQUNaUSxRQUFRQyxTQUFTLEdBQUdDLHVIQUFpQztJQUNyREYsUUFBUUcsTUFBTSxHQUFHRCx5SEFBa0M7QUFDdkQsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL2luZGV4LmpzPzhmYzkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE5vZGVXYWxsZXQgZnJvbSBcIi4vbm9kZXdhbGxldFwiO1xuaW1wb3J0IHsgaXNCcm93c2VyIH0gZnJvbSBcIi4vdXRpbHMvY29tbW9uLmpzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEJOIH0gZnJvbSBcImJuLmpzXCI7XG5leHBvcnQgKiBhcyB3ZWIzIGZyb20gXCJAc29sYW5hL3dlYjMuanNcIjtcbmV4cG9ydCB7IGdldFByb3ZpZGVyLCBzZXRQcm92aWRlciwgQW5jaG9yUHJvdmlkZXIsIH0gZnJvbSBcIi4vcHJvdmlkZXIuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2Vycm9yLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9jb2Rlci9pbmRleC5qc1wiO1xuZXhwb3J0ICogYXMgdXRpbHMgZnJvbSBcIi4vdXRpbHMvaW5kZXguanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3Byb2dyYW0vaW5kZXguanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL25hdGl2ZS9pbmRleC5qc1wiO1xuaWYgKCFpc0Jyb3dzZXIpIHtcbiAgICBleHBvcnRzLndvcmtzcGFjZSA9IHJlcXVpcmUoXCIuL3dvcmtzcGFjZS5qc1wiKS5kZWZhdWx0O1xuICAgIGV4cG9ydHMuV2FsbGV0ID0gcmVxdWlyZShcIi4vbm9kZXdhbGxldC5qc1wiKS5kZWZhdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIk5vZGVXYWxsZXQiLCJpc0Jyb3dzZXIiLCJkZWZhdWx0IiwiQk4iLCJ3ZWIzIiwiZ2V0UHJvdmlkZXIiLCJzZXRQcm92aWRlciIsIkFuY2hvclByb3ZpZGVyIiwidXRpbHMiLCJleHBvcnRzIiwid29ya3NwYWNlIiwicmVxdWlyZSIsIldhbGxldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/native/index.js":
/*!******************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/native/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Native: () => (/* binding */ Native)\n/* harmony export */ });\n/* harmony import */ var _system_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./system.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/native/system.js\");\n\nclass Native {\n    static system(provider) {\n        return (0,_system_js__WEBPACK_IMPORTED_MODULE_0__.program)(provider);\n    }\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL25hdGl2ZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF1RDtBQUNoRCxNQUFNRTtJQUNULE9BQU9DLE9BQU9DLFFBQVEsRUFBRTtRQUNwQixPQUFPSCxtREFBYUEsQ0FBQ0c7SUFDekI7QUFDSixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGNvcmFsLXh5ei9hbmNob3IvZGlzdC9lc20vbmF0aXZlL2luZGV4LmpzPzE0ZGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcHJvZ3JhbSBhcyBzeXN0ZW1Qcm9ncmFtIH0gZnJvbSBcIi4vc3lzdGVtLmpzXCI7XG5leHBvcnQgY2xhc3MgTmF0aXZlIHtcbiAgICBzdGF0aWMgc3lzdGVtKHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBzeXN0ZW1Qcm9ncmFtKHByb3ZpZGVyKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsicHJvZ3JhbSIsInN5c3RlbVByb2dyYW0iLCJOYXRpdmUiLCJzeXN0ZW0iLCJwcm92aWRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/native/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/native/system.js":
/*!*******************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/native/system.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IDL: () => (/* binding */ IDL),\n/* harmony export */   SYSTEM_PROGRAM_ID: () => (/* binding */ SYSTEM_PROGRAM_ID),\n/* harmony export */   coder: () => (/* binding */ coder),\n/* harmony export */   program: () => (/* binding */ program)\n/* harmony export */ });\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/node_modules/@solana/web3.js/lib/index.esm.js\");\n/* harmony import */ var _program_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../program/index.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/index.js\");\n/* harmony import */ var _coder_system_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../coder/system/index.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/system/index.js\");\n\n\n\nconst SYSTEM_PROGRAM_ID = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(\"11111111111111111111111111111111\");\nfunction program(provider) {\n    return new _program_index_js__WEBPACK_IMPORTED_MODULE_1__.Program(IDL, provider, coder());\n}\nfunction coder() {\n    return new _coder_system_index_js__WEBPACK_IMPORTED_MODULE_2__.SystemCoder(IDL);\n}\nconst IDL = {\n    address: \"11111111111111111111111111111111\",\n    metadata: {\n        name: \"systemProgram\",\n        version: \"0.1.0\",\n        spec: \"0.1.0\"\n    },\n    instructions: [\n        {\n            name: \"advanceNonceAccount\",\n            discriminator: [\n                4,\n                0,\n                0,\n                0\n            ],\n            accounts: [\n                {\n                    name: \"nonce\",\n                    writable: true\n                },\n                {\n                    name: \"recentBlockhashes\"\n                },\n                {\n                    name: \"authorized\",\n                    signer: true\n                }\n            ],\n            args: [\n                {\n                    name: \"authorized\",\n                    type: \"pubkey\"\n                }\n            ]\n        },\n        {\n            name: \"allocate\",\n            discriminator: [\n                8,\n                0,\n                0,\n                0\n            ],\n            accounts: [\n                {\n                    name: \"pubkey\",\n                    writable: true,\n                    signer: true\n                }\n            ],\n            args: [\n                {\n                    name: \"space\",\n                    type: \"u64\"\n                }\n            ]\n        },\n        {\n            name: \"allocateWithSeed\",\n            discriminator: [\n                9,\n                0,\n                0,\n                0\n            ],\n            accounts: [\n                {\n                    name: \"account\",\n                    writable: true\n                },\n                {\n                    name: \"base\",\n                    signer: true\n                }\n            ],\n            args: [\n                {\n                    name: \"base\",\n                    type: \"pubkey\"\n                },\n                {\n                    name: \"seed\",\n                    type: \"string\"\n                },\n                {\n                    name: \"space\",\n                    type: \"u64\"\n                },\n                {\n                    name: \"owner\",\n                    type: \"pubkey\"\n                }\n            ]\n        },\n        {\n            name: \"assign\",\n            discriminator: [\n                1,\n                0,\n                0,\n                0\n            ],\n            accounts: [\n                {\n                    name: \"pubkey\",\n                    writable: true,\n                    signer: true\n                }\n            ],\n            args: [\n                {\n                    name: \"owner\",\n                    type: \"pubkey\"\n                }\n            ]\n        },\n        {\n            name: \"assignWithSeed\",\n            discriminator: [\n                10,\n                0,\n                0,\n                0\n            ],\n            accounts: [\n                {\n                    name: \"account\",\n                    writable: true\n                },\n                {\n                    name: \"base\",\n                    signer: true\n                }\n            ],\n            args: [\n                {\n                    name: \"base\",\n                    type: \"pubkey\"\n                },\n                {\n                    name: \"seed\",\n                    type: \"string\"\n                },\n                {\n                    name: \"owner\",\n                    type: \"pubkey\"\n                }\n            ]\n        },\n        {\n            name: \"authorizeNonceAccount\",\n            discriminator: [\n                7,\n                0,\n                0,\n                0\n            ],\n            accounts: [\n                {\n                    name: \"nonce\",\n                    writable: true\n                },\n                {\n                    name: \"authorized\",\n                    signer: true\n                }\n            ],\n            args: [\n                {\n                    name: \"authorized\",\n                    type: \"pubkey\"\n                }\n            ]\n        },\n        {\n            name: \"createAccount\",\n            discriminator: [\n                0,\n                0,\n                0,\n                0\n            ],\n            accounts: [\n                {\n                    name: \"from\",\n                    writable: true,\n                    signer: true\n                },\n                {\n                    name: \"to\",\n                    writable: true,\n                    signer: true\n                }\n            ],\n            args: [\n                {\n                    name: \"lamports\",\n                    type: \"u64\"\n                },\n                {\n                    name: \"space\",\n                    type: \"u64\"\n                },\n                {\n                    name: \"owner\",\n                    type: \"pubkey\"\n                }\n            ]\n        },\n        {\n            name: \"createAccountWithSeed\",\n            discriminator: [\n                3,\n                0,\n                0,\n                0\n            ],\n            accounts: [\n                {\n                    name: \"from\",\n                    writable: true,\n                    signer: true\n                },\n                {\n                    name: \"to\",\n                    writable: true\n                },\n                {\n                    name: \"base\",\n                    signer: true\n                }\n            ],\n            args: [\n                {\n                    name: \"base\",\n                    type: \"pubkey\"\n                },\n                {\n                    name: \"seed\",\n                    type: \"string\"\n                },\n                {\n                    name: \"lamports\",\n                    type: \"u64\"\n                },\n                {\n                    name: \"space\",\n                    type: \"u64\"\n                },\n                {\n                    name: \"owner\",\n                    type: \"pubkey\"\n                }\n            ]\n        },\n        {\n            name: \"initializeNonceAccount\",\n            discriminator: [\n                6,\n                0,\n                0,\n                0\n            ],\n            accounts: [\n                {\n                    name: \"nonce\",\n                    writable: true,\n                    signer: true\n                },\n                {\n                    name: \"recentBlockhashes\"\n                },\n                {\n                    name: \"rent\",\n                    address: \"SysvarRent111111111111111111111111111111111\"\n                }\n            ],\n            args: [\n                {\n                    name: \"authorized\",\n                    type: \"pubkey\"\n                }\n            ]\n        },\n        {\n            name: \"transfer\",\n            discriminator: [\n                2,\n                0,\n                0,\n                0\n            ],\n            accounts: [\n                {\n                    name: \"from\",\n                    writable: true,\n                    signer: true\n                },\n                {\n                    name: \"to\",\n                    writable: true\n                }\n            ],\n            args: [\n                {\n                    name: \"lamports\",\n                    type: \"u64\"\n                }\n            ]\n        },\n        {\n            name: \"transferWithSeed\",\n            discriminator: [\n                11,\n                0,\n                0,\n                0\n            ],\n            accounts: [\n                {\n                    name: \"from\",\n                    writable: true\n                },\n                {\n                    name: \"base\",\n                    signer: true\n                },\n                {\n                    name: \"to\",\n                    writable: true\n                }\n            ],\n            args: [\n                {\n                    name: \"lamports\",\n                    type: \"u64\"\n                },\n                {\n                    name: \"seed\",\n                    type: \"string\"\n                },\n                {\n                    name: \"owner\",\n                    type: \"pubkey\"\n                }\n            ]\n        },\n        {\n            name: \"withdrawNonceAccount\",\n            discriminator: [\n                5,\n                0,\n                0,\n                0\n            ],\n            accounts: [\n                {\n                    name: \"nonce\",\n                    writable: true\n                },\n                {\n                    name: \"to\",\n                    writable: true\n                },\n                {\n                    name: \"recentBlockhashes\"\n                },\n                {\n                    name: \"rent\",\n                    address: \"SysvarRent111111111111111111111111111111111\"\n                },\n                {\n                    name: \"authorized\",\n                    signer: true\n                }\n            ],\n            args: [\n                {\n                    name: \"lamports\",\n                    type: \"u64\"\n                }\n            ]\n        }\n    ],\n    accounts: [\n        {\n            name: \"nonce\",\n            discriminator: []\n        }\n    ],\n    types: [\n        {\n            name: \"feeCalculator\",\n            type: {\n                kind: \"struct\",\n                fields: [\n                    {\n                        name: \"lamportsPerSignature\",\n                        type: \"u64\"\n                    }\n                ]\n            }\n        },\n        {\n            name: \"nonce\",\n            type: {\n                kind: \"struct\",\n                fields: [\n                    {\n                        name: \"version\",\n                        type: \"u32\"\n                    },\n                    {\n                        name: \"state\",\n                        type: \"u32\"\n                    },\n                    {\n                        name: \"authorizedPubkey\",\n                        type: \"pubkey\"\n                    },\n                    {\n                        name: \"nonce\",\n                        type: \"pubkey\"\n                    },\n                    {\n                        name: \"feeCalculator\",\n                        type: {\n                            defined: {\n                                name: \"feeCalculator\"\n                            }\n                        }\n                    }\n                ]\n            }\n        }\n    ]\n}; //# sourceMappingURL=system.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL25hdGl2ZS9zeXN0ZW0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUE0QztBQUNFO0FBQ1M7QUFDaEQsTUFBTUcsb0JBQW9CLElBQUlILHNEQUFTQSxDQUFDLG9DQUFvQztBQUM1RSxTQUFTSSxRQUFRQyxRQUFRO0lBQzVCLE9BQU8sSUFBSUosc0RBQU9BLENBQUNLLEtBQUtELFVBQVVFO0FBQ3RDO0FBQ08sU0FBU0E7SUFDWixPQUFPLElBQUlMLCtEQUFXQSxDQUFDSTtBQUMzQjtBQUNPLE1BQU1BLE1BQU07SUFDZkUsU0FBUztJQUNUQyxVQUFVO1FBQ05DLE1BQU07UUFDTkMsU0FBUztRQUNUQyxNQUFNO0lBQ1Y7SUFDQUMsY0FBYztRQUNWO1lBQ0lILE1BQU07WUFDTkksZUFBZTtnQkFBQztnQkFBRztnQkFBRztnQkFBRzthQUFFO1lBQzNCQyxVQUFVO2dCQUNOO29CQUNJTCxNQUFNO29CQUNOTSxVQUFVO2dCQUNkO2dCQUNBO29CQUNJTixNQUFNO2dCQUNWO2dCQUNBO29CQUNJQSxNQUFNO29CQUNOTyxRQUFRO2dCQUNaO2FBQ0g7WUFDREMsTUFBTTtnQkFDRjtvQkFDSVIsTUFBTTtvQkFDTlMsTUFBTTtnQkFDVjthQUNIO1FBQ0w7UUFDQTtZQUNJVCxNQUFNO1lBQ05JLGVBQWU7Z0JBQUM7Z0JBQUc7Z0JBQUc7Z0JBQUc7YUFBRTtZQUMzQkMsVUFBVTtnQkFDTjtvQkFDSUwsTUFBTTtvQkFDTk0sVUFBVTtvQkFDVkMsUUFBUTtnQkFDWjthQUNIO1lBQ0RDLE1BQU07Z0JBQ0Y7b0JBQ0lSLE1BQU07b0JBQ05TLE1BQU07Z0JBQ1Y7YUFDSDtRQUNMO1FBQ0E7WUFDSVQsTUFBTTtZQUNOSSxlQUFlO2dCQUFDO2dCQUFHO2dCQUFHO2dCQUFHO2FBQUU7WUFDM0JDLFVBQVU7Z0JBQ047b0JBQ0lMLE1BQU07b0JBQ05NLFVBQVU7Z0JBQ2Q7Z0JBQ0E7b0JBQ0lOLE1BQU07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QU07Z0JBQ05DLFFBQVE7b0JBQ0o7d0JBQ0laLE1BQU07d0JBQ05TLE1BQU07b0JBQ1Y7aUJBQ0g7WUFDTDtRQUNKO1FBQ0E7WUFDSVQsTUFBTTtZQUNOUyxNQUFNO2dCQUNGRSxNQUFNO2dCQUNOQyxRQUFRO29CQUNKO3dCQUNJWixNQUFNO3dCQUNOUyxNQUFNO29CQUNWO29CQUNBO3dCQUNJVCxNQUFNO3dCQUNOUyxNQUFNO29CQUNWO29CQUNBO3dCQUNJVCxNQUFNO3dCQUNOUyxNQUFNO29CQUNWO29CQUNBO3dCQUNJVCxNQUFNO3dCQUNOUyxNQUFNO29CQUNWO29CQUNBO3dCQUNJVCxNQUFNO3dCQUNOUyxNQUFNOzRCQUNGSSxTQUFTO2dDQUNMYixNQUFNOzRCQUNWO3dCQUNKO29CQUNKO2lCQUNIO1lBQ0w7UUFDSjtLQUNIO0FBQ0wsRUFBRSxDQUNGLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGNvcmFsLXh5ei9hbmNob3IvZGlzdC9lc20vbmF0aXZlL3N5c3RlbS5qcz9kMGMyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gXCJAc29sYW5hL3dlYjMuanNcIjtcbmltcG9ydCB7IFByb2dyYW0gfSBmcm9tIFwiLi4vcHJvZ3JhbS9pbmRleC5qc1wiO1xuaW1wb3J0IHsgU3lzdGVtQ29kZXIgfSBmcm9tIFwiLi4vY29kZXIvc3lzdGVtL2luZGV4LmpzXCI7XG5leHBvcnQgY29uc3QgU1lTVEVNX1BST0dSQU1fSUQgPSBuZXcgUHVibGljS2V5KFwiMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTFcIik7XG5leHBvcnQgZnVuY3Rpb24gcHJvZ3JhbShwcm92aWRlcikge1xuICAgIHJldHVybiBuZXcgUHJvZ3JhbShJREwsIHByb3ZpZGVyLCBjb2RlcigpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb2RlcigpIHtcbiAgICByZXR1cm4gbmV3IFN5c3RlbUNvZGVyKElETCk7XG59XG5leHBvcnQgY29uc3QgSURMID0ge1xuICAgIGFkZHJlc3M6IFwiMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTFcIixcbiAgICBtZXRhZGF0YToge1xuICAgICAgICBuYW1lOiBcInN5c3RlbVByb2dyYW1cIixcbiAgICAgICAgdmVyc2lvbjogXCIwLjEuMFwiLFxuICAgICAgICBzcGVjOiBcIjAuMS4wXCIsXG4gICAgfSxcbiAgICBpbnN0cnVjdGlvbnM6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogXCJhZHZhbmNlTm9uY2VBY2NvdW50XCIsXG4gICAgICAgICAgICBkaXNjcmltaW5hdG9yOiBbNCwgMCwgMCwgMF0sXG4gICAgICAgICAgICBhY2NvdW50czogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJub25jZVwiLFxuICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJyZWNlbnRCbG9ja2hhc2hlc1wiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImF1dGhvcml6ZWRcIixcbiAgICAgICAgICAgICAgICAgICAgc2lnbmVyOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJhdXRob3JpemVkXCIsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicHVia2V5XCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFwiYWxsb2NhdGVcIixcbiAgICAgICAgICAgIGRpc2NyaW1pbmF0b3I6IFs4LCAwLCAwLCAwXSxcbiAgICAgICAgICAgIGFjY291bnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInB1YmtleVwiLFxuICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmVyOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJzcGFjZVwiLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInU2NFwiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBcImFsbG9jYXRlV2l0aFNlZWRcIixcbiAgICAgICAgICAgIGRpc2NyaW1pbmF0b3I6IFs5LCAwLCAwLCAwXSxcbiAgICAgICAgICAgIGFjY291bnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImFjY291bnRcIixcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiYmFzZVwiLFxuICAgICAgICAgICAgICAgICAgICBzaWduZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImJhc2VcIixcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJwdWJrZXlcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJzZWVkXCIsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwic3BhY2VcIixcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ1NjRcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJvd25lclwiLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInB1YmtleVwiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBcImFzc2lnblwiLFxuICAgICAgICAgICAgZGlzY3JpbWluYXRvcjogWzEsIDAsIDAsIDBdLFxuICAgICAgICAgICAgYWNjb3VudHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwicHVia2V5XCIsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzaWduZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIm93bmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicHVia2V5XCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFwiYXNzaWduV2l0aFNlZWRcIixcbiAgICAgICAgICAgIGRpc2NyaW1pbmF0b3I6IFsxMCwgMCwgMCwgMF0sXG4gICAgICAgICAgICBhY2NvdW50czogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJhY2NvdW50XCIsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImJhc2VcIixcbiAgICAgICAgICAgICAgICAgICAgc2lnbmVyOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJiYXNlXCIsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicHVia2V5XCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwic2VlZFwiLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIm93bmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicHVia2V5XCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFwiYXV0aG9yaXplTm9uY2VBY2NvdW50XCIsXG4gICAgICAgICAgICBkaXNjcmltaW5hdG9yOiBbNywgMCwgMCwgMF0sXG4gICAgICAgICAgICBhY2NvdW50czogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJub25jZVwiLFxuICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJhdXRob3JpemVkXCIsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25lcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiYXV0aG9yaXplZFwiLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInB1YmtleVwiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBcImNyZWF0ZUFjY291bnRcIixcbiAgICAgICAgICAgIGRpc2NyaW1pbmF0b3I6IFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgIGFjY291bnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImZyb21cIixcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25lcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJ0b1wiLFxuICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmVyOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJsYW1wb3J0c1wiLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInU2NFwiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInNwYWNlXCIsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidTY0XCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwib3duZXJcIixcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJwdWJrZXlcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogXCJjcmVhdGVBY2NvdW50V2l0aFNlZWRcIixcbiAgICAgICAgICAgIGRpc2NyaW1pbmF0b3I6IFszLCAwLCAwLCAwXSxcbiAgICAgICAgICAgIGFjY291bnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImZyb21cIixcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25lcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJ0b1wiLFxuICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJiYXNlXCIsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25lcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiYmFzZVwiLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInB1YmtleVwiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInNlZWRcIixcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJsYW1wb3J0c1wiLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInU2NFwiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInNwYWNlXCIsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidTY0XCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwib3duZXJcIixcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJwdWJrZXlcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogXCJpbml0aWFsaXplTm9uY2VBY2NvdW50XCIsXG4gICAgICAgICAgICBkaXNjcmltaW5hdG9yOiBbNiwgMCwgMCwgMF0sXG4gICAgICAgICAgICBhY2NvdW50czogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJub25jZVwiLFxuICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmVyOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInJlY2VudEJsb2NraGFzaGVzXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwicmVudFwiLFxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBcIlN5c3ZhclJlbnQxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTFcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiYXV0aG9yaXplZFwiLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInB1YmtleVwiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBcInRyYW5zZmVyXCIsXG4gICAgICAgICAgICBkaXNjcmltaW5hdG9yOiBbMiwgMCwgMCwgMF0sXG4gICAgICAgICAgICBhY2NvdW50czogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJmcm9tXCIsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzaWduZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwidG9cIixcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImxhbXBvcnRzXCIsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidTY0XCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFwidHJhbnNmZXJXaXRoU2VlZFwiLFxuICAgICAgICAgICAgZGlzY3JpbWluYXRvcjogWzExLCAwLCAwLCAwXSxcbiAgICAgICAgICAgIGFjY291bnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImZyb21cIixcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiYmFzZVwiLFxuICAgICAgICAgICAgICAgICAgICBzaWduZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwidG9cIixcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImxhbXBvcnRzXCIsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidTY0XCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwic2VlZFwiLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIm93bmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicHVia2V5XCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFwid2l0aGRyYXdOb25jZUFjY291bnRcIixcbiAgICAgICAgICAgIGRpc2NyaW1pbmF0b3I6IFs1LCAwLCAwLCAwXSxcbiAgICAgICAgICAgIGFjY291bnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIm5vbmNlXCIsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInRvXCIsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInJlY2VudEJsb2NraGFzaGVzXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwicmVudFwiLFxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBcIlN5c3ZhclJlbnQxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTFcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJhdXRob3JpemVkXCIsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25lcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwibGFtcG9ydHNcIixcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ1NjRcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICBdLFxuICAgIGFjY291bnRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFwibm9uY2VcIixcbiAgICAgICAgICAgIGRpc2NyaW1pbmF0b3I6IFtdLFxuICAgICAgICB9LFxuICAgIF0sXG4gICAgdHlwZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogXCJmZWVDYWxjdWxhdG9yXCIsXG4gICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAga2luZDogXCJzdHJ1Y3RcIixcbiAgICAgICAgICAgICAgICBmaWVsZHM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJsYW1wb3J0c1BlclNpZ25hdHVyZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ1NjRcIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogXCJub25jZVwiLFxuICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgIGtpbmQ6IFwic3RydWN0XCIsXG4gICAgICAgICAgICAgICAgZmllbGRzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwidmVyc2lvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ1MzJcIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJzdGF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ1MzJcIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJhdXRob3JpemVkUHVia2V5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInB1YmtleVwiLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIm5vbmNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInB1YmtleVwiLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImZlZUNhbGN1bGF0b3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZpbmVkOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiZmVlQ2FsY3VsYXRvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIF0sXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3lzdGVtLmpzLm1hcCJdLCJuYW1lcyI6WyJQdWJsaWNLZXkiLCJQcm9ncmFtIiwiU3lzdGVtQ29kZXIiLCJTWVNURU1fUFJPR1JBTV9JRCIsInByb2dyYW0iLCJwcm92aWRlciIsIklETCIsImNvZGVyIiwiYWRkcmVzcyIsIm1ldGFkYXRhIiwibmFtZSIsInZlcnNpb24iLCJzcGVjIiwiaW5zdHJ1Y3Rpb25zIiwiZGlzY3JpbWluYXRvciIsImFjY291bnRzIiwid3JpdGFibGUiLCJzaWduZXIiLCJhcmdzIiwidHlwZSIsInR5cGVzIiwia2luZCIsImZpZWxkcyIsImRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/native/system.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/nodewallet.js":
/*!****************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/nodewallet.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ NodeWallet)\n/* harmony export */ });\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(buffer__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/node_modules/@solana/web3.js/lib/index.esm.js\");\n/* harmony import */ var _utils_common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/common.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/common.js\");\n\n\n\n/**\n * Node only wallet.\n */ class NodeWallet {\n    constructor(payer){\n        this.payer = payer;\n    }\n    static local() {\n        const process = __webpack_require__(/*! process */ \"process\");\n        if (!process.env.ANCHOR_WALLET || process.env.ANCHOR_WALLET === \"\") {\n            throw new Error(\"expected environment variable `ANCHOR_WALLET` is not set.\");\n        }\n        const payer = _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.Keypair.fromSecretKey(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(JSON.parse((__webpack_require__(/*! fs */ \"fs\").readFileSync)(process.env.ANCHOR_WALLET, {\n            encoding: \"utf-8\"\n        }))));\n        return new NodeWallet(payer);\n    }\n    async signTransaction(tx) {\n        if ((0,_utils_common_js__WEBPACK_IMPORTED_MODULE_2__.isVersionedTransaction)(tx)) {\n            tx.sign([\n                this.payer\n            ]);\n        } else {\n            tx.partialSign(this.payer);\n        }\n        return tx;\n    }\n    async signAllTransactions(txs) {\n        return txs.map((t)=>{\n            if ((0,_utils_common_js__WEBPACK_IMPORTED_MODULE_2__.isVersionedTransaction)(t)) {\n                t.sign([\n                    this.payer\n                ]);\n            } else {\n                t.partialSign(this.payer);\n            }\n            return t;\n        });\n    }\n    get publicKey() {\n        return this.payer.publicKey;\n    }\n} //# sourceMappingURL=nodewallet.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL25vZGV3YWxsZXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBZ0M7QUFDVztBQUNnQjtBQUMzRDs7Q0FFQyxHQUNjLE1BQU1HO0lBQ2pCQyxZQUFZQyxLQUFLLENBQUU7UUFDZixJQUFJLENBQUNBLEtBQUssR0FBR0E7SUFDakI7SUFDQSxPQUFPQyxRQUFRO1FBQ1gsTUFBTUMsVUFBVUMsbUJBQU9BLENBQUMsd0JBQVM7UUFDakMsSUFBSSxDQUFDRCxRQUFRRSxHQUFHLENBQUNDLGFBQWEsSUFBSUgsUUFBUUUsR0FBRyxDQUFDQyxhQUFhLEtBQUssSUFBSTtZQUNoRSxNQUFNLElBQUlDLE1BQU07UUFDcEI7UUFDQSxNQUFNTixRQUFRSixvREFBT0EsQ0FBQ1csYUFBYSxDQUFDWiwwQ0FBTUEsQ0FBQ2EsSUFBSSxDQUFDQyxLQUFLQyxLQUFLLENBQUNQLGtEQUEwQixDQUFDRCxRQUFRRSxHQUFHLENBQUNDLGFBQWEsRUFBRTtZQUM3R08sVUFBVTtRQUNkO1FBQ0EsT0FBTyxJQUFJZCxXQUFXRTtJQUMxQjtJQUNBLE1BQU1hLGdCQUFnQkMsRUFBRSxFQUFFO1FBQ3RCLElBQUlqQix3RUFBc0JBLENBQUNpQixLQUFLO1lBQzVCQSxHQUFHQyxJQUFJLENBQUM7Z0JBQUMsSUFBSSxDQUFDZixLQUFLO2FBQUM7UUFDeEIsT0FDSztZQUNEYyxHQUFHRSxXQUFXLENBQUMsSUFBSSxDQUFDaEIsS0FBSztRQUM3QjtRQUNBLE9BQU9jO0lBQ1g7SUFDQSxNQUFNRyxvQkFBb0JDLEdBQUcsRUFBRTtRQUMzQixPQUFPQSxJQUFJQyxHQUFHLENBQUMsQ0FBQ0M7WUFDWixJQUFJdkIsd0VBQXNCQSxDQUFDdUIsSUFBSTtnQkFDM0JBLEVBQUVMLElBQUksQ0FBQztvQkFBQyxJQUFJLENBQUNmLEtBQUs7aUJBQUM7WUFDdkIsT0FDSztnQkFDRG9CLEVBQUVKLFdBQVcsQ0FBQyxJQUFJLENBQUNoQixLQUFLO1lBQzVCO1lBQ0EsT0FBT29CO1FBQ1g7SUFDSjtJQUNBLElBQUlDLFlBQVk7UUFDWixPQUFPLElBQUksQ0FBQ3JCLEtBQUssQ0FBQ3FCLFNBQVM7SUFDL0I7QUFDSixFQUNBLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGNvcmFsLXh5ei9hbmNob3IvZGlzdC9lc20vbm9kZXdhbGxldC5qcz9lOGVkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1ZmZlciB9IGZyb20gXCJidWZmZXJcIjtcbmltcG9ydCB7IEtleXBhaXIsIH0gZnJvbSBcIkBzb2xhbmEvd2ViMy5qc1wiO1xuaW1wb3J0IHsgaXNWZXJzaW9uZWRUcmFuc2FjdGlvbiB9IGZyb20gXCIuL3V0aWxzL2NvbW1vbi5qc1wiO1xuLyoqXG4gKiBOb2RlIG9ubHkgd2FsbGV0LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb2RlV2FsbGV0IHtcbiAgICBjb25zdHJ1Y3RvcihwYXllcikge1xuICAgICAgICB0aGlzLnBheWVyID0gcGF5ZXI7XG4gICAgfVxuICAgIHN0YXRpYyBsb2NhbCgpIHtcbiAgICAgICAgY29uc3QgcHJvY2VzcyA9IHJlcXVpcmUoXCJwcm9jZXNzXCIpO1xuICAgICAgICBpZiAoIXByb2Nlc3MuZW52LkFOQ0hPUl9XQUxMRVQgfHwgcHJvY2Vzcy5lbnYuQU5DSE9SX1dBTExFVCA9PT0gXCJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0ZWQgZW52aXJvbm1lbnQgdmFyaWFibGUgYEFOQ0hPUl9XQUxMRVRgIGlzIG5vdCBzZXQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBheWVyID0gS2V5cGFpci5mcm9tU2VjcmV0S2V5KEJ1ZmZlci5mcm9tKEpTT04ucGFyc2UocmVxdWlyZShcImZzXCIpLnJlYWRGaWxlU3luYyhwcm9jZXNzLmVudi5BTkNIT1JfV0FMTEVULCB7XG4gICAgICAgICAgICBlbmNvZGluZzogXCJ1dGYtOFwiLFxuICAgICAgICB9KSkpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlV2FsbGV0KHBheWVyKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIGlmIChpc1ZlcnNpb25lZFRyYW5zYWN0aW9uKHR4KSkge1xuICAgICAgICAgICAgdHguc2lnbihbdGhpcy5wYXllcl0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHgucGFydGlhbFNpZ24odGhpcy5wYXllcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICBhc3luYyBzaWduQWxsVHJhbnNhY3Rpb25zKHR4cykge1xuICAgICAgICByZXR1cm4gdHhzLm1hcCgodCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzVmVyc2lvbmVkVHJhbnNhY3Rpb24odCkpIHtcbiAgICAgICAgICAgICAgICB0LnNpZ24oW3RoaXMucGF5ZXJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHQucGFydGlhbFNpZ24odGhpcy5wYXllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBwdWJsaWNLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBheWVyLnB1YmxpY0tleTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub2Rld2FsbGV0LmpzLm1hcCJdLCJuYW1lcyI6WyJCdWZmZXIiLCJLZXlwYWlyIiwiaXNWZXJzaW9uZWRUcmFuc2FjdGlvbiIsIk5vZGVXYWxsZXQiLCJjb25zdHJ1Y3RvciIsInBheWVyIiwibG9jYWwiLCJwcm9jZXNzIiwicmVxdWlyZSIsImVudiIsIkFOQ0hPUl9XQUxMRVQiLCJFcnJvciIsImZyb21TZWNyZXRLZXkiLCJmcm9tIiwiSlNPTiIsInBhcnNlIiwicmVhZEZpbGVTeW5jIiwiZW5jb2RpbmciLCJzaWduVHJhbnNhY3Rpb24iLCJ0eCIsInNpZ24iLCJwYXJ0aWFsU2lnbiIsInNpZ25BbGxUcmFuc2FjdGlvbnMiLCJ0eHMiLCJtYXAiLCJ0IiwicHVibGljS2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/nodewallet.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/accounts-resolver.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/program/accounts-resolver.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AccountsResolver: () => (/* binding */ AccountsResolver),\n/* harmony export */   isAccountsGeneric: () => (/* binding */ isAccountsGeneric)\n/* harmony export */ });\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bn.js */ \"(ssr)/../node_modules/bn.js/lib/bn.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bn_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/node_modules/@solana/web3.js/lib/index.esm.js\");\n/* harmony import */ var _idl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../idl.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/idl.js\");\n/* harmony import */ var _token_account_layout__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./token-account-layout */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/token-account-layout.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./index.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/index.js\");\n/* harmony import */ var _namespace_methods__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./namespace/methods */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/namespace/methods.js\");\n\n\n\n\n\n\nfunction isAccountsGeneric(accounts) {\n    return !(accounts instanceof _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.PublicKey);\n}\n// Populates a given accounts context with PDAs and common missing accounts.\nclass AccountsResolver {\n    constructor(_args, _accounts, _provider, _programId, _idlIx, accountNamespace, _idlTypes, _customResolver){\n        this._args = _args;\n        this._accounts = _accounts;\n        this._provider = _provider;\n        this._programId = _programId;\n        this._idlIx = _idlIx;\n        this._idlTypes = _idlTypes;\n        this._customResolver = _customResolver;\n        this._accountStore = new AccountStore(_provider, accountNamespace, _programId);\n    }\n    args(args) {\n        this._args = args;\n    }\n    // Note: We serially resolve PDAs one by one rather than doing them\n    //       in parallel because there can be dependencies between\n    //       addresses. That is, one PDA can be used as a seed in another.\n    async resolve() {\n        this.resolveEventCpi(this._idlIx.accounts);\n        this.resolveConst(this._idlIx.accounts);\n        // Auto populate pdas and relations until we stop finding new accounts\n        let depth = 0;\n        while(await this.resolvePdasAndRelations(this._idlIx.accounts) + await this.resolveCustom() > 0){\n            depth++;\n            if (depth === 16) {\n                throw new Error(\"Reached maximum depth for account resolution\");\n            }\n        }\n    }\n    resolveOptionals(accounts) {\n        Object.assign(this._accounts, this.resolveOptionalsHelper(accounts, this._idlIx.accounts));\n    }\n    get(path) {\n        // Only return if pubkey\n        const ret = path.reduce((acc, subPath)=>acc && acc[subPath], this._accounts);\n        if (ret && ret.toBase58) {\n            return ret;\n        }\n    }\n    set(path, value) {\n        let cur = this._accounts;\n        path.forEach((p, i)=>{\n            var _a;\n            const isLast = i === path.length - 1;\n            if (isLast) {\n                cur[p] = value;\n            }\n            cur[p] = (_a = cur[p]) !== null && _a !== void 0 ? _a : {};\n            cur = cur[p];\n        });\n    }\n    resolveOptionalsHelper(partialAccounts, accounts) {\n        const nestedAccountsGeneric = {};\n        // Looping through accountItem array instead of on partialAccounts, so\n        // we only traverse array once\n        for (const accountItem of accounts){\n            const accountName = accountItem.name;\n            const partialAccount = partialAccounts[accountName];\n            // Skip if the account isn't included (thus would be undefined)\n            if (partialAccount === undefined) continue;\n            if ((0,_namespace_methods__WEBPACK_IMPORTED_MODULE_5__.isPartialAccounts)(partialAccount)) {\n                // is compound accounts, recurse one level deeper\n                if ((0,_idl_js__WEBPACK_IMPORTED_MODULE_2__.isCompositeAccounts)(accountItem)) {\n                    nestedAccountsGeneric[accountName] = this.resolveOptionalsHelper(partialAccount, accountItem[\"accounts\"]);\n                } else {\n                    // Here we try our best to recover gracefully. If there are optionals we can't check, we will fail then.\n                    nestedAccountsGeneric[accountName] = (0,_namespace_methods__WEBPACK_IMPORTED_MODULE_5__.flattenPartialAccounts)(partialAccount, true);\n                }\n            } else {\n                // if not compound accounts, do null/optional check and proceed\n                if (partialAccount !== null) {\n                    nestedAccountsGeneric[accountName] = (0,_index_js__WEBPACK_IMPORTED_MODULE_4__.translateAddress)(partialAccount);\n                } else if (accountItem[\"optional\"]) {\n                    nestedAccountsGeneric[accountName] = this._programId;\n                }\n            }\n        }\n        return nestedAccountsGeneric;\n    }\n    async resolveCustom() {\n        if (this._customResolver) {\n            const { accounts, resolved } = await this._customResolver({\n                args: this._args,\n                accounts: this._accounts,\n                provider: this._provider,\n                programId: this._programId,\n                idlIx: this._idlIx\n            });\n            this._accounts = accounts;\n            return resolved;\n        }\n        return 0;\n    }\n    /**\n     * Resolve event CPI accounts `eventAuthority` and `program`.\n     *\n     * Accounts will only be resolved if they are declared next to each other to\n     * reduce the chance of name collision.\n     */ resolveEventCpi(accounts, path = []) {\n        for(const i in accounts){\n            const accountOrAccounts = accounts[i];\n            if ((0,_idl_js__WEBPACK_IMPORTED_MODULE_2__.isCompositeAccounts)(accountOrAccounts)) {\n                this.resolveEventCpi(accountOrAccounts.accounts, [\n                    ...path,\n                    accountOrAccounts.name\n                ]);\n            }\n            // Validate next index exists\n            const nextIndex = +i + 1;\n            if (nextIndex === accounts.length) return;\n            const currentName = accounts[i].name;\n            const nextName = accounts[nextIndex].name;\n            // Populate event CPI accounts if they exist\n            if (currentName === \"eventAuthority\" && nextName === \"program\") {\n                const currentPath = [\n                    ...path,\n                    currentName\n                ];\n                const nextPath = [\n                    ...path,\n                    nextName\n                ];\n                if (!this.get(currentPath)) {\n                    this.set(currentPath, _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.PublicKey.findProgramAddressSync([\n                        Buffer.from(\"__event_authority\")\n                    ], this._programId)[0]);\n                }\n                if (!this.get(nextPath)) {\n                    this.set(nextPath, this._programId);\n                }\n                return;\n            }\n        }\n    }\n    resolveConst(accounts, path = []) {\n        for (const accountOrAccounts of accounts){\n            const name = accountOrAccounts.name;\n            if ((0,_idl_js__WEBPACK_IMPORTED_MODULE_2__.isCompositeAccounts)(accountOrAccounts)) {\n                this.resolveConst(accountOrAccounts.accounts, [\n                    ...path,\n                    name\n                ]);\n            } else {\n                const account = accountOrAccounts;\n                if ((account.signer || account.address) && !this.get([\n                    ...path,\n                    name\n                ])) {\n                    // Default signers to the provider\n                    if (account.signer) {\n                        // @ts-expect-error\n                        if (!this._provider.wallet) {\n                            throw new Error(\"This function requires the `Provider` interface implementor to have a `wallet` field.\");\n                        }\n                        // @ts-expect-error\n                        this.set([\n                            ...path,\n                            name\n                        ], this._provider.wallet.publicKey);\n                    }\n                    // Set based on `address` field\n                    if (account.address) {\n                        this.set([\n                            ...path,\n                            name\n                        ], (0,_index_js__WEBPACK_IMPORTED_MODULE_4__.translateAddress)(account.address));\n                    }\n                }\n            }\n        }\n    }\n    async resolvePdasAndRelations(accounts, path = []) {\n        let found = 0;\n        for (const accountOrAccounts of accounts){\n            const name = accountOrAccounts.name;\n            if ((0,_idl_js__WEBPACK_IMPORTED_MODULE_2__.isCompositeAccounts)(accountOrAccounts)) {\n                found += await this.resolvePdasAndRelations(accountOrAccounts.accounts, [\n                    ...path,\n                    name\n                ]);\n            } else {\n                const account = accountOrAccounts;\n                if ((account.pda || account.relations) && !this.get([\n                    ...path,\n                    name\n                ])) {\n                    found++;\n                    // Accounts might not get resolved successfully if a seed depends on\n                    // another seed to be resolved *and* the accounts for resolution are\n                    // out of order. In this case, skip the accounts that throw in order\n                    // to resolve those accounts later.\n                    try {\n                        if (account.pda) {\n                            const seeds = await Promise.all(account.pda.seeds.map((seed)=>this.toBuffer(seed, path)));\n                            if (seeds.some((seed)=>!seed)) {\n                                continue;\n                            }\n                            const programId = await this.parseProgramId(account, path);\n                            const [pubkey] = _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.PublicKey.findProgramAddressSync(seeds, programId);\n                            this.set([\n                                ...path,\n                                name\n                            ], pubkey);\n                        }\n                    } catch  {}\n                    try {\n                        if (account.relations) {\n                            const accountKey = this.get([\n                                ...path,\n                                account.relations[0]\n                            ]);\n                            if (accountKey) {\n                                const account = await this._accountStore.fetchAccount({\n                                    publicKey: accountKey\n                                });\n                                this.set([\n                                    ...path,\n                                    name\n                                ], account[name]);\n                            }\n                        }\n                    } catch  {}\n                }\n            }\n        }\n        return found;\n    }\n    async parseProgramId(account, path = []) {\n        var _a;\n        if (!((_a = account.pda) === null || _a === void 0 ? void 0 : _a.program)) {\n            return this._programId;\n        }\n        const buf = await this.toBuffer(account.pda.program, path);\n        if (!buf) {\n            throw new Error(`Program seed not resolved: ${account.name}`);\n        }\n        return new _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.PublicKey(buf);\n    }\n    async toBuffer(seed, path = []) {\n        switch(seed.kind){\n            case \"const\":\n                return this.toBufferConst(seed);\n            case \"arg\":\n                return await this.toBufferArg(seed);\n            case \"account\":\n                return await this.toBufferAccount(seed, path);\n            default:\n                throw new Error(`Unexpected seed: ${seed}`);\n        }\n    }\n    toBufferConst(seed) {\n        return this.toBufferValue(\"bytes\", seed.value);\n    }\n    async toBufferArg(seed) {\n        const [name, ...path] = seed.path.split(\".\");\n        const index = this._idlIx.args.findIndex((arg)=>arg.name === name);\n        if (index === -1) {\n            throw new Error(`Unable to find argument for seed: ${name}`);\n        }\n        const value = path.reduce((acc, path)=>(acc !== null && acc !== void 0 ? acc : {})[path], this._args[index]);\n        if (value === undefined) {\n            return;\n        }\n        const type = this.getType(this._idlIx.args[index].type, path);\n        return this.toBufferValue(type, value);\n    }\n    async toBufferAccount(seed, path = []) {\n        const [name, ...paths] = seed.path.split(\".\");\n        const fieldPubkey = this.get([\n            ...path,\n            name\n        ]);\n        if (!fieldPubkey) return;\n        // The seed is a pubkey of the account.\n        if (!paths.length) {\n            return this.toBufferValue(\"pubkey\", fieldPubkey);\n        }\n        if (!seed.account) {\n            throw new Error(`Seed account is required in order to resolve type: ${seed.path}`);\n        }\n        // The key is account data.\n        //\n        // Fetch and deserialize it.\n        const account = await this._accountStore.fetchAccount({\n            publicKey: fieldPubkey,\n            name: seed.account\n        });\n        // Dereference all fields in the path to get the field value\n        // used in the seed.\n        let accountValue = account;\n        let currentPaths = paths;\n        while(currentPaths.length > 0){\n            accountValue = accountValue[currentPaths[0]];\n            currentPaths = currentPaths.slice(1);\n        }\n        if (accountValue === undefined) return;\n        const type = this.getType({\n            defined: {\n                name: seed.account\n            }\n        }, paths);\n        return this.toBufferValue(type, accountValue);\n    }\n    /**\n     * Converts the given idl valaue into a Buffer. The values here must be\n     * primitives, e.g. no structs.\n     */ toBufferValue(type, value) {\n        switch(type){\n            case \"u8\":\n            case \"i8\":\n                return Buffer.from([\n                    value\n                ]);\n            case \"u16\":\n            case \"i16\":\n                return new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(value).toArrayLike(Buffer, \"le\", 2);\n            case \"u32\":\n            case \"i32\":\n                return new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(value).toArrayLike(Buffer, \"le\", 4);\n            case \"u64\":\n            case \"i64\":\n                return new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(value).toArrayLike(Buffer, \"le\", 8);\n            case \"u128\":\n            case \"i128\":\n                return new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(value).toArrayLike(Buffer, \"le\", 16);\n            case \"u256\":\n            case \"i256\":\n                return new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(value).toArrayLike(Buffer, \"le\", 32);\n            case \"string\":\n                return Buffer.from(value);\n            case \"pubkey\":\n                return value.toBuffer();\n            case \"bytes\":\n                return Buffer.from(value);\n            default:\n                if (type === null || type === void 0 ? void 0 : type.array) {\n                    return Buffer.from(value);\n                }\n                throw new Error(`Unexpected seed type: ${type}`);\n        }\n    }\n    /**\n     * Recursively get the type at some path of either a primitive or a user\n     * defined struct.\n     */ getType(type, path = []) {\n        var _a;\n        const typeName = (_a = type === null || type === void 0 ? void 0 : type.defined) === null || _a === void 0 ? void 0 : _a.name;\n        if (typeName) {\n            // Handle token account separately\n            if (typeName === \"tokenAccount\") {\n                switch(path.at(0)){\n                    case \"mint\":\n                    case \"owner\":\n                        return \"pubkey\";\n                    case \"amount\":\n                    case \"delagatedAmount\":\n                        return \"u64\";\n                    default:\n                        throw new Error(`Unknown token account path: ${path}`);\n                }\n            }\n            const definedType = this._idlTypes.find((t)=>t.name === typeName);\n            if (!definedType) {\n                throw new Error(`Type not found: ${typeName}`);\n            }\n            // Only named structs are supported\n            const [fieldName, ...subPath] = path;\n            const fields = definedType.type.fields;\n            const field = fields.find((field)=>field.name === fieldName);\n            if (!field) {\n                throw new Error(`Field not found: ${fieldName}`);\n            }\n            return this.getType(field.type, subPath);\n        }\n        return type;\n    }\n}\n// TODO: this should be configurable to avoid unnecessary requests.\nclass AccountStore {\n    constructor(_provider, accounts, programId){\n        this._provider = _provider;\n        this._cache = new Map();\n        this._idls = {};\n        this._idls[programId.toBase58()] = accounts;\n    }\n    async fetchAccount({ publicKey, name }) {\n        const address = publicKey.toBase58();\n        if (!this._cache.has(address)) {\n            const accountInfo = await this._provider.connection.getAccountInfo(publicKey);\n            if (accountInfo === null) {\n                throw new Error(`Account not found: ${address}`);\n            }\n            if (name === \"tokenAccount\") {\n                const account = (0,_token_account_layout__WEBPACK_IMPORTED_MODULE_3__.decodeTokenAccount)(accountInfo.data);\n                this._cache.set(address, account);\n            } else {\n                const accounts = await this.getAccountsNs(accountInfo.owner);\n                if (accounts) {\n                    const accountNs = Object.values(accounts)[0];\n                    if (accountNs) {\n                        const account = accountNs.coder.accounts.decodeAny(accountInfo.data);\n                        this._cache.set(address, account);\n                    }\n                }\n            }\n        }\n        return this._cache.get(address);\n    }\n    async getAccountsNs(programId) {\n        const programIdStr = programId.toBase58();\n        if (!this._idls[programIdStr]) {\n            const idl = await _index_js__WEBPACK_IMPORTED_MODULE_4__.Program.fetchIdl(programId, this._provider);\n            if (idl) {\n                const program = new _index_js__WEBPACK_IMPORTED_MODULE_4__.Program(idl, this._provider);\n                this._idls[programIdStr] = program.account;\n            }\n        }\n        return this._idls[programIdStr];\n    }\n} //# sourceMappingURL=accounts-resolver.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3Byb2dyYW0vYWNjb3VudHMtcmVzb2x2ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXVCO0FBQ3FCO0FBQ0s7QUFDVztBQUNMO0FBQzBCO0FBQzFFLFNBQVNRLGtCQUFrQkMsUUFBUTtJQUN0QyxPQUFPLENBQUVBLENBQUFBLG9CQUFvQlIsc0RBQVE7QUFDekM7QUFDQSw0RUFBNEU7QUFDckUsTUFBTVM7SUFDVEMsWUFBWUMsS0FBSyxFQUFFQyxTQUFTLEVBQUVDLFNBQVMsRUFBRUMsVUFBVSxFQUFFQyxNQUFNLEVBQUVDLGdCQUFnQixFQUFFQyxTQUFTLEVBQUVDLGVBQWUsQ0FBRTtRQUN2RyxJQUFJLENBQUNQLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNDLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDQyxTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ0MsVUFBVSxHQUFHQTtRQUNsQixJQUFJLENBQUNDLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNFLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDQyxlQUFlLEdBQUdBO1FBQ3ZCLElBQUksQ0FBQ0MsYUFBYSxHQUFHLElBQUlDLGFBQWFQLFdBQVdHLGtCQUFrQkY7SUFDdkU7SUFDQU8sS0FBS0EsSUFBSSxFQUFFO1FBQ1AsSUFBSSxDQUFDVixLQUFLLEdBQUdVO0lBQ2pCO0lBQ0EsbUVBQW1FO0lBQ25FLDhEQUE4RDtJQUM5RCxzRUFBc0U7SUFDdEUsTUFBTUMsVUFBVTtRQUNaLElBQUksQ0FBQ0MsZUFBZSxDQUFDLElBQUksQ0FBQ1IsTUFBTSxDQUFDUCxRQUFRO1FBQ3pDLElBQUksQ0FBQ2dCLFlBQVksQ0FBQyxJQUFJLENBQUNULE1BQU0sQ0FBQ1AsUUFBUTtRQUN0QyxzRUFBc0U7UUFDdEUsSUFBSWlCLFFBQVE7UUFDWixNQUFPLE1BQU8sSUFBSSxDQUFDQyx1QkFBdUIsQ0FBQyxJQUFJLENBQUNY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SUFBSSxDQUFDa0QsS0FBSyxDQUFDWSxhQUFhO0lBQ25DO0FBQ0osRUFDQSw2Q0FBNkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3Byb2dyYW0vYWNjb3VudHMtcmVzb2x2ZXIuanM/N2MxZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQk4gZnJvbSBcImJuLmpzXCI7XG5pbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tIFwiQHNvbGFuYS93ZWIzLmpzXCI7XG5pbXBvcnQgeyBpc0NvbXBvc2l0ZUFjY291bnRzLCB9IGZyb20gXCIuLi9pZGwuanNcIjtcbmltcG9ydCB7IGRlY29kZVRva2VuQWNjb3VudCB9IGZyb20gXCIuL3Rva2VuLWFjY291bnQtbGF5b3V0XCI7XG5pbXBvcnQgeyBQcm9ncmFtLCB0cmFuc2xhdGVBZGRyZXNzIH0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCB7IGZsYXR0ZW5QYXJ0aWFsQWNjb3VudHMsIGlzUGFydGlhbEFjY291bnRzLCB9IGZyb20gXCIuL25hbWVzcGFjZS9tZXRob2RzXCI7XG5leHBvcnQgZnVuY3Rpb24gaXNBY2NvdW50c0dlbmVyaWMoYWNjb3VudHMpIHtcbiAgICByZXR1cm4gIShhY2NvdW50cyBpbnN0YW5jZW9mIFB1YmxpY0tleSk7XG59XG4vLyBQb3B1bGF0ZXMgYSBnaXZlbiBhY2NvdW50cyBjb250ZXh0IHdpdGggUERBcyBhbmQgY29tbW9uIG1pc3NpbmcgYWNjb3VudHMuXG5leHBvcnQgY2xhc3MgQWNjb3VudHNSZXNvbHZlciB7XG4gICAgY29uc3RydWN0b3IoX2FyZ3MsIF9hY2NvdW50cywgX3Byb3ZpZGVyLCBfcHJvZ3JhbUlkLCBfaWRsSXgsIGFjY291bnROYW1lc3BhY2UsIF9pZGxUeXBlcywgX2N1c3RvbVJlc29sdmVyKSB7XG4gICAgICAgIHRoaXMuX2FyZ3MgPSBfYXJncztcbiAgICAgICAgdGhpcy5fYWNjb3VudHMgPSBfYWNjb3VudHM7XG4gICAgICAgIHRoaXMuX3Byb3ZpZGVyID0gX3Byb3ZpZGVyO1xuICAgICAgICB0aGlzLl9wcm9ncmFtSWQgPSBfcHJvZ3JhbUlkO1xuICAgICAgICB0aGlzLl9pZGxJeCA9IF9pZGxJeDtcbiAgICAgICAgdGhpcy5faWRsVHlwZXMgPSBfaWRsVHlwZXM7XG4gICAgICAgIHRoaXMuX2N1c3RvbVJlc29sdmVyID0gX2N1c3RvbVJlc29sdmVyO1xuICAgICAgICB0aGlzLl9hY2NvdW50U3RvcmUgPSBuZXcgQWNjb3VudFN0b3JlKF9wcm92aWRlciwgYWNjb3VudE5hbWVzcGFjZSwgX3Byb2dyYW1JZCk7XG4gICAgfVxuICAgIGFyZ3MoYXJncykge1xuICAgICAgICB0aGlzLl9hcmdzID0gYXJncztcbiAgICB9XG4gICAgLy8gTm90ZTogV2Ugc2VyaWFsbHkgcmVzb2x2ZSBQREFzIG9uZSBieSBvbmUgcmF0aGVyIHRoYW4gZG9pbmcgdGhlbVxuICAgIC8vICAgICAgIGluIHBhcmFsbGVsIGJlY2F1c2UgdGhlcmUgY2FuIGJlIGRlcGVuZGVuY2llcyBiZXR3ZWVuXG4gICAgLy8gICAgICAgYWRkcmVzc2VzLiBUaGF0IGlzLCBvbmUgUERBIGNhbiBiZSB1c2VkIGFzIGEgc2VlZCBpbiBhbm90aGVyLlxuICAgIGFzeW5jIHJlc29sdmUoKSB7XG4gICAgICAgIHRoaXMucmVzb2x2ZUV2ZW50Q3BpKHRoaXMuX2lkbEl4LmFjY291bnRzKTtcbiAgICAgICAgdGhpcy5yZXNvbHZlQ29uc3QodGhpcy5faWRsSXguYWNjb3VudHMpO1xuICAgICAgICAvLyBBdXRvIHBvcHVsYXRlIHBkYXMgYW5kIHJlbGF0aW9ucyB1bnRpbCB3ZSBzdG9wIGZpbmRpbmcgbmV3IGFjY291bnRzXG4gICAgICAgIGxldCBkZXB0aCA9IDA7XG4gICAgICAgIHdoaWxlICgoYXdhaXQgdGhpcy5yZXNvbHZlUGRhc0FuZFJlbGF0aW9ucyh0aGlzLl9pZGxJeC5hY2NvdW50cykpICtcbiAgICAgICAgICAgIChhd2FpdCB0aGlzLnJlc29sdmVDdXN0b20oKSkgPlxuICAgICAgICAgICAgMCkge1xuICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgIGlmIChkZXB0aCA9PT0gMTYpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWFjaGVkIG1heGltdW0gZGVwdGggZm9yIGFjY291bnQgcmVzb2x1dGlvblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNvbHZlT3B0aW9uYWxzKGFjY291bnRzKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fYWNjb3VudHMsIHRoaXMucmVzb2x2ZU9wdGlvbmFsc0hlbHBlcihhY2NvdW50cywgdGhpcy5faWRsSXguYWNjb3VudHMpKTtcbiAgICB9XG4gICAgZ2V0KHBhdGgpIHtcbiAgICAgICAgLy8gT25seSByZXR1cm4gaWYgcHVia2V5XG4gICAgICAgIGNvbnN0IHJldCA9IHBhdGgucmVkdWNlKChhY2MsIHN1YlBhdGgpID0+IGFjYyAmJiBhY2Nbc3ViUGF0aF0sIHRoaXMuX2FjY291bnRzKTtcbiAgICAgICAgaWYgKHJldCAmJiByZXQudG9CYXNlNTgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0KHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIGxldCBjdXIgPSB0aGlzLl9hY2NvdW50cztcbiAgICAgICAgcGF0aC5mb3JFYWNoKChwLCBpKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBpc0xhc3QgPSBpID09PSBwYXRoLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBpZiAoaXNMYXN0KSB7XG4gICAgICAgICAgICAgICAgY3VyW3BdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJbcF0gPSAoX2EgPSBjdXJbcF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xuICAgICAgICAgICAgY3VyID0gY3VyW3BdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVzb2x2ZU9wdGlvbmFsc0hlbHBlcihwYXJ0aWFsQWNjb3VudHMsIGFjY291bnRzKSB7XG4gICAgICAgIGNvbnN0IG5lc3RlZEFjY291bnRzR2VuZXJpYyA9IHt9O1xuICAgICAgICAvLyBMb29waW5nIHRocm91Z2ggYWNjb3VudEl0ZW0gYXJyYXkgaW5zdGVhZCBvZiBvbiBwYXJ0aWFsQWNjb3VudHMsIHNvXG4gICAgICAgIC8vIHdlIG9ubHkgdHJhdmVyc2UgYXJyYXkgb25jZVxuICAgICAgICBmb3IgKGNvbnN0IGFjY291bnRJdGVtIG9mIGFjY291bnRzKSB7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50TmFtZSA9IGFjY291bnRJdGVtLm5hbWU7XG4gICAgICAgICAgICBjb25zdCBwYXJ0aWFsQWNjb3VudCA9IHBhcnRpYWxBY2NvdW50c1thY2NvdW50TmFtZV07XG4gICAgICAgICAgICAvLyBTa2lwIGlmIHRoZSBhY2NvdW50IGlzbid0IGluY2x1ZGVkICh0aHVzIHdvdWxkIGJlIHVuZGVmaW5lZClcbiAgICAgICAgICAgIGlmIChwYXJ0aWFsQWNjb3VudCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKGlzUGFydGlhbEFjY291bnRzKHBhcnRpYWxBY2NvdW50KSkge1xuICAgICAgICAgICAgICAgIC8vIGlzIGNvbXBvdW5kIGFjY291bnRzLCByZWN1cnNlIG9uZSBsZXZlbCBkZWVwZXJcbiAgICAgICAgICAgICAgICBpZiAoaXNDb21wb3NpdGVBY2NvdW50cyhhY2NvdW50SXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmVzdGVkQWNjb3VudHNHZW5lcmljW2FjY291bnROYW1lXSA9IHRoaXMucmVzb2x2ZU9wdGlvbmFsc0hlbHBlcihwYXJ0aWFsQWNjb3VudCwgYWNjb3VudEl0ZW1bXCJhY2NvdW50c1wiXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBIZXJlIHdlIHRyeSBvdXIgYmVzdCB0byByZWNvdmVyIGdyYWNlZnVsbHkuIElmIHRoZXJlIGFyZSBvcHRpb25hbHMgd2UgY2FuJ3QgY2hlY2ssIHdlIHdpbGwgZmFpbCB0aGVuLlxuICAgICAgICAgICAgICAgICAgICBuZXN0ZWRBY2NvdW50c0dlbmVyaWNbYWNjb3VudE5hbWVdID0gZmxhdHRlblBhcnRpYWxBY2NvdW50cyhwYXJ0aWFsQWNjb3VudCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgbm90IGNvbXBvdW5kIGFjY291bnRzLCBkbyBudWxsL29wdGlvbmFsIGNoZWNrIGFuZCBwcm9jZWVkXG4gICAgICAgICAgICAgICAgaWYgKHBhcnRpYWxBY2NvdW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5lc3RlZEFjY291bnRzR2VuZXJpY1thY2NvdW50TmFtZV0gPSB0cmFuc2xhdGVBZGRyZXNzKHBhcnRpYWxBY2NvdW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYWNjb3VudEl0ZW1bXCJvcHRpb25hbFwiXSkge1xuICAgICAgICAgICAgICAgICAgICBuZXN0ZWRBY2NvdW50c0dlbmVyaWNbYWNjb3VudE5hbWVdID0gdGhpcy5fcHJvZ3JhbUlkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmVzdGVkQWNjb3VudHNHZW5lcmljO1xuICAgIH1cbiAgICBhc3luYyByZXNvbHZlQ3VzdG9tKCkge1xuICAgICAgICBpZiAodGhpcy5fY3VzdG9tUmVzb2x2ZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYWNjb3VudHMsIHJlc29sdmVkIH0gPSBhd2FpdCB0aGlzLl9jdXN0b21SZXNvbHZlcih7XG4gICAgICAgICAgICAgICAgYXJnczogdGhpcy5fYXJncyxcbiAgICAgICAgICAgICAgICBhY2NvdW50czogdGhpcy5fYWNjb3VudHMsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXMuX3Byb3ZpZGVyLFxuICAgICAgICAgICAgICAgIHByb2dyYW1JZDogdGhpcy5fcHJvZ3JhbUlkLFxuICAgICAgICAgICAgICAgIGlkbEl4OiB0aGlzLl9pZGxJeCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fYWNjb3VudHMgPSBhY2NvdW50cztcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZSBldmVudCBDUEkgYWNjb3VudHMgYGV2ZW50QXV0aG9yaXR5YCBhbmQgYHByb2dyYW1gLlxuICAgICAqXG4gICAgICogQWNjb3VudHMgd2lsbCBvbmx5IGJlIHJlc29sdmVkIGlmIHRoZXkgYXJlIGRlY2xhcmVkIG5leHQgdG8gZWFjaCBvdGhlciB0b1xuICAgICAqIHJlZHVjZSB0aGUgY2hhbmNlIG9mIG5hbWUgY29sbGlzaW9uLlxuICAgICAqL1xuICAgIHJlc29sdmVFdmVudENwaShhY2NvdW50cywgcGF0aCA9IFtdKSB7XG4gICAgICAgIGZvciAoY29uc3QgaSBpbiBhY2NvdW50cykge1xuICAgICAgICAgICAgY29uc3QgYWNjb3VudE9yQWNjb3VudHMgPSBhY2NvdW50c1tpXTtcbiAgICAgICAgICAgIGlmIChpc0NvbXBvc2l0ZUFjY291bnRzKGFjY291bnRPckFjY291bnRzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZUV2ZW50Q3BpKGFjY291bnRPckFjY291bnRzLmFjY291bnRzLCBbXG4gICAgICAgICAgICAgICAgICAgIC4uLnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRPckFjY291bnRzLm5hbWUsXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBWYWxpZGF0ZSBuZXh0IGluZGV4IGV4aXN0c1xuICAgICAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gK2kgKyAxO1xuICAgICAgICAgICAgaWYgKG5leHRJbmRleCA9PT0gYWNjb3VudHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnROYW1lID0gYWNjb3VudHNbaV0ubmFtZTtcbiAgICAgICAgICAgIGNvbnN0IG5leHROYW1lID0gYWNjb3VudHNbbmV4dEluZGV4XS5uYW1lO1xuICAgICAgICAgICAgLy8gUG9wdWxhdGUgZXZlbnQgQ1BJIGFjY291bnRzIGlmIHRoZXkgZXhpc3RcbiAgICAgICAgICAgIGlmIChjdXJyZW50TmFtZSA9PT0gXCJldmVudEF1dGhvcml0eVwiICYmIG5leHROYW1lID09PSBcInByb2dyYW1cIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQYXRoID0gWy4uLnBhdGgsIGN1cnJlbnROYW1lXTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0UGF0aCA9IFsuLi5wYXRoLCBuZXh0TmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmdldChjdXJyZW50UGF0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQoY3VycmVudFBhdGgsIFB1YmxpY0tleS5maW5kUHJvZ3JhbUFkZHJlc3NTeW5jKFtCdWZmZXIuZnJvbShcIl9fZXZlbnRfYXV0aG9yaXR5XCIpXSwgdGhpcy5fcHJvZ3JhbUlkKVswXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5nZXQobmV4dFBhdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KG5leHRQYXRoLCB0aGlzLl9wcm9ncmFtSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzb2x2ZUNvbnN0KGFjY291bnRzLCBwYXRoID0gW10pIHtcbiAgICAgICAgZm9yIChjb25zdCBhY2NvdW50T3JBY2NvdW50cyBvZiBhY2NvdW50cykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGFjY291bnRPckFjY291bnRzLm5hbWU7XG4gICAgICAgICAgICBpZiAoaXNDb21wb3NpdGVBY2NvdW50cyhhY2NvdW50T3JBY2NvdW50cykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVDb25zdChhY2NvdW50T3JBY2NvdW50cy5hY2NvdW50cywgWy4uLnBhdGgsIG5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjY291bnQgPSBhY2NvdW50T3JBY2NvdW50cztcbiAgICAgICAgICAgICAgICBpZiAoKGFjY291bnQuc2lnbmVyIHx8IGFjY291bnQuYWRkcmVzcykgJiYgIXRoaXMuZ2V0KFsuLi5wYXRoLCBuYW1lXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdCBzaWduZXJzIHRvIHRoZSBwcm92aWRlclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWNjb3VudC5zaWduZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcHJvdmlkZXIud2FsbGV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBmdW5jdGlvbiByZXF1aXJlcyB0aGUgYFByb3ZpZGVyYCBpbnRlcmZhY2UgaW1wbGVtZW50b3IgdG8gaGF2ZSBhIGB3YWxsZXRgIGZpZWxkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KFsuLi5wYXRoLCBuYW1lXSwgdGhpcy5fcHJvdmlkZXIud2FsbGV0LnB1YmxpY0tleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGJhc2VkIG9uIGBhZGRyZXNzYCBmaWVsZFxuICAgICAgICAgICAgICAgICAgICBpZiAoYWNjb3VudC5hZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldChbLi4ucGF0aCwgbmFtZV0sIHRyYW5zbGF0ZUFkZHJlc3MoYWNjb3VudC5hZGRyZXNzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmVzb2x2ZVBkYXNBbmRSZWxhdGlvbnMoYWNjb3VudHMsIHBhdGggPSBbXSkge1xuICAgICAgICBsZXQgZm91bmQgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGFjY291bnRPckFjY291bnRzIG9mIGFjY291bnRzKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gYWNjb3VudE9yQWNjb3VudHMubmFtZTtcbiAgICAgICAgICAgIGlmIChpc0NvbXBvc2l0ZUFjY291bnRzKGFjY291bnRPckFjY291bnRzKSkge1xuICAgICAgICAgICAgICAgIGZvdW5kICs9IGF3YWl0IHRoaXMucmVzb2x2ZVBkYXNBbmRSZWxhdGlvbnMoYWNjb3VudE9yQWNjb3VudHMuYWNjb3VudHMsIFsuLi5wYXRoLCBuYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhY2NvdW50ID0gYWNjb3VudE9yQWNjb3VudHM7XG4gICAgICAgICAgICAgICAgaWYgKChhY2NvdW50LnBkYSB8fCBhY2NvdW50LnJlbGF0aW9ucykgJiYgIXRoaXMuZ2V0KFsuLi5wYXRoLCBuYW1lXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQrKztcbiAgICAgICAgICAgICAgICAgICAgLy8gQWNjb3VudHMgbWlnaHQgbm90IGdldCByZXNvbHZlZCBzdWNjZXNzZnVsbHkgaWYgYSBzZWVkIGRlcGVuZHMgb25cbiAgICAgICAgICAgICAgICAgICAgLy8gYW5vdGhlciBzZWVkIHRvIGJlIHJlc29sdmVkICphbmQqIHRoZSBhY2NvdW50cyBmb3IgcmVzb2x1dGlvbiBhcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gb3V0IG9mIG9yZGVyLiBJbiB0aGlzIGNhc2UsIHNraXAgdGhlIGFjY291bnRzIHRoYXQgdGhyb3cgaW4gb3JkZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gcmVzb2x2ZSB0aG9zZSBhY2NvdW50cyBsYXRlci5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhY2NvdW50LnBkYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlZWRzID0gYXdhaXQgUHJvbWlzZS5hbGwoYWNjb3VudC5wZGEuc2VlZHMubWFwKChzZWVkKSA9PiB0aGlzLnRvQnVmZmVyKHNlZWQsIHBhdGgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlZWRzLnNvbWUoKHNlZWQpID0+ICFzZWVkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvZ3JhbUlkID0gYXdhaXQgdGhpcy5wYXJzZVByb2dyYW1JZChhY2NvdW50LCBwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbcHVia2V5XSA9IFB1YmxpY0tleS5maW5kUHJvZ3JhbUFkZHJlc3NTeW5jKHNlZWRzLCBwcm9ncmFtSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KFsuLi5wYXRoLCBuYW1lXSwgcHVia2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCB7IH1cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhY2NvdW50LnJlbGF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFjY291bnRLZXkgPSB0aGlzLmdldChbLi4ucGF0aCwgYWNjb3VudC5yZWxhdGlvbnNbMF1dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWNjb3VudEtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgdGhpcy5fYWNjb3VudFN0b3JlLmZldGNoQWNjb3VudCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWJsaWNLZXk6IGFjY291bnRLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldChbLi4ucGF0aCwgbmFtZV0sIGFjY291bnRbbmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCB7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgICBhc3luYyBwYXJzZVByb2dyYW1JZChhY2NvdW50LCBwYXRoID0gW10pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoISgoX2EgPSBhY2NvdW50LnBkYSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByb2dyYW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvZ3JhbUlkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZiA9IGF3YWl0IHRoaXMudG9CdWZmZXIoYWNjb3VudC5wZGEucHJvZ3JhbSwgcGF0aCk7XG4gICAgICAgIGlmICghYnVmKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb2dyYW0gc2VlZCBub3QgcmVzb2x2ZWQ6ICR7YWNjb3VudC5uYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHVibGljS2V5KGJ1Zik7XG4gICAgfVxuICAgIGFzeW5jIHRvQnVmZmVyKHNlZWQsIHBhdGggPSBbXSkge1xuICAgICAgICBzd2l0Y2ggKHNlZWQua2luZCkge1xuICAgICAgICAgICAgY2FzZSBcImNvbnN0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9CdWZmZXJDb25zdChzZWVkKTtcbiAgICAgICAgICAgIGNhc2UgXCJhcmdcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50b0J1ZmZlckFyZyhzZWVkKTtcbiAgICAgICAgICAgIGNhc2UgXCJhY2NvdW50XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudG9CdWZmZXJBY2NvdW50KHNlZWQsIHBhdGgpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgc2VlZDogJHtzZWVkfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvQnVmZmVyQ29uc3Qoc2VlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0J1ZmZlclZhbHVlKFwiYnl0ZXNcIiwgc2VlZC52YWx1ZSk7XG4gICAgfVxuICAgIGFzeW5jIHRvQnVmZmVyQXJnKHNlZWQpIHtcbiAgICAgICAgY29uc3QgW25hbWUsIC4uLnBhdGhdID0gc2VlZC5wYXRoLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9pZGxJeC5hcmdzLmZpbmRJbmRleCgoYXJnKSA9PiBhcmcubmFtZSA9PT0gbmFtZSk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGZpbmQgYXJndW1lbnQgZm9yIHNlZWQ6ICR7bmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHBhdGgucmVkdWNlKChhY2MsIHBhdGgpID0+IChhY2MgIT09IG51bGwgJiYgYWNjICE9PSB2b2lkIDAgPyBhY2MgOiB7fSlbcGF0aF0sIHRoaXMuX2FyZ3NbaW5kZXhdKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKHRoaXMuX2lkbEl4LmFyZ3NbaW5kZXhdLnR5cGUsIHBhdGgpO1xuICAgICAgICByZXR1cm4gdGhpcy50b0J1ZmZlclZhbHVlKHR5cGUsIHZhbHVlKTtcbiAgICB9XG4gICAgYXN5bmMgdG9CdWZmZXJBY2NvdW50KHNlZWQsIHBhdGggPSBbXSkge1xuICAgICAgICBjb25zdCBbbmFtZSwgLi4ucGF0aHNdID0gc2VlZC5wYXRoLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgY29uc3QgZmllbGRQdWJrZXkgPSB0aGlzLmdldChbLi4ucGF0aCwgbmFtZV0pO1xuICAgICAgICBpZiAoIWZpZWxkUHVia2V5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBUaGUgc2VlZCBpcyBhIHB1YmtleSBvZiB0aGUgYWNjb3VudC5cbiAgICAgICAgaWYgKCFwYXRocy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQnVmZmVyVmFsdWUoXCJwdWJrZXlcIiwgZmllbGRQdWJrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2VlZC5hY2NvdW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlZWQgYWNjb3VudCBpcyByZXF1aXJlZCBpbiBvcmRlciB0byByZXNvbHZlIHR5cGU6ICR7c2VlZC5wYXRofWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBrZXkgaXMgYWNjb3VudCBkYXRhLlxuICAgICAgICAvL1xuICAgICAgICAvLyBGZXRjaCBhbmQgZGVzZXJpYWxpemUgaXQuXG4gICAgICAgIGNvbnN0IGFjY291bnQgPSBhd2FpdCB0aGlzLl9hY2NvdW50U3RvcmUuZmV0Y2hBY2NvdW50KHtcbiAgICAgICAgICAgIHB1YmxpY0tleTogZmllbGRQdWJrZXksXG4gICAgICAgICAgICBuYW1lOiBzZWVkLmFjY291bnQsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBEZXJlZmVyZW5jZSBhbGwgZmllbGRzIGluIHRoZSBwYXRoIHRvIGdldCB0aGUgZmllbGQgdmFsdWVcbiAgICAgICAgLy8gdXNlZCBpbiB0aGUgc2VlZC5cbiAgICAgICAgbGV0IGFjY291bnRWYWx1ZSA9IGFjY291bnQ7XG4gICAgICAgIGxldCBjdXJyZW50UGF0aHMgPSBwYXRocztcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRQYXRocy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBhY2NvdW50VmFsdWUgPSBhY2NvdW50VmFsdWVbY3VycmVudFBhdGhzWzBdXTtcbiAgICAgICAgICAgIGN1cnJlbnRQYXRocyA9IGN1cnJlbnRQYXRocy5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWNjb3VudFZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoeyBkZWZpbmVkOiB7IG5hbWU6IHNlZWQuYWNjb3VudCB9IH0sIHBhdGhzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9CdWZmZXJWYWx1ZSh0eXBlLCBhY2NvdW50VmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gaWRsIHZhbGF1ZSBpbnRvIGEgQnVmZmVyLiBUaGUgdmFsdWVzIGhlcmUgbXVzdCBiZVxuICAgICAqIHByaW1pdGl2ZXMsIGUuZy4gbm8gc3RydWN0cy5cbiAgICAgKi9cbiAgICB0b0J1ZmZlclZhbHVlKHR5cGUsIHZhbHVlKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInU4XCI6XG4gICAgICAgICAgICBjYXNlIFwiaThcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oW3ZhbHVlXSk7XG4gICAgICAgICAgICBjYXNlIFwidTE2XCI6XG4gICAgICAgICAgICBjYXNlIFwiaTE2XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCTih2YWx1ZSkudG9BcnJheUxpa2UoQnVmZmVyLCBcImxlXCIsIDIpO1xuICAgICAgICAgICAgY2FzZSBcInUzMlwiOlxuICAgICAgICAgICAgY2FzZSBcImkzMlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQk4odmFsdWUpLnRvQXJyYXlMaWtlKEJ1ZmZlciwgXCJsZVwiLCA0KTtcbiAgICAgICAgICAgIGNhc2UgXCJ1NjRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJpNjRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJOKHZhbHVlKS50b0FycmF5TGlrZShCdWZmZXIsIFwibGVcIiwgOCk7XG4gICAgICAgICAgICBjYXNlIFwidTEyOFwiOlxuICAgICAgICAgICAgY2FzZSBcImkxMjhcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJOKHZhbHVlKS50b0FycmF5TGlrZShCdWZmZXIsIFwibGVcIiwgMTYpO1xuICAgICAgICAgICAgY2FzZSBcInUyNTZcIjpcbiAgICAgICAgICAgIGNhc2UgXCJpMjU2XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCTih2YWx1ZSkudG9BcnJheUxpa2UoQnVmZmVyLCBcImxlXCIsIDMyKTtcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUpO1xuICAgICAgICAgICAgY2FzZSBcInB1YmtleVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b0J1ZmZlcigpO1xuICAgICAgICAgICAgY2FzZSBcImJ5dGVzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHlwZS5hcnJheSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgc2VlZCB0eXBlOiAke3R5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgZ2V0IHRoZSB0eXBlIGF0IHNvbWUgcGF0aCBvZiBlaXRoZXIgYSBwcmltaXRpdmUgb3IgYSB1c2VyXG4gICAgICogZGVmaW5lZCBzdHJ1Y3QuXG4gICAgICovXG4gICAgZ2V0VHlwZSh0eXBlLCBwYXRoID0gW10pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB0eXBlTmFtZSA9IChfYSA9IHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHlwZS5kZWZpbmVkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZTtcbiAgICAgICAgaWYgKHR5cGVOYW1lKSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgdG9rZW4gYWNjb3VudCBzZXBhcmF0ZWx5XG4gICAgICAgICAgICBpZiAodHlwZU5hbWUgPT09IFwidG9rZW5BY2NvdW50XCIpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHBhdGguYXQoMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1pbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm93bmVyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJwdWJrZXlcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFtb3VudFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGVsYWdhdGVkQW1vdW50XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ1NjRcIjtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biB0b2tlbiBhY2NvdW50IHBhdGg6ICR7cGF0aH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZWZpbmVkVHlwZSA9IHRoaXMuX2lkbFR5cGVzLmZpbmQoKHQpID0+IHQubmFtZSA9PT0gdHlwZU5hbWUpO1xuICAgICAgICAgICAgaWYgKCFkZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVHlwZSBub3QgZm91bmQ6ICR7dHlwZU5hbWV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPbmx5IG5hbWVkIHN0cnVjdHMgYXJlIHN1cHBvcnRlZFxuICAgICAgICAgICAgY29uc3QgW2ZpZWxkTmFtZSwgLi4uc3ViUGF0aF0gPSBwYXRoO1xuICAgICAgICAgICAgY29uc3QgZmllbGRzID0gZGVmaW5lZFR5cGUudHlwZVxuICAgICAgICAgICAgICAgIC5maWVsZHM7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IGZpZWxkcy5maW5kKChmaWVsZCkgPT4gZmllbGQubmFtZSA9PT0gZmllbGROYW1lKTtcbiAgICAgICAgICAgIGlmICghZmllbGQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpZWxkIG5vdCBmb3VuZDogJHtmaWVsZE5hbWV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlKGZpZWxkLnR5cGUsIHN1YlBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbn1cbi8vIFRPRE86IHRoaXMgc2hvdWxkIGJlIGNvbmZpZ3VyYWJsZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSByZXF1ZXN0cy5cbmNsYXNzIEFjY291bnRTdG9yZSB7XG4gICAgY29uc3RydWN0b3IoX3Byb3ZpZGVyLCBhY2NvdW50cywgcHJvZ3JhbUlkKSB7XG4gICAgICAgIHRoaXMuX3Byb3ZpZGVyID0gX3Byb3ZpZGVyO1xuICAgICAgICB0aGlzLl9jYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5faWRscyA9IHt9O1xuICAgICAgICB0aGlzLl9pZGxzW3Byb2dyYW1JZC50b0Jhc2U1OCgpXSA9IGFjY291bnRzO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaEFjY291bnQoeyBwdWJsaWNLZXksIG5hbWUsIH0pIHtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IHB1YmxpY0tleS50b0Jhc2U1OCgpO1xuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlLmhhcyhhZGRyZXNzKSkge1xuICAgICAgICAgICAgY29uc3QgYWNjb3VudEluZm8gPSBhd2FpdCB0aGlzLl9wcm92aWRlci5jb25uZWN0aW9uLmdldEFjY291bnRJbmZvKHB1YmxpY0tleSk7XG4gICAgICAgICAgICBpZiAoYWNjb3VudEluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFjY291bnQgbm90IGZvdW5kOiAke2FkZHJlc3N9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gXCJ0b2tlbkFjY291bnRcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjY291bnQgPSBkZWNvZGVUb2tlbkFjY291bnQoYWNjb3VudEluZm8uZGF0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGUuc2V0KGFkZHJlc3MsIGFjY291bnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCB0aGlzLmdldEFjY291bnRzTnMoYWNjb3VudEluZm8ub3duZXIpO1xuICAgICAgICAgICAgICAgIGlmIChhY2NvdW50cykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhY2NvdW50TnMgPSBPYmplY3QudmFsdWVzKGFjY291bnRzKVswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjY291bnROcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWNjb3VudCA9IGFjY291bnROcy5jb2Rlci5hY2NvdW50cy5kZWNvZGVBbnkoYWNjb3VudEluZm8uZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5zZXQoYWRkcmVzcywgYWNjb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlLmdldChhZGRyZXNzKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QWNjb3VudHNOcyhwcm9ncmFtSWQpIHtcbiAgICAgICAgY29uc3QgcHJvZ3JhbUlkU3RyID0gcHJvZ3JhbUlkLnRvQmFzZTU4KCk7XG4gICAgICAgIGlmICghdGhpcy5faWRsc1twcm9ncmFtSWRTdHJdKSB7XG4gICAgICAgICAgICBjb25zdCBpZGwgPSBhd2FpdCBQcm9ncmFtLmZldGNoSWRsKHByb2dyYW1JZCwgdGhpcy5fcHJvdmlkZXIpO1xuICAgICAgICAgICAgaWYgKGlkbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb2dyYW0gPSBuZXcgUHJvZ3JhbShpZGwsIHRoaXMuX3Byb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pZGxzW3Byb2dyYW1JZFN0cl0gPSBwcm9ncmFtLmFjY291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkbHNbcHJvZ3JhbUlkU3RyXTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY2NvdW50cy1yZXNvbHZlci5qcy5tYXAiXSwibmFtZXMiOlsiQk4iLCJQdWJsaWNLZXkiLCJpc0NvbXBvc2l0ZUFjY291bnRzIiwiZGVjb2RlVG9rZW5BY2NvdW50IiwiUHJvZ3JhbSIsInRyYW5zbGF0ZUFkZHJlc3MiLCJmbGF0dGVuUGFydGlhbEFjY291bnRzIiwiaXNQYXJ0aWFsQWNjb3VudHMiLCJpc0FjY291bnRzR2VuZXJpYyIsImFjY291bnRzIiwiQWNjb3VudHNSZXNvbHZlciIsImNvbnN0cnVjdG9yIiwiX2FyZ3MiLCJfYWNjb3VudHMiLCJfcHJvdmlkZXIiLCJfcHJvZ3JhbUlkIiwiX2lkbEl4IiwiYWNjb3VudE5hbWVzcGFjZSIsIl9pZGxUeXBlcyIsIl9jdXN0b21SZXNvbHZlciIsIl9hY2NvdW50U3RvcmUiLCJBY2NvdW50U3RvcmUiLCJhcmdzIiwicmVzb2x2ZSIsInJlc29sdmVFdmVudENwaSIsInJlc29sdmVDb25zdCIsImRlcHRoIiwicmVzb2x2ZVBkYXNBbmRSZWxhdGlvbnMiLCJyZXNvbHZlQ3VzdG9tIiwiRXJyb3IiLCJyZXNvbHZlT3B0aW9uYWxzIiwiT2JqZWN0IiwiYXNzaWduIiwicmVzb2x2ZU9wdGlvbmFsc0hlbHBlciIsImdldCIsInBhdGgiLCJyZXQiLCJyZWR1Y2UiLCJhY2MiLCJzdWJQYXRoIiwidG9CYXNlNTgiLCJzZXQiLCJ2YWx1ZSIsImN1ciIsImZvckVhY2giLCJwIiwiaSIsIl9hIiwiaXNMYXN0IiwibGVuZ3RoIiwicGFydGlhbEFjY291bnRzIiwibmVzdGVkQWNjb3VudHNHZW5lcmljIiwiYWNjb3VudEl0ZW0iLCJhY2NvdW50TmFtZSIsIm5hbWUiLCJwYXJ0aWFsQWNjb3VudCIsInVuZGVmaW5lZCIsInJlc29sdmVkIiwicHJvdmlkZXIiLCJwcm9ncmFtSWQiLCJpZGxJeCIsImFjY291bnRPckFjY291bnRzIiwibmV4dEluZGV4IiwiY3VycmVudE5hbWUiLCJuZXh0TmFtZSIsImN1cnJlbnRQYXRoIiwibmV4dFBhdGgiLCJmaW5kUHJvZ3JhbUFkZHJlc3NTeW5jIiwiQnVmZmVyIiwiZnJvbSIsImFjY291bnQiLCJzaWduZXIiLCJhZGRyZXNzIiwid2FsbGV0IiwicHVibGljS2V5IiwiZm91bmQiLCJwZGEiLCJyZWxhdGlvbnMiLCJzZWVkcyIsIlByb21pc2UiLCJhbGwiLCJtYXAiLCJzZWVkIiwidG9CdWZmZXIiLCJzb21lIiwicGFyc2VQcm9ncmFtSWQiLCJwdWJrZXkiLCJhY2NvdW50S2V5IiwiZmV0Y2hBY2NvdW50IiwicHJvZ3JhbSIsImJ1ZiIsImtpbmQiLCJ0b0J1ZmZlckNvbnN0IiwidG9CdWZmZXJBcmciLCJ0b0J1ZmZlckFjY291bnQiLCJ0b0J1ZmZlclZhbHVlIiwic3BsaXQiLCJpbmRleCIsImZpbmRJbmRleCIsImFyZyIsInR5cGUiLCJnZXRUeXBlIiwicGF0aHMiLCJmaWVsZFB1YmtleSIsImFjY291bnRWYWx1ZSIsImN1cnJlbnRQYXRocyIsInNsaWNlIiwiZGVmaW5lZCIsInRvQXJyYXlMaWtlIiwiYXJyYXkiLCJ0eXBlTmFtZSIsImF0IiwiZGVmaW5lZFR5cGUiLCJmaW5kIiwidCIsImZpZWxkTmFtZSIsImZpZWxkcyIsImZpZWxkIiwiX2NhY2hlIiwiTWFwIiwiX2lkbHMiLCJoYXMiLCJhY2NvdW50SW5mbyIsImNvbm5lY3Rpb24iLCJnZXRBY2NvdW50SW5mbyIsImRhdGEiLCJnZXRBY2NvdW50c05zIiwib3duZXIiLCJhY2NvdW50TnMiLCJ2YWx1ZXMiLCJjb2RlciIsImRlY29kZUFueSIsInByb2dyYW1JZFN0ciIsImlkbCIsImZldGNoSWRsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/accounts-resolver.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/common.js":
/*!********************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/program/common.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseIdlErrors: () => (/* binding */ parseIdlErrors),\n/* harmony export */   toInstruction: () => (/* binding */ toInstruction),\n/* harmony export */   translateAddress: () => (/* binding */ translateAddress),\n/* harmony export */   validateAccounts: () => (/* binding */ validateAccounts)\n/* harmony export */ });\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/node_modules/@solana/web3.js/lib/index.esm.js\");\n/* harmony import */ var _idl_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../idl.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/idl.js\");\n\n\nfunction parseIdlErrors(idl) {\n    const errors = new Map();\n    if (idl.errors) {\n        idl.errors.forEach((e)=>{\n            var _a;\n            let msg = (_a = e.msg) !== null && _a !== void 0 ? _a : e.name;\n            errors.set(e.code, msg);\n        });\n    }\n    return errors;\n}\nfunction toInstruction(idlIx, ...args) {\n    if (idlIx.args.length != args.length) {\n        throw new Error(\"Invalid argument length\");\n    }\n    const ix = {};\n    let idx = 0;\n    idlIx.args.forEach((ixArg)=>{\n        ix[ixArg.name] = args[idx];\n        idx += 1;\n    });\n    return ix;\n}\n// Throws error if any account required for the `ix` is not given.\nfunction validateAccounts(ixAccounts, accounts = {}) {\n    ixAccounts.forEach((acc)=>{\n        if ((0,_idl_js__WEBPACK_IMPORTED_MODULE_1__.isCompositeAccounts)(acc)) {\n            validateAccounts(acc.accounts, accounts[acc.name]);\n        } else {\n            if (!accounts[acc.name]) {\n                throw new Error(`Account \\`${acc.name}\\` not provided.`);\n            }\n        }\n    });\n}\n// Translates an address to a Pubkey.\nfunction translateAddress(address) {\n    return address instanceof _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey ? address : new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(address);\n} //# sourceMappingURL=common.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3Byb2dyYW0vY29tbW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE0QztBQUNLO0FBQzFDLFNBQVNFLGVBQWVDLEdBQUc7SUFDOUIsTUFBTUMsU0FBUyxJQUFJQztJQUNuQixJQUFJRixJQUFJQyxNQUFNLEVBQUU7UUFDWkQsSUFBSUMsTUFBTSxDQUFDRSxPQUFPLENBQUMsQ0FBQ0M7WUFDaEIsSUFBSUM7WUFDSixJQUFJQyxNQUFNLENBQUNELEtBQUtELEVBQUVFLEdBQUcsTUFBTSxRQUFRRCxPQUFPLEtBQUssSUFBSUEsS0FBS0QsRUFBRUcsSUFBSTtZQUM5RE4sT0FBT08sR0FBRyxDQUFDSixFQUFFSyxJQUFJLEVBQUVIO1FBQ3ZCO0lBQ0o7SUFDQSxPQUFPTDtBQUNYO0FBQ08sU0FBU1MsY0FBY0MsS0FBSyxFQUFFLEdBQUdDLElBQUk7SUFDeEMsSUFBSUQsTUFBTUMsSUFBSSxDQUFDQyxNQUFNLElBQUlELEtBQUtDLE1BQU0sRUFBRTtRQUNsQyxNQUFNLElBQUlDLE1BQU07SUFDcEI7SUFDQSxNQUFNQyxLQUFLLENBQUM7SUFDWixJQUFJQyxNQUFNO0lBQ1ZMLE1BQU1DLElBQUksQ0FBQ1QsT0FBTyxDQUFDLENBQUNjO1FBQ2hCRixFQUFFLENBQUNFLE1BQU1WLElBQUksQ0FBQyxHQUFHSyxJQUFJLENBQUNJLElBQUk7UUFDMUJBLE9BQU87SUFDWDtJQUNBLE9BQU9EO0FBQ1g7QUFDQSxrRUFBa0U7QUFDM0QsU0FBU0csaUJBQWlCQyxVQUFVLEVBQUVDLFdBQVcsQ0FBQyxDQUFDO0lBQ3RERCxXQUFXaEIsT0FBTyxDQUFDLENBQUNrQjtRQUNoQixJQUFJdkIsNERBQW1CQSxDQUFDdUIsTUFBTTtZQUMxQkgsaUJBQWlCRyxJQUFJRCxRQUFRLEVBQUVBLFFBQVEsQ0FBQ0MsSUFBSWQsSUFBSSxDQUFDO1FBQ3JELE9BQ0s7WUFDRCxJQUFJLENBQUNhLFFBQVEsQ0FBQ0MsSUFBSWQsSUFBSSxDQUFDLEVBQUU7Z0JBQ3JCLE1BQU0sSUFBSU8sTUFBTSxDQUFDLFVBQVUsRUFBRU8sSUFBSWQsSUFBSSxDQUFDLGdCQUFnQixDQUFDO1lBQzNEO1FBQ0o7SUFDSjtBQUNKO0FBQ0EscUNBQXFDO0FBQzlCLFNBQVNlLGlCQUFpQkMsT0FBTztJQUNwQyxPQUFPQSxtQkFBbUIxQixzREFBU0EsR0FBRzBCLFVBQVUsSUFBSTFCLHNEQUFTQSxDQUFDMEI7QUFDbEUsRUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3Byb2dyYW0vY29tbW9uLmpzPzQ4MTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUHVibGljS2V5IH0gZnJvbSBcIkBzb2xhbmEvd2ViMy5qc1wiO1xuaW1wb3J0IHsgaXNDb21wb3NpdGVBY2NvdW50cywgfSBmcm9tIFwiLi4vaWRsLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VJZGxFcnJvcnMoaWRsKSB7XG4gICAgY29uc3QgZXJyb3JzID0gbmV3IE1hcCgpO1xuICAgIGlmIChpZGwuZXJyb3JzKSB7XG4gICAgICAgIGlkbC5lcnJvcnMuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgbGV0IG1zZyA9IChfYSA9IGUubXNnKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBlLm5hbWU7XG4gICAgICAgICAgICBlcnJvcnMuc2V0KGUuY29kZSwgbXNnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnM7XG59XG5leHBvcnQgZnVuY3Rpb24gdG9JbnN0cnVjdGlvbihpZGxJeCwgLi4uYXJncykge1xuICAgIGlmIChpZGxJeC5hcmdzLmxlbmd0aCAhPSBhcmdzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50IGxlbmd0aFwiKTtcbiAgICB9XG4gICAgY29uc3QgaXggPSB7fTtcbiAgICBsZXQgaWR4ID0gMDtcbiAgICBpZGxJeC5hcmdzLmZvckVhY2goKGl4QXJnKSA9PiB7XG4gICAgICAgIGl4W2l4QXJnLm5hbWVdID0gYXJnc1tpZHhdO1xuICAgICAgICBpZHggKz0gMTtcbiAgICB9KTtcbiAgICByZXR1cm4gaXg7XG59XG4vLyBUaHJvd3MgZXJyb3IgaWYgYW55IGFjY291bnQgcmVxdWlyZWQgZm9yIHRoZSBgaXhgIGlzIG5vdCBnaXZlbi5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUFjY291bnRzKGl4QWNjb3VudHMsIGFjY291bnRzID0ge30pIHtcbiAgICBpeEFjY291bnRzLmZvckVhY2goKGFjYykgPT4ge1xuICAgICAgICBpZiAoaXNDb21wb3NpdGVBY2NvdW50cyhhY2MpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUFjY291bnRzKGFjYy5hY2NvdW50cywgYWNjb3VudHNbYWNjLm5hbWVdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghYWNjb3VudHNbYWNjLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBY2NvdW50IFxcYCR7YWNjLm5hbWV9XFxgIG5vdCBwcm92aWRlZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuLy8gVHJhbnNsYXRlcyBhbiBhZGRyZXNzIHRvIGEgUHVia2V5LlxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZUFkZHJlc3MoYWRkcmVzcykge1xuICAgIHJldHVybiBhZGRyZXNzIGluc3RhbmNlb2YgUHVibGljS2V5ID8gYWRkcmVzcyA6IG5ldyBQdWJsaWNLZXkoYWRkcmVzcyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb24uanMubWFwIl0sIm5hbWVzIjpbIlB1YmxpY0tleSIsImlzQ29tcG9zaXRlQWNjb3VudHMiLCJwYXJzZUlkbEVycm9ycyIsImlkbCIsImVycm9ycyIsIk1hcCIsImZvckVhY2giLCJlIiwiX2EiLCJtc2ciLCJuYW1lIiwic2V0IiwiY29kZSIsInRvSW5zdHJ1Y3Rpb24iLCJpZGxJeCIsImFyZ3MiLCJsZW5ndGgiLCJFcnJvciIsIml4IiwiaWR4IiwiaXhBcmciLCJ2YWxpZGF0ZUFjY291bnRzIiwiaXhBY2NvdW50cyIsImFjY291bnRzIiwiYWNjIiwidHJhbnNsYXRlQWRkcmVzcyIsImFkZHJlc3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/common.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/context.js":
/*!*********************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/program/context.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   splitArgsAndCtx: () => (/* binding */ splitArgsAndCtx)\n/* harmony export */ });\nfunction splitArgsAndCtx(idlIx, args) {\n    var _a, _b;\n    let options = {};\n    const inputLen = idlIx.args ? idlIx.args.length : 0;\n    if (args.length > inputLen) {\n        if (args.length !== inputLen + 1) {\n            throw new Error(`provided too many arguments ${args} to instruction ${idlIx === null || idlIx === void 0 ? void 0 : idlIx.name} expecting: ${(_b = (_a = idlIx.args) === null || _a === void 0 ? void 0 : _a.map((a)=>a.name)) !== null && _b !== void 0 ? _b : []}`);\n        }\n        options = args.pop();\n    }\n    return [\n        args,\n        options\n    ];\n} //# sourceMappingURL=context.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3Byb2dyYW0vY29udGV4dC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sU0FBU0EsZ0JBQWdCQyxLQUFLLEVBQUVDLElBQUk7SUFDdkMsSUFBSUMsSUFBSUM7SUFDUixJQUFJQyxVQUFVLENBQUM7SUFDZixNQUFNQyxXQUFXTCxNQUFNQyxJQUFJLEdBQUdELE1BQU1DLElBQUksQ0FBQ0ssTUFBTSxHQUFHO0lBQ2xELElBQUlMLEtBQUtLLE1BQU0sR0FBR0QsVUFBVTtRQUN4QixJQUFJSixLQUFLSyxNQUFNLEtBQUtELFdBQVcsR0FBRztZQUM5QixNQUFNLElBQUlFLE1BQU0sQ0FBQyw0QkFBNEIsRUFBRU4sS0FBSyxnQkFBZ0IsRUFBRUQsVUFBVSxRQUFRQSxVQUFVLEtBQUssSUFBSSxLQUFLLElBQUlBLE1BQU1RLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQ0wsS0FBSyxDQUFDRCxLQUFLRixNQUFNQyxJQUFJLE1BQU0sUUFBUUMsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHTyxHQUFHLENBQUMsQ0FBQ0MsSUFBTUEsRUFBRUYsSUFBSSxPQUFPLFFBQVFMLE9BQU8sS0FBSyxJQUFJQSxLQUFLLEVBQUUsQ0FBQyxDQUFDO1FBQzFRO1FBQ0FDLFVBQVVILEtBQUtVLEdBQUc7SUFDdEI7SUFDQSxPQUFPO1FBQUNWO1FBQU1HO0tBQVE7QUFDMUIsRUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3Byb2dyYW0vY29udGV4dC5qcz9hZDZjIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBzcGxpdEFyZ3NBbmRDdHgoaWRsSXgsIGFyZ3MpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGxldCBvcHRpb25zID0ge307XG4gICAgY29uc3QgaW5wdXRMZW4gPSBpZGxJeC5hcmdzID8gaWRsSXguYXJncy5sZW5ndGggOiAwO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IGlucHV0TGVuKSB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gaW5wdXRMZW4gKyAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHByb3ZpZGVkIHRvbyBtYW55IGFyZ3VtZW50cyAke2FyZ3N9IHRvIGluc3RydWN0aW9uICR7aWRsSXggPT09IG51bGwgfHwgaWRsSXggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlkbEl4Lm5hbWV9IGV4cGVjdGluZzogJHsoX2IgPSAoX2EgPSBpZGxJeC5hcmdzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChhKSA9PiBhLm5hbWUpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXX1gKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zID0gYXJncy5wb3AoKTtcbiAgICB9XG4gICAgcmV0dXJuIFthcmdzLCBvcHRpb25zXTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnRleHQuanMubWFwIl0sIm5hbWVzIjpbInNwbGl0QXJnc0FuZEN0eCIsImlkbEl4IiwiYXJncyIsIl9hIiwiX2IiLCJvcHRpb25zIiwiaW5wdXRMZW4iLCJsZW5ndGgiLCJFcnJvciIsIm5hbWUiLCJtYXAiLCJhIiwicG9wIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/context.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/event.js":
/*!*******************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/program/event.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventManager: () => (/* binding */ EventManager),\n/* harmony export */   EventParser: () => (/* binding */ EventParser)\n/* harmony export */ });\nconst PROGRAM_LOG = \"Program log: \";\nconst PROGRAM_DATA = \"Program data: \";\nconst PROGRAM_LOG_START_INDEX = PROGRAM_LOG.length;\nconst PROGRAM_DATA_START_INDEX = PROGRAM_DATA.length;\nclass EventManager {\n    constructor(programId, provider, coder){\n        this._programId = programId;\n        this._provider = provider;\n        this._eventParser = new EventParser(programId, coder);\n        this._eventCallbacks = new Map();\n        this._eventListeners = new Map();\n        this._listenerIdCount = 0;\n    }\n    addEventListener(eventName, callback) {\n        var _a;\n        let listener = this._listenerIdCount;\n        this._listenerIdCount += 1;\n        // Store the listener into the event map.\n        if (!this._eventListeners.has(eventName)) {\n            this._eventListeners.set(eventName, []);\n        }\n        this._eventListeners.set(eventName, ((_a = this._eventListeners.get(eventName)) !== null && _a !== void 0 ? _a : []).concat(listener));\n        // Store the callback into the listener map.\n        this._eventCallbacks.set(listener, [\n            eventName,\n            callback\n        ]);\n        // Create the subscription singleton, if needed.\n        if (this._onLogsSubscriptionId !== undefined) {\n            return listener;\n        }\n        this._onLogsSubscriptionId = this._provider.connection.onLogs(this._programId, (logs, ctx)=>{\n            if (logs.err) {\n                return;\n            }\n            for (const event of this._eventParser.parseLogs(logs.logs)){\n                const allListeners = this._eventListeners.get(event.name);\n                if (allListeners) {\n                    allListeners.forEach((listener)=>{\n                        const listenerCb = this._eventCallbacks.get(listener);\n                        if (listenerCb) {\n                            const [, callback] = listenerCb;\n                            callback(event.data, ctx.slot, logs.signature);\n                        }\n                    });\n                }\n            }\n        });\n        return listener;\n    }\n    async removeEventListener(listener) {\n        // Get the callback.\n        const callback = this._eventCallbacks.get(listener);\n        if (!callback) {\n            throw new Error(`Event listener ${listener} doesn't exist!`);\n        }\n        const [eventName] = callback;\n        // Get the listeners.\n        let listeners = this._eventListeners.get(eventName);\n        if (!listeners) {\n            throw new Error(`Event listeners don't exist for ${eventName}!`);\n        }\n        // Update both maps.\n        this._eventCallbacks.delete(listener);\n        listeners = listeners.filter((l)=>l !== listener);\n        this._eventListeners.set(eventName, listeners);\n        if (listeners.length === 0) {\n            this._eventListeners.delete(eventName);\n        }\n        // Kill the websocket connection if all listeners have been removed.\n        if (this._eventCallbacks.size === 0) {\n            if (this._eventListeners.size !== 0) {\n                throw new Error(`Expected event listeners size to be 0 but got ${this._eventListeners.size}`);\n            }\n            if (this._onLogsSubscriptionId !== undefined) {\n                await this._provider.connection.removeOnLogsListener(this._onLogsSubscriptionId);\n                this._onLogsSubscriptionId = undefined;\n            }\n        }\n    }\n}\nclass EventParser {\n    constructor(programId, coder){\n        this.coder = coder;\n        this.programId = programId;\n    }\n    // Each log given, represents an array of messages emitted by\n    // a single transaction, which can execute many different programs across\n    // CPI boundaries. However, the subscription is only interested in the\n    // events emitted by *this* program. In achieving this, we keep track of the\n    // program execution context by parsing each log and looking for a CPI\n    // `invoke` call. If one exists, we know a new program is executing. So we\n    // push the programId onto a stack and switch the program context. This\n    // allows us to track, for a given log, which program was executing during\n    // its emission, thereby allowing us to know if a given log event was\n    // emitted by *this* program. If it was, then we parse the raw string and\n    // emit the event if the string matches the event being subscribed to.\n    *parseLogs(logs, errorOnDecodeFailure = false) {\n        const logScanner = new LogScanner(logs);\n        const execution = new ExecutionContext();\n        let log = logScanner.next();\n        while(log !== null){\n            let [event, newProgram, didPop] = this.handleLog(execution, log, errorOnDecodeFailure);\n            if (event) {\n                yield event;\n            }\n            if (newProgram) {\n                execution.push(newProgram);\n            }\n            if (didPop) {\n                execution.pop();\n            }\n            log = logScanner.next();\n        }\n    }\n    // Main log handler. Returns a three element array of the event, the\n    // next program that was invoked for CPI, and a boolean indicating if\n    // a program has completed execution (and thus should be popped off the\n    // execution stack).\n    handleLog(execution, log, errorOnDecodeFailure) {\n        // Executing program is this program.\n        if (execution.stack.length > 0 && execution.program() === this.programId.toString()) {\n            return this.handleProgramLog(log, errorOnDecodeFailure);\n        } else {\n            return [\n                null,\n                ...this.handleSystemLog(log)\n            ];\n        }\n    }\n    // Handles logs from *this* program.\n    handleProgramLog(log, errorOnDecodeFailure) {\n        // This is a `msg!` log or a `sol_log_data` log.\n        if (log.startsWith(PROGRAM_LOG) || log.startsWith(PROGRAM_DATA)) {\n            const logStr = log.startsWith(PROGRAM_LOG) ? log.slice(PROGRAM_LOG_START_INDEX) : log.slice(PROGRAM_DATA_START_INDEX);\n            const event = this.coder.events.decode(logStr);\n            if (errorOnDecodeFailure && event === null) {\n                throw new Error(`Unable to decode event ${logStr}`);\n            }\n            return [\n                event,\n                null,\n                false\n            ];\n        } else {\n            return [\n                null,\n                ...this.handleSystemLog(log)\n            ];\n        }\n    }\n    // Handles logs when the current program being executing is *not* this.\n    handleSystemLog(log) {\n        // System component.\n        const logStart = log.split(\":\")[0];\n        // Did the program finish executing?\n        if (logStart.match(/^Program (.*) success/g) !== null) {\n            return [\n                null,\n                true\n            ];\n        // Recursive call.\n        } else if (logStart.startsWith(`Program ${this.programId.toString()} invoke`)) {\n            return [\n                this.programId.toString(),\n                false\n            ];\n        } else if (logStart.includes(\"invoke\")) {\n            return [\n                \"cpi\",\n                false\n            ]; // Any string will do.\n        } else {\n            return [\n                null,\n                false\n            ];\n        }\n    }\n}\n// Stack frame execution context, allowing one to track what program is\n// executing for a given log.\nclass ExecutionContext {\n    constructor(){\n        this.stack = [];\n    }\n    program() {\n        if (!this.stack.length) {\n            throw new Error(\"Expected the stack to have elements\");\n        }\n        return this.stack[this.stack.length - 1];\n    }\n    push(newProgram) {\n        this.stack.push(newProgram);\n    }\n    pop() {\n        if (!this.stack.length) {\n            throw new Error(\"Expected the stack to have elements\");\n        }\n        this.stack.pop();\n    }\n}\nclass LogScanner {\n    constructor(logs){\n        this.logs = logs;\n    }\n    next() {\n        if (this.logs.length === 0) {\n            return null;\n        }\n        let l = this.logs[0];\n        this.logs = this.logs.slice(1);\n        return l;\n    }\n} //# sourceMappingURL=event.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3Byb2dyYW0vZXZlbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxNQUFNQSxjQUFjO0FBQ3BCLE1BQU1DLGVBQWU7QUFDckIsTUFBTUMsMEJBQTBCRixZQUFZRyxNQUFNO0FBQ2xELE1BQU1DLDJCQUEyQkgsYUFBYUUsTUFBTTtBQUM3QyxNQUFNRTtJQUNUQyxZQUFZQyxTQUFTLEVBQUVDLFFBQVEsRUFBRUMsS0FBSyxDQUFFO1FBQ3BDLElBQUksQ0FBQ0MsVUFBVSxHQUFHSDtRQUNsQixJQUFJLENBQUNJLFNBQVMsR0FBR0g7UUFDakIsSUFBSSxDQUFDSSxZQUFZLEdBQUcsSUFBSUMsWUFBWU4sV0FBV0U7UUFDL0MsSUFBSSxDQUFDSyxlQUFlLEdBQUcsSUFBSUM7UUFDM0IsSUFBSSxDQUFDQyxlQUFlLEdBQUcsSUFBSUQ7UUFDM0IsSUFBSSxDQUFDRSxnQkFBZ0IsR0FBRztJQUM1QjtJQUNBQyxpQkFBaUJDLFNBQVMsRUFBRUMsUUFBUSxFQUFFO1FBQ2xDLElBQUlDO1FBQ0osSUFBSUMsV0FBVyxJQUFJLENBQUNMLGdCQUFnQjtRQUNwQyxJQUFJLENBQUNBLGdCQUFnQixJQUFJO1FBQ3pCLHlDQUF5QztRQUN6QyxJQUFJLENBQUMsSUFBSSxDQUFDRCxlQUFlLENBQUNPLEdBQUcsQ0FBQ0osWUFBWTtZQUN0QyxJQUFJLENBQUNILGVBQWUsQ0FBQ1EsR0FBRyxDQUFDTCxXQUFXLEVBQUU7UUFDMUM7UUFDQSxJQUFJLENBQUNILGVBQWUsQ0FBQ1EsR0FBRyxDQUFDTCxXQUFXLENBQUMsQ0FBQ0UsS0FBSyxJQUFJLENBQUNMLGVBQWUsQ0FBQ1MsR0FBRyxDQUFDTixVQUFTLE1BQU8sUUFBUUUsT0FBTyxLQUFLLElBQUlBLEtBQUssRUFBRSxFQUFFSyxNQUFNLENBQUNKO1FBQzVILDRDQUE0QztRQUM1QyxJQUFJLENBQUNSLGVBQWUsQ0FBQ1UsR0FBRyxDQUFDRixVQUFVO1lB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Q0FBQ0QsS0FBSyxDQUFDNUQsTUFBTSxFQUFFO1lBQ3BCLE1BQU0sSUFBSXlDLE1BQU07UUFDcEI7UUFDQSxPQUFPLElBQUksQ0FBQ21CLEtBQUssQ0FBQyxJQUFJLENBQUNBLEtBQUssQ0FBQzVELE1BQU0sR0FBRyxFQUFFO0lBQzVDO0lBQ0EwRCxLQUFLSCxVQUFVLEVBQUU7UUFDYixJQUFJLENBQUNLLEtBQUssQ0FBQ0YsSUFBSSxDQUFDSDtJQUNwQjtJQUNBSSxNQUFNO1FBQ0YsSUFBSSxDQUFDLElBQUksQ0FBQ0MsS0FBSyxDQUFDNUQsTUFBTSxFQUFFO1lBQ3BCLE1BQU0sSUFBSXlDLE1BQU07UUFDcEI7UUFDQSxJQUFJLENBQUNtQixLQUFLLENBQUNELEdBQUc7SUFDbEI7QUFDSjtBQUNBLE1BQU1UO0lBQ0YvQyxZQUFZeUIsSUFBSSxDQUFFO1FBQ2QsSUFBSSxDQUFDQSxJQUFJLEdBQUdBO0lBQ2hCO0lBQ0EwQixPQUFPO1FBQ0gsSUFBSSxJQUFJLENBQUMxQixJQUFJLENBQUM1QixNQUFNLEtBQUssR0FBRztZQUN4QixPQUFPO1FBQ1g7UUFDQSxJQUFJNkMsSUFBSSxJQUFJLENBQUNqQixJQUFJLENBQUMsRUFBRTtRQUNwQixJQUFJLENBQUNBLElBQUksR0FBRyxJQUFJLENBQUNBLElBQUksQ0FBQ3VDLEtBQUssQ0FBQztRQUM1QixPQUFPdEI7SUFDWDtBQUNKLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AY29yYWwteHl6L2FuY2hvci9kaXN0L2VzbS9wcm9ncmFtL2V2ZW50LmpzPzJmZmEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgUFJPR1JBTV9MT0cgPSBcIlByb2dyYW0gbG9nOiBcIjtcbmNvbnN0IFBST0dSQU1fREFUQSA9IFwiUHJvZ3JhbSBkYXRhOiBcIjtcbmNvbnN0IFBST0dSQU1fTE9HX1NUQVJUX0lOREVYID0gUFJPR1JBTV9MT0cubGVuZ3RoO1xuY29uc3QgUFJPR1JBTV9EQVRBX1NUQVJUX0lOREVYID0gUFJPR1JBTV9EQVRBLmxlbmd0aDtcbmV4cG9ydCBjbGFzcyBFdmVudE1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKHByb2dyYW1JZCwgcHJvdmlkZXIsIGNvZGVyKSB7XG4gICAgICAgIHRoaXMuX3Byb2dyYW1JZCA9IHByb2dyYW1JZDtcbiAgICAgICAgdGhpcy5fcHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgdGhpcy5fZXZlbnRQYXJzZXIgPSBuZXcgRXZlbnRQYXJzZXIocHJvZ3JhbUlkLCBjb2Rlcik7XG4gICAgICAgIHRoaXMuX2V2ZW50Q2FsbGJhY2tzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9ldmVudExpc3RlbmVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJJZENvdW50ID0gMDtcbiAgICB9XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGxpc3RlbmVyID0gdGhpcy5fbGlzdGVuZXJJZENvdW50O1xuICAgICAgICB0aGlzLl9saXN0ZW5lcklkQ291bnQgKz0gMTtcbiAgICAgICAgLy8gU3RvcmUgdGhlIGxpc3RlbmVyIGludG8gdGhlIGV2ZW50IG1hcC5cbiAgICAgICAgaWYgKCF0aGlzLl9ldmVudExpc3RlbmVycy5oYXMoZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnMuc2V0KGV2ZW50TmFtZSwgW10pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJzLnNldChldmVudE5hbWUsICgoX2EgPSB0aGlzLl9ldmVudExpc3RlbmVycy5nZXQoZXZlbnROYW1lKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pLmNvbmNhdChsaXN0ZW5lcikpO1xuICAgICAgICAvLyBTdG9yZSB0aGUgY2FsbGJhY2sgaW50byB0aGUgbGlzdGVuZXIgbWFwLlxuICAgICAgICB0aGlzLl9ldmVudENhbGxiYWNrcy5zZXQobGlzdGVuZXIsIFtldmVudE5hbWUsIGNhbGxiYWNrXSk7XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgc3Vic2NyaXB0aW9uIHNpbmdsZXRvbiwgaWYgbmVlZGVkLlxuICAgICAgICBpZiAodGhpcy5fb25Mb2dzU3Vic2NyaXB0aW9uSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29uTG9nc1N1YnNjcmlwdGlvbklkID0gdGhpcy5fcHJvdmlkZXIuY29ubmVjdGlvbi5vbkxvZ3ModGhpcy5fcHJvZ3JhbUlkLCAobG9ncywgY3R4KSA9PiB7XG4gICAgICAgICAgICBpZiAobG9ncy5lcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIHRoaXMuX2V2ZW50UGFyc2VyLnBhcnNlTG9ncyhsb2dzLmxvZ3MpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxsTGlzdGVuZXJzID0gdGhpcy5fZXZlbnRMaXN0ZW5lcnMuZ2V0KGV2ZW50Lm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChhbGxMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsTGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsaXN0ZW5lckNiID0gdGhpcy5fZXZlbnRDYWxsYmFja3MuZ2V0KGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lckNiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgWywgY2FsbGJhY2tdID0gbGlzdGVuZXJDYjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhldmVudC5kYXRhLCBjdHguc2xvdCwgbG9ncy5zaWduYXR1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbGlzdGVuZXI7XG4gICAgfVxuICAgIGFzeW5jIHJlbW92ZUV2ZW50TGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgLy8gR2V0IHRoZSBjYWxsYmFjay5cbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLl9ldmVudENhbGxiYWNrcy5nZXQobGlzdGVuZXIpO1xuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV2ZW50IGxpc3RlbmVyICR7bGlzdGVuZXJ9IGRvZXNuJ3QgZXhpc3QhYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2V2ZW50TmFtZV0gPSBjYWxsYmFjaztcbiAgICAgICAgLy8gR2V0IHRoZSBsaXN0ZW5lcnMuXG4gICAgICAgIGxldCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudExpc3RlbmVycy5nZXQoZXZlbnROYW1lKTtcbiAgICAgICAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXZlbnQgbGlzdGVuZXJzIGRvbid0IGV4aXN0IGZvciAke2V2ZW50TmFtZX0hYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIGJvdGggbWFwcy5cbiAgICAgICAgdGhpcy5fZXZlbnRDYWxsYmFja3MuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmZpbHRlcigobCkgPT4gbCAhPT0gbGlzdGVuZXIpO1xuICAgICAgICB0aGlzLl9ldmVudExpc3RlbmVycy5zZXQoZXZlbnROYW1lLCBsaXN0ZW5lcnMpO1xuICAgICAgICBpZiAobGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnMuZGVsZXRlKGV2ZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gS2lsbCB0aGUgd2Vic29ja2V0IGNvbm5lY3Rpb24gaWYgYWxsIGxpc3RlbmVycyBoYXZlIGJlZW4gcmVtb3ZlZC5cbiAgICAgICAgaWYgKHRoaXMuX2V2ZW50Q2FsbGJhY2tzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9ldmVudExpc3RlbmVycy5zaXplICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBldmVudCBsaXN0ZW5lcnMgc2l6ZSB0byBiZSAwIGJ1dCBnb3QgJHt0aGlzLl9ldmVudExpc3RlbmVycy5zaXplfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX29uTG9nc1N1YnNjcmlwdGlvbklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9wcm92aWRlci5jb25uZWN0aW9uLnJlbW92ZU9uTG9nc0xpc3RlbmVyKHRoaXMuX29uTG9nc1N1YnNjcmlwdGlvbklkKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkxvZ3NTdWJzY3JpcHRpb25JZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBFdmVudFBhcnNlciB7XG4gICAgY29uc3RydWN0b3IocHJvZ3JhbUlkLCBjb2Rlcikge1xuICAgICAgICB0aGlzLmNvZGVyID0gY29kZXI7XG4gICAgICAgIHRoaXMucHJvZ3JhbUlkID0gcHJvZ3JhbUlkO1xuICAgIH1cbiAgICAvLyBFYWNoIGxvZyBnaXZlbiwgcmVwcmVzZW50cyBhbiBhcnJheSBvZiBtZXNzYWdlcyBlbWl0dGVkIGJ5XG4gICAgLy8gYSBzaW5nbGUgdHJhbnNhY3Rpb24sIHdoaWNoIGNhbiBleGVjdXRlIG1hbnkgZGlmZmVyZW50IHByb2dyYW1zIGFjcm9zc1xuICAgIC8vIENQSSBib3VuZGFyaWVzLiBIb3dldmVyLCB0aGUgc3Vic2NyaXB0aW9uIGlzIG9ubHkgaW50ZXJlc3RlZCBpbiB0aGVcbiAgICAvLyBldmVudHMgZW1pdHRlZCBieSAqdGhpcyogcHJvZ3JhbS4gSW4gYWNoaWV2aW5nIHRoaXMsIHdlIGtlZXAgdHJhY2sgb2YgdGhlXG4gICAgLy8gcHJvZ3JhbSBleGVjdXRpb24gY29udGV4dCBieSBwYXJzaW5nIGVhY2ggbG9nIGFuZCBsb29raW5nIGZvciBhIENQSVxuICAgIC8vIGBpbnZva2VgIGNhbGwuIElmIG9uZSBleGlzdHMsIHdlIGtub3cgYSBuZXcgcHJvZ3JhbSBpcyBleGVjdXRpbmcuIFNvIHdlXG4gICAgLy8gcHVzaCB0aGUgcHJvZ3JhbUlkIG9udG8gYSBzdGFjayBhbmQgc3dpdGNoIHRoZSBwcm9ncmFtIGNvbnRleHQuIFRoaXNcbiAgICAvLyBhbGxvd3MgdXMgdG8gdHJhY2ssIGZvciBhIGdpdmVuIGxvZywgd2hpY2ggcHJvZ3JhbSB3YXMgZXhlY3V0aW5nIGR1cmluZ1xuICAgIC8vIGl0cyBlbWlzc2lvbiwgdGhlcmVieSBhbGxvd2luZyB1cyB0byBrbm93IGlmIGEgZ2l2ZW4gbG9nIGV2ZW50IHdhc1xuICAgIC8vIGVtaXR0ZWQgYnkgKnRoaXMqIHByb2dyYW0uIElmIGl0IHdhcywgdGhlbiB3ZSBwYXJzZSB0aGUgcmF3IHN0cmluZyBhbmRcbiAgICAvLyBlbWl0IHRoZSBldmVudCBpZiB0aGUgc3RyaW5nIG1hdGNoZXMgdGhlIGV2ZW50IGJlaW5nIHN1YnNjcmliZWQgdG8uXG4gICAgKnBhcnNlTG9ncyhsb2dzLCBlcnJvck9uRGVjb2RlRmFpbHVyZSA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGxvZ1NjYW5uZXIgPSBuZXcgTG9nU2Nhbm5lcihsb2dzKTtcbiAgICAgICAgY29uc3QgZXhlY3V0aW9uID0gbmV3IEV4ZWN1dGlvbkNvbnRleHQoKTtcbiAgICAgICAgbGV0IGxvZyA9IGxvZ1NjYW5uZXIubmV4dCgpO1xuICAgICAgICB3aGlsZSAobG9nICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgW2V2ZW50LCBuZXdQcm9ncmFtLCBkaWRQb3BdID0gdGhpcy5oYW5kbGVMb2coZXhlY3V0aW9uLCBsb2csIGVycm9yT25EZWNvZGVGYWlsdXJlKTtcbiAgICAgICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGV2ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld1Byb2dyYW0pIHtcbiAgICAgICAgICAgICAgICBleGVjdXRpb24ucHVzaChuZXdQcm9ncmFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaWRQb3ApIHtcbiAgICAgICAgICAgICAgICBleGVjdXRpb24ucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2cgPSBsb2dTY2FubmVyLm5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBNYWluIGxvZyBoYW5kbGVyLiBSZXR1cm5zIGEgdGhyZWUgZWxlbWVudCBhcnJheSBvZiB0aGUgZXZlbnQsIHRoZVxuICAgIC8vIG5leHQgcHJvZ3JhbSB0aGF0IHdhcyBpbnZva2VkIGZvciBDUEksIGFuZCBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZlxuICAgIC8vIGEgcHJvZ3JhbSBoYXMgY29tcGxldGVkIGV4ZWN1dGlvbiAoYW5kIHRodXMgc2hvdWxkIGJlIHBvcHBlZCBvZmYgdGhlXG4gICAgLy8gZXhlY3V0aW9uIHN0YWNrKS5cbiAgICBoYW5kbGVMb2coZXhlY3V0aW9uLCBsb2csIGVycm9yT25EZWNvZGVGYWlsdXJlKSB7XG4gICAgICAgIC8vIEV4ZWN1dGluZyBwcm9ncmFtIGlzIHRoaXMgcHJvZ3JhbS5cbiAgICAgICAgaWYgKGV4ZWN1dGlvbi5zdGFjay5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICBleGVjdXRpb24ucHJvZ3JhbSgpID09PSB0aGlzLnByb2dyYW1JZC50b1N0cmluZygpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVQcm9ncmFtTG9nKGxvZywgZXJyb3JPbkRlY29kZUZhaWx1cmUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4ZWN1dGluZyBwcm9ncmFtIGlzIG5vdCB0aGlzIHByb2dyYW0uXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtudWxsLCAuLi50aGlzLmhhbmRsZVN5c3RlbUxvZyhsb2cpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBIYW5kbGVzIGxvZ3MgZnJvbSAqdGhpcyogcHJvZ3JhbS5cbiAgICBoYW5kbGVQcm9ncmFtTG9nKGxvZywgZXJyb3JPbkRlY29kZUZhaWx1cmUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGBtc2chYCBsb2cgb3IgYSBgc29sX2xvZ19kYXRhYCBsb2cuXG4gICAgICAgIGlmIChsb2cuc3RhcnRzV2l0aChQUk9HUkFNX0xPRykgfHwgbG9nLnN0YXJ0c1dpdGgoUFJPR1JBTV9EQVRBKSkge1xuICAgICAgICAgICAgY29uc3QgbG9nU3RyID0gbG9nLnN0YXJ0c1dpdGgoUFJPR1JBTV9MT0cpXG4gICAgICAgICAgICAgICAgPyBsb2cuc2xpY2UoUFJPR1JBTV9MT0dfU1RBUlRfSU5ERVgpXG4gICAgICAgICAgICAgICAgOiBsb2cuc2xpY2UoUFJPR1JBTV9EQVRBX1NUQVJUX0lOREVYKTtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5jb2Rlci5ldmVudHMuZGVjb2RlKGxvZ1N0cik7XG4gICAgICAgICAgICBpZiAoZXJyb3JPbkRlY29kZUZhaWx1cmUgJiYgZXZlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBkZWNvZGUgZXZlbnQgJHtsb2dTdHJ9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW2V2ZW50LCBudWxsLCBmYWxzZV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3lzdGVtIGxvZy5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW251bGwsIC4uLnRoaXMuaGFuZGxlU3lzdGVtTG9nKGxvZyldO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEhhbmRsZXMgbG9ncyB3aGVuIHRoZSBjdXJyZW50IHByb2dyYW0gYmVpbmcgZXhlY3V0aW5nIGlzICpub3QqIHRoaXMuXG4gICAgaGFuZGxlU3lzdGVtTG9nKGxvZykge1xuICAgICAgICAvLyBTeXN0ZW0gY29tcG9uZW50LlxuICAgICAgICBjb25zdCBsb2dTdGFydCA9IGxvZy5zcGxpdChcIjpcIilbMF07XG4gICAgICAgIC8vIERpZCB0aGUgcHJvZ3JhbSBmaW5pc2ggZXhlY3V0aW5nP1xuICAgICAgICBpZiAobG9nU3RhcnQubWF0Y2goL15Qcm9ncmFtICguKikgc3VjY2Vzcy9nKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFtudWxsLCB0cnVlXTtcbiAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZSBjYWxsLlxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxvZ1N0YXJ0LnN0YXJ0c1dpdGgoYFByb2dyYW0gJHt0aGlzLnByb2dyYW1JZC50b1N0cmluZygpfSBpbnZva2VgKSkge1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLnByb2dyYW1JZC50b1N0cmluZygpLCBmYWxzZV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ1BJIGNhbGwuXG4gICAgICAgIGVsc2UgaWYgKGxvZ1N0YXJ0LmluY2x1ZGVzKFwiaW52b2tlXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gW1wiY3BpXCIsIGZhbHNlXTsgLy8gQW55IHN0cmluZyB3aWxsIGRvLlxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtudWxsLCBmYWxzZV07XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBTdGFjayBmcmFtZSBleGVjdXRpb24gY29udGV4dCwgYWxsb3dpbmcgb25lIHRvIHRyYWNrIHdoYXQgcHJvZ3JhbSBpc1xuLy8gZXhlY3V0aW5nIGZvciBhIGdpdmVuIGxvZy5cbmNsYXNzIEV4ZWN1dGlvbkNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgfVxuICAgIHByb2dyYW0oKSB7XG4gICAgICAgIGlmICghdGhpcy5zdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHRoZSBzdGFjayB0byBoYXZlIGVsZW1lbnRzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHB1c2gobmV3UHJvZ3JhbSkge1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2gobmV3UHJvZ3JhbSk7XG4gICAgfVxuICAgIHBvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgdGhlIHN0YWNrIHRvIGhhdmUgZWxlbWVudHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICB9XG59XG5jbGFzcyBMb2dTY2FubmVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2dzKSB7XG4gICAgICAgIHRoaXMubG9ncyA9IGxvZ3M7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGlmICh0aGlzLmxvZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbCA9IHRoaXMubG9nc1swXTtcbiAgICAgICAgdGhpcy5sb2dzID0gdGhpcy5sb2dzLnNsaWNlKDEpO1xuICAgICAgICByZXR1cm4gbDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldmVudC5qcy5tYXAiXSwibmFtZXMiOlsiUFJPR1JBTV9MT0ciLCJQUk9HUkFNX0RBVEEiLCJQUk9HUkFNX0xPR19TVEFSVF9JTkRFWCIsImxlbmd0aCIsIlBST0dSQU1fREFUQV9TVEFSVF9JTkRFWCIsIkV2ZW50TWFuYWdlciIsImNvbnN0cnVjdG9yIiwicHJvZ3JhbUlkIiwicHJvdmlkZXIiLCJjb2RlciIsIl9wcm9ncmFtSWQiLCJfcHJvdmlkZXIiLCJfZXZlbnRQYXJzZXIiLCJFdmVudFBhcnNlciIsIl9ldmVudENhbGxiYWNrcyIsIk1hcCIsIl9ldmVudExpc3RlbmVycyIsIl9saXN0ZW5lcklkQ291bnQiLCJhZGRFdmVudExpc3RlbmVyIiwiZXZlbnROYW1lIiwiY2FsbGJhY2siLCJfYSIsImxpc3RlbmVyIiwiaGFzIiwic2V0IiwiZ2V0IiwiY29uY2F0IiwiX29uTG9nc1N1YnNjcmlwdGlvbklkIiwidW5kZWZpbmVkIiwiY29ubmVjdGlvbiIsIm9uTG9ncyIsImxvZ3MiLCJjdHgiLCJlcnIiLCJldmVudCIsInBhcnNlTG9ncyIsImFsbExpc3RlbmVycyIsIm5hbWUiLCJmb3JFYWNoIiwibGlzdGVuZXJDYiIsImRhdGEiLCJzbG90Iiwic2lnbmF0dXJlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIkVycm9yIiwibGlzdGVuZXJzIiwiZGVsZXRlIiwiZmlsdGVyIiwibCIsInNpemUiLCJyZW1vdmVPbkxvZ3NMaXN0ZW5lciIsImVycm9yT25EZWNvZGVGYWlsdXJlIiwibG9nU2Nhbm5lciIsIkxvZ1NjYW5uZXIiLCJleGVjdXRpb24iLCJFeGVjdXRpb25Db250ZXh0IiwibG9nIiwibmV4dCIsIm5ld1Byb2dyYW0iLCJkaWRQb3AiLCJoYW5kbGVMb2ciLCJwdXNoIiwicG9wIiwic3RhY2siLCJwcm9ncmFtIiwidG9TdHJpbmciLCJoYW5kbGVQcm9ncmFtTG9nIiwiaGFuZGxlU3lzdGVtTG9nIiwic3RhcnRzV2l0aCIsImxvZ1N0ciIsInNsaWNlIiwiZXZlbnRzIiwiZGVjb2RlIiwibG9nU3RhcnQiLCJzcGxpdCIsIm1hdGNoIiwiaW5jbHVkZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/event.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/index.js":
/*!*******************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/program/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AccountClient: () => (/* reexport safe */ _namespace_index_js__WEBPACK_IMPORTED_MODULE_4__.AccountClient),\n/* harmony export */   EventManager: () => (/* reexport safe */ _event_js__WEBPACK_IMPORTED_MODULE_6__.EventManager),\n/* harmony export */   EventParser: () => (/* reexport safe */ _event_js__WEBPACK_IMPORTED_MODULE_6__.EventParser),\n/* harmony export */   MethodsBuilderFactory: () => (/* reexport safe */ _namespace_index_js__WEBPACK_IMPORTED_MODULE_4__.MethodsBuilderFactory),\n/* harmony export */   Program: () => (/* binding */ Program),\n/* harmony export */   parseIdlErrors: () => (/* reexport safe */ _common_js__WEBPACK_IMPORTED_MODULE_7__.parseIdlErrors),\n/* harmony export */   splitArgsAndCtx: () => (/* reexport safe */ _context_js__WEBPACK_IMPORTED_MODULE_8__.splitArgsAndCtx),\n/* harmony export */   toInstruction: () => (/* reexport safe */ _common_js__WEBPACK_IMPORTED_MODULE_7__.toInstruction),\n/* harmony export */   translateAddress: () => (/* reexport safe */ _common_js__WEBPACK_IMPORTED_MODULE_7__.translateAddress),\n/* harmony export */   validateAccounts: () => (/* reexport safe */ _common_js__WEBPACK_IMPORTED_MODULE_7__.validateAccounts)\n/* harmony export */ });\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pako */ \"(ssr)/../node_modules/pako/dist/pako.esm.mjs\");\n/* harmony import */ var _provider_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../provider.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/provider.js\");\n/* harmony import */ var _idl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../idl.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/idl.js\");\n/* harmony import */ var _coder_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../coder/index.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/index.js\");\n/* harmony import */ var _namespace_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./namespace/index.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/namespace/index.js\");\n/* harmony import */ var _utils_bytes_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/bytes/index.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/bytes/index.js\");\n/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./event.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/event.js\");\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./common.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/common.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./context.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/context.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * ## Program\n *\n * Program provides the IDL deserialized client representation of an Anchor\n * program.\n *\n * This API is the one stop shop for all things related to communicating with\n * on-chain programs. Among other things, one can send transactions, fetch\n * deserialized accounts, decode instruction data, subscribe to account\n * changes, and listen to events.\n *\n * In addition to field accessors and methods, the object provides a set of\n * dynamically generated properties, also known as namespaces, that\n * map one-to-one to program methods and accounts. These namespaces generally\n *  can be used as follows:\n *\n * ## Usage\n *\n * ```javascript\n * program.<namespace>.<program-specific-method>\n * ```\n *\n * API specifics are namespace dependent. The examples used in the documentation\n * below will refer to the two counter examples found\n * [here](https://github.com/coral-xyz/anchor#examples).\n */ class Program {\n    /**\n     * Address of the program.\n     */ get programId() {\n        return this._programId;\n    }\n    /**\n     * IDL in camelCase format to work in TypeScript.\n     *\n     * See {@link rawIdl} field if you need the original IDL.\n     */ get idl() {\n        return this._idl;\n    }\n    /**\n     * Raw IDL i.e. the original IDL without camelCase conversion.\n     *\n     * See {@link idl} field if you need the camelCased version of the IDL.\n     */ get rawIdl() {\n        return this._rawIdl;\n    }\n    /**\n     * Coder for serializing requests.\n     */ get coder() {\n        return this._coder;\n    }\n    /**\n     * Wallet and network provider.\n     */ get provider() {\n        return this._provider;\n    }\n    /**\n     * @param idl       The interface definition.\n     * @param provider  The network and wallet context to use. If not provided\n     *                  then uses [[getProvider]].\n     * @param getCustomResolver A function that returns a custom account resolver\n     *                          for the given instruction. This is useful for resolving\n     *                          public keys of missing accounts when building instructions\n     */ constructor(idl, provider = (0,_provider_js__WEBPACK_IMPORTED_MODULE_1__.getProvider)(), coder, getCustomResolver){\n        const camelCasedIdl = (0,_idl_js__WEBPACK_IMPORTED_MODULE_2__.convertIdlToCamelCase)(idl);\n        // Fields.\n        this._idl = camelCasedIdl;\n        this._rawIdl = idl;\n        this._provider = provider;\n        this._programId = (0,_common_js__WEBPACK_IMPORTED_MODULE_7__.translateAddress)(idl.address);\n        this._coder = coder !== null && coder !== void 0 ? coder : new _coder_index_js__WEBPACK_IMPORTED_MODULE_3__.BorshCoder(camelCasedIdl);\n        this._events = new _event_js__WEBPACK_IMPORTED_MODULE_6__.EventManager(this._programId, provider, this._coder);\n        // Dynamic namespaces.\n        const [rpc, instruction, transaction, account, simulate, methods, views] = _namespace_index_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].build(camelCasedIdl, this._coder, this._programId, provider, getCustomResolver);\n        this.rpc = rpc;\n        this.instruction = instruction;\n        this.transaction = transaction;\n        this.account = account;\n        this.simulate = simulate;\n        this.methods = methods;\n        this.views = views;\n    }\n    /**\n     * Generates a Program client by fetching the IDL from the network.\n     *\n     * In order to use this method, an IDL must have been previously initialized\n     * via the anchor CLI's `anchor idl init` command.\n     *\n     * @param programId The on-chain address of the program.\n     * @param provider  The network and wallet context.\n     */ static async at(address, provider) {\n        const programId = (0,_common_js__WEBPACK_IMPORTED_MODULE_7__.translateAddress)(address);\n        const idl = await Program.fetchIdl(programId, provider);\n        if (!idl) {\n            throw new Error(`IDL not found for program: ${address.toString()}`);\n        }\n        return new Program(idl, provider);\n    }\n    /**\n     * Fetches an idl from the blockchain.\n     *\n     * In order to use this method, an IDL must have been previously initialized\n     * via the anchor CLI's `anchor idl init` command.\n     *\n     * @param programId The on-chain address of the program.\n     * @param provider  The network and wallet context.\n     */ static async fetchIdl(address, provider) {\n        provider = provider !== null && provider !== void 0 ? provider : (0,_provider_js__WEBPACK_IMPORTED_MODULE_1__.getProvider)();\n        const programId = (0,_common_js__WEBPACK_IMPORTED_MODULE_7__.translateAddress)(address);\n        const idlAddr = await (0,_idl_js__WEBPACK_IMPORTED_MODULE_2__.idlAddress)(programId);\n        const accountInfo = await provider.connection.getAccountInfo(idlAddr);\n        if (!accountInfo) {\n            return null;\n        }\n        // Chop off account discriminator.\n        let idlAccount = (0,_idl_js__WEBPACK_IMPORTED_MODULE_2__.decodeIdlAccount)(accountInfo.data.slice(8));\n        const inflatedIdl = (0,pako__WEBPACK_IMPORTED_MODULE_0__.inflate)(idlAccount.data);\n        return JSON.parse(_utils_bytes_index_js__WEBPACK_IMPORTED_MODULE_5__.utf8.decode(inflatedIdl));\n    }\n    /**\n     * Invokes the given callback every time the given event is emitted.\n     *\n     * @param eventName The PascalCase name of the event, provided by the IDL.\n     * @param callback  The function to invoke whenever the event is emitted from\n     *                  program logs.\n     */ addEventListener(eventName, callback) {\n        return this._events.addEventListener(eventName, callback);\n    }\n    /**\n     * Unsubscribes from the given eventName.\n     */ async removeEventListener(listener) {\n        return await this._events.removeEventListener(listener);\n    }\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3Byb2dyYW0vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUErQjtBQUNjO0FBQ29DO0FBQ2xDO0FBQ0s7QUFDTDtBQUNMO0FBQ0s7QUFDbkI7QUFDQztBQUNGO0FBQ1U7QUFDckM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F5QkMsR0FDTSxNQUFNVTtJQUNUOztLQUVDLEdBQ0QsSUFBSUMsWUFBWTtRQUNaLE9BQU8sSUFBSSxDQUFDQyxVQUFVO0lBQzFCO0lBQ0E7Ozs7S0FJQyxHQUNELElBQUlDLE1BQU07UUFDTixPQUFPLElBQUksQ0FBQ0MsSUFBSTtJQUNwQjtJQUNBOzs7O0tBSUMsR0FDRCxJQUFJQyxTQUFTO1FBQ1QsT0FBTyxJQUFJLENBQUNDLE9BQU87SUFDdkI7SUFDQTs7S0FFQyxHQUNELElBQUlDLFFBQVE7UUFDUixPQUFPLElBQUksQ0FBQ0MsTUFBTTtJQUN0QjtJQUNBOztLQUVDLEdBQ0QsSUFBSUMsV0FBVztRQUNYLE9BQU8sSUFBSSxDQUFDQyxTQUFTO0lBQ3pCO0lBQ0E7Ozs7Ozs7S0FPQyxHQUNEQyxZQUFZUixHQUFHLEVBQUVNLFdBQVdsQix5REFBV0EsRUFBRSxFQUFFZ0IsS0FBSyxFQUFFSyxpQkFBaUIsQ0FBRTtRQUNqRSxNQUFNQyxnQkFBZ0JuQiw4REFBcUJBLENBQUNTO1FBQzVDLFVBQVU7UUFDVixJQUFJLENBQUNDLElBQUksR0FBR1M7UUFDWixJQUFJLENBQUNQLE9BQU8sR0FBR0g7UUFDZixJQUFJLENBQUNPLFNBQVMsR0FBR0Q7UUFDakIsSUFBSSxDQUFDUCxVQUFVLEdBQUdILDREQUFnQkEsQ0FBQ0ksSUFBSVcsT0FBTztRQUM5QyxJQUFJLENBQUNOLE1BQU0sR0FBR0QsVUFBVSxRQUFRQSxVQUFVLEtBQUssSUFBSUEsUUFBUSxJQUFJWix1REFBVUEsQ0FBQ2tCO1FBQzFFLElBQUksQ0FBQ0UsT0FBTyxHQUFHLElBQUlqQixtREFBWUEsQ0FBQyxJQUFJLENBQUNJLFVBQVUsRUFBRU8sVUFBVSxJQUFJLENBQUNELE1BQU07UUFDdEUsc0JBQXNCO1FBQ3RCLE1BQU0sQ0FBQ1EsS0FBS0MsYUFBYUMsYUFBYUMsU0FBU0MsVUFBVUMsU0FBU0MsTUFBTSxHQUFHMUIsMkRBQWdCQSxDQUFDMkIsS0FBSyxDQUFDVixlQUFlLElBQUksQ0FBQ0wsTUFBTSxFQUFFLElBQUksQ0FBQ04sVUFBVSxFQUFFTyxVQUFVRztRQUN6SixJQUFJLENBQUNJLEdBQUcsR0FBR0E7UUFDWCxJQUFJLENBQUNDLFdBQVcsR0FBR0E7UUFDbkIsSUFBSSxDQUFDQyxXQUFXLEdBQUdBO1FBQ25CLElBQUksQ0FBQ0MsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0MsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNDLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNDLEtBQUssR0FBR0E7SUFDakI7SUFDQTs7Ozs7Ozs7S0FRQyxHQUNELGFBQWFFLEdBQUdWLE9BQU8sRUFBRUwsUUFBUSxFQUFFO1FBQy9CLE1BQU1SLFlBQVlGLDREQUFnQkEsQ0FBQ2U7UUFDbkMsTUFBTVgsTUFBTSxNQUFNSCxRQUFReUIsUUFBUSxDQUFDeEIsV0FBV1E7UUFDOUMsSUFBSSxDQUFDTixLQUFLO1lBQ04sTUFBTSxJQUFJdUIsTUFBTSxDQUFDLDJCQUEyQixFQUFFWixRQUFRYSxRQUFRLEdBQUcsQ0FBQztRQUN0RTtRQUNBLE9BQU8sSUFBSTNCLFFBQVFHLEtBQUtNO0lBQzVCO0lBQ0E7Ozs7Ozs7O0tBUUMsR0FDRCxhQUFhZ0IsU0FBU1gsT0FBTyxFQUFFTCxRQUFRLEVBQUU7UUFDckNBLFdBQVdBLGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUlBLFdBQVdsQix5REFBV0E7UUFDNUUsTUFBTVUsWUFBWUYsNERBQWdCQSxDQUFDZTtRQUNuQyxNQUFNYyxVQUFVLE1BQU1wQyxtREFBVUEsQ0FBQ1M7UUFDakMsTUFBTTRCLGNBQWMsTUFBTXBCLFNBQVNxQixVQUFVLENBQUNDLGNBQWMsQ0FBQ0g7UUFDN0QsSUFBSSxDQUFDQyxhQUFhO1lBQ2QsT0FBTztRQUNYO1FBQ0Esa0NBQWtDO1FBQ2xDLElBQUlHLGFBQWF2Qyx5REFBZ0JBLENBQUNvQyxZQUFZSSxJQUFJLENBQUNDLEtBQUssQ0FBQztRQUN6RCxNQUFNQyxjQUFjN0MsNkNBQU9BLENBQUMwQyxXQUFXQyxJQUFJO1FBQzNDLE9BQU9HLEtBQUtDLEtBQUssQ0FBQ3hDLDhEQUFXLENBQUNzQztJQUNsQztJQUNBOzs7Ozs7S0FNQyxHQUNESSxpQkFBaUJDLFNBQVMsRUFBRUMsUUFBUSxFQUFFO1FBQ2xDLE9BQU8sSUFBSSxDQUFDMUIsT0FBTyxDQUFDd0IsZ0JBQWdCLENBQUNDLFdBQVdDO0lBQ3BEO0lBQ0E7O0tBRUMsR0FDRCxNQUFNQyxvQkFBb0JDLFFBQVEsRUFBRTtRQUNoQyxPQUFPLE1BQU0sSUFBSSxDQUFDNUIsT0FBTyxDQUFDMkIsbUJBQW1CLENBQUNDO0lBQ2xEO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3Byb2dyYW0vaW5kZXguanM/MjQ4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpbmZsYXRlIH0gZnJvbSBcInBha29cIjtcbmltcG9ydCB7IGdldFByb3ZpZGVyIH0gZnJvbSBcIi4uL3Byb3ZpZGVyLmpzXCI7XG5pbXBvcnQgeyBpZGxBZGRyZXNzLCBkZWNvZGVJZGxBY2NvdW50LCBjb252ZXJ0SWRsVG9DYW1lbENhc2UsIH0gZnJvbSBcIi4uL2lkbC5qc1wiO1xuaW1wb3J0IHsgQm9yc2hDb2RlciB9IGZyb20gXCIuLi9jb2Rlci9pbmRleC5qc1wiO1xuaW1wb3J0IE5hbWVzcGFjZUZhY3RvcnkgZnJvbSBcIi4vbmFtZXNwYWNlL2luZGV4LmpzXCI7XG5pbXBvcnQgeyB1dGY4IH0gZnJvbSBcIi4uL3V0aWxzL2J5dGVzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBFdmVudE1hbmFnZXIgfSBmcm9tIFwiLi9ldmVudC5qc1wiO1xuaW1wb3J0IHsgdHJhbnNsYXRlQWRkcmVzcyB9IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vY29tbW9uLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9jb250ZXh0LmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9ldmVudC5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vbmFtZXNwYWNlL2luZGV4LmpzXCI7XG4vKipcbiAqICMjIFByb2dyYW1cbiAqXG4gKiBQcm9ncmFtIHByb3ZpZGVzIHRoZSBJREwgZGVzZXJpYWxpemVkIGNsaWVudCByZXByZXNlbnRhdGlvbiBvZiBhbiBBbmNob3JcbiAqIHByb2dyYW0uXG4gKlxuICogVGhpcyBBUEkgaXMgdGhlIG9uZSBzdG9wIHNob3AgZm9yIGFsbCB0aGluZ3MgcmVsYXRlZCB0byBjb21tdW5pY2F0aW5nIHdpdGhcbiAqIG9uLWNoYWluIHByb2dyYW1zLiBBbW9uZyBvdGhlciB0aGluZ3MsIG9uZSBjYW4gc2VuZCB0cmFuc2FjdGlvbnMsIGZldGNoXG4gKiBkZXNlcmlhbGl6ZWQgYWNjb3VudHMsIGRlY29kZSBpbnN0cnVjdGlvbiBkYXRhLCBzdWJzY3JpYmUgdG8gYWNjb3VudFxuICogY2hhbmdlcywgYW5kIGxpc3RlbiB0byBldmVudHMuXG4gKlxuICogSW4gYWRkaXRpb24gdG8gZmllbGQgYWNjZXNzb3JzIGFuZCBtZXRob2RzLCB0aGUgb2JqZWN0IHByb3ZpZGVzIGEgc2V0IG9mXG4gKiBkeW5hbWljYWxseSBnZW5lcmF0ZWQgcHJvcGVydGllcywgYWxzbyBrbm93biBhcyBuYW1lc3BhY2VzLCB0aGF0XG4gKiBtYXAgb25lLXRvLW9uZSB0byBwcm9ncmFtIG1ldGhvZHMgYW5kIGFjY291bnRzLiBUaGVzZSBuYW1lc3BhY2VzIGdlbmVyYWxseVxuICogIGNhbiBiZSB1c2VkIGFzIGZvbGxvd3M6XG4gKlxuICogIyMgVXNhZ2VcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBwcm9ncmFtLjxuYW1lc3BhY2U+Ljxwcm9ncmFtLXNwZWNpZmljLW1ldGhvZD5cbiAqIGBgYFxuICpcbiAqIEFQSSBzcGVjaWZpY3MgYXJlIG5hbWVzcGFjZSBkZXBlbmRlbnQuIFRoZSBleGFtcGxlcyB1c2VkIGluIHRoZSBkb2N1bWVudGF0aW9uXG4gKiBiZWxvdyB3aWxsIHJlZmVyIHRvIHRoZSB0d28gY291bnRlciBleGFtcGxlcyBmb3VuZFxuICogW2hlcmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9jb3JhbC14eXovYW5jaG9yI2V4YW1wbGVzKS5cbiAqL1xuZXhwb3J0IGNsYXNzIFByb2dyYW0ge1xuICAgIC8qKlxuICAgICAqIEFkZHJlc3Mgb2YgdGhlIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0IHByb2dyYW1JZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2dyYW1JZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSURMIGluIGNhbWVsQ2FzZSBmb3JtYXQgdG8gd29yayBpbiBUeXBlU2NyaXB0LlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayByYXdJZGx9IGZpZWxkIGlmIHlvdSBuZWVkIHRoZSBvcmlnaW5hbCBJREwuXG4gICAgICovXG4gICAgZ2V0IGlkbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmF3IElETCBpLmUuIHRoZSBvcmlnaW5hbCBJREwgd2l0aG91dCBjYW1lbENhc2UgY29udmVyc2lvbi5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgaWRsfSBmaWVsZCBpZiB5b3UgbmVlZCB0aGUgY2FtZWxDYXNlZCB2ZXJzaW9uIG9mIHRoZSBJREwuXG4gICAgICovXG4gICAgZ2V0IHJhd0lkbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jhd0lkbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29kZXIgZm9yIHNlcmlhbGl6aW5nIHJlcXVlc3RzLlxuICAgICAqL1xuICAgIGdldCBjb2RlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXYWxsZXQgYW5kIG5ldHdvcmsgcHJvdmlkZXIuXG4gICAgICovXG4gICAgZ2V0IHByb3ZpZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvdmlkZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBpZGwgICAgICAgVGhlIGludGVyZmFjZSBkZWZpbml0aW9uLlxuICAgICAqIEBwYXJhbSBwcm92aWRlciAgVGhlIG5ldHdvcmsgYW5kIHdhbGxldCBjb250ZXh0IHRvIHVzZS4gSWYgbm90IHByb3ZpZGVkXG4gICAgICogICAgICAgICAgICAgICAgICB0aGVuIHVzZXMgW1tnZXRQcm92aWRlcl1dLlxuICAgICAqIEBwYXJhbSBnZXRDdXN0b21SZXNvbHZlciBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGN1c3RvbSBhY2NvdW50IHJlc29sdmVyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGZvciB0aGUgZ2l2ZW4gaW5zdHJ1Y3Rpb24uIFRoaXMgaXMgdXNlZnVsIGZvciByZXNvbHZpbmdcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgcHVibGljIGtleXMgb2YgbWlzc2luZyBhY2NvdW50cyB3aGVuIGJ1aWxkaW5nIGluc3RydWN0aW9uc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGlkbCwgcHJvdmlkZXIgPSBnZXRQcm92aWRlcigpLCBjb2RlciwgZ2V0Q3VzdG9tUmVzb2x2ZXIpIHtcbiAgICAgICAgY29uc3QgY2FtZWxDYXNlZElkbCA9IGNvbnZlcnRJZGxUb0NhbWVsQ2FzZShpZGwpO1xuICAgICAgICAvLyBGaWVsZHMuXG4gICAgICAgIHRoaXMuX2lkbCA9IGNhbWVsQ2FzZWRJZGw7XG4gICAgICAgIHRoaXMuX3Jhd0lkbCA9IGlkbDtcbiAgICAgICAgdGhpcy5fcHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgdGhpcy5fcHJvZ3JhbUlkID0gdHJhbnNsYXRlQWRkcmVzcyhpZGwuYWRkcmVzcyk7XG4gICAgICAgIHRoaXMuX2NvZGVyID0gY29kZXIgIT09IG51bGwgJiYgY29kZXIgIT09IHZvaWQgMCA/IGNvZGVyIDogbmV3IEJvcnNoQ29kZXIoY2FtZWxDYXNlZElkbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudE1hbmFnZXIodGhpcy5fcHJvZ3JhbUlkLCBwcm92aWRlciwgdGhpcy5fY29kZXIpO1xuICAgICAgICAvLyBEeW5hbWljIG5hbWVzcGFjZXMuXG4gICAgICAgIGNvbnN0IFtycGMsIGluc3RydWN0aW9uLCB0cmFuc2FjdGlvbiwgYWNjb3VudCwgc2ltdWxhdGUsIG1ldGhvZHMsIHZpZXdzXSA9IE5hbWVzcGFjZUZhY3RvcnkuYnVpbGQoY2FtZWxDYXNlZElkbCwgdGhpcy5fY29kZXIsIHRoaXMuX3Byb2dyYW1JZCwgcHJvdmlkZXIsIGdldEN1c3RvbVJlc29sdmVyKTtcbiAgICAgICAgdGhpcy5ycGMgPSBycGM7XG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbjtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xuICAgICAgICB0aGlzLmFjY291bnQgPSBhY2NvdW50O1xuICAgICAgICB0aGlzLnNpbXVsYXRlID0gc2ltdWxhdGU7XG4gICAgICAgIHRoaXMubWV0aG9kcyA9IG1ldGhvZHM7XG4gICAgICAgIHRoaXMudmlld3MgPSB2aWV3cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgUHJvZ3JhbSBjbGllbnQgYnkgZmV0Y2hpbmcgdGhlIElETCBmcm9tIHRoZSBuZXR3b3JrLlxuICAgICAqXG4gICAgICogSW4gb3JkZXIgdG8gdXNlIHRoaXMgbWV0aG9kLCBhbiBJREwgbXVzdCBoYXZlIGJlZW4gcHJldmlvdXNseSBpbml0aWFsaXplZFxuICAgICAqIHZpYSB0aGUgYW5jaG9yIENMSSdzIGBhbmNob3IgaWRsIGluaXRgIGNvbW1hbmQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJvZ3JhbUlkIFRoZSBvbi1jaGFpbiBhZGRyZXNzIG9mIHRoZSBwcm9ncmFtLlxuICAgICAqIEBwYXJhbSBwcm92aWRlciAgVGhlIG5ldHdvcmsgYW5kIHdhbGxldCBjb250ZXh0LlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBhdChhZGRyZXNzLCBwcm92aWRlcikge1xuICAgICAgICBjb25zdCBwcm9ncmFtSWQgPSB0cmFuc2xhdGVBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICBjb25zdCBpZGwgPSBhd2FpdCBQcm9ncmFtLmZldGNoSWRsKHByb2dyYW1JZCwgcHJvdmlkZXIpO1xuICAgICAgICBpZiAoIWlkbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJREwgbm90IGZvdW5kIGZvciBwcm9ncmFtOiAke2FkZHJlc3MudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb2dyYW0oaWRsLCBwcm92aWRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYW4gaWRsIGZyb20gdGhlIGJsb2NrY2hhaW4uXG4gICAgICpcbiAgICAgKiBJbiBvcmRlciB0byB1c2UgdGhpcyBtZXRob2QsIGFuIElETCBtdXN0IGhhdmUgYmVlbiBwcmV2aW91c2x5IGluaXRpYWxpemVkXG4gICAgICogdmlhIHRoZSBhbmNob3IgQ0xJJ3MgYGFuY2hvciBpZGwgaW5pdGAgY29tbWFuZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcm9ncmFtSWQgVGhlIG9uLWNoYWluIGFkZHJlc3Mgb2YgdGhlIHByb2dyYW0uXG4gICAgICogQHBhcmFtIHByb3ZpZGVyICBUaGUgbmV0d29yayBhbmQgd2FsbGV0IGNvbnRleHQuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGZldGNoSWRsKGFkZHJlc3MsIHByb3ZpZGVyKSB7XG4gICAgICAgIHByb3ZpZGVyID0gcHJvdmlkZXIgIT09IG51bGwgJiYgcHJvdmlkZXIgIT09IHZvaWQgMCA/IHByb3ZpZGVyIDogZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgY29uc3QgcHJvZ3JhbUlkID0gdHJhbnNsYXRlQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgY29uc3QgaWRsQWRkciA9IGF3YWl0IGlkbEFkZHJlc3MocHJvZ3JhbUlkKTtcbiAgICAgICAgY29uc3QgYWNjb3VudEluZm8gPSBhd2FpdCBwcm92aWRlci5jb25uZWN0aW9uLmdldEFjY291bnRJbmZvKGlkbEFkZHIpO1xuICAgICAgICBpZiAoIWFjY291bnRJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaG9wIG9mZiBhY2NvdW50IGRpc2NyaW1pbmF0b3IuXG4gICAgICAgIGxldCBpZGxBY2NvdW50ID0gZGVjb2RlSWRsQWNjb3VudChhY2NvdW50SW5mby5kYXRhLnNsaWNlKDgpKTtcbiAgICAgICAgY29uc3QgaW5mbGF0ZWRJZGwgPSBpbmZsYXRlKGlkbEFjY291bnQuZGF0YSk7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHV0ZjguZGVjb2RlKGluZmxhdGVkSWRsKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIGdpdmVuIGNhbGxiYWNrIGV2ZXJ5IHRpbWUgdGhlIGdpdmVuIGV2ZW50IGlzIGVtaXR0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIFRoZSBQYXNjYWxDYXNlIG5hbWUgb2YgdGhlIGV2ZW50LCBwcm92aWRlZCBieSB0aGUgSURMLlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAgVGhlIGZ1bmN0aW9uIHRvIGludm9rZSB3aGVuZXZlciB0aGUgZXZlbnQgaXMgZW1pdHRlZCBmcm9tXG4gICAgICogICAgICAgICAgICAgICAgICBwcm9ncmFtIGxvZ3MuXG4gICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudHMuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmVzIGZyb20gdGhlIGdpdmVuIGV2ZW50TmFtZS5cbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVFdmVudExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9ldmVudHMucmVtb3ZlRXZlbnRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbImluZmxhdGUiLCJnZXRQcm92aWRlciIsImlkbEFkZHJlc3MiLCJkZWNvZGVJZGxBY2NvdW50IiwiY29udmVydElkbFRvQ2FtZWxDYXNlIiwiQm9yc2hDb2RlciIsIk5hbWVzcGFjZUZhY3RvcnkiLCJ1dGY4IiwiRXZlbnRNYW5hZ2VyIiwidHJhbnNsYXRlQWRkcmVzcyIsIlByb2dyYW0iLCJwcm9ncmFtSWQiLCJfcHJvZ3JhbUlkIiwiaWRsIiwiX2lkbCIsInJhd0lkbCIsIl9yYXdJZGwiLCJjb2RlciIsIl9jb2RlciIsInByb3ZpZGVyIiwiX3Byb3ZpZGVyIiwiY29uc3RydWN0b3IiLCJnZXRDdXN0b21SZXNvbHZlciIsImNhbWVsQ2FzZWRJZGwiLCJhZGRyZXNzIiwiX2V2ZW50cyIsInJwYyIsImluc3RydWN0aW9uIiwidHJhbnNhY3Rpb24iLCJhY2NvdW50Iiwic2ltdWxhdGUiLCJtZXRob2RzIiwidmlld3MiLCJidWlsZCIsImF0IiwiZmV0Y2hJZGwiLCJFcnJvciIsInRvU3RyaW5nIiwiaWRsQWRkciIsImFjY291bnRJbmZvIiwiY29ubmVjdGlvbiIsImdldEFjY291bnRJbmZvIiwiaWRsQWNjb3VudCIsImRhdGEiLCJzbGljZSIsImluZmxhdGVkSWRsIiwiSlNPTiIsInBhcnNlIiwiZGVjb2RlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50TmFtZSIsImNhbGxiYWNrIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImxpc3RlbmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/namespace/account.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/program/namespace/account.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AccountClient: () => (/* binding */ AccountClient),\n/* harmony export */   \"default\": () => (/* binding */ AccountFactory)\n/* harmony export */ });\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ \"(ssr)/../node_modules/eventemitter3/index.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/node_modules/@solana/web3.js/lib/index.esm.js\");\n/* harmony import */ var _provider_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../provider.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/provider.js\");\n/* harmony import */ var _coder_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../coder/index.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/index.js\");\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/common.js\");\n/* harmony import */ var _utils_rpc_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/rpc.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/rpc.js\");\n\n\n\n\n\n\nclass AccountFactory {\n    static build(idl, coder, programId, provider) {\n        var _a;\n        return ((_a = idl.accounts) !== null && _a !== void 0 ? _a : []).reduce((accountFns, acc)=>{\n            accountFns[acc.name] = new AccountClient(idl, acc, programId, provider, coder);\n            return accountFns;\n        }, {});\n    }\n}\nclass AccountClient {\n    /**\n     * Returns the number of bytes in this account.\n     */ get size() {\n        return this._size;\n    }\n    /**\n     * Returns the program ID owning all accounts.\n     */ get programId() {\n        return this._programId;\n    }\n    /**\n     * Returns the client's wallet and network provider.\n     */ get provider() {\n        return this._provider;\n    }\n    /**\n     * Returns the coder.\n     */ get coder() {\n        return this._coder;\n    }\n    constructor(idl, idlAccount, programId, provider, coder){\n        this._idlAccount = idlAccount;\n        this._programId = programId;\n        this._provider = provider !== null && provider !== void 0 ? provider : (0,_provider_js__WEBPACK_IMPORTED_MODULE_2__.getProvider)();\n        this._coder = coder !== null && coder !== void 0 ? coder : new _coder_index_js__WEBPACK_IMPORTED_MODULE_3__.BorshCoder(idl);\n        this._size = this._coder.accounts.size(idlAccount.name);\n    }\n    /**\n     * Returns a deserialized account, returning null if it doesn't exist.\n     *\n     * @param address The address of the account to fetch.\n     */ async fetchNullable(address, commitment) {\n        const { data } = await this.fetchNullableAndContext(address, commitment);\n        return data;\n    }\n    /**\n     * Returns a deserialized account along with the associated rpc response context, returning null if it doesn't exist.\n     *\n     * @param address The address of the account to fetch.\n     */ async fetchNullableAndContext(address, commitment) {\n        const accountInfo = await this.getAccountInfoAndContext(address, commitment);\n        const { value, context } = accountInfo;\n        return {\n            data: value && value.data.length !== 0 ? this._coder.accounts.decode(this._idlAccount.name, value.data) : null,\n            context\n        };\n    }\n    /**\n     * Returns a deserialized account.\n     *\n     * @param address The address of the account to fetch.\n     */ async fetch(address, commitment) {\n        const { data } = await this.fetchNullableAndContext(address, commitment);\n        if (data === null) {\n            throw new Error(`Account does not exist or has no data ${address.toString()}`);\n        }\n        return data;\n    }\n    /**\n     * Returns a deserialized account along with the associated rpc response context.\n     *\n     * @param address The address of the account to fetch.\n     */ async fetchAndContext(address, commitment) {\n        const { data, context } = await this.fetchNullableAndContext(address, commitment);\n        if (data === null) {\n            throw new Error(`Account does not exist ${address.toString()}`);\n        }\n        return {\n            data,\n            context\n        };\n    }\n    /**\n     * Returns multiple deserialized accounts.\n     * Accounts not found or with wrong discriminator are returned as null.\n     *\n     * @param addresses The addresses of the accounts to fetch.\n     */ async fetchMultiple(addresses, commitment) {\n        const accounts = await this.fetchMultipleAndContext(addresses, commitment);\n        return accounts.map((account)=>account ? account.data : null);\n    }\n    /**\n     * Returns multiple deserialized accounts.\n     * Accounts not found or with wrong discriminator are returned as null.\n     *\n     * @param addresses The addresses of the accounts to fetch.\n     */ async fetchMultipleAndContext(addresses, commitment) {\n        const accounts = await _utils_rpc_js__WEBPACK_IMPORTED_MODULE_5__.getMultipleAccountsAndContext(this._provider.connection, addresses.map((address)=>(0,_common_js__WEBPACK_IMPORTED_MODULE_4__.translateAddress)(address)), commitment);\n        // Decode accounts where discriminator is correct, null otherwise\n        return accounts.map((result)=>{\n            if (result == null) {\n                return null;\n            }\n            const { account, context } = result;\n            return {\n                data: this._coder.accounts.decode(this._idlAccount.name, account.data),\n                context\n            };\n        });\n    }\n    /**\n     * Returns all instances of this account type for the program.\n     *\n     * @param filters User-provided filters to narrow the results from `connection.getProgramAccounts`.\n     *\n     *                When filters are not defined this method returns all\n     *                the account instances.\n     *\n     *                When filters are of type `Buffer`, the filters are appended\n     *                after the discriminator.\n     *\n     *                When filters are of type `GetProgramAccountsFilter[]`,\n     *                filters are appended after the discriminator filter.\n     */ async all(filters) {\n        const filter = this.coder.accounts.memcmp(this._idlAccount.name, filters instanceof Buffer ? filters : undefined);\n        const coderFilters = [];\n        if ((filter === null || filter === void 0 ? void 0 : filter.offset) != undefined && (filter === null || filter === void 0 ? void 0 : filter.bytes) != undefined) {\n            coderFilters.push({\n                memcmp: {\n                    offset: filter.offset,\n                    bytes: filter.bytes\n                }\n            });\n        }\n        if ((filter === null || filter === void 0 ? void 0 : filter.dataSize) != undefined) {\n            coderFilters.push({\n                dataSize: filter.dataSize\n            });\n        }\n        let resp = await this._provider.connection.getProgramAccounts(this._programId, {\n            commitment: this._provider.connection.commitment,\n            filters: [\n                ...coderFilters,\n                ...Array.isArray(filters) ? filters : []\n            ]\n        });\n        return resp.map(({ pubkey, account })=>{\n            return {\n                publicKey: pubkey,\n                account: this._coder.accounts.decode(this._idlAccount.name, account.data)\n            };\n        });\n    }\n    /**\n     * Returns an `EventEmitter` emitting a \"change\" event whenever the account\n     * changes.\n     */ subscribe(address, commitment) {\n        const sub = subscriptions.get(address.toString());\n        if (sub) {\n            return sub.ee;\n        }\n        const ee = new (eventemitter3__WEBPACK_IMPORTED_MODULE_0___default())();\n        address = (0,_common_js__WEBPACK_IMPORTED_MODULE_4__.translateAddress)(address);\n        const listener = this._provider.connection.onAccountChange(address, (acc)=>{\n            const account = this._coder.accounts.decode(this._idlAccount.name, acc.data);\n            ee.emit(\"change\", account);\n        }, commitment);\n        subscriptions.set(address.toString(), {\n            ee,\n            listener\n        });\n        return ee;\n    }\n    /**\n     * Unsubscribes from the account at the given address.\n     */ async unsubscribe(address) {\n        let sub = subscriptions.get(address.toString());\n        if (!sub) {\n            console.warn(\"Address is not subscribed\");\n            return;\n        }\n        if (subscriptions) {\n            await this._provider.connection.removeAccountChangeListener(sub.listener).then(()=>{\n                subscriptions.delete(address.toString());\n            }).catch(console.error);\n        }\n    }\n    /**\n     * Returns an instruction for creating this account.\n     */ async createInstruction(signer, sizeOverride) {\n        const size = this.size;\n        if (this._provider.publicKey === undefined) {\n            throw new Error(\"This function requires the Provider interface implementor to have a 'publicKey' field.\");\n        }\n        return _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.SystemProgram.createAccount({\n            fromPubkey: this._provider.publicKey,\n            newAccountPubkey: signer.publicKey,\n            space: sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size,\n            lamports: await this._provider.connection.getMinimumBalanceForRentExemption(sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size),\n            programId: this._programId\n        });\n    }\n    async getAccountInfo(address, commitment) {\n        return await this._provider.connection.getAccountInfo((0,_common_js__WEBPACK_IMPORTED_MODULE_4__.translateAddress)(address), commitment);\n    }\n    async getAccountInfoAndContext(address, commitment) {\n        return await this._provider.connection.getAccountInfoAndContext((0,_common_js__WEBPACK_IMPORTED_MODULE_4__.translateAddress)(address), commitment);\n    }\n}\n// Tracks all subscriptions.\nconst subscriptions = new Map(); //# sourceMappingURL=account.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3Byb2dyYW0vbmFtZXNwYWNlL2FjY291bnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXlDO0FBQ1E7QUFDRDtBQUNFO0FBQ0Y7QUFDRjtBQUMvQixNQUFNTTtJQUNqQixPQUFPQyxNQUFNQyxHQUFHLEVBQUVDLEtBQUssRUFBRUMsU0FBUyxFQUFFQyxRQUFRLEVBQUU7UUFDMUMsSUFBSUM7UUFDSixPQUFPLENBQUMsQ0FBQ0EsS0FBS0osSUFBSUssUUFBUSxNQUFNLFFBQVFELE9BQU8sS0FBSyxJQUFJQSxLQUFLLEVBQUUsRUFBRUUsTUFBTSxDQUFDLENBQUNDLFlBQVlDO1lBQ2pGRCxVQUFVLENBQUNDLElBQUlDLElBQUksQ0FBQyxHQUFHLElBQUlDLGNBQWNWLEtBQUtRLEtBQUtOLFdBQVdDLFVBQVVGO1lBQ3hFLE9BQU9NO1FBQ1gsR0FBRyxDQUFDO0lBQ1I7QUFDSjtBQUNPLE1BQU1HO0lBQ1Q7O0tBRUMsR0FDRCxJQUFJQyxPQUFPO1FBQ1AsT0FBTyxJQUFJLENBQUNDLEtBQUs7SUFDckI7SUFDQTs7S0FFQyxHQUNELElBQUlWLFlBQVk7UUFDWixPQUFPLElBQUksQ0FBQ1csVUFBVTtJQUMxQjtJQUNBOztLQUVDLEdBQ0QsSUFBSVYsV0FBVztRQUNYLE9BQU8sSUFBSSxDQUFDVyxTQUFTO0lBQ3pCO0lBQ0E7O0tBRUMsR0FDRCxJQUFJYixRQUFRO1FBQ1IsT0FBTyxJQUFJLENBQUNjLE1BQU07SUFDdEI7SUFDQUMsWUFBWWhCLEdBQUcsRUFBRWlCLFVBQVUsRUFBRWYsU0FBUyxFQUFFQyxRQUFRLEVBQUVGLEtBQUssQ0FBRTtRQUNyRCxJQUFJLENBQUNpQixXQUFXLEdBQUdEO1FBQ25CLElBQUksQ0FBQ0osVUFBVSxHQUFHWDtRQUNsQixJQUFJLENBQUNZLFNBQVMsR0FBR1gsYUFBYSxRQUFRQSxhQUFhLEtBQUssSUFBSUEsV0FBV1QseURBQVdBO1FBQ2xG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QUFJLENBQUNBLElBQUk7UUFDdEIsSUFBSSxJQUFJLENBQUNHLFNBQVMsQ0FBQzRDLFNBQVMsS0FBS1gsV0FBVztZQUN4QyxNQUFNLElBQUloQixNQUFNO1FBQ3BCO1FBQ0EsT0FBT3RDLDBEQUFhQSxDQUFDc0YsYUFBYSxDQUFDO1lBQy9CQyxZQUFZLElBQUksQ0FBQ2xFLFNBQVMsQ0FBQzRDLFNBQVM7WUFDcEN1QixrQkFBa0JKLE9BQU9uQixTQUFTO1lBQ2xDd0IsT0FBT0osaUJBQWlCLFFBQVFBLGlCQUFpQixLQUFLLElBQUlBLGVBQWVuRTtZQUN6RXdFLFVBQVUsTUFBTSxJQUFJLENBQUNyRSxTQUFTLENBQUMwQixVQUFVLENBQUM0QyxpQ0FBaUMsQ0FBQ04saUJBQWlCLFFBQVFBLGlCQUFpQixLQUFLLElBQUlBLGVBQWVuRTtZQUM5SVQsV0FBVyxJQUFJLENBQUNXLFVBQVU7UUFDOUI7SUFDSjtJQUNBLE1BQU13RSxlQUFlakUsT0FBTyxFQUFFQyxVQUFVLEVBQUU7UUFDdEMsT0FBTyxNQUFNLElBQUksQ0FBQ1AsU0FBUyxDQUFDMEIsVUFBVSxDQUFDNkMsY0FBYyxDQUFDekYsNERBQWdCQSxDQUFDd0IsVUFBVUM7SUFDckY7SUFDQSxNQUFNSSx5QkFBeUJMLE9BQU8sRUFBRUMsVUFBVSxFQUFFO1FBQ2hELE9BQU8sTUFBTSxJQUFJLENBQUNQLFNBQVMsQ0FBQzBCLFVBQVUsQ0FBQ2Ysd0JBQXdCLENBQUM3Qiw0REFBZ0JBLENBQUN3QixVQUFVQztJQUMvRjtBQUNKO0FBQ0EsNEJBQTRCO0FBQzVCLE1BQU13QyxnQkFBZ0IsSUFBSXlCLE9BQzFCLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGNvcmFsLXh5ei9hbmNob3IvZGlzdC9lc20vcHJvZ3JhbS9uYW1lc3BhY2UvYWNjb3VudC5qcz80MjM2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSBcImV2ZW50ZW1pdHRlcjNcIjtcbmltcG9ydCB7IFN5c3RlbVByb2dyYW0sIH0gZnJvbSBcIkBzb2xhbmEvd2ViMy5qc1wiO1xuaW1wb3J0IHsgZ2V0UHJvdmlkZXIgfSBmcm9tIFwiLi4vLi4vcHJvdmlkZXIuanNcIjtcbmltcG9ydCB7IEJvcnNoQ29kZXIgfSBmcm9tIFwiLi4vLi4vY29kZXIvaW5kZXguanNcIjtcbmltcG9ydCB7IHRyYW5zbGF0ZUFkZHJlc3MgfSBmcm9tIFwiLi4vY29tbW9uLmpzXCI7XG5pbXBvcnQgKiBhcyBycGNVdGlsIGZyb20gXCIuLi8uLi91dGlscy9ycGMuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFjY291bnRGYWN0b3J5IHtcbiAgICBzdGF0aWMgYnVpbGQoaWRsLCBjb2RlciwgcHJvZ3JhbUlkLCBwcm92aWRlcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gaWRsLmFjY291bnRzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSkucmVkdWNlKChhY2NvdW50Rm5zLCBhY2MpID0+IHtcbiAgICAgICAgICAgIGFjY291bnRGbnNbYWNjLm5hbWVdID0gbmV3IEFjY291bnRDbGllbnQoaWRsLCBhY2MsIHByb2dyYW1JZCwgcHJvdmlkZXIsIGNvZGVyKTtcbiAgICAgICAgICAgIHJldHVybiBhY2NvdW50Rm5zO1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEFjY291bnRDbGllbnQge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBieXRlcyBpbiB0aGlzIGFjY291bnQuXG4gICAgICovXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwcm9ncmFtIElEIG93bmluZyBhbGwgYWNjb3VudHMuXG4gICAgICovXG4gICAgZ2V0IHByb2dyYW1JZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2dyYW1JZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY2xpZW50J3Mgd2FsbGV0IGFuZCBuZXR3b3JrIHByb3ZpZGVyLlxuICAgICAqL1xuICAgIGdldCBwcm92aWRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3ZpZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb2Rlci5cbiAgICAgKi9cbiAgICBnZXQgY29kZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2RlcjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoaWRsLCBpZGxBY2NvdW50LCBwcm9ncmFtSWQsIHByb3ZpZGVyLCBjb2Rlcikge1xuICAgICAgICB0aGlzLl9pZGxBY2NvdW50ID0gaWRsQWNjb3VudDtcbiAgICAgICAgdGhpcy5fcHJvZ3JhbUlkID0gcHJvZ3JhbUlkO1xuICAgICAgICB0aGlzLl9wcm92aWRlciA9IHByb3ZpZGVyICE9PSBudWxsICYmIHByb3ZpZGVyICE9PSB2b2lkIDAgPyBwcm92aWRlciA6IGdldFByb3ZpZGVyKCk7XG4gICAgICAgIHRoaXMuX2NvZGVyID0gY29kZXIgIT09IG51bGwgJiYgY29kZXIgIT09IHZvaWQgMCA/IGNvZGVyIDogbmV3IEJvcnNoQ29kZXIoaWRsKTtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IHRoaXMuX2NvZGVyLmFjY291bnRzLnNpemUoaWRsQWNjb3VudC5uYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGRlc2VyaWFsaXplZCBhY2NvdW50LCByZXR1cm5pbmcgbnVsbCBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgVGhlIGFkZHJlc3Mgb2YgdGhlIGFjY291bnQgdG8gZmV0Y2guXG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hOdWxsYWJsZShhZGRyZXNzLCBjb21taXRtZW50KSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgdGhpcy5mZXRjaE51bGxhYmxlQW5kQ29udGV4dChhZGRyZXNzLCBjb21taXRtZW50KTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBkZXNlcmlhbGl6ZWQgYWNjb3VudCBhbG9uZyB3aXRoIHRoZSBhc3NvY2lhdGVkIHJwYyByZXNwb25zZSBjb250ZXh0LCByZXR1cm5pbmcgbnVsbCBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgVGhlIGFkZHJlc3Mgb2YgdGhlIGFjY291bnQgdG8gZmV0Y2guXG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hOdWxsYWJsZUFuZENvbnRleHQoYWRkcmVzcywgY29tbWl0bWVudCkge1xuICAgICAgICBjb25zdCBhY2NvdW50SW5mbyA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudEluZm9BbmRDb250ZXh0KGFkZHJlc3MsIGNvbW1pdG1lbnQpO1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBjb250ZXh0IH0gPSBhY2NvdW50SW5mbztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IHZhbHVlICYmIHZhbHVlLmRhdGEubGVuZ3RoICE9PSAwXG4gICAgICAgICAgICAgICAgPyB0aGlzLl9jb2Rlci5hY2NvdW50cy5kZWNvZGUodGhpcy5faWRsQWNjb3VudC5uYW1lLCB2YWx1ZS5kYXRhKVxuICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBkZXNlcmlhbGl6ZWQgYWNjb3VudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIFRoZSBhZGRyZXNzIG9mIHRoZSBhY2NvdW50IHRvIGZldGNoLlxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoKGFkZHJlc3MsIGNvbW1pdG1lbnQpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCB0aGlzLmZldGNoTnVsbGFibGVBbmRDb250ZXh0KGFkZHJlc3MsIGNvbW1pdG1lbnQpO1xuICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBY2NvdW50IGRvZXMgbm90IGV4aXN0IG9yIGhhcyBubyBkYXRhICR7YWRkcmVzcy50b1N0cmluZygpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZGVzZXJpYWxpemVkIGFjY291bnQgYWxvbmcgd2l0aCB0aGUgYXNzb2NpYXRlZCBycGMgcmVzcG9uc2UgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIFRoZSBhZGRyZXNzIG9mIHRoZSBhY2NvdW50IHRvIGZldGNoLlxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoQW5kQ29udGV4dChhZGRyZXNzLCBjb21taXRtZW50KSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSwgY29udGV4dCB9ID0gYXdhaXQgdGhpcy5mZXRjaE51bGxhYmxlQW5kQ29udGV4dChhZGRyZXNzLCBjb21taXRtZW50KTtcbiAgICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQWNjb3VudCBkb2VzIG5vdCBleGlzdCAke2FkZHJlc3MudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkYXRhLCBjb250ZXh0IH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbXVsdGlwbGUgZGVzZXJpYWxpemVkIGFjY291bnRzLlxuICAgICAqIEFjY291bnRzIG5vdCBmb3VuZCBvciB3aXRoIHdyb25nIGRpc2NyaW1pbmF0b3IgYXJlIHJldHVybmVkIGFzIG51bGwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzc2VzIFRoZSBhZGRyZXNzZXMgb2YgdGhlIGFjY291bnRzIHRvIGZldGNoLlxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoTXVsdGlwbGUoYWRkcmVzc2VzLCBjb21taXRtZW50KSB7XG4gICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgdGhpcy5mZXRjaE11bHRpcGxlQW5kQ29udGV4dChhZGRyZXNzZXMsIGNvbW1pdG1lbnQpO1xuICAgICAgICByZXR1cm4gYWNjb3VudHMubWFwKChhY2NvdW50KSA9PiAoYWNjb3VudCA/IGFjY291bnQuZGF0YSA6IG51bGwpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBtdWx0aXBsZSBkZXNlcmlhbGl6ZWQgYWNjb3VudHMuXG4gICAgICogQWNjb3VudHMgbm90IGZvdW5kIG9yIHdpdGggd3JvbmcgZGlzY3JpbWluYXRvciBhcmUgcmV0dXJuZWQgYXMgbnVsbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzZXMgVGhlIGFkZHJlc3NlcyBvZiB0aGUgYWNjb3VudHMgdG8gZmV0Y2guXG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hNdWx0aXBsZUFuZENvbnRleHQoYWRkcmVzc2VzLCBjb21taXRtZW50KSB7XG4gICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgcnBjVXRpbC5nZXRNdWx0aXBsZUFjY291bnRzQW5kQ29udGV4dCh0aGlzLl9wcm92aWRlci5jb25uZWN0aW9uLCBhZGRyZXNzZXMubWFwKChhZGRyZXNzKSA9PiB0cmFuc2xhdGVBZGRyZXNzKGFkZHJlc3MpKSwgY29tbWl0bWVudCk7XG4gICAgICAgIC8vIERlY29kZSBhY2NvdW50cyB3aGVyZSBkaXNjcmltaW5hdG9yIGlzIGNvcnJlY3QsIG51bGwgb3RoZXJ3aXNlXG4gICAgICAgIHJldHVybiBhY2NvdW50cy5tYXAoKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGFjY291bnQsIGNvbnRleHQgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogdGhpcy5fY29kZXIuYWNjb3VudHMuZGVjb2RlKHRoaXMuX2lkbEFjY291bnQubmFtZSwgYWNjb3VudC5kYXRhKSxcbiAgICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGluc3RhbmNlcyBvZiB0aGlzIGFjY291bnQgdHlwZSBmb3IgdGhlIHByb2dyYW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsdGVycyBVc2VyLXByb3ZpZGVkIGZpbHRlcnMgdG8gbmFycm93IHRoZSByZXN1bHRzIGZyb20gYGNvbm5lY3Rpb24uZ2V0UHJvZ3JhbUFjY291bnRzYC5cbiAgICAgKlxuICAgICAqICAgICAgICAgICAgICAgIFdoZW4gZmlsdGVycyBhcmUgbm90IGRlZmluZWQgdGhpcyBtZXRob2QgcmV0dXJucyBhbGxcbiAgICAgKiAgICAgICAgICAgICAgICB0aGUgYWNjb3VudCBpbnN0YW5jZXMuXG4gICAgICpcbiAgICAgKiAgICAgICAgICAgICAgICBXaGVuIGZpbHRlcnMgYXJlIG9mIHR5cGUgYEJ1ZmZlcmAsIHRoZSBmaWx0ZXJzIGFyZSBhcHBlbmRlZFxuICAgICAqICAgICAgICAgICAgICAgIGFmdGVyIHRoZSBkaXNjcmltaW5hdG9yLlxuICAgICAqXG4gICAgICogICAgICAgICAgICAgICAgV2hlbiBmaWx0ZXJzIGFyZSBvZiB0eXBlIGBHZXRQcm9ncmFtQWNjb3VudHNGaWx0ZXJbXWAsXG4gICAgICogICAgICAgICAgICAgICAgZmlsdGVycyBhcmUgYXBwZW5kZWQgYWZ0ZXIgdGhlIGRpc2NyaW1pbmF0b3IgZmlsdGVyLlxuICAgICAqL1xuICAgIGFzeW5jIGFsbChmaWx0ZXJzKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuY29kZXIuYWNjb3VudHMubWVtY21wKHRoaXMuX2lkbEFjY291bnQubmFtZSwgZmlsdGVycyBpbnN0YW5jZW9mIEJ1ZmZlciA/IGZpbHRlcnMgOiB1bmRlZmluZWQpO1xuICAgICAgICBjb25zdCBjb2RlckZpbHRlcnMgPSBbXTtcbiAgICAgICAgaWYgKChmaWx0ZXIgPT09IG51bGwgfHwgZmlsdGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWx0ZXIub2Zmc2V0KSAhPSB1bmRlZmluZWQgJiYgKGZpbHRlciA9PT0gbnVsbCB8fCBmaWx0ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpbHRlci5ieXRlcykgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb2RlckZpbHRlcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbWVtY21wOiB7IG9mZnNldDogZmlsdGVyLm9mZnNldCwgYnl0ZXM6IGZpbHRlci5ieXRlcyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChmaWx0ZXIgPT09IG51bGwgfHwgZmlsdGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWx0ZXIuZGF0YVNpemUpICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29kZXJGaWx0ZXJzLnB1c2goeyBkYXRhU2l6ZTogZmlsdGVyLmRhdGFTaXplIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwID0gYXdhaXQgdGhpcy5fcHJvdmlkZXIuY29ubmVjdGlvbi5nZXRQcm9ncmFtQWNjb3VudHModGhpcy5fcHJvZ3JhbUlkLCB7XG4gICAgICAgICAgICBjb21taXRtZW50OiB0aGlzLl9wcm92aWRlci5jb25uZWN0aW9uLmNvbW1pdG1lbnQsXG4gICAgICAgICAgICBmaWx0ZXJzOiBbLi4uY29kZXJGaWx0ZXJzLCAuLi4oQXJyYXkuaXNBcnJheShmaWx0ZXJzKSA/IGZpbHRlcnMgOiBbXSldLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3AubWFwKCh7IHB1YmtleSwgYWNjb3VudCB9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHB1YmxpY0tleTogcHVia2V5LFxuICAgICAgICAgICAgICAgIGFjY291bnQ6IHRoaXMuX2NvZGVyLmFjY291bnRzLmRlY29kZSh0aGlzLl9pZGxBY2NvdW50Lm5hbWUsIGFjY291bnQuZGF0YSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBgRXZlbnRFbWl0dGVyYCBlbWl0dGluZyBhIFwiY2hhbmdlXCIgZXZlbnQgd2hlbmV2ZXIgdGhlIGFjY291bnRcbiAgICAgKiBjaGFuZ2VzLlxuICAgICAqL1xuICAgIHN1YnNjcmliZShhZGRyZXNzLCBjb21taXRtZW50KSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IHN1YnNjcmlwdGlvbnMuZ2V0KGFkZHJlc3MudG9TdHJpbmcoKSk7XG4gICAgICAgIGlmIChzdWIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWIuZWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIGFkZHJlc3MgPSB0cmFuc2xhdGVBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IHRoaXMuX3Byb3ZpZGVyLmNvbm5lY3Rpb24ub25BY2NvdW50Q2hhbmdlKGFkZHJlc3MsIChhY2MpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnQgPSB0aGlzLl9jb2Rlci5hY2NvdW50cy5kZWNvZGUodGhpcy5faWRsQWNjb3VudC5uYW1lLCBhY2MuZGF0YSk7XG4gICAgICAgICAgICBlZS5lbWl0KFwiY2hhbmdlXCIsIGFjY291bnQpO1xuICAgICAgICB9LCBjb21taXRtZW50KTtcbiAgICAgICAgc3Vic2NyaXB0aW9ucy5zZXQoYWRkcmVzcy50b1N0cmluZygpLCB7XG4gICAgICAgICAgICBlZSxcbiAgICAgICAgICAgIGxpc3RlbmVyLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnN1YnNjcmliZXMgZnJvbSB0aGUgYWNjb3VudCBhdCB0aGUgZ2l2ZW4gYWRkcmVzcy5cbiAgICAgKi9cbiAgICBhc3luYyB1bnN1YnNjcmliZShhZGRyZXNzKSB7XG4gICAgICAgIGxldCBzdWIgPSBzdWJzY3JpcHRpb25zLmdldChhZGRyZXNzLnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQWRkcmVzcyBpcyBub3Qgc3Vic2NyaWJlZFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcHJvdmlkZXIuY29ubmVjdGlvblxuICAgICAgICAgICAgICAgIC5yZW1vdmVBY2NvdW50Q2hhbmdlTGlzdGVuZXIoc3ViLmxpc3RlbmVyKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25zLmRlbGV0ZShhZGRyZXNzLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBpbnN0cnVjdGlvbiBmb3IgY3JlYXRpbmcgdGhpcyBhY2NvdW50LlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUluc3RydWN0aW9uKHNpZ25lciwgc2l6ZU92ZXJyaWRlKSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLnNpemU7XG4gICAgICAgIGlmICh0aGlzLl9wcm92aWRlci5wdWJsaWNLZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBmdW5jdGlvbiByZXF1aXJlcyB0aGUgUHJvdmlkZXIgaW50ZXJmYWNlIGltcGxlbWVudG9yIHRvIGhhdmUgYSAncHVibGljS2V5JyBmaWVsZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN5c3RlbVByb2dyYW0uY3JlYXRlQWNjb3VudCh7XG4gICAgICAgICAgICBmcm9tUHVia2V5OiB0aGlzLl9wcm92aWRlci5wdWJsaWNLZXksXG4gICAgICAgICAgICBuZXdBY2NvdW50UHVia2V5OiBzaWduZXIucHVibGljS2V5LFxuICAgICAgICAgICAgc3BhY2U6IHNpemVPdmVycmlkZSAhPT0gbnVsbCAmJiBzaXplT3ZlcnJpZGUgIT09IHZvaWQgMCA/IHNpemVPdmVycmlkZSA6IHNpemUsXG4gICAgICAgICAgICBsYW1wb3J0czogYXdhaXQgdGhpcy5fcHJvdmlkZXIuY29ubmVjdGlvbi5nZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb24oc2l6ZU92ZXJyaWRlICE9PSBudWxsICYmIHNpemVPdmVycmlkZSAhPT0gdm9pZCAwID8gc2l6ZU92ZXJyaWRlIDogc2l6ZSksXG4gICAgICAgICAgICBwcm9ncmFtSWQ6IHRoaXMuX3Byb2dyYW1JZCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGdldEFjY291bnRJbmZvKGFkZHJlc3MsIGNvbW1pdG1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3Byb3ZpZGVyLmNvbm5lY3Rpb24uZ2V0QWNjb3VudEluZm8odHJhbnNsYXRlQWRkcmVzcyhhZGRyZXNzKSwgY29tbWl0bWVudCk7XG4gICAgfVxuICAgIGFzeW5jIGdldEFjY291bnRJbmZvQW5kQ29udGV4dChhZGRyZXNzLCBjb21taXRtZW50KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9wcm92aWRlci5jb25uZWN0aW9uLmdldEFjY291bnRJbmZvQW5kQ29udGV4dCh0cmFuc2xhdGVBZGRyZXNzKGFkZHJlc3MpLCBjb21taXRtZW50KTtcbiAgICB9XG59XG4vLyBUcmFja3MgYWxsIHN1YnNjcmlwdGlvbnMuXG5jb25zdCBzdWJzY3JpcHRpb25zID0gbmV3IE1hcCgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWNjb3VudC5qcy5tYXAiXSwibmFtZXMiOlsiRXZlbnRFbWl0dGVyIiwiU3lzdGVtUHJvZ3JhbSIsImdldFByb3ZpZGVyIiwiQm9yc2hDb2RlciIsInRyYW5zbGF0ZUFkZHJlc3MiLCJycGNVdGlsIiwiQWNjb3VudEZhY3RvcnkiLCJidWlsZCIsImlkbCIsImNvZGVyIiwicHJvZ3JhbUlkIiwicHJvdmlkZXIiLCJfYSIsImFjY291bnRzIiwicmVkdWNlIiwiYWNjb3VudEZucyIsImFjYyIsIm5hbWUiLCJBY2NvdW50Q2xpZW50Iiwic2l6ZSIsIl9zaXplIiwiX3Byb2dyYW1JZCIsIl9wcm92aWRlciIsIl9jb2RlciIsImNvbnN0cnVjdG9yIiwiaWRsQWNjb3VudCIsIl9pZGxBY2NvdW50IiwiZmV0Y2hOdWxsYWJsZSIsImFkZHJlc3MiLCJjb21taXRtZW50IiwiZGF0YSIsImZldGNoTnVsbGFibGVBbmRDb250ZXh0IiwiYWNjb3VudEluZm8iLCJnZXRBY2NvdW50SW5mb0FuZENvbnRleHQiLCJ2YWx1ZSIsImNvbnRleHQiLCJsZW5ndGgiLCJkZWNvZGUiLCJmZXRjaCIsIkVycm9yIiwidG9TdHJpbmciLCJmZXRjaEFuZENvbnRleHQiLCJmZXRjaE11bHRpcGxlIiwiYWRkcmVzc2VzIiwiZmV0Y2hNdWx0aXBsZUFuZENvbnRleHQiLCJtYXAiLCJhY2NvdW50IiwiZ2V0TXVsdGlwbGVBY2NvdW50c0FuZENvbnRleHQiLCJjb25uZWN0aW9uIiwicmVzdWx0IiwiYWxsIiwiZmlsdGVycyIsImZpbHRlciIsIm1lbWNtcCIsIkJ1ZmZlciIsInVuZGVmaW5lZCIsImNvZGVyRmlsdGVycyIsIm9mZnNldCIsImJ5dGVzIiwicHVzaCIsImRhdGFTaXplIiwicmVzcCIsImdldFByb2dyYW1BY2NvdW50cyIsIkFycmF5IiwiaXNBcnJheSIsInB1YmtleSIsInB1YmxpY0tleSIsInN1YnNjcmliZSIsInN1YiIsInN1YnNjcmlwdGlvbnMiLCJnZXQiLCJlZSIsImxpc3RlbmVyIiwib25BY2NvdW50Q2hhbmdlIiwiZW1pdCIsInNldCIsInVuc3Vic2NyaWJlIiwiY29uc29sZSIsIndhcm4iLCJyZW1vdmVBY2NvdW50Q2hhbmdlTGlzdGVuZXIiLCJ0aGVuIiwiZGVsZXRlIiwiY2F0Y2giLCJlcnJvciIsImNyZWF0ZUluc3RydWN0aW9uIiwic2lnbmVyIiwic2l6ZU92ZXJyaWRlIiwiY3JlYXRlQWNjb3VudCIsImZyb21QdWJrZXkiLCJuZXdBY2NvdW50UHVia2V5Iiwic3BhY2UiLCJsYW1wb3J0cyIsImdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvbiIsImdldEFjY291bnRJbmZvIiwiTWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/namespace/account.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/namespace/index.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/program/namespace/index.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AccountClient: () => (/* reexport safe */ _account_js__WEBPACK_IMPORTED_MODULE_3__.AccountClient),\n/* harmony export */   MethodsBuilderFactory: () => (/* reexport safe */ _methods__WEBPACK_IMPORTED_MODULE_6__.MethodsBuilderFactory),\n/* harmony export */   \"default\": () => (/* binding */ NamespaceFactory)\n/* harmony export */ });\n/* harmony import */ var _instruction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instruction.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/namespace/instruction.js\");\n/* harmony import */ var _transaction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transaction.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/namespace/transaction.js\");\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rpc.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/namespace/rpc.js\");\n/* harmony import */ var _account_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./account.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/namespace/account.js\");\n/* harmony import */ var _simulate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./simulate.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/namespace/simulate.js\");\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/common.js\");\n/* harmony import */ var _methods__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./methods */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/namespace/methods.js\");\n/* harmony import */ var _views__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./views */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/namespace/views.js\");\n\n\n\n\n\n\n\n\n\n\nclass NamespaceFactory {\n    /**\n     * Generates all namespaces for a given program.\n     */ static build(idl, coder, programId, provider, getCustomResolver) {\n        const rpc = {};\n        const instruction = {};\n        const transaction = {};\n        const simulate = {};\n        const methods = {};\n        const view = {};\n        const idlErrors = (0,_common_js__WEBPACK_IMPORTED_MODULE_5__.parseIdlErrors)(idl);\n        const account = idl.accounts ? _account_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].build(idl, coder, programId, provider) : {};\n        idl.instructions.forEach((idlIx)=>{\n            const ixItem = _instruction_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].build(idlIx, (ixName, ix)=>coder.instruction.encode(ixName, ix), programId);\n            const txItem = _transaction_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].build(idlIx, ixItem);\n            const rpcItem = _rpc_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].build(idlIx, txItem, idlErrors, provider);\n            const simulateItem = _simulate_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].build(idlIx, txItem, idlErrors, provider, coder, programId, idl);\n            const viewItem = _views__WEBPACK_IMPORTED_MODULE_7__[\"default\"].build(programId, idlIx, simulateItem, idl);\n            const methodItem = _methods__WEBPACK_IMPORTED_MODULE_6__.MethodsBuilderFactory.build(provider, programId, idlIx, ixItem, txItem, rpcItem, simulateItem, viewItem, account, idl.types || [], getCustomResolver === null || getCustomResolver === void 0 ? void 0 : getCustomResolver(idlIx));\n            const name = idlIx.name;\n            instruction[name] = ixItem;\n            transaction[name] = txItem;\n            rpc[name] = rpcItem;\n            simulate[name] = simulateItem;\n            methods[name] = methodItem;\n            if (viewItem) {\n                view[name] = viewItem;\n            }\n        });\n        return [\n            rpc,\n            instruction,\n            transaction,\n            account,\n            simulate,\n            methods,\n            view\n        ];\n    }\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3Byb2dyYW0vbmFtZXNwYWNlL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQWtEO0FBQ0E7QUFDaEI7QUFDUTtBQUNFO0FBQ0U7QUFDSTtBQUNoQjtBQUNXO0FBQ0s7QUFDbkMsTUFBTVM7SUFDakI7O0tBRUMsR0FDRCxPQUFPQyxNQUFNQyxHQUFHLEVBQUVDLEtBQUssRUFBRUMsU0FBUyxFQUFFQyxRQUFRLEVBQUVDLGlCQUFpQixFQUFFO1FBQzdELE1BQU1DLE1BQU0sQ0FBQztRQUNiLE1BQU1DLGNBQWMsQ0FBQztRQUNyQixNQUFNQyxjQUFjLENBQUM7UUFDckIsTUFBTUMsV0FBVyxDQUFDO1FBQ2xCLE1BQU1DLFVBQVUsQ0FBQztRQUNqQixNQUFNQyxPQUFPLENBQUM7UUFDZCxNQUFNQyxZQUFZakIsMERBQWNBLENBQUNNO1FBQ2pDLE1BQU1ZLFVBQVVaLElBQUlhLFFBQVEsR0FDdEJyQixtREFBY0EsQ0FBQ08sS0FBSyxDQUFDQyxLQUFLQyxPQUFPQyxXQUFXQyxZQUM1QyxDQUFDO1FBQ1BILElBQUljLFlBQVksQ0FBQ0MsT0FBTyxDQUFDLENBQUNDO1lBQ3RCLE1BQU1DLFNBQVM1Qix1REFBa0JBLENBQUNVLEtBQUssQ0FBQ2lCLE9BQU8sQ0FBQ0UsUUFBUUMsS0FBT2xCLE1BQU1LLFdBQVcsQ0FBQ2MsTUFBTSxDQUFDRixRQUFRQyxLQUFLakI7WUFDckcsTUFBTW1CLFNBQVMvQix1REFBa0JBLENBQUNTLEtBQUssQ0FBQ2lCLE9BQU9DO1lBQy9DLE1BQU1LLFVBQVUvQiwrQ0FBVUEsQ0FBQ1EsS0FBSyxDQUFDaUIsT0FBT0ssUUFBUVYsV0FBV1I7WUFDM0QsTUFBTW9CLGVBQWU5QixvREFBZUEsQ0FBQ00sS0FBSyxDQUFDaUIsT0FBT0ssUUFBUVYsV0FBV1IsVUFBVUYsT0FBT0MsV0FBV0Y7WUFDakcsTUFBTXdCLFdBQVc1Qiw4Q0FBV0EsQ0FBQ0csS0FBSyxDQUFDRyxXQUFXYyxPQUFPTyxjQUFjdkI7WUFDbkUsTUFBTXlCLGFBQWE5QiwyREFBcUJBLENBQUNJLEtBQUssQ0FBQ0ksVUFBVUQsV0FBV2MsT0FBT0MsUUFBUUksUUFBUUMsU0FBU0MsY0FBY0MsVUFBVVosU0FBU1osSUFBSTBCLEtBQUssSUFBSSxFQUFFLEVBQUV0QixzQkFBc0IsUUFBUUEsc0JBQXNCLEtBQUssSUFBSSxLQUFLLElBQUlBLGtCQUFrQlk7WUFDOU8sTUFBTVcsT0FBT1gsTUFBTVcsSUFBSTtZQUN2QnJCLFdBQVcsQ0FBQ3FCLEtBQUssR0FBR1Y7WUFDcEJWLFdBQVcsQ0FBQ29CLEtBQUssR0FBR047WUFDcEJoQixHQUFHLENBQUNzQixLQUFLLEdBQUdMO1lBQ1pkLFFBQVEsQ0FBQ21CLEtBQUssR0FBR0o7WUFDakJkLE9BQU8sQ0FBQ2tCLEtBQUssR0FBR0Y7WUFDaEIsSUFBSUQsVUFBVTtnQkFDVmQsSUFBSSxDQUFDaUIsS0FBSyxHQUFHSDtZQUNqQjtRQUNKO1FBQ0EsT0FBTztZQUNIbkI7WUFDQUM7WUFDQUM7WUFDQUs7WUFDQUo7WUFDQUM7WUFDQUM7U0FDSDtJQUNMO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3Byb2dyYW0vbmFtZXNwYWNlL2luZGV4LmpzPzRhODYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEluc3RydWN0aW9uRmFjdG9yeSBmcm9tIFwiLi9pbnN0cnVjdGlvbi5qc1wiO1xuaW1wb3J0IFRyYW5zYWN0aW9uRmFjdG9yeSBmcm9tIFwiLi90cmFuc2FjdGlvbi5qc1wiO1xuaW1wb3J0IFJwY0ZhY3RvcnkgZnJvbSBcIi4vcnBjLmpzXCI7XG5pbXBvcnQgQWNjb3VudEZhY3RvcnkgZnJvbSBcIi4vYWNjb3VudC5qc1wiO1xuaW1wb3J0IFNpbXVsYXRlRmFjdG9yeSBmcm9tIFwiLi9zaW11bGF0ZS5qc1wiO1xuaW1wb3J0IHsgcGFyc2VJZGxFcnJvcnMgfSBmcm9tIFwiLi4vY29tbW9uLmpzXCI7XG5pbXBvcnQgeyBNZXRob2RzQnVpbGRlckZhY3RvcnkgfSBmcm9tIFwiLi9tZXRob2RzXCI7XG5pbXBvcnQgVmlld0ZhY3RvcnkgZnJvbSBcIi4vdmlld3NcIjtcbmV4cG9ydCB7IEFjY291bnRDbGllbnQgfSBmcm9tIFwiLi9hY2NvdW50LmpzXCI7XG5leHBvcnQgeyBNZXRob2RzQnVpbGRlckZhY3RvcnkgfSBmcm9tIFwiLi9tZXRob2RzXCI7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOYW1lc3BhY2VGYWN0b3J5IHtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYWxsIG5hbWVzcGFjZXMgZm9yIGEgZ2l2ZW4gcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnVpbGQoaWRsLCBjb2RlciwgcHJvZ3JhbUlkLCBwcm92aWRlciwgZ2V0Q3VzdG9tUmVzb2x2ZXIpIHtcbiAgICAgICAgY29uc3QgcnBjID0ge307XG4gICAgICAgIGNvbnN0IGluc3RydWN0aW9uID0ge307XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0ge307XG4gICAgICAgIGNvbnN0IHNpbXVsYXRlID0ge307XG4gICAgICAgIGNvbnN0IG1ldGhvZHMgPSB7fTtcbiAgICAgICAgY29uc3QgdmlldyA9IHt9O1xuICAgICAgICBjb25zdCBpZGxFcnJvcnMgPSBwYXJzZUlkbEVycm9ycyhpZGwpO1xuICAgICAgICBjb25zdCBhY2NvdW50ID0gaWRsLmFjY291bnRzXG4gICAgICAgICAgICA/IEFjY291bnRGYWN0b3J5LmJ1aWxkKGlkbCwgY29kZXIsIHByb2dyYW1JZCwgcHJvdmlkZXIpXG4gICAgICAgICAgICA6IHt9O1xuICAgICAgICBpZGwuaW5zdHJ1Y3Rpb25zLmZvckVhY2goKGlkbEl4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpeEl0ZW0gPSBJbnN0cnVjdGlvbkZhY3RvcnkuYnVpbGQoaWRsSXgsIChpeE5hbWUsIGl4KSA9PiBjb2Rlci5pbnN0cnVjdGlvbi5lbmNvZGUoaXhOYW1lLCBpeCksIHByb2dyYW1JZCk7XG4gICAgICAgICAgICBjb25zdCB0eEl0ZW0gPSBUcmFuc2FjdGlvbkZhY3RvcnkuYnVpbGQoaWRsSXgsIGl4SXRlbSk7XG4gICAgICAgICAgICBjb25zdCBycGNJdGVtID0gUnBjRmFjdG9yeS5idWlsZChpZGxJeCwgdHhJdGVtLCBpZGxFcnJvcnMsIHByb3ZpZGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHNpbXVsYXRlSXRlbSA9IFNpbXVsYXRlRmFjdG9yeS5idWlsZChpZGxJeCwgdHhJdGVtLCBpZGxFcnJvcnMsIHByb3ZpZGVyLCBjb2RlciwgcHJvZ3JhbUlkLCBpZGwpO1xuICAgICAgICAgICAgY29uc3Qgdmlld0l0ZW0gPSBWaWV3RmFjdG9yeS5idWlsZChwcm9ncmFtSWQsIGlkbEl4LCBzaW11bGF0ZUl0ZW0sIGlkbCk7XG4gICAgICAgICAgICBjb25zdCBtZXRob2RJdGVtID0gTWV0aG9kc0J1aWxkZXJGYWN0b3J5LmJ1aWxkKHByb3ZpZGVyLCBwcm9ncmFtSWQsIGlkbEl4LCBpeEl0ZW0sIHR4SXRlbSwgcnBjSXRlbSwgc2ltdWxhdGVJdGVtLCB2aWV3SXRlbSwgYWNjb3VudCwgaWRsLnR5cGVzIHx8IFtdLCBnZXRDdXN0b21SZXNvbHZlciA9PT0gbnVsbCB8fCBnZXRDdXN0b21SZXNvbHZlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2V0Q3VzdG9tUmVzb2x2ZXIoaWRsSXgpKTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBpZGxJeC5uYW1lO1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25bbmFtZV0gPSBpeEl0ZW07XG4gICAgICAgICAgICB0cmFuc2FjdGlvbltuYW1lXSA9IHR4SXRlbTtcbiAgICAgICAgICAgIHJwY1tuYW1lXSA9IHJwY0l0ZW07XG4gICAgICAgICAgICBzaW11bGF0ZVtuYW1lXSA9IHNpbXVsYXRlSXRlbTtcbiAgICAgICAgICAgIG1ldGhvZHNbbmFtZV0gPSBtZXRob2RJdGVtO1xuICAgICAgICAgICAgaWYgKHZpZXdJdGVtKSB7XG4gICAgICAgICAgICAgICAgdmlld1tuYW1lXSA9IHZpZXdJdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHJwYyxcbiAgICAgICAgICAgIGluc3RydWN0aW9uLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgICAgICBhY2NvdW50LFxuICAgICAgICAgICAgc2ltdWxhdGUsXG4gICAgICAgICAgICBtZXRob2RzLFxuICAgICAgICAgICAgdmlldyxcbiAgICAgICAgXTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiSW5zdHJ1Y3Rpb25GYWN0b3J5IiwiVHJhbnNhY3Rpb25GYWN0b3J5IiwiUnBjRmFjdG9yeSIsIkFjY291bnRGYWN0b3J5IiwiU2ltdWxhdGVGYWN0b3J5IiwicGFyc2VJZGxFcnJvcnMiLCJNZXRob2RzQnVpbGRlckZhY3RvcnkiLCJWaWV3RmFjdG9yeSIsIkFjY291bnRDbGllbnQiLCJOYW1lc3BhY2VGYWN0b3J5IiwiYnVpbGQiLCJpZGwiLCJjb2RlciIsInByb2dyYW1JZCIsInByb3ZpZGVyIiwiZ2V0Q3VzdG9tUmVzb2x2ZXIiLCJycGMiLCJpbnN0cnVjdGlvbiIsInRyYW5zYWN0aW9uIiwic2ltdWxhdGUiLCJtZXRob2RzIiwidmlldyIsImlkbEVycm9ycyIsImFjY291bnQiLCJhY2NvdW50cyIsImluc3RydWN0aW9ucyIsImZvckVhY2giLCJpZGxJeCIsIml4SXRlbSIsIml4TmFtZSIsIml4IiwiZW5jb2RlIiwidHhJdGVtIiwicnBjSXRlbSIsInNpbXVsYXRlSXRlbSIsInZpZXdJdGVtIiwibWV0aG9kSXRlbSIsInR5cGVzIiwibmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/namespace/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/namespace/instruction.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/program/namespace/instruction.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ InstructionNamespaceFactory)\n/* harmony export */ });\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/node_modules/@solana/web3.js/lib/index.esm.js\");\n/* harmony import */ var _idl_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../idl.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/idl.js\");\n/* harmony import */ var _error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../error.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/error.js\");\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/common.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../context.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/context.js\");\n/* harmony import */ var _utils_features_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/features.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/features.js\");\n\n\n\n\n\n\nclass InstructionNamespaceFactory {\n    static build(idlIx, encodeFn, programId) {\n        if (idlIx.name === \"_inner\") {\n            throw new _error_js__WEBPACK_IMPORTED_MODULE_2__.IdlError(\"the _inner name is reserved\");\n        }\n        const ix = (...args)=>{\n            const [ixArgs, ctx] = (0,_context_js__WEBPACK_IMPORTED_MODULE_4__.splitArgsAndCtx)(idlIx, [\n                ...args\n            ]);\n            (0,_common_js__WEBPACK_IMPORTED_MODULE_3__.validateAccounts)(idlIx.accounts, ctx.accounts);\n            validateInstruction(idlIx, ...args);\n            const keys = ix.accounts(ctx.accounts);\n            if (ctx.remainingAccounts !== undefined) {\n                keys.push(...ctx.remainingAccounts);\n            }\n            if (_utils_features_js__WEBPACK_IMPORTED_MODULE_5__.isSet(\"debug-logs\")) {\n                console.log(\"Outgoing account metas:\", keys);\n            }\n            return new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.TransactionInstruction({\n                keys,\n                programId,\n                data: encodeFn(idlIx.name, (0,_common_js__WEBPACK_IMPORTED_MODULE_3__.toInstruction)(idlIx, ...ixArgs))\n            });\n        };\n        // Utility fn for ordering the accounts for this instruction.\n        ix[\"accounts\"] = (accs)=>{\n            return InstructionNamespaceFactory.accountsArray(accs, idlIx.accounts, programId, idlIx.name);\n        };\n        return ix;\n    }\n    static accountsArray(ctx, accounts, programId, ixName) {\n        if (!ctx) {\n            return [];\n        }\n        return accounts.map((acc)=>{\n            if ((0,_idl_js__WEBPACK_IMPORTED_MODULE_1__.isCompositeAccounts)(acc)) {\n                const rpcAccs = ctx[acc.name];\n                return InstructionNamespaceFactory.accountsArray(rpcAccs, acc.accounts, programId, ixName).flat();\n            }\n            let pubkey;\n            try {\n                pubkey = (0,_common_js__WEBPACK_IMPORTED_MODULE_3__.translateAddress)(ctx[acc.name]);\n            } catch (err) {\n                throw new Error(`Wrong input type for account \"${acc.name}\" in the instruction accounts object${ixName !== undefined ? ' for instruction \"' + ixName + '\"' : \"\"}. Expected PublicKey or string.`);\n            }\n            const isOptional = acc.optional && pubkey.equals(programId);\n            const isWritable = Boolean(acc.writable && !isOptional);\n            const isSigner = Boolean(acc.signer && !isOptional);\n            return {\n                pubkey,\n                isWritable,\n                isSigner\n            };\n        }).flat();\n    }\n}\n// Throws error if any argument required for the `ix` is not given.\nfunction validateInstruction(ix, ...args) {\n// todo\n} //# sourceMappingURL=instruction.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3Byb2dyYW0vbmFtZXNwYWNlL2luc3RydWN0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBMEQ7QUFDTjtBQUNWO0FBQ3dDO0FBQ2xDO0FBQ0k7QUFDckMsTUFBTVE7SUFDakIsT0FBT0MsTUFBTUMsS0FBSyxFQUFFQyxRQUFRLEVBQUVDLFNBQVMsRUFBRTtRQUNyQyxJQUFJRixNQUFNRyxJQUFJLEtBQUssVUFBVTtZQUN6QixNQUFNLElBQUlYLCtDQUFRQSxDQUFDO1FBQ3ZCO1FBQ0EsTUFBTVksS0FBSyxDQUFDLEdBQUdDO1lBQ1gsTUFBTSxDQUFDQyxRQUFRQyxJQUFJLEdBQUdYLDREQUFlQSxDQUFDSSxPQUFPO21CQUFJSzthQUFLO1lBQ3REViw0REFBZ0JBLENBQUNLLE1BQU1RLFFBQVEsRUFBRUQsSUFBSUMsUUFBUTtZQUM3Q0Msb0JBQW9CVCxVQUFVSztZQUM5QixNQUFNSyxPQUFPTixHQUFHSSxRQUFRLENBQUNELElBQUlDLFFBQVE7WUFDckMsSUFBSUQsSUFBSUksaUJBQWlCLEtBQUtDLFdBQVc7Z0JBQ3JDRixLQUFLRyxJQUFJLElBQUlOLElBQUlJLGlCQUFpQjtZQUN0QztZQUNBLElBQUlkLHFEQUFjLENBQUMsZUFBZTtnQkFDOUJrQixRQUFRQyxHQUFHLENBQUMsMkJBQTJCTjtZQUMzQztZQUNBLE9BQU8sSUFBSXBCLG1FQUFzQkEsQ0FBQztnQkFDOUJvQjtnQkFDQVI7Z0JBQ0FlLE1BQU1oQixTQUFTRCxNQUFNRyxJQUFJLEVBQUVWLHlEQUFhQSxDQUFDTyxVQUFVTTtZQUN2RDtRQUNKO1FBQ0EsNkRBQTZEO1FBQzdERixFQUFFLENBQUMsV0FBVyxHQUFHLENBQUNjO1lBQ2QsT0FBT3BCLDRCQUE0QnFCLGFBQWEsQ0FBQ0QsTUFBTWxCLE1BQU1RLFFBQVEsRUFBRU4sV0FBV0YsTUFBTUcsSUFBSTtRQUNoRztRQUNBLE9BQU9DO0lBQ1g7SUFDQSxPQUFPZSxjQUFjWixHQUFHLEVBQUVDLFFBQVEsRUFBRU4sU0FBUyxFQUFFa0IsTUFBTSxFQUFFO1FBQ25ELElBQUksQ0FBQ2IsS0FBSztZQUNOLE9BQU8sRUFBRTtRQUNiO1FBQ0EsT0FBT0MsU0FDRmEsR0FBRyxDQUFDLENBQUNDO1lBQ04sSUFBSS9CLDREQUFtQkEsQ0FBQytCLE1BQU07Z0JBQzFCLE1BQU1DLFVBQVVoQixHQUFHLENBQUNlLElBQUluQixJQUFJLENBQUM7Z0JBQzdCLE9BQU9MLDRCQUE0QnFCLGFBQWEsQ0FBQ0ksU0FBU0QsSUFBSWQsUUFBUSxFQUFFTixXQUFXa0IsUUFBUUksSUFBSTtZQUNuRztZQUNBLElBQUlDO1lBQ0osSUFBSTtnQkFDQUEsU0FBUy9CLDREQUFnQkEsQ0FBQ2EsR0FBRyxDQUFDZSxJQUFJbkIsSUFBSSxDQUFDO1lBQzNDLEVBQ0EsT0FBT3VCLEtBQUs7Z0JBQ1IsTUFBTSxJQUFJQyxNQUFNLENBQUMsOEJBQThCLEVBQUVMLElBQUluQixJQUFJLENBQUMsb0NBQW9DLEVBQUVpQixXQUFXUixZQUFZLHVCQUF1QlEsU0FBUyxNQUFNLEdBQUcsK0JBQStCLENBQUM7WUFDcE07WUFDQSxNQUFNUSxhQUFhTixJQUFJTyxRQUFRLElBQUlKLE9BQU9LLE1BQU0sQ0FBQzVCO1lBQ2pELE1BQU02QixhQUFhQyxRQUFRVixJQUFJVyxRQUFRLElBQUksQ0FBQ0w7WUFDNUMsTUFBTU0sV0FBV0YsUUFBUVYsSUFBSWEsTUFBTSxJQUFJLENBQUNQO1lBQ3hDLE9BQU87Z0JBQ0hIO2dCQUNBTTtnQkFDQUc7WUFDSjtRQUNKLEdBQ0tWLElBQUk7SUFDYjtBQUNKO0FBQ0EsbUVBQW1FO0FBQ25FLFNBQVNmLG9CQUFvQkwsRUFBRSxFQUFFLEdBQUdDLElBQUk7QUFDcEMsT0FBTztBQUNYLEVBQ0EsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AY29yYWwteHl6L2FuY2hvci9kaXN0L2VzbS9wcm9ncmFtL25hbWVzcGFjZS9pbnN0cnVjdGlvbi5qcz84N2E2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24sIH0gZnJvbSBcIkBzb2xhbmEvd2ViMy5qc1wiO1xuaW1wb3J0IHsgaXNDb21wb3NpdGVBY2NvdW50cywgfSBmcm9tIFwiLi4vLi4vaWRsLmpzXCI7XG5pbXBvcnQgeyBJZGxFcnJvciB9IGZyb20gXCIuLi8uLi9lcnJvci5qc1wiO1xuaW1wb3J0IHsgdG9JbnN0cnVjdGlvbiwgdHJhbnNsYXRlQWRkcmVzcywgdmFsaWRhdGVBY2NvdW50cywgfSBmcm9tIFwiLi4vY29tbW9uLmpzXCI7XG5pbXBvcnQgeyBzcGxpdEFyZ3NBbmRDdHggfSBmcm9tIFwiLi4vY29udGV4dC5qc1wiO1xuaW1wb3J0ICogYXMgZmVhdHVyZXMgZnJvbSBcIi4uLy4uL3V0aWxzL2ZlYXR1cmVzLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnN0cnVjdGlvbk5hbWVzcGFjZUZhY3Rvcnkge1xuICAgIHN0YXRpYyBidWlsZChpZGxJeCwgZW5jb2RlRm4sIHByb2dyYW1JZCkge1xuICAgICAgICBpZiAoaWRsSXgubmFtZSA9PT0gXCJfaW5uZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElkbEVycm9yKFwidGhlIF9pbm5lciBuYW1lIGlzIHJlc2VydmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl4ID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFtpeEFyZ3MsIGN0eF0gPSBzcGxpdEFyZ3NBbmRDdHgoaWRsSXgsIFsuLi5hcmdzXSk7XG4gICAgICAgICAgICB2YWxpZGF0ZUFjY291bnRzKGlkbEl4LmFjY291bnRzLCBjdHguYWNjb3VudHMpO1xuICAgICAgICAgICAgdmFsaWRhdGVJbnN0cnVjdGlvbihpZGxJeCwgLi4uYXJncyk7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gaXguYWNjb3VudHMoY3R4LmFjY291bnRzKTtcbiAgICAgICAgICAgIGlmIChjdHgucmVtYWluaW5nQWNjb3VudHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaCguLi5jdHgucmVtYWluaW5nQWNjb3VudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZlYXR1cmVzLmlzU2V0KFwiZGVidWctbG9nc1wiKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiT3V0Z29pbmcgYWNjb3VudCBtZXRhczpcIiwga2V5cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICAgICAgICAgIGtleXMsXG4gICAgICAgICAgICAgICAgcHJvZ3JhbUlkLFxuICAgICAgICAgICAgICAgIGRhdGE6IGVuY29kZUZuKGlkbEl4Lm5hbWUsIHRvSW5zdHJ1Y3Rpb24oaWRsSXgsIC4uLml4QXJncykpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFV0aWxpdHkgZm4gZm9yIG9yZGVyaW5nIHRoZSBhY2NvdW50cyBmb3IgdGhpcyBpbnN0cnVjdGlvbi5cbiAgICAgICAgaXhbXCJhY2NvdW50c1wiXSA9IChhY2NzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gSW5zdHJ1Y3Rpb25OYW1lc3BhY2VGYWN0b3J5LmFjY291bnRzQXJyYXkoYWNjcywgaWRsSXguYWNjb3VudHMsIHByb2dyYW1JZCwgaWRsSXgubmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpeDtcbiAgICB9XG4gICAgc3RhdGljIGFjY291bnRzQXJyYXkoY3R4LCBhY2NvdW50cywgcHJvZ3JhbUlkLCBpeE5hbWUpIHtcbiAgICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjb3VudHNcbiAgICAgICAgICAgIC5tYXAoKGFjYykgPT4ge1xuICAgICAgICAgICAgaWYgKGlzQ29tcG9zaXRlQWNjb3VudHMoYWNjKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJwY0FjY3MgPSBjdHhbYWNjLm5hbWVdO1xuICAgICAgICAgICAgICAgIHJldHVybiBJbnN0cnVjdGlvbk5hbWVzcGFjZUZhY3RvcnkuYWNjb3VudHNBcnJheShycGNBY2NzLCBhY2MuYWNjb3VudHMsIHByb2dyYW1JZCwgaXhOYW1lKS5mbGF0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcHVia2V5O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwdWJrZXkgPSB0cmFuc2xhdGVBZGRyZXNzKGN0eFthY2MubmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgaW5wdXQgdHlwZSBmb3IgYWNjb3VudCBcIiR7YWNjLm5hbWV9XCIgaW4gdGhlIGluc3RydWN0aW9uIGFjY291bnRzIG9iamVjdCR7aXhOYW1lICE9PSB1bmRlZmluZWQgPyAnIGZvciBpbnN0cnVjdGlvbiBcIicgKyBpeE5hbWUgKyAnXCInIDogXCJcIn0uIEV4cGVjdGVkIFB1YmxpY0tleSBvciBzdHJpbmcuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpc09wdGlvbmFsID0gYWNjLm9wdGlvbmFsICYmIHB1YmtleS5lcXVhbHMocHJvZ3JhbUlkKTtcbiAgICAgICAgICAgIGNvbnN0IGlzV3JpdGFibGUgPSBCb29sZWFuKGFjYy53cml0YWJsZSAmJiAhaXNPcHRpb25hbCk7XG4gICAgICAgICAgICBjb25zdCBpc1NpZ25lciA9IEJvb2xlYW4oYWNjLnNpZ25lciAmJiAhaXNPcHRpb25hbCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHB1YmtleSxcbiAgICAgICAgICAgICAgICBpc1dyaXRhYmxlLFxuICAgICAgICAgICAgICAgIGlzU2lnbmVyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5mbGF0KCk7XG4gICAgfVxufVxuLy8gVGhyb3dzIGVycm9yIGlmIGFueSBhcmd1bWVudCByZXF1aXJlZCBmb3IgdGhlIGBpeGAgaXMgbm90IGdpdmVuLlxuZnVuY3Rpb24gdmFsaWRhdGVJbnN0cnVjdGlvbihpeCwgLi4uYXJncykge1xuICAgIC8vIHRvZG9cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluc3RydWN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJUcmFuc2FjdGlvbkluc3RydWN0aW9uIiwiaXNDb21wb3NpdGVBY2NvdW50cyIsIklkbEVycm9yIiwidG9JbnN0cnVjdGlvbiIsInRyYW5zbGF0ZUFkZHJlc3MiLCJ2YWxpZGF0ZUFjY291bnRzIiwic3BsaXRBcmdzQW5kQ3R4IiwiZmVhdHVyZXMiLCJJbnN0cnVjdGlvbk5hbWVzcGFjZUZhY3RvcnkiLCJidWlsZCIsImlkbEl4IiwiZW5jb2RlRm4iLCJwcm9ncmFtSWQiLCJuYW1lIiwiaXgiLCJhcmdzIiwiaXhBcmdzIiwiY3R4IiwiYWNjb3VudHMiLCJ2YWxpZGF0ZUluc3RydWN0aW9uIiwia2V5cyIsInJlbWFpbmluZ0FjY291bnRzIiwidW5kZWZpbmVkIiwicHVzaCIsImlzU2V0IiwiY29uc29sZSIsImxvZyIsImRhdGEiLCJhY2NzIiwiYWNjb3VudHNBcnJheSIsIml4TmFtZSIsIm1hcCIsImFjYyIsInJwY0FjY3MiLCJmbGF0IiwicHVia2V5IiwiZXJyIiwiRXJyb3IiLCJpc09wdGlvbmFsIiwib3B0aW9uYWwiLCJlcXVhbHMiLCJpc1dyaXRhYmxlIiwiQm9vbGVhbiIsIndyaXRhYmxlIiwiaXNTaWduZXIiLCJzaWduZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/namespace/instruction.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/namespace/methods.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/program/namespace/methods.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MethodsBuilder: () => (/* binding */ MethodsBuilder),\n/* harmony export */   MethodsBuilderFactory: () => (/* binding */ MethodsBuilderFactory),\n/* harmony export */   flattenPartialAccounts: () => (/* binding */ flattenPartialAccounts),\n/* harmony export */   isPartialAccounts: () => (/* binding */ isPartialAccounts)\n/* harmony export */ });\n/* harmony import */ var _accounts_resolver_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../accounts-resolver.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/accounts-resolver.js\");\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/common.js\");\n\n\nclass MethodsBuilderFactory {\n    static build(provider, programId, idlIx, ixFn, txFn, rpcFn, simulateFn, viewFn, accountNamespace, idlTypes, customResolver) {\n        return (...args)=>new MethodsBuilder(args, ixFn, txFn, rpcFn, simulateFn, viewFn, provider, programId, idlIx, accountNamespace, idlTypes, customResolver);\n    }\n}\nfunction isPartialAccounts(partialAccount) {\n    return typeof partialAccount === \"object\" && partialAccount !== null && !(\"_bn\" in partialAccount // Ensures not a pubkey\n    );\n}\nfunction flattenPartialAccounts(partialAccounts, throwOnNull) {\n    const toReturn = {};\n    for(const accountName in partialAccounts){\n        const account = partialAccounts[accountName];\n        if (account === null) {\n            if (throwOnNull) throw new Error(\"Failed to resolve optionals due to IDL type mismatch with input accounts!\");\n            continue;\n        }\n        toReturn[accountName] = isPartialAccounts(account) ? flattenPartialAccounts(account, true) : (0,_common_js__WEBPACK_IMPORTED_MODULE_1__.translateAddress)(account);\n    }\n    return toReturn;\n}\nclass MethodsBuilder {\n    constructor(_args, _ixFn, _txFn, _rpcFn, _simulateFn, _viewFn, provider, programId, idlIx, accountNamespace, idlTypes, customResolver){\n        this._args = _args;\n        this._ixFn = _ixFn;\n        this._txFn = _txFn;\n        this._rpcFn = _rpcFn;\n        this._simulateFn = _simulateFn;\n        this._viewFn = _viewFn;\n        this._accounts = {};\n        this._remainingAccounts = [];\n        this._signers = [];\n        this._preInstructions = [];\n        this._postInstructions = [];\n        this._resolveAccounts = true;\n        this._accountsResolver = new _accounts_resolver_js__WEBPACK_IMPORTED_MODULE_0__.AccountsResolver(_args, this._accounts, provider, programId, idlIx, accountNamespace, idlTypes, customResolver);\n    }\n    args(args) {\n        this._args = args;\n        this._accountsResolver.args(args);\n    }\n    /**\n     * Set instruction accounts with account resolution.\n     *\n     * This method only accepts accounts that cannot be resolved.\n     *\n     * See {@link accountsPartial} for overriding the account resolution or\n     * {@link accountsStrict} for strictly specifying all accounts.\n     */ accounts(accounts) {\n        // @ts-ignore\n        return this.accountsPartial(accounts);\n    }\n    /**\n     * Set instruction accounts with account resolution.\n     *\n     * There is no functional difference between this method and {@link accounts}\n     * method, the only difference is this method allows specifying all accounts\n     * even if they can be resolved. On the other hand, {@link accounts} method\n     * doesn't accept accounts that can be resolved.\n     */ accountsPartial(accounts) {\n        this._resolveAccounts = true;\n        this._accountsResolver.resolveOptionals(accounts);\n        return this;\n    }\n    /**\n     * Set instruction accounts without account resolution.\n     *\n     * All accounts strictly need to be specified when this method is used.\n     *\n     * See {@link accounts} and {@link accountsPartial} methods for automatically\n     * resolving accounts.\n     */ accountsStrict(accounts) {\n        this._resolveAccounts = false;\n        this._accountsResolver.resolveOptionals(accounts);\n        return this;\n    }\n    signers(signers) {\n        this._signers = this._signers.concat(signers);\n        return this;\n    }\n    remainingAccounts(accounts) {\n        this._remainingAccounts = this._remainingAccounts.concat(accounts);\n        return this;\n    }\n    preInstructions(ixs, prepend = false) {\n        if (prepend) {\n            this._preInstructions = ixs.concat(this._preInstructions);\n        } else {\n            this._preInstructions = this._preInstructions.concat(ixs);\n        }\n        return this;\n    }\n    postInstructions(ixs) {\n        this._postInstructions = this._postInstructions.concat(ixs);\n        return this;\n    }\n    /**\n     * Get the public keys of the instruction accounts.\n     *\n     * The return type is an object with account names as keys and their public\n     * keys as their values.\n     *\n     * Note that an account key is `undefined` if the account hasn't yet been\n     * specified or resolved.\n     */ async pubkeys() {\n        if (this._resolveAccounts) {\n            await this._accountsResolver.resolve();\n        }\n        // @ts-ignore\n        return this._accounts;\n    }\n    async rpc(options) {\n        if (this._resolveAccounts) {\n            await this._accountsResolver.resolve();\n        }\n        // @ts-ignore\n        return this._rpcFn(...this._args, {\n            accounts: this._accounts,\n            signers: this._signers,\n            remainingAccounts: this._remainingAccounts,\n            preInstructions: this._preInstructions,\n            postInstructions: this._postInstructions,\n            options\n        });\n    }\n    async rpcAndKeys(options) {\n        const pubkeys = await this.pubkeys();\n        return {\n            pubkeys: pubkeys,\n            signature: await this.rpc(options)\n        };\n    }\n    async view(options) {\n        if (this._resolveAccounts) {\n            await this._accountsResolver.resolve();\n        }\n        if (!this._viewFn) {\n            throw new Error(\"Method does not support views\");\n        }\n        // @ts-ignore\n        return this._viewFn(...this._args, {\n            accounts: this._accounts,\n            signers: this._signers,\n            remainingAccounts: this._remainingAccounts,\n            preInstructions: this._preInstructions,\n            postInstructions: this._postInstructions,\n            options\n        });\n    }\n    async simulate(options) {\n        if (this._resolveAccounts) {\n            await this._accountsResolver.resolve();\n        }\n        // @ts-ignore\n        return this._simulateFn(...this._args, {\n            accounts: this._accounts,\n            signers: this._signers,\n            remainingAccounts: this._remainingAccounts,\n            preInstructions: this._preInstructions,\n            postInstructions: this._postInstructions,\n            options\n        });\n    }\n    async instruction() {\n        if (this._resolveAccounts) {\n            await this._accountsResolver.resolve();\n        }\n        // @ts-ignore\n        return this._ixFn(...this._args, {\n            accounts: this._accounts,\n            signers: this._signers,\n            remainingAccounts: this._remainingAccounts,\n            preInstructions: this._preInstructions,\n            postInstructions: this._postInstructions\n        });\n    }\n    /**\n     * Convenient shortcut to get instructions and pubkeys via:\n     *\n     * ```ts\n     * const { pubkeys, instructions } = await method.prepare();\n     * ```\n     */ async prepare() {\n        return {\n            instruction: await this.instruction(),\n            pubkeys: await this.pubkeys(),\n            signers: this._signers\n        };\n    }\n    async transaction() {\n        if (this._resolveAccounts) {\n            await this._accountsResolver.resolve();\n        }\n        // @ts-ignore\n        return this._txFn(...this._args, {\n            accounts: this._accounts,\n            signers: this._signers,\n            remainingAccounts: this._remainingAccounts,\n            preInstructions: this._preInstructions,\n            postInstructions: this._postInstructions\n        });\n    }\n} //# sourceMappingURL=methods.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3Byb2dyYW0vbmFtZXNwYWNlL21ldGhvZHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTREO0FBQ1o7QUFDekMsTUFBTUU7SUFDVCxPQUFPQyxNQUFNQyxRQUFRLEVBQUVDLFNBQVMsRUFBRUMsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsS0FBSyxFQUFFQyxVQUFVLEVBQUVDLE1BQU0sRUFBRUMsZ0JBQWdCLEVBQUVDLFFBQVEsRUFBRUMsY0FBYyxFQUFFO1FBQ3hILE9BQU8sQ0FBQyxHQUFHQyxPQUFTLElBQUlDLGVBQWVELE1BQU1SLE1BQU1DLE1BQU1DLE9BQU9DLFlBQVlDLFFBQVFQLFVBQVVDLFdBQVdDLE9BQU9NLGtCQUFrQkMsVUFBVUM7SUFDaEo7QUFDSjtBQUNPLFNBQVNHLGtCQUFrQkMsY0FBYztJQUM1QyxPQUFRLE9BQU9BLG1CQUFtQixZQUM5QkEsbUJBQW1CLFFBQ25CLENBQUUsVUFBU0EsZUFBZ0IsdUJBQXVCO0lBQTFCO0FBRWhDO0FBQ08sU0FBU0MsdUJBQXVCQyxlQUFlLEVBQUVDLFdBQVc7SUFDL0QsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLElBQUssTUFBTUMsZUFBZUgsZ0JBQWlCO1FBQ3ZDLE1BQU1JLFVBQVVKLGVBQWUsQ0FBQ0csWUFBWTtRQUM1QyxJQUFJQyxZQUFZLE1BQU07WUFDbEIsSUFBSUgsYUFDQSxNQUFNLElBQUlJLE1BQU07WUFDcEI7UUFDSjtRQUNBSCxRQUFRLENBQUNDLFlBQVksR0FBR04sa0JBQWtCTyxXQUNwQ0wsdUJBQXVCSyxTQUFTLFFBQ2hDdkIsNERBQWdCQSxDQUFDdUI7SUFDM0I7SUFDQSxPQUFPRjtBQUNYO0FBQ08sTUFBTU47SUFDVFUsWUFBWUMsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFFQyxXQUFXLEVBQUVDLE9BQU8sRUFBRTVCLFFBQVEsRUFBRUMsU0FBUyxF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WixrQkFBa0I7WUFDMUNhLGlCQUFpQixJQUFJLENBQUNYLGdCQUFnQjtZQUN0Q2Msa0JBQWtCLElBQUksQ0FBQ2IsaUJBQWlCO1FBQzVDO0lBQ0o7QUFDSixFQUNBLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGNvcmFsLXh5ei9hbmNob3IvZGlzdC9lc20vcHJvZ3JhbS9uYW1lc3BhY2UvbWV0aG9kcy5qcz9hNjhhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFjY291bnRzUmVzb2x2ZXIsIH0gZnJvbSBcIi4uL2FjY291bnRzLXJlc29sdmVyLmpzXCI7XG5pbXBvcnQgeyB0cmFuc2xhdGVBZGRyZXNzIH0gZnJvbSBcIi4uL2NvbW1vbi5qc1wiO1xuZXhwb3J0IGNsYXNzIE1ldGhvZHNCdWlsZGVyRmFjdG9yeSB7XG4gICAgc3RhdGljIGJ1aWxkKHByb3ZpZGVyLCBwcm9ncmFtSWQsIGlkbEl4LCBpeEZuLCB0eEZuLCBycGNGbiwgc2ltdWxhdGVGbiwgdmlld0ZuLCBhY2NvdW50TmFtZXNwYWNlLCBpZGxUeXBlcywgY3VzdG9tUmVzb2x2ZXIpIHtcbiAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiBuZXcgTWV0aG9kc0J1aWxkZXIoYXJncywgaXhGbiwgdHhGbiwgcnBjRm4sIHNpbXVsYXRlRm4sIHZpZXdGbiwgcHJvdmlkZXIsIHByb2dyYW1JZCwgaWRsSXgsIGFjY291bnROYW1lc3BhY2UsIGlkbFR5cGVzLCBjdXN0b21SZXNvbHZlcik7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzUGFydGlhbEFjY291bnRzKHBhcnRpYWxBY2NvdW50KSB7XG4gICAgcmV0dXJuICh0eXBlb2YgcGFydGlhbEFjY291bnQgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgcGFydGlhbEFjY291bnQgIT09IG51bGwgJiZcbiAgICAgICAgIShcIl9iblwiIGluIHBhcnRpYWxBY2NvdW50KSAvLyBFbnN1cmVzIG5vdCBhIHB1YmtleVxuICAgICk7XG59XG5leHBvcnQgZnVuY3Rpb24gZmxhdHRlblBhcnRpYWxBY2NvdW50cyhwYXJ0aWFsQWNjb3VudHMsIHRocm93T25OdWxsKSB7XG4gICAgY29uc3QgdG9SZXR1cm4gPSB7fTtcbiAgICBmb3IgKGNvbnN0IGFjY291bnROYW1lIGluIHBhcnRpYWxBY2NvdW50cykge1xuICAgICAgICBjb25zdCBhY2NvdW50ID0gcGFydGlhbEFjY291bnRzW2FjY291bnROYW1lXTtcbiAgICAgICAgaWYgKGFjY291bnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aHJvd09uTnVsbClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gcmVzb2x2ZSBvcHRpb25hbHMgZHVlIHRvIElETCB0eXBlIG1pc21hdGNoIHdpdGggaW5wdXQgYWNjb3VudHMhXCIpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdG9SZXR1cm5bYWNjb3VudE5hbWVdID0gaXNQYXJ0aWFsQWNjb3VudHMoYWNjb3VudClcbiAgICAgICAgICAgID8gZmxhdHRlblBhcnRpYWxBY2NvdW50cyhhY2NvdW50LCB0cnVlKVxuICAgICAgICAgICAgOiB0cmFuc2xhdGVBZGRyZXNzKGFjY291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9SZXR1cm47XG59XG5leHBvcnQgY2xhc3MgTWV0aG9kc0J1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKF9hcmdzLCBfaXhGbiwgX3R4Rm4sIF9ycGNGbiwgX3NpbXVsYXRlRm4sIF92aWV3Rm4sIHByb3ZpZGVyLCBwcm9ncmFtSWQsIGlkbEl4LCBhY2NvdW50TmFtZXNwYWNlLCBpZGxUeXBlcywgY3VzdG9tUmVzb2x2ZXIpIHtcbiAgICAgICAgdGhpcy5fYXJncyA9IF9hcmdzO1xuICAgICAgICB0aGlzLl9peEZuID0gX2l4Rm47XG4gICAgICAgIHRoaXMuX3R4Rm4gPSBfdHhGbjtcbiAgICAgICAgdGhpcy5fcnBjRm4gPSBfcnBjRm47XG4gICAgICAgIHRoaXMuX3NpbXVsYXRlRm4gPSBfc2ltdWxhdGVGbjtcbiAgICAgICAgdGhpcy5fdmlld0ZuID0gX3ZpZXdGbjtcbiAgICAgICAgdGhpcy5fYWNjb3VudHMgPSB7fTtcbiAgICAgICAgdGhpcy5fcmVtYWluaW5nQWNjb3VudHMgPSBbXTtcbiAgICAgICAgdGhpcy5fc2lnbmVycyA9IFtdO1xuICAgICAgICB0aGlzLl9wcmVJbnN0cnVjdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5fcG9zdEluc3RydWN0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLl9yZXNvbHZlQWNjb3VudHMgPSB0cnVlO1xuICAgICAgICB0aGlzLl9hY2NvdW50c1Jlc29sdmVyID0gbmV3IEFjY291bnRzUmVzb2x2ZXIoX2FyZ3MsIHRoaXMuX2FjY291bnRzLCBwcm92aWRlciwgcHJvZ3JhbUlkLCBpZGxJeCwgYWNjb3VudE5hbWVzcGFjZSwgaWRsVHlwZXMsIGN1c3RvbVJlc29sdmVyKTtcbiAgICB9XG4gICAgYXJncyhhcmdzKSB7XG4gICAgICAgIHRoaXMuX2FyZ3MgPSBhcmdzO1xuICAgICAgICB0aGlzLl9hY2NvdW50c1Jlc29sdmVyLmFyZ3MoYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBpbnN0cnVjdGlvbiBhY2NvdW50cyB3aXRoIGFjY291bnQgcmVzb2x1dGlvbi5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG9ubHkgYWNjZXB0cyBhY2NvdW50cyB0aGF0IGNhbm5vdCBiZSByZXNvbHZlZC5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgYWNjb3VudHNQYXJ0aWFsfSBmb3Igb3ZlcnJpZGluZyB0aGUgYWNjb3VudCByZXNvbHV0aW9uIG9yXG4gICAgICoge0BsaW5rIGFjY291bnRzU3RyaWN0fSBmb3Igc3RyaWN0bHkgc3BlY2lmeWluZyBhbGwgYWNjb3VudHMuXG4gICAgICovXG4gICAgYWNjb3VudHMoYWNjb3VudHMpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gdGhpcy5hY2NvdW50c1BhcnRpYWwoYWNjb3VudHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgaW5zdHJ1Y3Rpb24gYWNjb3VudHMgd2l0aCBhY2NvdW50IHJlc29sdXRpb24uXG4gICAgICpcbiAgICAgKiBUaGVyZSBpcyBubyBmdW5jdGlvbmFsIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGlzIG1ldGhvZCBhbmQge0BsaW5rIGFjY291bnRzfVxuICAgICAqIG1ldGhvZCwgdGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB0aGlzIG1ldGhvZCBhbGxvd3Mgc3BlY2lmeWluZyBhbGwgYWNjb3VudHNcbiAgICAgKiBldmVuIGlmIHRoZXkgY2FuIGJlIHJlc29sdmVkLiBPbiB0aGUgb3RoZXIgaGFuZCwge0BsaW5rIGFjY291bnRzfSBtZXRob2RcbiAgICAgKiBkb2Vzbid0IGFjY2VwdCBhY2NvdW50cyB0aGF0IGNhbiBiZSByZXNvbHZlZC5cbiAgICAgKi9cbiAgICBhY2NvdW50c1BhcnRpYWwoYWNjb3VudHMpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUFjY291bnRzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fYWNjb3VudHNSZXNvbHZlci5yZXNvbHZlT3B0aW9uYWxzKGFjY291bnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBpbnN0cnVjdGlvbiBhY2NvdW50cyB3aXRob3V0IGFjY291bnQgcmVzb2x1dGlvbi5cbiAgICAgKlxuICAgICAqIEFsbCBhY2NvdW50cyBzdHJpY3RseSBuZWVkIHRvIGJlIHNwZWNpZmllZCB3aGVuIHRoaXMgbWV0aG9kIGlzIHVzZWQuXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rIGFjY291bnRzfSBhbmQge0BsaW5rIGFjY291bnRzUGFydGlhbH0gbWV0aG9kcyBmb3IgYXV0b21hdGljYWxseVxuICAgICAqIHJlc29sdmluZyBhY2NvdW50cy5cbiAgICAgKi9cbiAgICBhY2NvdW50c1N0cmljdChhY2NvdW50cykge1xuICAgICAgICB0aGlzLl9yZXNvbHZlQWNjb3VudHMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYWNjb3VudHNSZXNvbHZlci5yZXNvbHZlT3B0aW9uYWxzKGFjY291bnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNpZ25lcnMoc2lnbmVycykge1xuICAgICAgICB0aGlzLl9zaWduZXJzID0gdGhpcy5fc2lnbmVycy5jb25jYXQoc2lnbmVycyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZW1haW5pbmdBY2NvdW50cyhhY2NvdW50cykge1xuICAgICAgICB0aGlzLl9yZW1haW5pbmdBY2NvdW50cyA9IHRoaXMuX3JlbWFpbmluZ0FjY291bnRzLmNvbmNhdChhY2NvdW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBwcmVJbnN0cnVjdGlvbnMoaXhzLCBwcmVwZW5kID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHByZXBlbmQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByZUluc3RydWN0aW9ucyA9IGl4cy5jb25jYXQodGhpcy5fcHJlSW5zdHJ1Y3Rpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3ByZUluc3RydWN0aW9ucyA9IHRoaXMuX3ByZUluc3RydWN0aW9ucy5jb25jYXQoaXhzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcG9zdEluc3RydWN0aW9ucyhpeHMpIHtcbiAgICAgICAgdGhpcy5fcG9zdEluc3RydWN0aW9ucyA9IHRoaXMuX3Bvc3RJbnN0cnVjdGlvbnMuY29uY2F0KGl4cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHB1YmxpYyBrZXlzIG9mIHRoZSBpbnN0cnVjdGlvbiBhY2NvdW50cy5cbiAgICAgKlxuICAgICAqIFRoZSByZXR1cm4gdHlwZSBpcyBhbiBvYmplY3Qgd2l0aCBhY2NvdW50IG5hbWVzIGFzIGtleXMgYW5kIHRoZWlyIHB1YmxpY1xuICAgICAqIGtleXMgYXMgdGhlaXIgdmFsdWVzLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGFuIGFjY291bnQga2V5IGlzIGB1bmRlZmluZWRgIGlmIHRoZSBhY2NvdW50IGhhc24ndCB5ZXQgYmVlblxuICAgICAqIHNwZWNpZmllZCBvciByZXNvbHZlZC5cbiAgICAgKi9cbiAgICBhc3luYyBwdWJrZXlzKCkge1xuICAgICAgICBpZiAodGhpcy5fcmVzb2x2ZUFjY291bnRzKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9hY2NvdW50c1Jlc29sdmVyLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiB0aGlzLl9hY2NvdW50cztcbiAgICB9XG4gICAgYXN5bmMgcnBjKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Jlc29sdmVBY2NvdW50cykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fYWNjb3VudHNSZXNvbHZlci5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gdGhpcy5fcnBjRm4oLi4udGhpcy5fYXJncywge1xuICAgICAgICAgICAgYWNjb3VudHM6IHRoaXMuX2FjY291bnRzLFxuICAgICAgICAgICAgc2lnbmVyczogdGhpcy5fc2lnbmVycyxcbiAgICAgICAgICAgIHJlbWFpbmluZ0FjY291bnRzOiB0aGlzLl9yZW1haW5pbmdBY2NvdW50cyxcbiAgICAgICAgICAgIHByZUluc3RydWN0aW9uczogdGhpcy5fcHJlSW5zdHJ1Y3Rpb25zLFxuICAgICAgICAgICAgcG9zdEluc3RydWN0aW9uczogdGhpcy5fcG9zdEluc3RydWN0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBycGNBbmRLZXlzKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcHVia2V5cyA9IGF3YWl0IHRoaXMucHVia2V5cygpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHVia2V5czogcHVia2V5cyxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogYXdhaXQgdGhpcy5ycGMob3B0aW9ucyksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHZpZXcob3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5fcmVzb2x2ZUFjY291bnRzKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9hY2NvdW50c1Jlc29sdmVyLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3ZpZXdGbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgdmlld3NcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gdGhpcy5fdmlld0ZuKC4uLnRoaXMuX2FyZ3MsIHtcbiAgICAgICAgICAgIGFjY291bnRzOiB0aGlzLl9hY2NvdW50cyxcbiAgICAgICAgICAgIHNpZ25lcnM6IHRoaXMuX3NpZ25lcnMsXG4gICAgICAgICAgICByZW1haW5pbmdBY2NvdW50czogdGhpcy5fcmVtYWluaW5nQWNjb3VudHMsXG4gICAgICAgICAgICBwcmVJbnN0cnVjdGlvbnM6IHRoaXMuX3ByZUluc3RydWN0aW9ucyxcbiAgICAgICAgICAgIHBvc3RJbnN0cnVjdGlvbnM6IHRoaXMuX3Bvc3RJbnN0cnVjdGlvbnMsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgc2ltdWxhdGUob3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5fcmVzb2x2ZUFjY291bnRzKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9hY2NvdW50c1Jlc29sdmVyLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiB0aGlzLl9zaW11bGF0ZUZuKC4uLnRoaXMuX2FyZ3MsIHtcbiAgICAgICAgICAgIGFjY291bnRzOiB0aGlzLl9hY2NvdW50cyxcbiAgICAgICAgICAgIHNpZ25lcnM6IHRoaXMuX3NpZ25lcnMsXG4gICAgICAgICAgICByZW1haW5pbmdBY2NvdW50czogdGhpcy5fcmVtYWluaW5nQWNjb3VudHMsXG4gICAgICAgICAgICBwcmVJbnN0cnVjdGlvbnM6IHRoaXMuX3ByZUluc3RydWN0aW9ucyxcbiAgICAgICAgICAgIHBvc3RJbnN0cnVjdGlvbnM6IHRoaXMuX3Bvc3RJbnN0cnVjdGlvbnMsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgaW5zdHJ1Y3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZXNvbHZlQWNjb3VudHMpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2FjY291bnRzUmVzb2x2ZXIucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l4Rm4oLi4udGhpcy5fYXJncywge1xuICAgICAgICAgICAgYWNjb3VudHM6IHRoaXMuX2FjY291bnRzLFxuICAgICAgICAgICAgc2lnbmVyczogdGhpcy5fc2lnbmVycyxcbiAgICAgICAgICAgIHJlbWFpbmluZ0FjY291bnRzOiB0aGlzLl9yZW1haW5pbmdBY2NvdW50cyxcbiAgICAgICAgICAgIHByZUluc3RydWN0aW9uczogdGhpcy5fcHJlSW5zdHJ1Y3Rpb25zLFxuICAgICAgICAgICAgcG9zdEluc3RydWN0aW9uczogdGhpcy5fcG9zdEluc3RydWN0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbnQgc2hvcnRjdXQgdG8gZ2V0IGluc3RydWN0aW9ucyBhbmQgcHVia2V5cyB2aWE6XG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHsgcHVia2V5cywgaW5zdHJ1Y3Rpb25zIH0gPSBhd2FpdCBtZXRob2QucHJlcGFyZSgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHByZXBhcmUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbjogYXdhaXQgdGhpcy5pbnN0cnVjdGlvbigpLFxuICAgICAgICAgICAgcHVia2V5czogYXdhaXQgdGhpcy5wdWJrZXlzKCksXG4gICAgICAgICAgICBzaWduZXJzOiB0aGlzLl9zaWduZXJzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyB0cmFuc2FjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Jlc29sdmVBY2NvdW50cykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fYWNjb3VudHNSZXNvbHZlci5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gdGhpcy5fdHhGbiguLi50aGlzLl9hcmdzLCB7XG4gICAgICAgICAgICBhY2NvdW50czogdGhpcy5fYWNjb3VudHMsXG4gICAgICAgICAgICBzaWduZXJzOiB0aGlzLl9zaWduZXJzLFxuICAgICAgICAgICAgcmVtYWluaW5nQWNjb3VudHM6IHRoaXMuX3JlbWFpbmluZ0FjY291bnRzLFxuICAgICAgICAgICAgcHJlSW5zdHJ1Y3Rpb25zOiB0aGlzLl9wcmVJbnN0cnVjdGlvbnMsXG4gICAgICAgICAgICBwb3N0SW5zdHJ1Y3Rpb25zOiB0aGlzLl9wb3N0SW5zdHJ1Y3Rpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXRob2RzLmpzLm1hcCJdLCJuYW1lcyI6WyJBY2NvdW50c1Jlc29sdmVyIiwidHJhbnNsYXRlQWRkcmVzcyIsIk1ldGhvZHNCdWlsZGVyRmFjdG9yeSIsImJ1aWxkIiwicHJvdmlkZXIiLCJwcm9ncmFtSWQiLCJpZGxJeCIsIml4Rm4iLCJ0eEZuIiwicnBjRm4iLCJzaW11bGF0ZUZuIiwidmlld0ZuIiwiYWNjb3VudE5hbWVzcGFjZSIsImlkbFR5cGVzIiwiY3VzdG9tUmVzb2x2ZXIiLCJhcmdzIiwiTWV0aG9kc0J1aWxkZXIiLCJpc1BhcnRpYWxBY2NvdW50cyIsInBhcnRpYWxBY2NvdW50IiwiZmxhdHRlblBhcnRpYWxBY2NvdW50cyIsInBhcnRpYWxBY2NvdW50cyIsInRocm93T25OdWxsIiwidG9SZXR1cm4iLCJhY2NvdW50TmFtZSIsImFjY291bnQiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwiX2FyZ3MiLCJfaXhGbiIsIl90eEZuIiwiX3JwY0ZuIiwiX3NpbXVsYXRlRm4iLCJfdmlld0ZuIiwiX2FjY291bnRzIiwiX3JlbWFpbmluZ0FjY291bnRzIiwiX3NpZ25lcnMiLCJfcHJlSW5zdHJ1Y3Rpb25zIiwiX3Bvc3RJbnN0cnVjdGlvbnMiLCJfcmVzb2x2ZUFjY291bnRzIiwiX2FjY291bnRzUmVzb2x2ZXIiLCJhY2NvdW50cyIsImFjY291bnRzUGFydGlhbCIsInJlc29sdmVPcHRpb25hbHMiLCJhY2NvdW50c1N0cmljdCIsInNpZ25lcnMiLCJjb25jYXQiLCJyZW1haW5pbmdBY2NvdW50cyIsInByZUluc3RydWN0aW9ucyIsIml4cyIsInByZXBlbmQiLCJwb3N0SW5zdHJ1Y3Rpb25zIiwicHVia2V5cyIsInJlc29sdmUiLCJycGMiLCJvcHRpb25zIiwicnBjQW5kS2V5cyIsInNpZ25hdHVyZSIsInZpZXciLCJzaW11bGF0ZSIsImluc3RydWN0aW9uIiwicHJlcGFyZSIsInRyYW5zYWN0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/namespace/methods.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/namespace/rpc.js":
/*!***************************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/program/namespace/rpc.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RpcFactory)\n/* harmony export */ });\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../context.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/context.js\");\n/* harmony import */ var _error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../error.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/error.js\");\n\n\nclass RpcFactory {\n    static build(idlIx, txFn, idlErrors, provider) {\n        const rpc = async (...args)=>{\n            var _a;\n            const tx = txFn(...args);\n            const [, ctx] = (0,_context_js__WEBPACK_IMPORTED_MODULE_0__.splitArgsAndCtx)(idlIx, [\n                ...args\n            ]);\n            if (provider.sendAndConfirm === undefined) {\n                throw new Error(\"This function requires 'Provider.sendAndConfirm' to be implemented.\");\n            }\n            try {\n                return await provider.sendAndConfirm(tx, (_a = ctx.signers) !== null && _a !== void 0 ? _a : [], ctx.options);\n            } catch (err) {\n                throw (0,_error_js__WEBPACK_IMPORTED_MODULE_1__.translateError)(err, idlErrors);\n            }\n        };\n        return rpc;\n    }\n} //# sourceMappingURL=rpc.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3Byb2dyYW0vbmFtZXNwYWNlL3JwYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBZ0Q7QUFDQTtBQUNqQyxNQUFNRTtJQUNqQixPQUFPQyxNQUFNQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsU0FBUyxFQUFFQyxRQUFRLEVBQUU7UUFDM0MsTUFBTUMsTUFBTSxPQUFPLEdBQUdDO1lBQ2xCLElBQUlDO1lBQ0osTUFBTUMsS0FBS04sUUFBUUk7WUFDbkIsTUFBTSxHQUFHRyxJQUFJLEdBQUdaLDREQUFlQSxDQUFDSSxPQUFPO21CQUFJSzthQUFLO1lBQ2hELElBQUlGLFNBQVNNLGNBQWMsS0FBS0MsV0FBVztnQkFDdkMsTUFBTSxJQUFJQyxNQUFNO1lBQ3BCO1lBQ0EsSUFBSTtnQkFDQSxPQUFPLE1BQU1SLFNBQVNNLGNBQWMsQ0FBQ0YsSUFBSSxDQUFDRCxLQUFLRSxJQUFJSSxPQUFPLE1BQU0sUUFBUU4sT0FBTyxLQUFLLElBQUlBLEtBQUssRUFBRSxFQUFFRSxJQUFJSyxPQUFPO1lBQ2hILEVBQ0EsT0FBT0MsS0FBSztnQkFDUixNQUFNakIseURBQWNBLENBQUNpQixLQUFLWjtZQUM5QjtRQUNKO1FBQ0EsT0FBT0U7SUFDWDtBQUNKLEVBQ0EsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AY29yYWwteHl6L2FuY2hvci9kaXN0L2VzbS9wcm9ncmFtL25hbWVzcGFjZS9ycGMuanM/MjQzNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzcGxpdEFyZ3NBbmRDdHggfSBmcm9tIFwiLi4vY29udGV4dC5qc1wiO1xuaW1wb3J0IHsgdHJhbnNsYXRlRXJyb3IgfSBmcm9tIFwiLi4vLi4vZXJyb3IuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJwY0ZhY3Rvcnkge1xuICAgIHN0YXRpYyBidWlsZChpZGxJeCwgdHhGbiwgaWRsRXJyb3JzLCBwcm92aWRlcikge1xuICAgICAgICBjb25zdCBycGMgPSBhc3luYyAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgdHggPSB0eEZuKC4uLmFyZ3MpO1xuICAgICAgICAgICAgY29uc3QgWywgY3R4XSA9IHNwbGl0QXJnc0FuZEN0eChpZGxJeCwgWy4uLmFyZ3NdKTtcbiAgICAgICAgICAgIGlmIChwcm92aWRlci5zZW5kQW5kQ29uZmlybSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBmdW5jdGlvbiByZXF1aXJlcyAnUHJvdmlkZXIuc2VuZEFuZENvbmZpcm0nIHRvIGJlIGltcGxlbWVudGVkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLnNlbmRBbmRDb25maXJtKHR4LCAoX2EgPSBjdHguc2lnbmVycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10sIGN0eC5vcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0cmFuc2xhdGVFcnJvcihlcnIsIGlkbEVycm9ycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBycGM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnBjLmpzLm1hcCJdLCJuYW1lcyI6WyJzcGxpdEFyZ3NBbmRDdHgiLCJ0cmFuc2xhdGVFcnJvciIsIlJwY0ZhY3RvcnkiLCJidWlsZCIsImlkbEl4IiwidHhGbiIsImlkbEVycm9ycyIsInByb3ZpZGVyIiwicnBjIiwiYXJncyIsIl9hIiwidHgiLCJjdHgiLCJzZW5kQW5kQ29uZmlybSIsInVuZGVmaW5lZCIsIkVycm9yIiwic2lnbmVycyIsIm9wdGlvbnMiLCJlcnIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/namespace/rpc.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/namespace/simulate.js":
/*!********************************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/program/namespace/simulate.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SimulateFactory)\n/* harmony export */ });\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../context.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/context.js\");\n/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../event.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/event.js\");\n/* harmony import */ var _error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../error.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/error.js\");\n\n\n\nclass SimulateFactory {\n    static build(idlIx, txFn, idlErrors, provider, coder, programId, idl) {\n        const simulate = async (...args)=>{\n            var _a;\n            const tx = txFn(...args);\n            const [, ctx] = (0,_context_js__WEBPACK_IMPORTED_MODULE_0__.splitArgsAndCtx)(idlIx, [\n                ...args\n            ]);\n            let resp = undefined;\n            if (provider.simulate === undefined) {\n                throw new Error(\"This function requires 'Provider.simulate' to be implemented.\");\n            }\n            try {\n                resp = await provider.simulate(tx, ctx.signers, (_a = ctx.options) === null || _a === void 0 ? void 0 : _a.commitment);\n            } catch (err) {\n                throw (0,_error_js__WEBPACK_IMPORTED_MODULE_2__.translateError)(err, idlErrors);\n            }\n            if (resp === undefined) {\n                throw new Error(\"Unable to simulate transaction\");\n            }\n            const logs = resp.logs;\n            if (!logs) {\n                throw new Error(\"Simulated logs not found\");\n            }\n            const events = [];\n            if (idl.events) {\n                let parser = new _event_js__WEBPACK_IMPORTED_MODULE_1__.EventParser(programId, coder);\n                for (const event of parser.parseLogs(logs)){\n                    events.push(event);\n                }\n            }\n            return {\n                events,\n                raw: logs\n            };\n        };\n        return simulate;\n    }\n} //# sourceMappingURL=simulate.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3Byb2dyYW0vbmFtZXNwYWNlL3NpbXVsYXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBZ0Q7QUFDTjtBQUNNO0FBQ2pDLE1BQU1HO0lBQ2pCLE9BQU9DLE1BQU1DLEtBQUssRUFBRUMsSUFBSSxFQUFFQyxTQUFTLEVBQUVDLFFBQVEsRUFBRUMsS0FBSyxFQUFFQyxTQUFTLEVBQUVDLEdBQUcsRUFBRTtRQUNsRSxNQUFNQyxXQUFXLE9BQU8sR0FBR0M7WUFDdkIsSUFBSUM7WUFDSixNQUFNQyxLQUFLVCxRQUFRTztZQUNuQixNQUFNLEdBQUdHLElBQUksR0FBR2hCLDREQUFlQSxDQUFDSyxPQUFPO21CQUFJUTthQUFLO1lBQ2hELElBQUlJLE9BQU9DO1lBQ1gsSUFBSVYsU0FBU0ksUUFBUSxLQUFLTSxXQUFXO2dCQUNqQyxNQUFNLElBQUlDLE1BQU07WUFDcEI7WUFDQSxJQUFJO2dCQUNBRixPQUFPLE1BQU1ULFNBQVNJLFFBQVEsQ0FBQ0csSUFBSUMsSUFBSUksT0FBTyxFQUFFLENBQUNOLEtBQUtFLElBQUlLLE9BQU8sTUFBTSxRQUFRUCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdRLFVBQVU7WUFDekgsRUFDQSxPQUFPQyxLQUFLO2dCQUNSLE1BQU1yQix5REFBY0EsQ0FBQ3FCLEtBQUtoQjtZQUM5QjtZQUNBLElBQUlVLFNBQVNDLFdBQVc7Z0JBQ3BCLE1BQU0sSUFBSUMsTUFBTTtZQUNwQjtZQUNBLE1BQU1LLE9BQU9QLEtBQUtPLElBQUk7WUFDdEIsSUFBSSxDQUFDQSxNQUFNO2dCQUNQLE1BQU0sSUFBSUwsTUFBTTtZQUNwQjtZQUNBLE1BQU1NLFNBQVMsRUFBRTtZQUNqQixJQUFJZCxJQUFJYyxNQUFNLEVBQUU7Z0JBQ1osSUFBSUMsU0FBUyxJQUFJekIsa0RBQVdBLENBQUNTLFdBQVdEO2dCQUN4QyxLQUFLLE1BQU1rQixTQUFTRCxPQUFPRSxTQUFTLENBQUNKLE1BQU87b0JBQ3hDQyxPQUFPSSxJQUFJLENBQUNGO2dCQUNoQjtZQUNKO1lBQ0EsT0FBTztnQkFBRUY7Z0JBQVFLLEtBQUtOO1lBQUs7UUFDL0I7UUFDQSxPQUFPWjtJQUNYO0FBQ0osRUFDQSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3Byb2dyYW0vbmFtZXNwYWNlL3NpbXVsYXRlLmpzPzBiMGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3BsaXRBcmdzQW5kQ3R4IH0gZnJvbSBcIi4uL2NvbnRleHQuanNcIjtcbmltcG9ydCB7IEV2ZW50UGFyc2VyIH0gZnJvbSBcIi4uL2V2ZW50LmpzXCI7XG5pbXBvcnQgeyB0cmFuc2xhdGVFcnJvciB9IGZyb20gXCIuLi8uLi9lcnJvci5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2ltdWxhdGVGYWN0b3J5IHtcbiAgICBzdGF0aWMgYnVpbGQoaWRsSXgsIHR4Rm4sIGlkbEVycm9ycywgcHJvdmlkZXIsIGNvZGVyLCBwcm9ncmFtSWQsIGlkbCkge1xuICAgICAgICBjb25zdCBzaW11bGF0ZSA9IGFzeW5jICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCB0eCA9IHR4Rm4oLi4uYXJncyk7XG4gICAgICAgICAgICBjb25zdCBbLCBjdHhdID0gc3BsaXRBcmdzQW5kQ3R4KGlkbEl4LCBbLi4uYXJnc10pO1xuICAgICAgICAgICAgbGV0IHJlc3AgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAocHJvdmlkZXIuc2ltdWxhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgZnVuY3Rpb24gcmVxdWlyZXMgJ1Byb3ZpZGVyLnNpbXVsYXRlJyB0byBiZSBpbXBsZW1lbnRlZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3AgPSBhd2FpdCBwcm92aWRlci5zaW11bGF0ZSh0eCwgY3R4LnNpZ25lcnMsIChfYSA9IGN0eC5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29tbWl0bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdHJhbnNsYXRlRXJyb3IoZXJyLCBpZGxFcnJvcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBzaW11bGF0ZSB0cmFuc2FjdGlvblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvZ3MgPSByZXNwLmxvZ3M7XG4gICAgICAgICAgICBpZiAoIWxvZ3MpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaW11bGF0ZWQgbG9ncyBub3QgZm91bmRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBldmVudHMgPSBbXTtcbiAgICAgICAgICAgIGlmIChpZGwuZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcnNlciA9IG5ldyBFdmVudFBhcnNlcihwcm9ncmFtSWQsIGNvZGVyKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIHBhcnNlci5wYXJzZUxvZ3MobG9ncykpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzLnB1c2goZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGV2ZW50cywgcmF3OiBsb2dzIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzaW11bGF0ZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaW11bGF0ZS5qcy5tYXAiXSwibmFtZXMiOlsic3BsaXRBcmdzQW5kQ3R4IiwiRXZlbnRQYXJzZXIiLCJ0cmFuc2xhdGVFcnJvciIsIlNpbXVsYXRlRmFjdG9yeSIsImJ1aWxkIiwiaWRsSXgiLCJ0eEZuIiwiaWRsRXJyb3JzIiwicHJvdmlkZXIiLCJjb2RlciIsInByb2dyYW1JZCIsImlkbCIsInNpbXVsYXRlIiwiYXJncyIsIl9hIiwidHgiLCJjdHgiLCJyZXNwIiwidW5kZWZpbmVkIiwiRXJyb3IiLCJzaWduZXJzIiwib3B0aW9ucyIsImNvbW1pdG1lbnQiLCJlcnIiLCJsb2dzIiwiZXZlbnRzIiwicGFyc2VyIiwiZXZlbnQiLCJwYXJzZUxvZ3MiLCJwdXNoIiwicmF3Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/namespace/simulate.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/namespace/transaction.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/program/namespace/transaction.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ TransactionFactory)\n/* harmony export */ });\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/node_modules/@solana/web3.js/lib/index.esm.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../context.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/context.js\");\n\n\nclass TransactionFactory {\n    static build(idlIx, ixFn) {\n        const txFn = (...args)=>{\n            var _a, _b, _c;\n            const [, ctx] = (0,_context_js__WEBPACK_IMPORTED_MODULE_1__.splitArgsAndCtx)(idlIx, [\n                ...args\n            ]);\n            const tx = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction();\n            if (ctx.preInstructions && ctx.instructions) {\n                throw new Error(\"instructions is deprecated, use preInstructions\");\n            }\n            (_a = ctx.preInstructions) === null || _a === void 0 ? void 0 : _a.forEach((ix)=>tx.add(ix));\n            (_b = ctx.instructions) === null || _b === void 0 ? void 0 : _b.forEach((ix)=>tx.add(ix));\n            tx.add(ixFn(...args));\n            (_c = ctx.postInstructions) === null || _c === void 0 ? void 0 : _c.forEach((ix)=>tx.add(ix));\n            return tx;\n        };\n        return txFn;\n    }\n} //# sourceMappingURL=transaction.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3Byb2dyYW0vbmFtZXNwYWNlL3RyYW5zYWN0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE4QztBQUNFO0FBQ2pDLE1BQU1FO0lBQ2pCLE9BQU9DLE1BQU1DLEtBQUssRUFBRUMsSUFBSSxFQUFFO1FBQ3RCLE1BQU1DLE9BQU8sQ0FBQyxHQUFHQztZQUNiLElBQUlDLElBQUlDLElBQUlDO1lBQ1osTUFBTSxHQUFHQyxJQUFJLEdBQUdWLDREQUFlQSxDQUFDRyxPQUFPO21CQUFJRzthQUFLO1lBQ2hELE1BQU1LLEtBQUssSUFBSVosd0RBQVdBO1lBQzFCLElBQUlXLElBQUlFLGVBQWUsSUFBSUYsSUFBSUcsWUFBWSxFQUFFO2dCQUN6QyxNQUFNLElBQUlDLE1BQU07WUFDcEI7WUFDQ1AsQ0FBQUEsS0FBS0csSUFBSUUsZUFBZSxNQUFNLFFBQVFMLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR1EsT0FBTyxDQUFDLENBQUNDLEtBQU9MLEdBQUdNLEdBQUcsQ0FBQ0Q7WUFDekZSLENBQUFBLEtBQUtFLElBQUlHLFlBQVksTUFBTSxRQUFRTCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdPLE9BQU8sQ0FBQyxDQUFDQyxLQUFPTCxHQUFHTSxHQUFHLENBQUNEO1lBQ3ZGTCxHQUFHTSxHQUFHLENBQUNiLFFBQVFFO1lBQ2RHLENBQUFBLEtBQUtDLElBQUlRLGdCQUFnQixNQUFNLFFBQVFULE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR00sT0FBTyxDQUFDLENBQUNDLEtBQU9MLEdBQUdNLEdBQUcsQ0FBQ0Q7WUFDM0YsT0FBT0w7UUFDWDtRQUNBLE9BQU9OO0lBQ1g7QUFDSixFQUNBLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGNvcmFsLXh5ei9hbmNob3IvZGlzdC9lc20vcHJvZ3JhbS9uYW1lc3BhY2UvdHJhbnNhY3Rpb24uanM/MzBmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gXCJAc29sYW5hL3dlYjMuanNcIjtcbmltcG9ydCB7IHNwbGl0QXJnc0FuZEN0eCB9IGZyb20gXCIuLi9jb250ZXh0LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUcmFuc2FjdGlvbkZhY3Rvcnkge1xuICAgIHN0YXRpYyBidWlsZChpZGxJeCwgaXhGbikge1xuICAgICAgICBjb25zdCB0eEZuID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgWywgY3R4XSA9IHNwbGl0QXJnc0FuZEN0eChpZGxJeCwgWy4uLmFyZ3NdKTtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAoY3R4LnByZUluc3RydWN0aW9ucyAmJiBjdHguaW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5zdHJ1Y3Rpb25zIGlzIGRlcHJlY2F0ZWQsIHVzZSBwcmVJbnN0cnVjdGlvbnNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoX2EgPSBjdHgucHJlSW5zdHJ1Y3Rpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaCgoaXgpID0+IHR4LmFkZChpeCkpO1xuICAgICAgICAgICAgKF9iID0gY3R4Lmluc3RydWN0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmZvckVhY2goKGl4KSA9PiB0eC5hZGQoaXgpKTtcbiAgICAgICAgICAgIHR4LmFkZChpeEZuKC4uLmFyZ3MpKTtcbiAgICAgICAgICAgIChfYyA9IGN0eC5wb3N0SW5zdHJ1Y3Rpb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZm9yRWFjaCgoaXgpID0+IHR4LmFkZChpeCkpO1xuICAgICAgICAgICAgcmV0dXJuIHR4O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdHhGbjtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2FjdGlvbi5qcy5tYXAiXSwibmFtZXMiOlsiVHJhbnNhY3Rpb24iLCJzcGxpdEFyZ3NBbmRDdHgiLCJUcmFuc2FjdGlvbkZhY3RvcnkiLCJidWlsZCIsImlkbEl4IiwiaXhGbiIsInR4Rm4iLCJhcmdzIiwiX2EiLCJfYiIsIl9jIiwiY3R4IiwidHgiLCJwcmVJbnN0cnVjdGlvbnMiLCJpbnN0cnVjdGlvbnMiLCJFcnJvciIsImZvckVhY2giLCJpeCIsImFkZCIsInBvc3RJbnN0cnVjdGlvbnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/namespace/transaction.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/namespace/views.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/program/namespace/views.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ViewFactory)\n/* harmony export */ });\n/* harmony import */ var _coder_borsh_idl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../coder/borsh/idl */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/coder/borsh/idl.js\");\n/* harmony import */ var _utils_bytes_base64__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/bytes/base64 */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/bytes/base64.js\");\n\n\nclass ViewFactory {\n    static build(programId, idlIx, simulateFn, idl) {\n        const isWritable = idlIx.accounts.find((a)=>a.writable);\n        const hasReturn = !!idlIx.returns;\n        if (isWritable || !hasReturn) return;\n        const view = async (...args)=>{\n            let simulationResult = await simulateFn(...args);\n            const returnPrefix = `Program return: ${programId} `;\n            let returnLog = simulationResult.raw.find((l)=>l.startsWith(returnPrefix));\n            if (!returnLog) {\n                throw new Error(\"View expected return log\");\n            }\n            let returnData = (0,_utils_bytes_base64__WEBPACK_IMPORTED_MODULE_1__.decode)(returnLog.slice(returnPrefix.length));\n            let returnType = idlIx.returns;\n            if (!returnType) {\n                throw new Error(\"View expected return type\");\n            }\n            const coder = _coder_borsh_idl__WEBPACK_IMPORTED_MODULE_0__.IdlCoder.fieldLayout({\n                type: returnType\n            }, idl.types);\n            return coder.decode(returnData);\n        };\n        return view;\n    }\n} //# sourceMappingURL=views.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3Byb2dyYW0vbmFtZXNwYWNlL3ZpZXdzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpRDtBQUNDO0FBQ25DLE1BQU1FO0lBQ2pCLE9BQU9DLE1BQU1DLFNBQVMsRUFBRUMsS0FBSyxFQUFFQyxVQUFVLEVBQUVDLEdBQUcsRUFBRTtRQUM1QyxNQUFNQyxhQUFhSCxNQUFNSSxRQUFRLENBQUNDLElBQUksQ0FBQyxDQUFDQyxJQUFNQSxFQUFFQyxRQUFRO1FBQ3hELE1BQU1DLFlBQVksQ0FBQyxDQUFDUixNQUFNUyxPQUFPO1FBQ2pDLElBQUlOLGNBQWMsQ0FBQ0ssV0FDZjtRQUNKLE1BQU1FLE9BQU8sT0FBTyxHQUFHQztZQUNuQixJQUFJQyxtQkFBbUIsTUFBTVgsY0FBY1U7WUFDM0MsTUFBTUUsZUFBZSxDQUFDLGdCQUFnQixFQUFFZCxVQUFVLENBQUMsQ0FBQztZQUNwRCxJQUFJZSxZQUFZRixpQkFBaUJHLEdBQUcsQ0FBQ1YsSUFBSSxDQUFDLENBQUNXLElBQU1BLEVBQUVDLFVBQVUsQ0FBQ0o7WUFDOUQsSUFBSSxDQUFDQyxXQUFXO2dCQUNaLE1BQU0sSUFBSUksTUFBTTtZQUNwQjtZQUNBLElBQUlDLGFBQWF2QiwyREFBTUEsQ0FBQ2tCLFVBQVVNLEtBQUssQ0FBQ1AsYUFBYVEsTUFBTTtZQUMzRCxJQUFJQyxhQUFhdEIsTUFBTVMsT0FBTztZQUM5QixJQUFJLENBQUNhLFlBQVk7Z0JBQ2IsTUFBTSxJQUFJSixNQUFNO1lBQ3BCO1lBQ0EsTUFBTUssUUFBUTVCLHNEQUFRQSxDQUFDNkIsV0FBVyxDQUFDO2dCQUFFQyxNQUFNSDtZQUFXLEdBQUdwQixJQUFJd0IsS0FBSztZQUNsRSxPQUFPSCxNQUFNM0IsTUFBTSxDQUFDdUI7UUFDeEI7UUFDQSxPQUFPVDtJQUNYO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3Byb2dyYW0vbmFtZXNwYWNlL3ZpZXdzLmpzPzE2YWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSWRsQ29kZXIgfSBmcm9tIFwiLi4vLi4vY29kZXIvYm9yc2gvaWRsXCI7XG5pbXBvcnQgeyBkZWNvZGUgfSBmcm9tIFwiLi4vLi4vdXRpbHMvYnl0ZXMvYmFzZTY0XCI7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWaWV3RmFjdG9yeSB7XG4gICAgc3RhdGljIGJ1aWxkKHByb2dyYW1JZCwgaWRsSXgsIHNpbXVsYXRlRm4sIGlkbCkge1xuICAgICAgICBjb25zdCBpc1dyaXRhYmxlID0gaWRsSXguYWNjb3VudHMuZmluZCgoYSkgPT4gYS53cml0YWJsZSk7XG4gICAgICAgIGNvbnN0IGhhc1JldHVybiA9ICEhaWRsSXgucmV0dXJucztcbiAgICAgICAgaWYgKGlzV3JpdGFibGUgfHwgIWhhc1JldHVybilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdmlldyA9IGFzeW5jICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBsZXQgc2ltdWxhdGlvblJlc3VsdCA9IGF3YWl0IHNpbXVsYXRlRm4oLi4uYXJncyk7XG4gICAgICAgICAgICBjb25zdCByZXR1cm5QcmVmaXggPSBgUHJvZ3JhbSByZXR1cm46ICR7cHJvZ3JhbUlkfSBgO1xuICAgICAgICAgICAgbGV0IHJldHVybkxvZyA9IHNpbXVsYXRpb25SZXN1bHQucmF3LmZpbmQoKGwpID0+IGwuc3RhcnRzV2l0aChyZXR1cm5QcmVmaXgpKTtcbiAgICAgICAgICAgIGlmICghcmV0dXJuTG9nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmlldyBleHBlY3RlZCByZXR1cm4gbG9nXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJldHVybkRhdGEgPSBkZWNvZGUocmV0dXJuTG9nLnNsaWNlKHJldHVyblByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIGxldCByZXR1cm5UeXBlID0gaWRsSXgucmV0dXJucztcbiAgICAgICAgICAgIGlmICghcmV0dXJuVHlwZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZpZXcgZXhwZWN0ZWQgcmV0dXJuIHR5cGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb2RlciA9IElkbENvZGVyLmZpZWxkTGF5b3V0KHsgdHlwZTogcmV0dXJuVHlwZSB9LCBpZGwudHlwZXMpO1xuICAgICAgICAgICAgcmV0dXJuIGNvZGVyLmRlY29kZShyZXR1cm5EYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHZpZXc7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlld3MuanMubWFwIl0sIm5hbWVzIjpbIklkbENvZGVyIiwiZGVjb2RlIiwiVmlld0ZhY3RvcnkiLCJidWlsZCIsInByb2dyYW1JZCIsImlkbEl4Iiwic2ltdWxhdGVGbiIsImlkbCIsImlzV3JpdGFibGUiLCJhY2NvdW50cyIsImZpbmQiLCJhIiwid3JpdGFibGUiLCJoYXNSZXR1cm4iLCJyZXR1cm5zIiwidmlldyIsImFyZ3MiLCJzaW11bGF0aW9uUmVzdWx0IiwicmV0dXJuUHJlZml4IiwicmV0dXJuTG9nIiwicmF3IiwibCIsInN0YXJ0c1dpdGgiLCJFcnJvciIsInJldHVybkRhdGEiLCJzbGljZSIsImxlbmd0aCIsInJldHVyblR5cGUiLCJjb2RlciIsImZpZWxkTGF5b3V0IiwidHlwZSIsInR5cGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/namespace/views.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/token-account-layout.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/program/token-account-layout.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeTokenAccount: () => (/* binding */ decodeTokenAccount)\n/* harmony export */ });\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bn.js */ \"(ssr)/../node_modules/bn.js/lib/bn.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bn_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var buffer_layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! buffer-layout */ \"(ssr)/../node_modules/buffer-layout/lib/Layout.js\");\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/node_modules/@solana/web3.js/lib/index.esm.js\");\n\n\n\n\nfunction uint64(property) {\n    return new WrappedLayout(buffer_layout__WEBPACK_IMPORTED_MODULE_1__.blob(8), (b)=>u64.fromBuffer(b), (n)=>n.toBuffer(), property);\n}\nfunction publicKey(property) {\n    return new WrappedLayout(buffer_layout__WEBPACK_IMPORTED_MODULE_1__.blob(32), (b)=>new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.PublicKey(b), (key)=>key.toBuffer(), property);\n}\nfunction coption(layout, property) {\n    return new COptionLayout(layout, property);\n}\nclass WrappedLayout extends buffer_layout__WEBPACK_IMPORTED_MODULE_1__.Layout {\n    constructor(layout, decoder, encoder, property){\n        super(layout.span, property);\n        this.layout = layout;\n        this.decoder = decoder;\n        this.encoder = encoder;\n    }\n    decode(b, offset) {\n        return this.decoder(this.layout.decode(b, offset));\n    }\n    encode(src, b, offset) {\n        return this.layout.encode(this.encoder(src), b, offset);\n    }\n    getSpan(b, offset) {\n        return this.layout.getSpan(b, offset);\n    }\n}\nclass COptionLayout extends buffer_layout__WEBPACK_IMPORTED_MODULE_1__.Layout {\n    constructor(layout, property){\n        super(-1, property);\n        this.layout = layout;\n        this.discriminator = buffer_layout__WEBPACK_IMPORTED_MODULE_1__.u32();\n    }\n    encode(src, b, offset = 0) {\n        if (src === null || src === undefined) {\n            return this.layout.span + this.discriminator.encode(0, b, offset);\n        }\n        this.discriminator.encode(1, b, offset);\n        return this.layout.encode(src, b, offset + 4) + 4;\n    }\n    decode(b, offset = 0) {\n        const discriminator = this.discriminator.decode(b, offset);\n        if (discriminator === 0) {\n            return null;\n        } else if (discriminator === 1) {\n            return this.layout.decode(b, offset + 4);\n        }\n        throw new Error(\"Invalid coption \" + this.layout.property);\n    }\n    getSpan(b, offset = 0) {\n        return this.layout.getSpan(b, offset + 4) + 4;\n    }\n}\nclass u64 extends (bn_js__WEBPACK_IMPORTED_MODULE_0___default()) {\n    /**\n     * Convert to Buffer representation\n     */ toBuffer() {\n        const a = super.toArray().reverse();\n        const b = Buffer.from(a);\n        if (b.length === 8) {\n            return b;\n        }\n        if (b.length >= 8) {\n            throw new Error(\"u64 too large\");\n        }\n        const zeroPad = Buffer.alloc(8);\n        b.copy(zeroPad);\n        return zeroPad;\n    }\n    /**\n     * Construct a u64 from Buffer representation\n     */ static fromBuffer(buffer) {\n        if (buffer.length !== 8) {\n            throw new Error(`Invalid buffer length: ${buffer.length}`);\n        }\n        return new u64([\n            ...buffer\n        ].reverse().map((i)=>`00${i.toString(16)}`.slice(-2)).join(\"\"), 16);\n    }\n}\nconst TOKEN_ACCOUNT_LAYOUT = buffer_layout__WEBPACK_IMPORTED_MODULE_1__.struct([\n    publicKey(\"mint\"),\n    publicKey(\"owner\"),\n    uint64(\"amount\"),\n    coption(publicKey(), \"delegate\"),\n    ((p)=>{\n        const U = buffer_layout__WEBPACK_IMPORTED_MODULE_1__.union(buffer_layout__WEBPACK_IMPORTED_MODULE_1__.u8(\"discriminator\"), null, p);\n        U.addVariant(0, buffer_layout__WEBPACK_IMPORTED_MODULE_1__.struct([]), \"uninitialized\");\n        U.addVariant(1, buffer_layout__WEBPACK_IMPORTED_MODULE_1__.struct([]), \"initialized\");\n        U.addVariant(2, buffer_layout__WEBPACK_IMPORTED_MODULE_1__.struct([]), \"frozen\");\n        return U;\n    })(\"state\"),\n    coption(uint64(), \"isNative\"),\n    uint64(\"delegatedAmount\"),\n    coption(publicKey(), \"closeAuthority\")\n]);\nfunction decodeTokenAccount(b) {\n    return TOKEN_ACCOUNT_LAYOUT.decode(b);\n} //# sourceMappingURL=token-account-layout.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3Byb2dyYW0vdG9rZW4tYWNjb3VudC1sYXlvdXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBdUI7QUFDdUI7QUFDUDtBQUNLO0FBQzVDLFNBQVNJLE9BQU9DLFFBQVE7SUFDcEIsT0FBTyxJQUFJQyxjQUFjTCwrQ0FBaUIsQ0FBQyxJQUFJLENBQUNPLElBQU1DLElBQUlDLFVBQVUsQ0FBQ0YsSUFBSSxDQUFDRyxJQUFNQSxFQUFFQyxRQUFRLElBQUlQO0FBQ2xHO0FBQ0EsU0FBU1EsVUFBVVIsUUFBUTtJQUN2QixPQUFPLElBQUlDLGNBQWNMLCtDQUFpQixDQUFDLEtBQUssQ0FBQ08sSUFBTSxJQUFJTCxzREFBU0EsQ0FBQ0ssSUFBSSxDQUFDTSxNQUFRQSxJQUFJRixRQUFRLElBQUlQO0FBQ3RHO0FBQ0EsU0FBU1UsUUFBUUMsTUFBTSxFQUFFWCxRQUFRO0lBQzdCLE9BQU8sSUFBSVksY0FBY0QsUUFBUVg7QUFDckM7QUFDQSxNQUFNQyxzQkFBc0JKLGlEQUFNQTtJQUM5QmdCLFlBQVlGLE1BQU0sRUFBRUcsT0FBTyxFQUFFQyxPQUFPLEVBQUVmLFFBQVEsQ0FBRTtRQUM1QyxLQUFLLENBQUNXLE9BQU9LLElBQUksRUFBRWhCO1FBQ25CLElBQUksQ0FBQ1csTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0csT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0MsT0FBTyxHQUFHQTtJQUNuQjtJQUNBRSxPQUFPZCxDQUFDLEVBQUVlLE1BQU0sRUFBRTtRQUNkLE9BQU8sSUFBSSxDQUFDSixPQUFPLENBQUMsSUFBSSxDQUFDSCxNQUFNLENBQUNNLE1BQU0sQ0FBQ2QsR0FBR2U7SUFDOUM7SUFDQUMsT0FBT0MsR0FBRyxFQUFFakIsQ0FBQyxFQUFFZSxNQUFNLEVBQUU7UUFDbkIsT0FBTyxJQUFJLENBQUNQLE1BQU0sQ0FBQ1EsTUFBTSxDQUFDLElBQUksQ0FBQ0osT0FBTyxDQUFD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QUFFRyxVQUFVLENBQUMsR0FBR25ELGlEQUFtQixDQUFDLEVBQUUsR0FBRztRQUN6Q2dELEVBQUVHLFVBQVUsQ0FBQyxHQUFHbkQsaURBQW1CLENBQUMsRUFBRSxHQUFHO1FBQ3pDLE9BQU9nRDtJQUNYLEdBQUc7SUFDSGxDLFFBQVFYLFVBQVU7SUFDbEJBLE9BQU87SUFDUFcsUUFBUUYsYUFBYTtDQUN4QjtBQUNNLFNBQVN3QyxtQkFBbUI3QyxDQUFDO0lBQ2hDLE9BQU9zQyxxQkFBcUJ4QixNQUFNLENBQUNkO0FBQ3ZDLEVBQ0EsZ0RBQWdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AY29yYWwteHl6L2FuY2hvci9kaXN0L2VzbS9wcm9ncmFtL3Rva2VuLWFjY291bnQtbGF5b3V0LmpzPzdhOTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJOIGZyb20gXCJibi5qc1wiO1xuaW1wb3J0ICogYXMgQnVmZmVyTGF5b3V0IGZyb20gXCJidWZmZXItbGF5b3V0XCI7XG5pbXBvcnQgeyBMYXlvdXQgfSBmcm9tIFwiYnVmZmVyLWxheW91dFwiO1xuaW1wb3J0IHsgUHVibGljS2V5IH0gZnJvbSBcIkBzb2xhbmEvd2ViMy5qc1wiO1xuZnVuY3Rpb24gdWludDY0KHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIG5ldyBXcmFwcGVkTGF5b3V0KEJ1ZmZlckxheW91dC5ibG9iKDgpLCAoYikgPT4gdTY0LmZyb21CdWZmZXIoYiksIChuKSA9PiBuLnRvQnVmZmVyKCksIHByb3BlcnR5KTtcbn1cbmZ1bmN0aW9uIHB1YmxpY0tleShwcm9wZXJ0eSkge1xuICAgIHJldHVybiBuZXcgV3JhcHBlZExheW91dChCdWZmZXJMYXlvdXQuYmxvYigzMiksIChiKSA9PiBuZXcgUHVibGljS2V5KGIpLCAoa2V5KSA9PiBrZXkudG9CdWZmZXIoKSwgcHJvcGVydHkpO1xufVxuZnVuY3Rpb24gY29wdGlvbihsYXlvdXQsIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIG5ldyBDT3B0aW9uTGF5b3V0KGxheW91dCwgcHJvcGVydHkpO1xufVxuY2xhc3MgV3JhcHBlZExheW91dCBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IobGF5b3V0LCBkZWNvZGVyLCBlbmNvZGVyLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcihsYXlvdXQuc3BhbiwgcHJvcGVydHkpO1xuICAgICAgICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgICAgICAgdGhpcy5kZWNvZGVyID0gZGVjb2RlcjtcbiAgICAgICAgdGhpcy5lbmNvZGVyID0gZW5jb2RlcjtcbiAgICB9XG4gICAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVyKHRoaXMubGF5b3V0LmRlY29kZShiLCBvZmZzZXQpKTtcbiAgICB9XG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheW91dC5lbmNvZGUodGhpcy5lbmNvZGVyKHNyYyksIGIsIG9mZnNldCk7XG4gICAgfVxuICAgIGdldFNwYW4oYiwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheW91dC5nZXRTcGFuKGIsIG9mZnNldCk7XG4gICAgfVxufVxuY2xhc3MgQ09wdGlvbkxheW91dCBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IobGF5b3V0LCBwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcigtMSwgcHJvcGVydHkpO1xuICAgICAgICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgICAgICAgdGhpcy5kaXNjcmltaW5hdG9yID0gQnVmZmVyTGF5b3V0LnUzMigpO1xuICAgIH1cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGlmIChzcmMgPT09IG51bGwgfHwgc3JjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxheW91dC5zcGFuICsgdGhpcy5kaXNjcmltaW5hdG9yLmVuY29kZSgwLCBiLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlzY3JpbWluYXRvci5lbmNvZGUoMSwgYiwgb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0LmVuY29kZShzcmMsIGIsIG9mZnNldCArIDQpICsgNDtcbiAgICB9XG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvciA9IHRoaXMuZGlzY3JpbWluYXRvci5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKGRpc2NyaW1pbmF0b3IgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpc2NyaW1pbmF0b3IgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxheW91dC5kZWNvZGUoYiwgb2Zmc2V0ICsgNCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb3B0aW9uIFwiICsgdGhpcy5sYXlvdXQucHJvcGVydHkpO1xuICAgIH1cbiAgICBnZXRTcGFuKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0LmdldFNwYW4oYiwgb2Zmc2V0ICsgNCkgKyA0O1xuICAgIH1cbn1cbmNsYXNzIHU2NCBleHRlbmRzIEJOIHtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRvIEJ1ZmZlciByZXByZXNlbnRhdGlvblxuICAgICAqL1xuICAgIHRvQnVmZmVyKCkge1xuICAgICAgICBjb25zdCBhID0gc3VwZXIudG9BcnJheSgpLnJldmVyc2UoKTtcbiAgICAgICAgY29uc3QgYiA9IEJ1ZmZlci5mcm9tKGEpO1xuICAgICAgICBpZiAoYi5sZW5ndGggPT09IDgpIHtcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiLmxlbmd0aCA+PSA4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1NjQgdG9vIGxhcmdlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHplcm9QYWQgPSBCdWZmZXIuYWxsb2MoOCk7XG4gICAgICAgIGIuY29weSh6ZXJvUGFkKTtcbiAgICAgICAgcmV0dXJuIHplcm9QYWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHU2NCBmcm9tIEJ1ZmZlciByZXByZXNlbnRhdGlvblxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQnVmZmVyKGJ1ZmZlcikge1xuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCAhPT0gOCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGJ1ZmZlciBsZW5ndGg6ICR7YnVmZmVyLmxlbmd0aH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IHU2NChbLi4uYnVmZmVyXVxuICAgICAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAgICAgLm1hcCgoaSkgPT4gYDAwJHtpLnRvU3RyaW5nKDE2KX1gLnNsaWNlKC0yKSlcbiAgICAgICAgICAgIC5qb2luKFwiXCIpLCAxNik7XG4gICAgfVxufVxuY29uc3QgVE9LRU5fQUNDT1VOVF9MQVlPVVQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtcbiAgICBwdWJsaWNLZXkoXCJtaW50XCIpLFxuICAgIHB1YmxpY0tleShcIm93bmVyXCIpLFxuICAgIHVpbnQ2NChcImFtb3VudFwiKSxcbiAgICBjb3B0aW9uKHB1YmxpY0tleSgpLCBcImRlbGVnYXRlXCIpLFxuICAgICgocCkgPT4ge1xuICAgICAgICBjb25zdCBVID0gQnVmZmVyTGF5b3V0LnVuaW9uKEJ1ZmZlckxheW91dC51OChcImRpc2NyaW1pbmF0b3JcIiksIG51bGwsIHApO1xuICAgICAgICBVLmFkZFZhcmlhbnQoMCwgQnVmZmVyTGF5b3V0LnN0cnVjdChbXSksIFwidW5pbml0aWFsaXplZFwiKTtcbiAgICAgICAgVS5hZGRWYXJpYW50KDEsIEJ1ZmZlckxheW91dC5zdHJ1Y3QoW10pLCBcImluaXRpYWxpemVkXCIpO1xuICAgICAgICBVLmFkZFZhcmlhbnQoMiwgQnVmZmVyTGF5b3V0LnN0cnVjdChbXSksIFwiZnJvemVuXCIpO1xuICAgICAgICByZXR1cm4gVTtcbiAgICB9KShcInN0YXRlXCIpLFxuICAgIGNvcHRpb24odWludDY0KCksIFwiaXNOYXRpdmVcIiksXG4gICAgdWludDY0KFwiZGVsZWdhdGVkQW1vdW50XCIpLFxuICAgIGNvcHRpb24ocHVibGljS2V5KCksIFwiY2xvc2VBdXRob3JpdHlcIiksXG5dKTtcbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVUb2tlbkFjY291bnQoYikge1xuICAgIHJldHVybiBUT0tFTl9BQ0NPVU5UX0xBWU9VVC5kZWNvZGUoYik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b2tlbi1hY2NvdW50LWxheW91dC5qcy5tYXAiXSwibmFtZXMiOlsiQk4iLCJCdWZmZXJMYXlvdXQiLCJMYXlvdXQiLCJQdWJsaWNLZXkiLCJ1aW50NjQiLCJwcm9wZXJ0eSIsIldyYXBwZWRMYXlvdXQiLCJibG9iIiwiYiIsInU2NCIsImZyb21CdWZmZXIiLCJuIiwidG9CdWZmZXIiLCJwdWJsaWNLZXkiLCJrZXkiLCJjb3B0aW9uIiwibGF5b3V0IiwiQ09wdGlvbkxheW91dCIsImNvbnN0cnVjdG9yIiwiZGVjb2RlciIsImVuY29kZXIiLCJzcGFuIiwiZGVjb2RlIiwib2Zmc2V0IiwiZW5jb2RlIiwic3JjIiwiZ2V0U3BhbiIsImRpc2NyaW1pbmF0b3IiLCJ1MzIiLCJ1bmRlZmluZWQiLCJFcnJvciIsImEiLCJ0b0FycmF5IiwicmV2ZXJzZSIsIkJ1ZmZlciIsImZyb20iLCJsZW5ndGgiLCJ6ZXJvUGFkIiwiYWxsb2MiLCJjb3B5IiwiYnVmZmVyIiwibWFwIiwiaSIsInRvU3RyaW5nIiwic2xpY2UiLCJqb2luIiwiVE9LRU5fQUNDT1VOVF9MQVlPVVQiLCJzdHJ1Y3QiLCJwIiwiVSIsInVuaW9uIiwidTgiLCJhZGRWYXJpYW50IiwiZGVjb2RlVG9rZW5BY2NvdW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/token-account-layout.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/provider.js":
/*!**************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/provider.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnchorProvider: () => (/* binding */ AnchorProvider),\n/* harmony export */   getProvider: () => (/* binding */ getProvider),\n/* harmony export */   setProvider: () => (/* binding */ setProvider)\n/* harmony export */ });\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/node_modules/@solana/web3.js/lib/index.esm.js\");\n/* harmony import */ var _utils_bytes_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/bytes/index.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/bytes/index.js\");\n/* harmony import */ var _utils_common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/common.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/common.js\");\n/* harmony import */ var _utils_rpc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/rpc.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/rpc.js\");\n\n\n\n\n/**\n * The network and wallet context used to send transactions paid for and signed\n * by the provider.\n */ class AnchorProvider {\n    /**\n     * @param connection The cluster connection where the program is deployed.\n     * @param wallet     The wallet used to pay for and sign all transactions.\n     * @param opts       Transaction confirmation options to use by default.\n     */ constructor(connection, wallet, opts = AnchorProvider.defaultOptions()){\n        this.connection = connection;\n        this.wallet = wallet;\n        this.opts = opts;\n        this.publicKey = wallet === null || wallet === void 0 ? void 0 : wallet.publicKey;\n    }\n    static defaultOptions() {\n        return {\n            preflightCommitment: \"processed\",\n            commitment: \"processed\"\n        };\n    }\n    /**\n     * Returns a `Provider` with a wallet read from the local filesystem.\n     *\n     * @param url  The network cluster url.\n     * @param opts The default transaction confirmation options.\n     *\n     * (This api is for Node only.)\n     */ static local(url, opts = AnchorProvider.defaultOptions()) {\n        if (_utils_common_js__WEBPACK_IMPORTED_MODULE_2__.isBrowser) {\n            throw new Error(`Provider local is not available on browser.`);\n        }\n        const connection = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Connection(url !== null && url !== void 0 ? url : \"http://127.0.0.1:8899\", opts.preflightCommitment);\n        const NodeWallet = (__webpack_require__(/*! ./nodewallet.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/nodewallet.js\")[\"default\"]);\n        const wallet = NodeWallet.local();\n        return new AnchorProvider(connection, wallet, opts);\n    }\n    /**\n     * Returns a `Provider` read from the `ANCHOR_PROVIDER_URL` environment\n     * variable\n     *\n     * (This api is for Node only.)\n     */ static env() {\n        if (_utils_common_js__WEBPACK_IMPORTED_MODULE_2__.isBrowser) {\n            throw new Error(`Provider env is not available on browser.`);\n        }\n        const process = __webpack_require__(/*! process */ \"process\");\n        const url = process.env.ANCHOR_PROVIDER_URL;\n        if (url === undefined) {\n            throw new Error(\"ANCHOR_PROVIDER_URL is not defined\");\n        }\n        const options = AnchorProvider.defaultOptions();\n        const connection = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Connection(url, options.commitment);\n        const NodeWallet = (__webpack_require__(/*! ./nodewallet.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/nodewallet.js\")[\"default\"]);\n        const wallet = NodeWallet.local();\n        return new AnchorProvider(connection, wallet, options);\n    }\n    /**\n     * Sends the given transaction, paid for and signed by the provider's wallet.\n     *\n     * @param tx      The transaction to send.\n     * @param signers The signers of the transaction.\n     * @param opts    Transaction confirmation options.\n     */ async sendAndConfirm(tx, signers, opts) {\n        var _a, _b, _c, _d;\n        if (opts === undefined) {\n            opts = this.opts;\n        }\n        if ((0,_utils_common_js__WEBPACK_IMPORTED_MODULE_2__.isVersionedTransaction)(tx)) {\n            if (signers) {\n                tx.sign(signers);\n            }\n        } else {\n            tx.feePayer = (_a = tx.feePayer) !== null && _a !== void 0 ? _a : this.wallet.publicKey;\n            tx.recentBlockhash = (await this.connection.getLatestBlockhash(opts.preflightCommitment)).blockhash;\n            if (signers) {\n                for (const signer of signers){\n                    tx.partialSign(signer);\n                }\n            }\n        }\n        tx = await this.wallet.signTransaction(tx);\n        const rawTx = tx.serialize();\n        try {\n            return await sendAndConfirmRawTransaction(this.connection, rawTx, opts);\n        } catch (err) {\n            // thrown if the underlying 'confirmTransaction' encounters a failed tx\n            // the 'confirmTransaction' error does not return logs so we make another rpc call to get them\n            if (err instanceof ConfirmError) {\n                // choose the shortest available commitment for 'getTransaction'\n                // (the json RPC does not support any shorter than \"confirmed\" for 'getTransaction')\n                // because that will see the tx sent with `sendAndConfirmRawTransaction` no matter which\n                // commitment `sendAndConfirmRawTransaction` used\n                const txSig = _utils_bytes_index_js__WEBPACK_IMPORTED_MODULE_1__.bs58.encode((0,_utils_common_js__WEBPACK_IMPORTED_MODULE_2__.isVersionedTransaction)(tx) ? ((_b = tx.signatures) === null || _b === void 0 ? void 0 : _b[0]) || new Uint8Array() : (_c = tx.signature) !== null && _c !== void 0 ? _c : new Uint8Array());\n                const maxVer = (0,_utils_common_js__WEBPACK_IMPORTED_MODULE_2__.isVersionedTransaction)(tx) ? 0 : undefined;\n                const failedTx = await this.connection.getTransaction(txSig, {\n                    commitment: \"confirmed\",\n                    maxSupportedTransactionVersion: maxVer\n                });\n                if (!failedTx) {\n                    throw err;\n                } else {\n                    const logs = (_d = failedTx.meta) === null || _d === void 0 ? void 0 : _d.logMessages;\n                    throw !logs ? err : new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.SendTransactionError(err.message, logs);\n                }\n            } else {\n                throw err;\n            }\n        }\n    }\n    /**\n     * Similar to `send`, but for an array of transactions and signers.\n     * All transactions need to be of the same type, it doesn't support a mix of `VersionedTransaction`s and `Transaction`s.\n     *\n     * @param txWithSigners Array of transactions and signers.\n     * @param opts          Transaction confirmation options.\n     */ async sendAll(txWithSigners, opts) {\n        var _a, _b, _c;\n        if (opts === undefined) {\n            opts = this.opts;\n        }\n        const recentBlockhash = (await this.connection.getLatestBlockhash(opts.preflightCommitment)).blockhash;\n        let txs = txWithSigners.map((r)=>{\n            var _a, _b;\n            if ((0,_utils_common_js__WEBPACK_IMPORTED_MODULE_2__.isVersionedTransaction)(r.tx)) {\n                let tx = r.tx;\n                if (r.signers) {\n                    tx.sign(r.signers);\n                }\n                return tx;\n            } else {\n                let tx = r.tx;\n                let signers = (_a = r.signers) !== null && _a !== void 0 ? _a : [];\n                tx.feePayer = (_b = tx.feePayer) !== null && _b !== void 0 ? _b : this.wallet.publicKey;\n                tx.recentBlockhash = recentBlockhash;\n                signers.forEach((kp)=>{\n                    tx.partialSign(kp);\n                });\n                return tx;\n            }\n        });\n        const signedTxs = await this.wallet.signAllTransactions(txs);\n        const sigs = [];\n        for(let k = 0; k < txs.length; k += 1){\n            const tx = signedTxs[k];\n            const rawTx = tx.serialize();\n            try {\n                sigs.push(await sendAndConfirmRawTransaction(this.connection, rawTx, opts));\n            } catch (err) {\n                // thrown if the underlying 'confirmTransaction' encounters a failed tx\n                // the 'confirmTransaction' error does not return logs so we make another rpc call to get them\n                if (err instanceof ConfirmError) {\n                    // choose the shortest available commitment for 'getTransaction'\n                    // (the json RPC does not support any shorter than \"confirmed\" for 'getTransaction')\n                    // because that will see the tx sent with `sendAndConfirmRawTransaction` no matter which\n                    // commitment `sendAndConfirmRawTransaction` used\n                    const txSig = _utils_bytes_index_js__WEBPACK_IMPORTED_MODULE_1__.bs58.encode((0,_utils_common_js__WEBPACK_IMPORTED_MODULE_2__.isVersionedTransaction)(tx) ? ((_a = tx.signatures) === null || _a === void 0 ? void 0 : _a[0]) || new Uint8Array() : (_b = tx.signature) !== null && _b !== void 0 ? _b : new Uint8Array());\n                    const maxVer = (0,_utils_common_js__WEBPACK_IMPORTED_MODULE_2__.isVersionedTransaction)(tx) ? 0 : undefined;\n                    const failedTx = await this.connection.getTransaction(txSig, {\n                        commitment: \"confirmed\",\n                        maxSupportedTransactionVersion: maxVer\n                    });\n                    if (!failedTx) {\n                        throw err;\n                    } else {\n                        const logs = (_c = failedTx.meta) === null || _c === void 0 ? void 0 : _c.logMessages;\n                        throw !logs ? err : new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.SendTransactionError(err.message, logs);\n                    }\n                } else {\n                    throw err;\n                }\n            }\n        }\n        return sigs;\n    }\n    /**\n     * Simulates the given transaction, returning emitted logs from execution.\n     *\n     * @param tx      The transaction to send.\n     * @param signers The signers of the transaction. If unset, the transaction\n     *                will be simulated with the \"sigVerify: false\" option. This\n     *                allows for simulation of transactions without asking the\n     *                wallet for a signature.\n     * @param opts    Transaction confirmation options.\n     */ async simulate(tx, signers, commitment, includeAccounts) {\n        let recentBlockhash = (await this.connection.getLatestBlockhash(commitment !== null && commitment !== void 0 ? commitment : this.connection.commitment)).blockhash;\n        let result;\n        if ((0,_utils_common_js__WEBPACK_IMPORTED_MODULE_2__.isVersionedTransaction)(tx)) {\n            if (signers && signers.length > 0) {\n                tx.sign(signers);\n                tx = await this.wallet.signTransaction(tx);\n            }\n            // Doesn't support includeAccounts which has been changed to something\n            // else in later versions of this function.\n            result = await this.connection.simulateTransaction(tx, {\n                commitment\n            });\n        } else {\n            tx.feePayer = tx.feePayer || this.wallet.publicKey;\n            tx.recentBlockhash = recentBlockhash;\n            if (signers && signers.length > 0) {\n                tx = await this.wallet.signTransaction(tx);\n            }\n            result = await (0,_utils_rpc_js__WEBPACK_IMPORTED_MODULE_3__.simulateTransaction)(this.connection, tx, signers, commitment, includeAccounts);\n        }\n        if (result.value.err) {\n            throw new SimulateError(result.value);\n        }\n        return result.value;\n    }\n}\nclass SimulateError extends Error {\n    constructor(simulationResponse, message){\n        super(message);\n        this.simulationResponse = simulationResponse;\n    }\n}\n// Copy of Connection.sendAndConfirmRawTransaction that throws\n// a better error if 'confirmTransaction` returns an error status\nasync function sendAndConfirmRawTransaction(connection, rawTransaction, options) {\n    const sendOptions = options && {\n        skipPreflight: options.skipPreflight,\n        preflightCommitment: options.preflightCommitment || options.commitment\n    };\n    const signature = await connection.sendRawTransaction(rawTransaction, sendOptions);\n    const status = (await connection.confirmTransaction(signature, options && options.commitment)).value;\n    if (status.err) {\n        throw new ConfirmError(`Raw transaction ${signature} failed (${JSON.stringify(status)})`);\n    }\n    return signature;\n}\nclass ConfirmError extends Error {\n    constructor(message){\n        super(message);\n    }\n}\n/**\n * Sets the default provider on the client.\n */ function setProvider(provider) {\n    _provider = provider;\n}\n/**\n * Returns the default provider being used by the client.\n */ function getProvider() {\n    if (_provider === null) {\n        return AnchorProvider.local();\n    }\n    return _provider;\n}\n// Global provider used as the default when a provider is not given.\nlet _provider = null; //# sourceMappingURL=provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3Byb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBb0U7QUFDdEI7QUFDd0I7QUFDaEI7QUFDdEQ7OztDQUdDLEdBQ00sTUFBTU07SUFDVDs7OztLQUlDLEdBQ0RDLFlBQVlDLFVBQVUsRUFBRUMsTUFBTSxFQUFFQyxPQUFPSixlQUFlSyxjQUFjLEVBQUUsQ0FBRTtRQUNwRSxJQUFJLENBQUNILFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDQyxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDQyxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDRSxTQUFTLEdBQUdILFdBQVcsUUFBUUEsV0FBVyxLQUFLLElBQUksS0FBSyxJQUFJQSxPQUFPRyxTQUFTO0lBQ3JGO0lBQ0EsT0FBT0QsaUJBQWlCO1FBQ3BCLE9BQU87WUFDSEUscUJBQXFCO1lBQ3JCQyxZQUFZO1FBQ2hCO0lBQ0o7SUFDQTs7Ozs7OztLQU9DLEdBQ0QsT0FBT0MsTUFBTUMsR0FBRyxFQUFFTixPQUFPSixlQUFlSyxjQUFjLEVBQUUsRUFBRTtRQUN0RCxJQUFJUix1REFBU0EsRUFBRTtZQUNYLE1BQU0sSUFBSWMsTUFBTSxDQUFDLDJDQUEyQyxDQUFDO1FBQ2pFO1FBQ0EsTUFBTVQsYUFBYSxJQUFJUix1REFBVUEsQ0FBQ2dCLFFBQVEsUUFBUUEsUUFBUSxLQUFLLElBQUlBLE1BQU0seUJBQXlCTixLQUFLRyxtQkFBbUI7UUFDMUgsTUFBTUssYUFBYUMseUhBQWtDO1FBQ3JELE1BQU1WLFNBQVNTLFdBQVdILEtBQUs7UUFDL0IsT0FBTyxJQUFJVCxlQUFlRSxZQUFZQyxRQUFRQztJQUNsRDtJQUNBOzs7OztLQUtDLEdBQ0QsT0FBT1csTUFBTTtRQUNULElBQUlsQix1REFBU0EsRUFBRTtZQUNYLE1BQU0sSUFBSWMsTUFBTSxDQUFDLHlDQUF5QyxDQUFDO1FBQy9EO1FBQ0EsTUFBTUssVUFBVUgsbUJBQU9B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QUksQ0FBQ21CLGtCQUFrQixHQUFHQTtJQUM5QjtBQUNKO0FBQ0EsOERBQThEO0FBQzlELGlFQUFpRTtBQUNqRSxlQUFlbEMsNkJBQTZCbkMsVUFBVSxFQUFFc0UsY0FBYyxFQUFFckQsT0FBTztJQUMzRSxNQUFNc0QsY0FBY3RELFdBQVc7UUFDM0J1RCxlQUFldkQsUUFBUXVELGFBQWE7UUFDcENuRSxxQkFBcUJZLFFBQVFaLG1CQUFtQixJQUFJWSxRQUFRWCxVQUFVO0lBQzFFO0lBQ0EsTUFBTW9DLFlBQVksTUFBTTFDLFdBQVd5RSxrQkFBa0IsQ0FBQ0gsZ0JBQWdCQztJQUN0RSxNQUFNRyxTQUFTLENBQUMsTUFBTTFFLFdBQVcyRSxrQkFBa0IsQ0FBQ2pDLFdBQVd6QixXQUFXQSxRQUFRWCxVQUFVLEdBQUc2RCxLQUFLO0lBQ3BHLElBQUlPLE9BQU90QyxHQUFHLEVBQUU7UUFDWixNQUFNLElBQUlDLGFBQWEsQ0FBQyxnQkFBZ0IsRUFBRUssVUFBVSxTQUFTLEVBQUVrQyxLQUFLQyxTQUFTLENBQUNILFFBQVEsQ0FBQyxDQUFDO0lBQzVGO0lBQ0EsT0FBT2hDO0FBQ1g7QUFDQSxNQUFNTCxxQkFBcUI1QjtJQUN2QlYsWUFBWW1ELE9BQU8sQ0FBRTtRQUNqQixLQUFLLENBQUNBO0lBQ1Y7QUFDSjtBQUNBOztDQUVDLEdBQ00sU0FBUzRCLFlBQVlDLFFBQVE7SUFDaENDLFlBQVlEO0FBQ2hCO0FBQ0E7O0NBRUMsR0FDTSxTQUFTRTtJQUNaLElBQUlELGNBQWMsTUFBTTtRQUNwQixPQUFPbEYsZUFBZVMsS0FBSztJQUMvQjtJQUNBLE9BQU95RTtBQUNYO0FBQ0Esb0VBQW9FO0FBQ3BFLElBQUlBLFlBQVksTUFDaEIsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AY29yYWwteHl6L2FuY2hvci9kaXN0L2VzbS9wcm92aWRlci5qcz8zYWI4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbm5lY3Rpb24sIFNlbmRUcmFuc2FjdGlvbkVycm9yLCB9IGZyb20gXCJAc29sYW5hL3dlYjMuanNcIjtcbmltcG9ydCB7IGJzNTggfSBmcm9tIFwiLi91dGlscy9ieXRlcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgaXNCcm93c2VyLCBpc1ZlcnNpb25lZFRyYW5zYWN0aW9uIH0gZnJvbSBcIi4vdXRpbHMvY29tbW9uLmpzXCI7XG5pbXBvcnQgeyBzaW11bGF0ZVRyYW5zYWN0aW9uLCB9IGZyb20gXCIuL3V0aWxzL3JwYy5qc1wiO1xuLyoqXG4gKiBUaGUgbmV0d29yayBhbmQgd2FsbGV0IGNvbnRleHQgdXNlZCB0byBzZW5kIHRyYW5zYWN0aW9ucyBwYWlkIGZvciBhbmQgc2lnbmVkXG4gKiBieSB0aGUgcHJvdmlkZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBBbmNob3JQcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGNvbm5lY3Rpb24gVGhlIGNsdXN0ZXIgY29ubmVjdGlvbiB3aGVyZSB0aGUgcHJvZ3JhbSBpcyBkZXBsb3llZC5cbiAgICAgKiBAcGFyYW0gd2FsbGV0ICAgICBUaGUgd2FsbGV0IHVzZWQgdG8gcGF5IGZvciBhbmQgc2lnbiBhbGwgdHJhbnNhY3Rpb25zLlxuICAgICAqIEBwYXJhbSBvcHRzICAgICAgIFRyYW5zYWN0aW9uIGNvbmZpcm1hdGlvbiBvcHRpb25zIHRvIHVzZSBieSBkZWZhdWx0LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb24sIHdhbGxldCwgb3B0cyA9IEFuY2hvclByb3ZpZGVyLmRlZmF1bHRPcHRpb25zKCkpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICAgICAgdGhpcy53YWxsZXQgPSB3YWxsZXQ7XG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgICAgIHRoaXMucHVibGljS2V5ID0gd2FsbGV0ID09PSBudWxsIHx8IHdhbGxldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2FsbGV0LnB1YmxpY0tleTtcbiAgICB9XG4gICAgc3RhdGljIGRlZmF1bHRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJlZmxpZ2h0Q29tbWl0bWVudDogXCJwcm9jZXNzZWRcIixcbiAgICAgICAgICAgIGNvbW1pdG1lbnQ6IFwicHJvY2Vzc2VkXCIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBgUHJvdmlkZXJgIHdpdGggYSB3YWxsZXQgcmVhZCBmcm9tIHRoZSBsb2NhbCBmaWxlc3lzdGVtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVybCAgVGhlIG5ldHdvcmsgY2x1c3RlciB1cmwuXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIGRlZmF1bHQgdHJhbnNhY3Rpb24gY29uZmlybWF0aW9uIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiAoVGhpcyBhcGkgaXMgZm9yIE5vZGUgb25seS4pXG4gICAgICovXG4gICAgc3RhdGljIGxvY2FsKHVybCwgb3B0cyA9IEFuY2hvclByb3ZpZGVyLmRlZmF1bHRPcHRpb25zKCkpIHtcbiAgICAgICAgaWYgKGlzQnJvd3Nlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm92aWRlciBsb2NhbCBpcyBub3QgYXZhaWxhYmxlIG9uIGJyb3dzZXIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IG5ldyBDb25uZWN0aW9uKHVybCAhPT0gbnVsbCAmJiB1cmwgIT09IHZvaWQgMCA/IHVybCA6IFwiaHR0cDovLzEyNy4wLjAuMTo4ODk5XCIsIG9wdHMucHJlZmxpZ2h0Q29tbWl0bWVudCk7XG4gICAgICAgIGNvbnN0IE5vZGVXYWxsZXQgPSByZXF1aXJlKFwiLi9ub2Rld2FsbGV0LmpzXCIpLmRlZmF1bHQ7XG4gICAgICAgIGNvbnN0IHdhbGxldCA9IE5vZGVXYWxsZXQubG9jYWwoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBbmNob3JQcm92aWRlcihjb25uZWN0aW9uLCB3YWxsZXQsIG9wdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYFByb3ZpZGVyYCByZWFkIGZyb20gdGhlIGBBTkNIT1JfUFJPVklERVJfVVJMYCBlbnZpcm9ubWVudFxuICAgICAqIHZhcmlhYmxlXG4gICAgICpcbiAgICAgKiAoVGhpcyBhcGkgaXMgZm9yIE5vZGUgb25seS4pXG4gICAgICovXG4gICAgc3RhdGljIGVudigpIHtcbiAgICAgICAgaWYgKGlzQnJvd3Nlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm92aWRlciBlbnYgaXMgbm90IGF2YWlsYWJsZSBvbiBicm93c2VyLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb2Nlc3MgPSByZXF1aXJlKFwicHJvY2Vzc1wiKTtcbiAgICAgICAgY29uc3QgdXJsID0gcHJvY2Vzcy5lbnYuQU5DSE9SX1BST1ZJREVSX1VSTDtcbiAgICAgICAgaWYgKHVybCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBTkNIT1JfUFJPVklERVJfVVJMIGlzIG5vdCBkZWZpbmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBBbmNob3JQcm92aWRlci5kZWZhdWx0T3B0aW9ucygpO1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gbmV3IENvbm5lY3Rpb24odXJsLCBvcHRpb25zLmNvbW1pdG1lbnQpO1xuICAgICAgICBjb25zdCBOb2RlV2FsbGV0ID0gcmVxdWlyZShcIi4vbm9kZXdhbGxldC5qc1wiKS5kZWZhdWx0O1xuICAgICAgICBjb25zdCB3YWxsZXQgPSBOb2RlV2FsbGV0LmxvY2FsKCk7XG4gICAgICAgIHJldHVybiBuZXcgQW5jaG9yUHJvdmlkZXIoY29ubmVjdGlvbiwgd2FsbGV0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgdGhlIGdpdmVuIHRyYW5zYWN0aW9uLCBwYWlkIGZvciBhbmQgc2lnbmVkIGJ5IHRoZSBwcm92aWRlcidzIHdhbGxldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eCAgICAgIFRoZSB0cmFuc2FjdGlvbiB0byBzZW5kLlxuICAgICAqIEBwYXJhbSBzaWduZXJzIFRoZSBzaWduZXJzIG9mIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0cyAgICBUcmFuc2FjdGlvbiBjb25maXJtYXRpb24gb3B0aW9ucy5cbiAgICAgKi9cbiAgICBhc3luYyBzZW5kQW5kQ29uZmlybSh0eCwgc2lnbmVycywgb3B0cykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGlmIChvcHRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdHMgPSB0aGlzLm9wdHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVmVyc2lvbmVkVHJhbnNhY3Rpb24odHgpKSB7XG4gICAgICAgICAgICBpZiAoc2lnbmVycykge1xuICAgICAgICAgICAgICAgIHR4LnNpZ24oc2lnbmVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0eC5mZWVQYXllciA9IChfYSA9IHR4LmZlZVBheWVyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLndhbGxldC5wdWJsaWNLZXk7XG4gICAgICAgICAgICB0eC5yZWNlbnRCbG9ja2hhc2ggPSAoYXdhaXQgdGhpcy5jb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaChvcHRzLnByZWZsaWdodENvbW1pdG1lbnQpKS5ibG9ja2hhc2g7XG4gICAgICAgICAgICBpZiAoc2lnbmVycykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc2lnbmVyIG9mIHNpZ25lcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdHgucGFydGlhbFNpZ24oc2lnbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHggPSBhd2FpdCB0aGlzLndhbGxldC5zaWduVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICBjb25zdCByYXdUeCA9IHR4LnNlcmlhbGl6ZSgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHNlbmRBbmRDb25maXJtUmF3VHJhbnNhY3Rpb24odGhpcy5jb25uZWN0aW9uLCByYXdUeCwgb3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gdGhyb3duIGlmIHRoZSB1bmRlcmx5aW5nICdjb25maXJtVHJhbnNhY3Rpb24nIGVuY291bnRlcnMgYSBmYWlsZWQgdHhcbiAgICAgICAgICAgIC8vIHRoZSAnY29uZmlybVRyYW5zYWN0aW9uJyBlcnJvciBkb2VzIG5vdCByZXR1cm4gbG9ncyBzbyB3ZSBtYWtlIGFub3RoZXIgcnBjIGNhbGwgdG8gZ2V0IHRoZW1cbiAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBDb25maXJtRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBjaG9vc2UgdGhlIHNob3J0ZXN0IGF2YWlsYWJsZSBjb21taXRtZW50IGZvciAnZ2V0VHJhbnNhY3Rpb24nXG4gICAgICAgICAgICAgICAgLy8gKHRoZSBqc29uIFJQQyBkb2VzIG5vdCBzdXBwb3J0IGFueSBzaG9ydGVyIHRoYW4gXCJjb25maXJtZWRcIiBmb3IgJ2dldFRyYW5zYWN0aW9uJylcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd2lsbCBzZWUgdGhlIHR4IHNlbnQgd2l0aCBgc2VuZEFuZENvbmZpcm1SYXdUcmFuc2FjdGlvbmAgbm8gbWF0dGVyIHdoaWNoXG4gICAgICAgICAgICAgICAgLy8gY29tbWl0bWVudCBgc2VuZEFuZENvbmZpcm1SYXdUcmFuc2FjdGlvbmAgdXNlZFxuICAgICAgICAgICAgICAgIGNvbnN0IHR4U2lnID0gYnM1OC5lbmNvZGUoaXNWZXJzaW9uZWRUcmFuc2FjdGlvbih0eClcbiAgICAgICAgICAgICAgICAgICAgPyAoKF9iID0gdHguc2lnbmF0dXJlcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iWzBdKSB8fCBuZXcgVWludDhBcnJheSgpXG4gICAgICAgICAgICAgICAgICAgIDogKF9jID0gdHguc2lnbmF0dXJlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBuZXcgVWludDhBcnJheSgpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXhWZXIgPSBpc1ZlcnNpb25lZFRyYW5zYWN0aW9uKHR4KSA/IDAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZmFpbGVkVHggPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uZ2V0VHJhbnNhY3Rpb24odHhTaWcsIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWl0bWVudDogXCJjb25maXJtZWRcIixcbiAgICAgICAgICAgICAgICAgICAgbWF4U3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9uOiBtYXhWZXIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFmYWlsZWRUeCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dzID0gKF9kID0gZmFpbGVkVHgubWV0YSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmxvZ01lc3NhZ2VzO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyAhbG9ncyA/IGVyciA6IG5ldyBTZW5kVHJhbnNhY3Rpb25FcnJvcihlcnIubWVzc2FnZSwgbG9ncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpbWlsYXIgdG8gYHNlbmRgLCBidXQgZm9yIGFuIGFycmF5IG9mIHRyYW5zYWN0aW9ucyBhbmQgc2lnbmVycy5cbiAgICAgKiBBbGwgdHJhbnNhY3Rpb25zIG5lZWQgdG8gYmUgb2YgdGhlIHNhbWUgdHlwZSwgaXQgZG9lc24ndCBzdXBwb3J0IGEgbWl4IG9mIGBWZXJzaW9uZWRUcmFuc2FjdGlvbmBzIGFuZCBgVHJhbnNhY3Rpb25gcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eFdpdGhTaWduZXJzIEFycmF5IG9mIHRyYW5zYWN0aW9ucyBhbmQgc2lnbmVycy5cbiAgICAgKiBAcGFyYW0gb3B0cyAgICAgICAgICBUcmFuc2FjdGlvbiBjb25maXJtYXRpb24gb3B0aW9ucy5cbiAgICAgKi9cbiAgICBhc3luYyBzZW5kQWxsKHR4V2l0aFNpZ25lcnMsIG9wdHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGlmIChvcHRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdHMgPSB0aGlzLm9wdHM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVjZW50QmxvY2toYXNoID0gKGF3YWl0IHRoaXMuY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2gob3B0cy5wcmVmbGlnaHRDb21taXRtZW50KSkuYmxvY2toYXNoO1xuICAgICAgICBsZXQgdHhzID0gdHhXaXRoU2lnbmVycy5tYXAoKHIpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBpZiAoaXNWZXJzaW9uZWRUcmFuc2FjdGlvbihyLnR4KSkge1xuICAgICAgICAgICAgICAgIGxldCB0eCA9IHIudHg7XG4gICAgICAgICAgICAgICAgaWYgKHIuc2lnbmVycykge1xuICAgICAgICAgICAgICAgICAgICB0eC5zaWduKHIuc2lnbmVycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0eDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB0eCA9IHIudHg7XG4gICAgICAgICAgICAgICAgbGV0IHNpZ25lcnMgPSAoX2EgPSByLnNpZ25lcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgICAgICAgICAgICAgIHR4LmZlZVBheWVyID0gKF9iID0gdHguZmVlUGF5ZXIpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRoaXMud2FsbGV0LnB1YmxpY0tleTtcbiAgICAgICAgICAgICAgICB0eC5yZWNlbnRCbG9ja2hhc2ggPSByZWNlbnRCbG9ja2hhc2g7XG4gICAgICAgICAgICAgICAgc2lnbmVycy5mb3JFYWNoKChrcCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0eC5wYXJ0aWFsU2lnbihrcCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc2lnbmVkVHhzID0gYXdhaXQgdGhpcy53YWxsZXQuc2lnbkFsbFRyYW5zYWN0aW9ucyh0eHMpO1xuICAgICAgICBjb25zdCBzaWdzID0gW107XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgdHhzLmxlbmd0aDsgayArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCB0eCA9IHNpZ25lZFR4c1trXTtcbiAgICAgICAgICAgIGNvbnN0IHJhd1R4ID0gdHguc2VyaWFsaXplKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHNpZ3MucHVzaChhd2FpdCBzZW5kQW5kQ29uZmlybVJhd1RyYW5zYWN0aW9uKHRoaXMuY29ubmVjdGlvbiwgcmF3VHgsIG9wdHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyB0aHJvd24gaWYgdGhlIHVuZGVybHlpbmcgJ2NvbmZpcm1UcmFuc2FjdGlvbicgZW5jb3VudGVycyBhIGZhaWxlZCB0eFxuICAgICAgICAgICAgICAgIC8vIHRoZSAnY29uZmlybVRyYW5zYWN0aW9uJyBlcnJvciBkb2VzIG5vdCByZXR1cm4gbG9ncyBzbyB3ZSBtYWtlIGFub3RoZXIgcnBjIGNhbGwgdG8gZ2V0IHRoZW1cbiAgICAgICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgQ29uZmlybUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNob29zZSB0aGUgc2hvcnRlc3QgYXZhaWxhYmxlIGNvbW1pdG1lbnQgZm9yICdnZXRUcmFuc2FjdGlvbidcbiAgICAgICAgICAgICAgICAgICAgLy8gKHRoZSBqc29uIFJQQyBkb2VzIG5vdCBzdXBwb3J0IGFueSBzaG9ydGVyIHRoYW4gXCJjb25maXJtZWRcIiBmb3IgJ2dldFRyYW5zYWN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdpbGwgc2VlIHRoZSB0eCBzZW50IHdpdGggYHNlbmRBbmRDb25maXJtUmF3VHJhbnNhY3Rpb25gIG5vIG1hdHRlciB3aGljaFxuICAgICAgICAgICAgICAgICAgICAvLyBjb21taXRtZW50IGBzZW5kQW5kQ29uZmlybVJhd1RyYW5zYWN0aW9uYCB1c2VkXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR4U2lnID0gYnM1OC5lbmNvZGUoaXNWZXJzaW9uZWRUcmFuc2FjdGlvbih0eClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKChfYSA9IHR4LnNpZ25hdHVyZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgfHwgbmV3IFVpbnQ4QXJyYXkoKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAoX2IgPSB0eC5zaWduYXR1cmUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG5ldyBVaW50OEFycmF5KCkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXhWZXIgPSBpc1ZlcnNpb25lZFRyYW5zYWN0aW9uKHR4KSA/IDAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZhaWxlZFR4ID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLmdldFRyYW5zYWN0aW9uKHR4U2lnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21taXRtZW50OiBcImNvbmZpcm1lZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4U3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9uOiBtYXhWZXIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZhaWxlZFR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dzID0gKF9jID0gZmFpbGVkVHgubWV0YSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmxvZ01lc3NhZ2VzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgIWxvZ3MgPyBlcnIgOiBuZXcgU2VuZFRyYW5zYWN0aW9uRXJyb3IoZXJyLm1lc3NhZ2UsIGxvZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaWdzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaW11bGF0ZXMgdGhlIGdpdmVuIHRyYW5zYWN0aW9uLCByZXR1cm5pbmcgZW1pdHRlZCBsb2dzIGZyb20gZXhlY3V0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHR4ICAgICAgVGhlIHRyYW5zYWN0aW9uIHRvIHNlbmQuXG4gICAgICogQHBhcmFtIHNpZ25lcnMgVGhlIHNpZ25lcnMgb2YgdGhlIHRyYW5zYWN0aW9uLiBJZiB1bnNldCwgdGhlIHRyYW5zYWN0aW9uXG4gICAgICogICAgICAgICAgICAgICAgd2lsbCBiZSBzaW11bGF0ZWQgd2l0aCB0aGUgXCJzaWdWZXJpZnk6IGZhbHNlXCIgb3B0aW9uLiBUaGlzXG4gICAgICogICAgICAgICAgICAgICAgYWxsb3dzIGZvciBzaW11bGF0aW9uIG9mIHRyYW5zYWN0aW9ucyB3aXRob3V0IGFza2luZyB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICB3YWxsZXQgZm9yIGEgc2lnbmF0dXJlLlxuICAgICAqIEBwYXJhbSBvcHRzICAgIFRyYW5zYWN0aW9uIGNvbmZpcm1hdGlvbiBvcHRpb25zLlxuICAgICAqL1xuICAgIGFzeW5jIHNpbXVsYXRlKHR4LCBzaWduZXJzLCBjb21taXRtZW50LCBpbmNsdWRlQWNjb3VudHMpIHtcbiAgICAgICAgbGV0IHJlY2VudEJsb2NraGFzaCA9IChhd2FpdCB0aGlzLmNvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2toYXNoKGNvbW1pdG1lbnQgIT09IG51bGwgJiYgY29tbWl0bWVudCAhPT0gdm9pZCAwID8gY29tbWl0bWVudCA6IHRoaXMuY29ubmVjdGlvbi5jb21taXRtZW50KSkuYmxvY2toYXNoO1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBpZiAoaXNWZXJzaW9uZWRUcmFuc2FjdGlvbih0eCkpIHtcbiAgICAgICAgICAgIGlmIChzaWduZXJzICYmIHNpZ25lcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHR4LnNpZ24oc2lnbmVycyk7XG4gICAgICAgICAgICAgICAgdHggPSBhd2FpdCB0aGlzLndhbGxldC5zaWduVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRG9lc24ndCBzdXBwb3J0IGluY2x1ZGVBY2NvdW50cyB3aGljaCBoYXMgYmVlbiBjaGFuZ2VkIHRvIHNvbWV0aGluZ1xuICAgICAgICAgICAgLy8gZWxzZSBpbiBsYXRlciB2ZXJzaW9ucyBvZiB0aGlzIGZ1bmN0aW9uLlxuICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLnNpbXVsYXRlVHJhbnNhY3Rpb24odHgsIHsgY29tbWl0bWVudCB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHR4LmZlZVBheWVyID0gdHguZmVlUGF5ZXIgfHwgdGhpcy53YWxsZXQucHVibGljS2V5O1xuICAgICAgICAgICAgdHgucmVjZW50QmxvY2toYXNoID0gcmVjZW50QmxvY2toYXNoO1xuICAgICAgICAgICAgaWYgKHNpZ25lcnMgJiYgc2lnbmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdHggPSBhd2FpdCB0aGlzLndhbGxldC5zaWduVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgc2ltdWxhdGVUcmFuc2FjdGlvbih0aGlzLmNvbm5lY3Rpb24sIHR4LCBzaWduZXJzLCBjb21taXRtZW50LCBpbmNsdWRlQWNjb3VudHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQudmFsdWUuZXJyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2ltdWxhdGVFcnJvcihyZXN1bHQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgfVxufVxuY2xhc3MgU2ltdWxhdGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihzaW11bGF0aW9uUmVzcG9uc2UsIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuc2ltdWxhdGlvblJlc3BvbnNlID0gc2ltdWxhdGlvblJlc3BvbnNlO1xuICAgIH1cbn1cbi8vIENvcHkgb2YgQ29ubmVjdGlvbi5zZW5kQW5kQ29uZmlybVJhd1RyYW5zYWN0aW9uIHRoYXQgdGhyb3dzXG4vLyBhIGJldHRlciBlcnJvciBpZiAnY29uZmlybVRyYW5zYWN0aW9uYCByZXR1cm5zIGFuIGVycm9yIHN0YXR1c1xuYXN5bmMgZnVuY3Rpb24gc2VuZEFuZENvbmZpcm1SYXdUcmFuc2FjdGlvbihjb25uZWN0aW9uLCByYXdUcmFuc2FjdGlvbiwgb3B0aW9ucykge1xuICAgIGNvbnN0IHNlbmRPcHRpb25zID0gb3B0aW9ucyAmJiB7XG4gICAgICAgIHNraXBQcmVmbGlnaHQ6IG9wdGlvbnMuc2tpcFByZWZsaWdodCxcbiAgICAgICAgcHJlZmxpZ2h0Q29tbWl0bWVudDogb3B0aW9ucy5wcmVmbGlnaHRDb21taXRtZW50IHx8IG9wdGlvbnMuY29tbWl0bWVudCxcbiAgICB9O1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IGNvbm5lY3Rpb24uc2VuZFJhd1RyYW5zYWN0aW9uKHJhd1RyYW5zYWN0aW9uLCBzZW5kT3B0aW9ucyk7XG4gICAgY29uc3Qgc3RhdHVzID0gKGF3YWl0IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHNpZ25hdHVyZSwgb3B0aW9ucyAmJiBvcHRpb25zLmNvbW1pdG1lbnQpKS52YWx1ZTtcbiAgICBpZiAoc3RhdHVzLmVycikge1xuICAgICAgICB0aHJvdyBuZXcgQ29uZmlybUVycm9yKGBSYXcgdHJhbnNhY3Rpb24gJHtzaWduYXR1cmV9IGZhaWxlZCAoJHtKU09OLnN0cmluZ2lmeShzdGF0dXMpfSlgKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpZ25hdHVyZTtcbn1cbmNsYXNzIENvbmZpcm1FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIH1cbn1cbi8qKlxuICogU2V0cyB0aGUgZGVmYXVsdCBwcm92aWRlciBvbiB0aGUgY2xpZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0UHJvdmlkZXIocHJvdmlkZXIpIHtcbiAgICBfcHJvdmlkZXIgPSBwcm92aWRlcjtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZGVmYXVsdCBwcm92aWRlciBiZWluZyB1c2VkIGJ5IHRoZSBjbGllbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcm92aWRlcigpIHtcbiAgICBpZiAoX3Byb3ZpZGVyID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBBbmNob3JQcm92aWRlci5sb2NhbCgpO1xuICAgIH1cbiAgICByZXR1cm4gX3Byb3ZpZGVyO1xufVxuLy8gR2xvYmFsIHByb3ZpZGVyIHVzZWQgYXMgdGhlIGRlZmF1bHQgd2hlbiBhIHByb3ZpZGVyIGlzIG5vdCBnaXZlbi5cbmxldCBfcHJvdmlkZXIgPSBudWxsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbIkNvbm5lY3Rpb24iLCJTZW5kVHJhbnNhY3Rpb25FcnJvciIsImJzNTgiLCJpc0Jyb3dzZXIiLCJpc1ZlcnNpb25lZFRyYW5zYWN0aW9uIiwic2ltdWxhdGVUcmFuc2FjdGlvbiIsIkFuY2hvclByb3ZpZGVyIiwiY29uc3RydWN0b3IiLCJjb25uZWN0aW9uIiwid2FsbGV0Iiwib3B0cyIsImRlZmF1bHRPcHRpb25zIiwicHVibGljS2V5IiwicHJlZmxpZ2h0Q29tbWl0bWVudCIsImNvbW1pdG1lbnQiLCJsb2NhbCIsInVybCIsIkVycm9yIiwiTm9kZVdhbGxldCIsInJlcXVpcmUiLCJkZWZhdWx0IiwiZW52IiwicHJvY2VzcyIsIkFOQ0hPUl9QUk9WSURFUl9VUkwiLCJ1bmRlZmluZWQiLCJvcHRpb25zIiwic2VuZEFuZENvbmZpcm0iLCJ0eCIsInNpZ25lcnMiLCJfYSIsIl9iIiwiX2MiLCJfZCIsInNpZ24iLCJmZWVQYXllciIsInJlY2VudEJsb2NraGFzaCIsImdldExhdGVzdEJsb2NraGFzaCIsImJsb2NraGFzaCIsInNpZ25lciIsInBhcnRpYWxTaWduIiwic2lnblRyYW5zYWN0aW9uIiwicmF3VHgiLCJzZXJpYWxpemUiLCJzZW5kQW5kQ29uZmlybVJhd1RyYW5zYWN0aW9uIiwiZXJyIiwiQ29uZmlybUVycm9yIiwidHhTaWciLCJlbmNvZGUiLCJzaWduYXR1cmVzIiwiVWludDhBcnJheSIsInNpZ25hdHVyZSIsIm1heFZlciIsImZhaWxlZFR4IiwiZ2V0VHJhbnNhY3Rpb24iLCJtYXhTdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb24iLCJsb2dzIiwibWV0YSIsImxvZ01lc3NhZ2VzIiwibWVzc2FnZSIsInNlbmRBbGwiLCJ0eFdpdGhTaWduZXJzIiwidHhzIiwibWFwIiwiciIsImZvckVhY2giLCJrcCIsInNpZ25lZFR4cyIsInNpZ25BbGxUcmFuc2FjdGlvbnMiLCJzaWdzIiwiayIsImxlbmd0aCIsInB1c2giLCJzaW11bGF0ZSIsImluY2x1ZGVBY2NvdW50cyIsInJlc3VsdCIsInZhbHVlIiwiU2ltdWxhdGVFcnJvciIsInNpbXVsYXRpb25SZXNwb25zZSIsInJhd1RyYW5zYWN0aW9uIiwic2VuZE9wdGlvbnMiLCJza2lwUHJlZmxpZ2h0Iiwic2VuZFJhd1RyYW5zYWN0aW9uIiwic3RhdHVzIiwiY29uZmlybVRyYW5zYWN0aW9uIiwiSlNPTiIsInN0cmluZ2lmeSIsInNldFByb3ZpZGVyIiwicHJvdmlkZXIiLCJfcHJvdmlkZXIiLCJnZXRQcm92aWRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/provider.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/bytes/base64.js":
/*!************************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/utils/bytes/base64.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(buffer__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction encode(data) {\n    return data.toString(\"base64\");\n}\nfunction decode(data) {\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(data, \"base64\");\n} //# sourceMappingURL=base64.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3V0aWxzL2J5dGVzL2Jhc2U2NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWdDO0FBQ3pCLFNBQVNDLE9BQU9DLElBQUk7SUFDdkIsT0FBT0EsS0FBS0MsUUFBUSxDQUFDO0FBQ3pCO0FBQ08sU0FBU0MsT0FBT0YsSUFBSTtJQUN2QixPQUFPRiwwQ0FBTUEsQ0FBQ0ssSUFBSSxDQUFDSCxNQUFNO0FBQzdCLEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AY29yYWwteHl6L2FuY2hvci9kaXN0L2VzbS91dGlscy9ieXRlcy9iYXNlNjQuanM/ZWJlZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCdWZmZXIgfSBmcm9tIFwiYnVmZmVyXCI7XG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS50b1N0cmluZyhcImJhc2U2NFwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGUoZGF0YSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShkYXRhLCBcImJhc2U2NFwiKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2U2NC5qcy5tYXAiXSwibmFtZXMiOlsiQnVmZmVyIiwiZW5jb2RlIiwiZGF0YSIsInRvU3RyaW5nIiwiZGVjb2RlIiwiZnJvbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/bytes/base64.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/bytes/bs58.js":
/*!**********************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/utils/bytes/bs58.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bs58 */ \"(ssr)/../node_modules/@coral-xyz/anchor/node_modules/bs58/index.js\");\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bs58__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction encode(data) {\n    return bs58__WEBPACK_IMPORTED_MODULE_0___default().encode(data);\n}\nfunction decode(data) {\n    return bs58__WEBPACK_IMPORTED_MODULE_0___default().decode(data);\n} //# sourceMappingURL=bs58.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3V0aWxzL2J5dGVzL2JzNTguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF3QjtBQUNqQixTQUFTQyxPQUFPQyxJQUFJO0lBQ3ZCLE9BQU9GLGtEQUFXLENBQUNFO0FBQ3ZCO0FBQ08sU0FBU0MsT0FBT0QsSUFBSTtJQUN2QixPQUFPRixrREFBVyxDQUFDRTtBQUN2QixFQUNBLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGNvcmFsLXh5ei9hbmNob3IvZGlzdC9lc20vdXRpbHMvYnl0ZXMvYnM1OC5qcz8zNjBiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBiczU4IGZyb20gXCJiczU4XCI7XG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKGRhdGEpIHtcbiAgICByZXR1cm4gYnM1OC5lbmNvZGUoZGF0YSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlKGRhdGEpIHtcbiAgICByZXR1cm4gYnM1OC5kZWNvZGUoZGF0YSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iczU4LmpzLm1hcCJdLCJuYW1lcyI6WyJiczU4IiwiZW5jb2RlIiwiZGF0YSIsImRlY29kZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/bytes/bs58.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/bytes/hex.js":
/*!*********************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/utils/bytes/hex.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(buffer__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction encode(data) {\n    return data.reduce((str, byte)=>str + byte.toString(16).padStart(2, \"0\"), \"0x\");\n}\nfunction decode(data) {\n    if (data.indexOf(\"0x\") === 0) {\n        data = data.substr(2);\n    }\n    if (data.length % 2 === 1) {\n        data = \"0\" + data;\n    }\n    let key = data.match(/.{2}/g);\n    if (key === null) {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([]);\n    }\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(key.map((byte)=>parseInt(byte, 16)));\n} //# sourceMappingURL=hex.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3V0aWxzL2J5dGVzL2hleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWdDO0FBQ3pCLFNBQVNDLE9BQU9DLElBQUk7SUFDdkIsT0FBT0EsS0FBS0MsTUFBTSxDQUFDLENBQUNDLEtBQUtDLE9BQVNELE1BQU1DLEtBQUtDLFFBQVEsQ0FBQyxJQUFJQyxRQUFRLENBQUMsR0FBRyxNQUFNO0FBQ2hGO0FBQ08sU0FBU0MsT0FBT04sSUFBSTtJQUN2QixJQUFJQSxLQUFLTyxPQUFPLENBQUMsVUFBVSxHQUFHO1FBQzFCUCxPQUFPQSxLQUFLUSxNQUFNLENBQUM7SUFDdkI7SUFDQSxJQUFJUixLQUFLUyxNQUFNLEdBQUcsTUFBTSxHQUFHO1FBQ3ZCVCxPQUFPLE1BQU1BO0lBQ2pCO0lBQ0EsSUFBSVUsTUFBTVYsS0FBS1csS0FBSyxDQUFDO0lBQ3JCLElBQUlELFFBQVEsTUFBTTtRQUNkLE9BQU9aLDBDQUFNQSxDQUFDYyxJQUFJLENBQUMsRUFBRTtJQUN6QjtJQUNBLE9BQU9kLDBDQUFNQSxDQUFDYyxJQUFJLENBQUNGLElBQUlHLEdBQUcsQ0FBQyxDQUFDVixPQUFTVyxTQUFTWCxNQUFNO0FBQ3hELEVBQ0EsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AY29yYWwteHl6L2FuY2hvci9kaXN0L2VzbS91dGlscy9ieXRlcy9oZXguanM/MjU3OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCdWZmZXIgfSBmcm9tIFwiYnVmZmVyXCI7XG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS5yZWR1Y2UoKHN0ciwgYnl0ZSkgPT4gc3RyICsgYnl0ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpLCBcIjB4XCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZShkYXRhKSB7XG4gICAgaWYgKGRhdGEuaW5kZXhPZihcIjB4XCIpID09PSAwKSB7XG4gICAgICAgIGRhdGEgPSBkYXRhLnN1YnN0cigyKTtcbiAgICB9XG4gICAgaWYgKGRhdGEubGVuZ3RoICUgMiA9PT0gMSkge1xuICAgICAgICBkYXRhID0gXCIwXCIgKyBkYXRhO1xuICAgIH1cbiAgICBsZXQga2V5ID0gZGF0YS5tYXRjaCgvLnsyfS9nKTtcbiAgICBpZiAoa2V5ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShbXSk7XG4gICAgfVxuICAgIHJldHVybiBCdWZmZXIuZnJvbShrZXkubWFwKChieXRlKSA9PiBwYXJzZUludChieXRlLCAxNikpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhleC5qcy5tYXAiXSwibmFtZXMiOlsiQnVmZmVyIiwiZW5jb2RlIiwiZGF0YSIsInJlZHVjZSIsInN0ciIsImJ5dGUiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiZGVjb2RlIiwiaW5kZXhPZiIsInN1YnN0ciIsImxlbmd0aCIsImtleSIsIm1hdGNoIiwiZnJvbSIsIm1hcCIsInBhcnNlSW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/bytes/hex.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/bytes/index.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/utils/bytes/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base64: () => (/* reexport module object */ _base64_js__WEBPACK_IMPORTED_MODULE_3__),\n/* harmony export */   bs58: () => (/* reexport module object */ _bs58_js__WEBPACK_IMPORTED_MODULE_2__),\n/* harmony export */   hex: () => (/* reexport module object */ _hex_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   utf8: () => (/* reexport module object */ _utf8_js__WEBPACK_IMPORTED_MODULE_1__)\n/* harmony export */ });\n/* harmony import */ var _hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hex.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/bytes/hex.js\");\n/* harmony import */ var _utf8_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utf8.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/bytes/utf8.js\");\n/* harmony import */ var _bs58_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bs58.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/bytes/bs58.js\");\n/* harmony import */ var _base64_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base64.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/bytes/base64.js\");\n\n\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3V0aWxzL2J5dGVzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWdDO0FBQ0U7QUFDQTtBQUNJLENBQ3RDLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGNvcmFsLXh5ei9hbmNob3IvZGlzdC9lc20vdXRpbHMvYnl0ZXMvaW5kZXguanM/NDEyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBhcyBoZXggZnJvbSBcIi4vaGV4LmpzXCI7XG5leHBvcnQgKiBhcyB1dGY4IGZyb20gXCIuL3V0ZjguanNcIjtcbmV4cG9ydCAqIGFzIGJzNTggZnJvbSBcIi4vYnM1OC5qc1wiO1xuZXhwb3J0ICogYXMgYmFzZTY0IGZyb20gXCIuL2Jhc2U2NC5qc1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbImhleCIsInV0ZjgiLCJiczU4IiwiYmFzZTY0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/bytes/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/bytes/utf8.js":
/*!**********************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/utils/bytes/utf8.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/common.js\");\n\nfunction decode(array) {\n    const decoder = _common__WEBPACK_IMPORTED_MODULE_0__.isBrowser ? new TextDecoder(\"utf-8\") // Browser https://caniuse.com/textencoder.\n     : new (__webpack_require__(/*! util */ \"util\").TextDecoder)(\"utf-8\"); // Node.\n    return decoder.decode(array);\n}\nfunction encode(input) {\n    const encoder = _common__WEBPACK_IMPORTED_MODULE_0__.isBrowser ? new TextEncoder() // Browser.\n     : new (__webpack_require__(/*! util */ \"util\").TextEncoder)(\"utf-8\"); // Node.\n    return encoder.encode(input);\n} //# sourceMappingURL=utf8.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3V0aWxzL2J5dGVzL3V0ZjguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXNDO0FBQy9CLFNBQVNDLE9BQU9DLEtBQUs7SUFDeEIsTUFBTUMsVUFBVUgsOENBQVNBLEdBQ25CLElBQUlJLFlBQVksU0FBUywyQ0FBMkM7T0FDcEUsSUFBS0MscURBQTJCLENBQUUsVUFBVSxRQUFRO0lBQzFELE9BQU9GLFFBQVFGLE1BQU0sQ0FBQ0M7QUFDMUI7QUFDTyxTQUFTSSxPQUFPQyxLQUFLO0lBQ3hCLE1BQU1DLFVBQVVSLDhDQUFTQSxHQUNuQixJQUFJUyxjQUFjLFdBQVc7T0FDN0IsSUFBS0oscURBQTJCLENBQUUsVUFBVSxRQUFRO0lBQzFELE9BQU9HLFFBQVFGLE1BQU0sQ0FBQ0M7QUFDMUIsRUFDQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3V0aWxzL2J5dGVzL3V0ZjguanM/M2VkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc0Jyb3dzZXIgfSBmcm9tIFwiLi4vY29tbW9uXCI7XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlKGFycmF5KSB7XG4gICAgY29uc3QgZGVjb2RlciA9IGlzQnJvd3NlclxuICAgICAgICA/IG5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIpIC8vIEJyb3dzZXIgaHR0cHM6Ly9jYW5pdXNlLmNvbS90ZXh0ZW5jb2Rlci5cbiAgICAgICAgOiBuZXcgKHJlcXVpcmUoXCJ1dGlsXCIpLlRleHREZWNvZGVyKShcInV0Zi04XCIpOyAvLyBOb2RlLlxuICAgIHJldHVybiBkZWNvZGVyLmRlY29kZShhcnJheSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG4gICAgY29uc3QgZW5jb2RlciA9IGlzQnJvd3NlclxuICAgICAgICA/IG5ldyBUZXh0RW5jb2RlcigpIC8vIEJyb3dzZXIuXG4gICAgICAgIDogbmV3IChyZXF1aXJlKFwidXRpbFwiKS5UZXh0RW5jb2RlcikoXCJ1dGYtOFwiKTsgLy8gTm9kZS5cbiAgICByZXR1cm4gZW5jb2Rlci5lbmNvZGUoaW5wdXQpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRmOC5qcy5tYXAiXSwibmFtZXMiOlsiaXNCcm93c2VyIiwiZGVjb2RlIiwiYXJyYXkiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJyZXF1aXJlIiwiZW5jb2RlIiwiaW5wdXQiLCJlbmNvZGVyIiwiVGV4dEVuY29kZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/bytes/utf8.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/common.js":
/*!******************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/utils/common.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   chunks: () => (/* binding */ chunks),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   isVersionedTransaction: () => (/* binding */ isVersionedTransaction)\n/* harmony export */ });\nvar _a;\n/**\n * Returns true if being run inside a web browser,\n * false if in a Node process or electron app.\n */ const isBrowser = process.env.ANCHOR_BROWSER ||  false && 0;\n/**\n * Splits an array into chunks\n *\n * @param array Array of objects to chunk.\n * @param size The max size of a chunk.\n * @returns A two dimensional array where each T[] length is < the provided size.\n */ function chunks(array, size) {\n    return Array.apply(0, new Array(Math.ceil(array.length / size))).map((_, index)=>array.slice(index * size, (index + 1) * size));\n}\n/**\n * Check if a transaction object is a VersionedTransaction or not\n *\n * @param tx\n * @returns bool\n */ const isVersionedTransaction = (tx)=>{\n    return \"version\" in tx;\n}; //# sourceMappingURL=common.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3V0aWxzL2NvbW1vbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxJQUFJQTtBQUNKOzs7Q0FHQyxHQUNNLE1BQU1DLFlBQVlDLFFBQVFDLEdBQUcsQ0FBQ0MsY0FBYyxJQUM5QyxNQUE2QixJQUFJLENBQXNGLENBQUc7QUFDL0g7Ozs7OztDQU1DLEdBQ00sU0FBU0csT0FBT0MsS0FBSyxFQUFFQyxJQUFJO0lBQzlCLE9BQU9DLE1BQU1DLEtBQUssQ0FBQyxHQUFHLElBQUlELE1BQU1FLEtBQUtDLElBQUksQ0FBQ0wsTUFBTU0sTUFBTSxHQUFHTCxRQUFRTSxHQUFHLENBQUMsQ0FBQ0MsR0FBR0MsUUFBVVQsTUFBTVUsS0FBSyxDQUFDRCxRQUFRUixNQUFNLENBQUNRLFFBQVEsS0FBS1I7QUFDL0g7QUFDQTs7Ozs7Q0FLQyxHQUNNLE1BQU1VLHlCQUF5QixDQUFDQztJQUNuQyxPQUFPLGFBQWFBO0FBQ3hCLEVBQUUsQ0FDRixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3V0aWxzL2NvbW1vbi5qcz82Njg3Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfYTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGJlaW5nIHJ1biBpbnNpZGUgYSB3ZWIgYnJvd3NlcixcbiAqIGZhbHNlIGlmIGluIGEgTm9kZSBwcm9jZXNzIG9yIGVsZWN0cm9uIGFwcC5cbiAqL1xuZXhwb3J0IGNvbnN0IGlzQnJvd3NlciA9IHByb2Nlc3MuZW52LkFOQ0hPUl9CUk9XU0VSIHx8XG4gICAgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgISgoX2EgPSB3aW5kb3cucHJvY2VzcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhhc093blByb3BlcnR5KFwidHlwZVwiKSkpO1xuLyoqXG4gKiBTcGxpdHMgYW4gYXJyYXkgaW50byBjaHVua3NcbiAqXG4gKiBAcGFyYW0gYXJyYXkgQXJyYXkgb2Ygb2JqZWN0cyB0byBjaHVuay5cbiAqIEBwYXJhbSBzaXplIFRoZSBtYXggc2l6ZSBvZiBhIGNodW5rLlxuICogQHJldHVybnMgQSB0d28gZGltZW5zaW9uYWwgYXJyYXkgd2hlcmUgZWFjaCBUW10gbGVuZ3RoIGlzIDwgdGhlIHByb3ZpZGVkIHNpemUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaHVua3MoYXJyYXksIHNpemUpIHtcbiAgICByZXR1cm4gQXJyYXkuYXBwbHkoMCwgbmV3IEFycmF5KE1hdGguY2VpbChhcnJheS5sZW5ndGggLyBzaXplKSkpLm1hcCgoXywgaW5kZXgpID0+IGFycmF5LnNsaWNlKGluZGV4ICogc2l6ZSwgKGluZGV4ICsgMSkgKiBzaXplKSk7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdHJhbnNhY3Rpb24gb2JqZWN0IGlzIGEgVmVyc2lvbmVkVHJhbnNhY3Rpb24gb3Igbm90XG4gKlxuICogQHBhcmFtIHR4XG4gKiBAcmV0dXJucyBib29sXG4gKi9cbmV4cG9ydCBjb25zdCBpc1ZlcnNpb25lZFRyYW5zYWN0aW9uID0gKHR4KSA9PiB7XG4gICAgcmV0dXJuIFwidmVyc2lvblwiIGluIHR4O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbW1vbi5qcy5tYXAiXSwibmFtZXMiOlsiX2EiLCJpc0Jyb3dzZXIiLCJwcm9jZXNzIiwiZW52IiwiQU5DSE9SX0JST1dTRVIiLCJ3aW5kb3ciLCJoYXNPd25Qcm9wZXJ0eSIsImNodW5rcyIsImFycmF5Iiwic2l6ZSIsIkFycmF5IiwiYXBwbHkiLCJNYXRoIiwiY2VpbCIsImxlbmd0aCIsIm1hcCIsIl8iLCJpbmRleCIsInNsaWNlIiwiaXNWZXJzaW9uZWRUcmFuc2FjdGlvbiIsInR4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/common.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/features.js":
/*!********************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/utils/features.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isSet: () => (/* binding */ isSet),\n/* harmony export */   set: () => (/* binding */ set)\n/* harmony export */ });\nconst _AVAILABLE_FEATURES = new Set([\n    \"debug-logs\"\n]);\nconst _FEATURES = new Map();\nfunction set(key) {\n    if (!_AVAILABLE_FEATURES.has(key)) {\n        throw new Error(\"Invalid feature\");\n    }\n    _FEATURES.set(key, true);\n}\nfunction isSet(key) {\n    return _FEATURES.get(key) !== undefined;\n} //# sourceMappingURL=features.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3V0aWxzL2ZlYXR1cmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsTUFBTUEsc0JBQXNCLElBQUlDLElBQUk7SUFBQztDQUFhO0FBQ2xELE1BQU1DLFlBQVksSUFBSUM7QUFDZixTQUFTQyxJQUFJQyxHQUFHO0lBQ25CLElBQUksQ0FBQ0wsb0JBQW9CTSxHQUFHLENBQUNELE1BQU07UUFDL0IsTUFBTSxJQUFJRSxNQUFNO0lBQ3BCO0lBQ0FMLFVBQVVFLEdBQUcsQ0FBQ0MsS0FBSztBQUN2QjtBQUNPLFNBQVNHLE1BQU1ILEdBQUc7SUFDckIsT0FBT0gsVUFBVU8sR0FBRyxDQUFDSixTQUFTSztBQUNsQyxFQUNBLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGNvcmFsLXh5ei9hbmNob3IvZGlzdC9lc20vdXRpbHMvZmVhdHVyZXMuanM/ZDAxYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBfQVZBSUxBQkxFX0ZFQVRVUkVTID0gbmV3IFNldChbXCJkZWJ1Zy1sb2dzXCJdKTtcbmNvbnN0IF9GRUFUVVJFUyA9IG5ldyBNYXAoKTtcbmV4cG9ydCBmdW5jdGlvbiBzZXQoa2V5KSB7XG4gICAgaWYgKCFfQVZBSUxBQkxFX0ZFQVRVUkVTLmhhcyhrZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZmVhdHVyZVwiKTtcbiAgICB9XG4gICAgX0ZFQVRVUkVTLnNldChrZXksIHRydWUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzU2V0KGtleSkge1xuICAgIHJldHVybiBfRkVBVFVSRVMuZ2V0KGtleSkgIT09IHVuZGVmaW5lZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZlYXR1cmVzLmpzLm1hcCJdLCJuYW1lcyI6WyJfQVZBSUxBQkxFX0ZFQVRVUkVTIiwiU2V0IiwiX0ZFQVRVUkVTIiwiTWFwIiwic2V0Iiwia2V5IiwiaGFzIiwiRXJyb3IiLCJpc1NldCIsImdldCIsInVuZGVmaW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/features.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/index.js":
/*!*****************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/utils/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bytes: () => (/* reexport module object */ _bytes_index_js__WEBPACK_IMPORTED_MODULE_3__),\n/* harmony export */   features: () => (/* reexport module object */ _features_js__WEBPACK_IMPORTED_MODULE_5__),\n/* harmony export */   publicKey: () => (/* reexport module object */ _pubkey_js__WEBPACK_IMPORTED_MODULE_2__),\n/* harmony export */   registry: () => (/* reexport module object */ _registry_js__WEBPACK_IMPORTED_MODULE_6__),\n/* harmony export */   rpc: () => (/* reexport module object */ _rpc_js__WEBPACK_IMPORTED_MODULE_1__),\n/* harmony export */   sha256: () => (/* reexport module object */ _sha256_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   token: () => (/* reexport module object */ _token_js__WEBPACK_IMPORTED_MODULE_4__)\n/* harmony export */ });\n/* harmony import */ var _sha256_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sha256.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/sha256.js\");\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rpc.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/rpc.js\");\n/* harmony import */ var _pubkey_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pubkey.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/pubkey.js\");\n/* harmony import */ var _bytes_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bytes/index.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/bytes/index.js\");\n/* harmony import */ var _token_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./token.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/token.js\");\n/* harmony import */ var _features_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./features.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/features.js\");\n/* harmony import */ var _registry_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./registry.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/registry.js\");\n\n\n\n\n\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3V0aWxzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXNDO0FBQ047QUFDUztBQUNDO0FBQ047QUFDTTtBQUNBLENBQzFDLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGNvcmFsLXh5ei9hbmNob3IvZGlzdC9lc20vdXRpbHMvaW5kZXguanM/NzliNyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBhcyBzaGEyNTYgZnJvbSBcIi4vc2hhMjU2LmpzXCI7XG5leHBvcnQgKiBhcyBycGMgZnJvbSBcIi4vcnBjLmpzXCI7XG5leHBvcnQgKiBhcyBwdWJsaWNLZXkgZnJvbSBcIi4vcHVia2V5LmpzXCI7XG5leHBvcnQgKiBhcyBieXRlcyBmcm9tIFwiLi9ieXRlcy9pbmRleC5qc1wiO1xuZXhwb3J0ICogYXMgdG9rZW4gZnJvbSBcIi4vdG9rZW4uanNcIjtcbmV4cG9ydCAqIGFzIGZlYXR1cmVzIGZyb20gXCIuL2ZlYXR1cmVzLmpzXCI7XG5leHBvcnQgKiBhcyByZWdpc3RyeSBmcm9tIFwiLi9yZWdpc3RyeS5qc1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbInNoYTI1NiIsInJwYyIsInB1YmxpY0tleSIsImJ5dGVzIiwidG9rZW4iLCJmZWF0dXJlcyIsInJlZ2lzdHJ5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/pubkey.js":
/*!******************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/utils/pubkey.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createWithSeedSync: () => (/* binding */ createWithSeedSync)\n/* harmony export */ });\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(buffer__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/node_modules/@solana/web3.js/lib/index.esm.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/../node_modules/@noble/hashes/esm/sha256.js\");\n\n\n\n// Sync version of web3.PublicKey.createWithSeed.\nfunction createWithSeedSync(fromPublicKey, seed, programId) {\n    const buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([\n        fromPublicKey.toBuffer(),\n        buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(seed),\n        programId.toBuffer()\n    ]);\n    return new _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.PublicKey((0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)(buffer));\n} //# sourceMappingURL=pubkey.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3V0aWxzL3B1YmtleS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFnQztBQUNZO0FBQ0U7QUFDOUMsaURBQWlEO0FBQzFDLFNBQVNHLG1CQUFtQkMsYUFBYSxFQUFFQyxJQUFJLEVBQUVDLFNBQVM7SUFDN0QsTUFBTUMsU0FBU1AsMENBQU1BLENBQUNRLE1BQU0sQ0FBQztRQUN6QkosY0FBY0ssUUFBUTtRQUN0QlQsMENBQU1BLENBQUNVLElBQUksQ0FBQ0w7UUFDWkMsVUFBVUcsUUFBUTtLQUNyQjtJQUNELE9BQU8sSUFBSVIsc0RBQVNBLENBQUNDLDREQUFNQSxDQUFDSztBQUNoQyxFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGNvcmFsLXh5ei9hbmNob3IvZGlzdC9lc20vdXRpbHMvcHVia2V5LmpzPzQ3YTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSBcImJ1ZmZlclwiO1xuaW1wb3J0IHsgUHVibGljS2V5IH0gZnJvbSBcIkBzb2xhbmEvd2ViMy5qc1wiO1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCI7XG4vLyBTeW5jIHZlcnNpb24gb2Ygd2ViMy5QdWJsaWNLZXkuY3JlYXRlV2l0aFNlZWQuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlV2l0aFNlZWRTeW5jKGZyb21QdWJsaWNLZXksIHNlZWQsIHByb2dyYW1JZCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW1xuICAgICAgICBmcm9tUHVibGljS2V5LnRvQnVmZmVyKCksXG4gICAgICAgIEJ1ZmZlci5mcm9tKHNlZWQpLFxuICAgICAgICBwcm9ncmFtSWQudG9CdWZmZXIoKSxcbiAgICBdKTtcbiAgICByZXR1cm4gbmV3IFB1YmxpY0tleShzaGEyNTYoYnVmZmVyKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wdWJrZXkuanMubWFwIl0sIm5hbWVzIjpbIkJ1ZmZlciIsIlB1YmxpY0tleSIsInNoYTI1NiIsImNyZWF0ZVdpdGhTZWVkU3luYyIsImZyb21QdWJsaWNLZXkiLCJzZWVkIiwicHJvZ3JhbUlkIiwiYnVmZmVyIiwiY29uY2F0IiwidG9CdWZmZXIiLCJmcm9tIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/pubkey.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/registry.js":
/*!********************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/utils/registry.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeUpgradeableLoaderState: () => (/* binding */ decodeUpgradeableLoaderState),\n/* harmony export */   fetchData: () => (/* binding */ fetchData),\n/* harmony export */   verifiedBuild: () => (/* binding */ verifiedBuild)\n/* harmony export */ });\n/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cross-fetch */ \"(ssr)/../node_modules/cross-fetch/dist/node-ponyfill.js\");\n/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(cross_fetch__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @coral-xyz/borsh */ \"(ssr)/../node_modules/@coral-xyz/anchor/node_modules/@coral-xyz/borsh/dist/index.js\");\n/* harmony import */ var _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_1__);\n\n\n/**\n * Returns a verified build from the anchor registry. null if no such\n * verified build exists, e.g., if the program has been upgraded since the\n * last verified build.\n */ async function verifiedBuild(connection, programId, limit = 5) {\n    const url = `https://api.apr.dev/api/v0/program/${programId.toString()}/latest?limit=${limit}`;\n    const [programData, latestBuildsResp] = await Promise.all([\n        fetchData(connection, programId),\n        cross_fetch__WEBPACK_IMPORTED_MODULE_0___default()(url)\n    ]);\n    // Filter out all non successful builds.\n    const latestBuilds = (await latestBuildsResp.json()).filter((b)=>!b.aborted && b.state === \"Built\" && b.verified === \"Verified\");\n    if (latestBuilds.length === 0) {\n        return null;\n    }\n    // Get the latest build.\n    const build = latestBuilds[0];\n    // Has the program been upgraded since the last build?\n    if (programData.slot.toNumber() !== build.verified_slot) {\n        return null;\n    }\n    // Success.\n    return build;\n}\n/**\n * Returns the program data account for this program, containing the\n * metadata for this program, e.g., the upgrade authority.\n */ async function fetchData(connection, programId) {\n    const accountInfo = await connection.getAccountInfo(programId);\n    if (accountInfo === null) {\n        throw new Error(\"program account not found\");\n    }\n    const { program } = decodeUpgradeableLoaderState(accountInfo.data);\n    const programdataAccountInfo = await connection.getAccountInfo(program.programdataAddress);\n    if (programdataAccountInfo === null) {\n        throw new Error(\"program data account not found\");\n    }\n    const { programData } = decodeUpgradeableLoaderState(programdataAccountInfo.data);\n    return programData;\n}\nconst UPGRADEABLE_LOADER_STATE_LAYOUT = _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_1__.rustEnum([\n    _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_1__.struct([], \"uninitialized\"),\n    _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_1__.struct([\n        _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_1__.option(_coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_1__.publicKey(), \"authorityAddress\")\n    ], \"buffer\"),\n    _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_1__.struct([\n        _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_1__.publicKey(\"programdataAddress\")\n    ], \"program\"),\n    _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_1__.struct([\n        _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_1__.u64(\"slot\"),\n        _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_1__.option(_coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_1__.publicKey(), \"upgradeAuthorityAddress\")\n    ], \"programData\")\n], undefined, _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_1__.u32());\nfunction decodeUpgradeableLoaderState(data) {\n    return UPGRADEABLE_LOADER_STATE_LAYOUT.decode(data);\n} //# sourceMappingURL=registry.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3V0aWxzL3JlZ2lzdHJ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBZ0M7QUFDVTtBQUMxQzs7OztDQUlDLEdBQ00sZUFBZUUsY0FBY0MsVUFBVSxFQUFFQyxTQUFTLEVBQUVDLFFBQVEsQ0FBQztJQUNoRSxNQUFNQyxNQUFNLENBQUMsbUNBQW1DLEVBQUVGLFVBQVVHLFFBQVEsR0FBRyxjQUFjLEVBQUVGLE1BQU0sQ0FBQztJQUM5RixNQUFNLENBQUNHLGFBQWFDLGlCQUFpQixHQUFHLE1BQU1DLFFBQVFDLEdBQUcsQ0FBQztRQUN0REMsVUFBVVQsWUFBWUM7UUFDdEJKLGtEQUFLQSxDQUFDTTtLQUNUO0lBQ0Qsd0NBQXdDO0lBQ3hDLE1BQU1PLGVBQWUsQ0FBQyxNQUFNSixpQkFBaUJLLElBQUksRUFBQyxFQUFHQyxNQUFNLENBQUMsQ0FBQ0MsSUFBTSxDQUFDQSxFQUFFQyxPQUFPLElBQUlELEVBQUVFLEtBQUssS0FBSyxXQUFXRixFQUFFRyxRQUFRLEtBQUs7SUFDdkgsSUFBSU4sYUFBYU8sTUFBTSxLQUFLLEdBQUc7UUFDM0IsT0FBTztJQUNYO0lBQ0Esd0JBQXdCO0lBQ3hCLE1BQU1DLFFBQVFSLFlBQVksQ0FBQyxFQUFFO0lBQzdCLHNEQUFzRDtJQUN0RCxJQUFJTCxZQUFZYyxJQUFJLENBQUNDLFFBQVEsT0FBT0YsTUFBTUcsYUFBYSxFQUFFO1FBQ3JELE9BQU87SUFDWDtJQUNBLFdBQVc7SUFDWCxPQUFPSDtBQUNYO0FBQ0E7OztDQUdDLEdBQ00sZUFBZVQsVUFBVVQsVUFBVSxFQUFFQyxTQUFTO0lBQ2pELE1BQU1xQixjQUFjLE1BQU10QixXQUFXdUIsY0FBYyxDQUFDdEI7SUFDcEQsSUFBSXFCLGdCQUFnQixNQUFNO1FBQ3RCLE1BQU0sSUFBSUUsTUFBTTtJQUNwQjtJQUNBLE1BQU0sRUFBRUMsT0FBTyxFQUFFLEdBQUdDLDZCQUE2QkosWUFBWUssSUFBSTtJQUNqRSxNQUFNQyx5QkFBeUIsTUFBTTVCLFdBQVd1QixjQUFjLENBQUNFLFFBQVFJLGtCQUFrQjtJQUN6RixJQUFJRCwyQkFBMkIsTUFBTTtRQUNqQyxNQUFNLElBQUlKLE1BQU07SUFDcEI7SUFDQSxNQUFNLEVBQUVuQixXQUFXLEVBQUUsR0FBR3FCLDZCQUE2QkUsdUJBQXVCRCxJQUFJO0lBQ2hGLE9BQU90QjtBQUNYO0FBQ0EsTUFBTXlCLGtDQUFrQ2hDLHNEQUFjLENBQUM7SUFDbkRBLG9EQUFZLENBQUMsRUFBRSxFQUFFO0lBQ2pCQSxvREFBWSxDQUFDO1FBQUNBLG9EQUFZLENBQUNBLHVEQUFlLElBQUk7S0FBb0IsRUFBRTtJQUNwRUEsb0RBQVksQ0FBQztRQUFDQSx1REFBZSxDQUFDO0tBQXNCLEVBQUU7SUFDdERBLG9EQUFZLENBQUM7UUFDVEEsaURBQVMsQ0FBQztRQUNWQSxvREFBWSxDQUFDQSx1REFBZSxJQUFJO0tBQ25DLEVBQUU7Q0FDTixFQUFFc0MsV0FBV3RDLGlEQUFTO0FBQ2hCLFNBQVM0Qiw2QkFBNkJDLElBQUk7SUFDN0MsT0FBT0csZ0NBQWdDUSxNQUFNLENBQUNYO0FBQ2xELEVBQ0Esb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AY29yYWwteHl6L2FuY2hvci9kaXN0L2VzbS91dGlscy9yZWdpc3RyeS5qcz8yNWU1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmZXRjaCBmcm9tIFwiY3Jvc3MtZmV0Y2hcIjtcbmltcG9ydCAqIGFzIGJvcnNoIGZyb20gXCJAY29yYWwteHl6L2JvcnNoXCI7XG4vKipcbiAqIFJldHVybnMgYSB2ZXJpZmllZCBidWlsZCBmcm9tIHRoZSBhbmNob3IgcmVnaXN0cnkuIG51bGwgaWYgbm8gc3VjaFxuICogdmVyaWZpZWQgYnVpbGQgZXhpc3RzLCBlLmcuLCBpZiB0aGUgcHJvZ3JhbSBoYXMgYmVlbiB1cGdyYWRlZCBzaW5jZSB0aGVcbiAqIGxhc3QgdmVyaWZpZWQgYnVpbGQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2ZXJpZmllZEJ1aWxkKGNvbm5lY3Rpb24sIHByb2dyYW1JZCwgbGltaXQgPSA1KSB7XG4gICAgY29uc3QgdXJsID0gYGh0dHBzOi8vYXBpLmFwci5kZXYvYXBpL3YwL3Byb2dyYW0vJHtwcm9ncmFtSWQudG9TdHJpbmcoKX0vbGF0ZXN0P2xpbWl0PSR7bGltaXR9YDtcbiAgICBjb25zdCBbcHJvZ3JhbURhdGEsIGxhdGVzdEJ1aWxkc1Jlc3BdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBmZXRjaERhdGEoY29ubmVjdGlvbiwgcHJvZ3JhbUlkKSxcbiAgICAgICAgZmV0Y2godXJsKSxcbiAgICBdKTtcbiAgICAvLyBGaWx0ZXIgb3V0IGFsbCBub24gc3VjY2Vzc2Z1bCBidWlsZHMuXG4gICAgY29uc3QgbGF0ZXN0QnVpbGRzID0gKGF3YWl0IGxhdGVzdEJ1aWxkc1Jlc3AuanNvbigpKS5maWx0ZXIoKGIpID0+ICFiLmFib3J0ZWQgJiYgYi5zdGF0ZSA9PT0gXCJCdWlsdFwiICYmIGIudmVyaWZpZWQgPT09IFwiVmVyaWZpZWRcIik7XG4gICAgaWYgKGxhdGVzdEJ1aWxkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgbGF0ZXN0IGJ1aWxkLlxuICAgIGNvbnN0IGJ1aWxkID0gbGF0ZXN0QnVpbGRzWzBdO1xuICAgIC8vIEhhcyB0aGUgcHJvZ3JhbSBiZWVuIHVwZ3JhZGVkIHNpbmNlIHRoZSBsYXN0IGJ1aWxkP1xuICAgIGlmIChwcm9ncmFtRGF0YS5zbG90LnRvTnVtYmVyKCkgIT09IGJ1aWxkLnZlcmlmaWVkX3Nsb3QpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFN1Y2Nlc3MuXG4gICAgcmV0dXJuIGJ1aWxkO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwcm9ncmFtIGRhdGEgYWNjb3VudCBmb3IgdGhpcyBwcm9ncmFtLCBjb250YWluaW5nIHRoZVxuICogbWV0YWRhdGEgZm9yIHRoaXMgcHJvZ3JhbSwgZS5nLiwgdGhlIHVwZ3JhZGUgYXV0aG9yaXR5LlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hEYXRhKGNvbm5lY3Rpb24sIHByb2dyYW1JZCkge1xuICAgIGNvbnN0IGFjY291bnRJbmZvID0gYXdhaXQgY29ubmVjdGlvbi5nZXRBY2NvdW50SW5mbyhwcm9ncmFtSWQpO1xuICAgIGlmIChhY2NvdW50SW5mbyA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcm9ncmFtIGFjY291bnQgbm90IGZvdW5kXCIpO1xuICAgIH1cbiAgICBjb25zdCB7IHByb2dyYW0gfSA9IGRlY29kZVVwZ3JhZGVhYmxlTG9hZGVyU3RhdGUoYWNjb3VudEluZm8uZGF0YSk7XG4gICAgY29uc3QgcHJvZ3JhbWRhdGFBY2NvdW50SW5mbyA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0QWNjb3VudEluZm8ocHJvZ3JhbS5wcm9ncmFtZGF0YUFkZHJlc3MpO1xuICAgIGlmIChwcm9ncmFtZGF0YUFjY291bnRJbmZvID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInByb2dyYW0gZGF0YSBhY2NvdW50IG5vdCBmb3VuZFwiKTtcbiAgICB9XG4gICAgY29uc3QgeyBwcm9ncmFtRGF0YSB9ID0gZGVjb2RlVXBncmFkZWFibGVMb2FkZXJTdGF0ZShwcm9ncmFtZGF0YUFjY291bnRJbmZvLmRhdGEpO1xuICAgIHJldHVybiBwcm9ncmFtRGF0YTtcbn1cbmNvbnN0IFVQR1JBREVBQkxFX0xPQURFUl9TVEFURV9MQVlPVVQgPSBib3JzaC5ydXN0RW51bShbXG4gICAgYm9yc2guc3RydWN0KFtdLCBcInVuaW5pdGlhbGl6ZWRcIiksXG4gICAgYm9yc2guc3RydWN0KFtib3JzaC5vcHRpb24oYm9yc2gucHVibGljS2V5KCksIFwiYXV0aG9yaXR5QWRkcmVzc1wiKV0sIFwiYnVmZmVyXCIpLFxuICAgIGJvcnNoLnN0cnVjdChbYm9yc2gucHVibGljS2V5KFwicHJvZ3JhbWRhdGFBZGRyZXNzXCIpXSwgXCJwcm9ncmFtXCIpLFxuICAgIGJvcnNoLnN0cnVjdChbXG4gICAgICAgIGJvcnNoLnU2NChcInNsb3RcIiksXG4gICAgICAgIGJvcnNoLm9wdGlvbihib3JzaC5wdWJsaWNLZXkoKSwgXCJ1cGdyYWRlQXV0aG9yaXR5QWRkcmVzc1wiKSxcbiAgICBdLCBcInByb2dyYW1EYXRhXCIpLFxuXSwgdW5kZWZpbmVkLCBib3JzaC51MzIoKSk7XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlVXBncmFkZWFibGVMb2FkZXJTdGF0ZShkYXRhKSB7XG4gICAgcmV0dXJuIFVQR1JBREVBQkxFX0xPQURFUl9TVEFURV9MQVlPVVQuZGVjb2RlKGRhdGEpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVnaXN0cnkuanMubWFwIl0sIm5hbWVzIjpbImZldGNoIiwiYm9yc2giLCJ2ZXJpZmllZEJ1aWxkIiwiY29ubmVjdGlvbiIsInByb2dyYW1JZCIsImxpbWl0IiwidXJsIiwidG9TdHJpbmciLCJwcm9ncmFtRGF0YSIsImxhdGVzdEJ1aWxkc1Jlc3AiLCJQcm9taXNlIiwiYWxsIiwiZmV0Y2hEYXRhIiwibGF0ZXN0QnVpbGRzIiwianNvbiIsImZpbHRlciIsImIiLCJhYm9ydGVkIiwic3RhdGUiLCJ2ZXJpZmllZCIsImxlbmd0aCIsImJ1aWxkIiwic2xvdCIsInRvTnVtYmVyIiwidmVyaWZpZWRfc2xvdCIsImFjY291bnRJbmZvIiwiZ2V0QWNjb3VudEluZm8iLCJFcnJvciIsInByb2dyYW0iLCJkZWNvZGVVcGdyYWRlYWJsZUxvYWRlclN0YXRlIiwiZGF0YSIsInByb2dyYW1kYXRhQWNjb3VudEluZm8iLCJwcm9ncmFtZGF0YUFkZHJlc3MiLCJVUEdSQURFQUJMRV9MT0FERVJfU1RBVEVfTEFZT1VUIiwicnVzdEVudW0iLCJzdHJ1Y3QiLCJvcHRpb24iLCJwdWJsaWNLZXkiLCJ1NjQiLCJ1bmRlZmluZWQiLCJ1MzIiLCJkZWNvZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/registry.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/rpc.js":
/*!***************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/utils/rpc.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getMultipleAccounts: () => (/* binding */ getMultipleAccounts),\n/* harmony export */   getMultipleAccountsAndContext: () => (/* binding */ getMultipleAccountsAndContext),\n/* harmony export */   invoke: () => (/* binding */ invoke),\n/* harmony export */   simulateTransaction: () => (/* binding */ simulateTransaction)\n/* harmony export */ });\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/node_modules/@solana/web3.js/lib/index.esm.js\");\n/* harmony import */ var _utils_common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/common.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/common.js\");\n/* harmony import */ var _program_common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../program/common.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/common.js\");\n/* harmony import */ var _provider_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../provider.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/provider.js\");\n/* harmony import */ var superstruct__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! superstruct */ \"(ssr)/../node_modules/superstruct/lib/index.es.js\");\n\n\n\n\n\n/**\n * Sends a transaction to a program with the given accounts and instruction\n * data.\n */ async function invoke(programId, accounts, data, provider) {\n    programId = (0,_program_common_js__WEBPACK_IMPORTED_MODULE_2__.translateAddress)(programId);\n    if (!provider) {\n        provider = (0,_provider_js__WEBPACK_IMPORTED_MODULE_3__.getProvider)();\n    }\n    const tx = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction();\n    tx.add(new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.TransactionInstruction({\n        programId,\n        keys: accounts !== null && accounts !== void 0 ? accounts : [],\n        data\n    }));\n    if (provider.sendAndConfirm === undefined) {\n        throw new Error(\"This function requires 'Provider.sendAndConfirm' to be implemented.\");\n    }\n    return await provider.sendAndConfirm(tx, []);\n}\nconst GET_MULTIPLE_ACCOUNTS_LIMIT = 99;\nasync function getMultipleAccounts(connection, publicKeys, commitment) {\n    const results = await getMultipleAccountsAndContext(connection, publicKeys, commitment);\n    return results.map((result)=>{\n        return result ? {\n            publicKey: result.publicKey,\n            account: result.account\n        } : null;\n    });\n}\nasync function getMultipleAccountsAndContext(connection, publicKeys, commitment) {\n    if (publicKeys.length <= GET_MULTIPLE_ACCOUNTS_LIMIT) {\n        return await getMultipleAccountsAndContextCore(connection, publicKeys, commitment);\n    } else {\n        const batches = (0,_utils_common_js__WEBPACK_IMPORTED_MODULE_1__.chunks)(publicKeys, GET_MULTIPLE_ACCOUNTS_LIMIT);\n        const results = await Promise.all(batches.map((batch)=>getMultipleAccountsAndContextCore(connection, batch, commitment)));\n        return results.flat();\n    }\n}\nasync function getMultipleAccountsAndContextCore(connection, publicKeys, commitmentOverride) {\n    const commitment = commitmentOverride !== null && commitmentOverride !== void 0 ? commitmentOverride : connection.commitment;\n    const { value: accountInfos, context } = await connection.getMultipleAccountsInfoAndContext(publicKeys, commitment);\n    const accounts = accountInfos.map((account, idx)=>{\n        if (account === null) {\n            return null;\n        }\n        return {\n            publicKey: publicKeys[idx],\n            account,\n            context\n        };\n    });\n    return accounts;\n}\n// copy from @solana/web3.js that has a commitment param\nasync function simulateTransaction(connection, transaction, signers, commitment, includeAccounts) {\n    var _a;\n    if (signers && signers.length > 0) {\n        transaction.sign(...signers);\n    }\n    // @ts-expect-error\n    const message = transaction._compile();\n    const signData = message.serialize();\n    // @ts-expect-error\n    const wireTransaction = transaction._serialize(signData);\n    const encodedTransaction = wireTransaction.toString(\"base64\");\n    const config = {\n        encoding: \"base64\",\n        commitment: commitment !== null && commitment !== void 0 ? commitment : connection.commitment\n    };\n    if (includeAccounts) {\n        const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map((key)=>key.toBase58());\n        config[\"accounts\"] = {\n            encoding: \"base64\",\n            addresses\n        };\n    }\n    if (signers && signers.length > 0) {\n        config.sigVerify = true;\n    }\n    const args = [\n        encodedTransaction,\n        config\n    ];\n    // @ts-expect-error\n    const unsafeRes = await connection._rpcRequest(\"simulateTransaction\", args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_4__.create)(unsafeRes, SimulatedTransactionResponseStruct);\n    if (\"error\" in res) {\n        let logs;\n        if (\"data\" in res.error) {\n            logs = (_a = res.error.data) === null || _a === void 0 ? void 0 : _a.logs;\n            if (logs && Array.isArray(logs)) {\n                const traceIndent = \"\\n    \";\n                const logTrace = traceIndent + logs.join(traceIndent);\n                console.error(res.error.message, logTrace);\n            }\n        }\n        throw new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.SendTransactionError(\"failed to simulate transaction: \" + res.error.message, logs);\n    }\n    return res.result;\n}\n// copy from @solana/web3.js\nfunction jsonRpcResult(schema) {\n    return (0,superstruct__WEBPACK_IMPORTED_MODULE_4__.coerce)(createRpcResult(schema), UnknownRpcResult, (value)=>{\n        if (\"error\" in value) {\n            return value;\n        } else {\n            return {\n                ...value,\n                result: (0,superstruct__WEBPACK_IMPORTED_MODULE_4__.create)(value.result, schema)\n            };\n        }\n    });\n}\n// copy from @solana/web3.js\nconst UnknownRpcResult = createRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_4__.unknown)());\n// copy from @solana/web3.js\nfunction createRpcResult(result) {\n    return (0,superstruct__WEBPACK_IMPORTED_MODULE_4__.union)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_4__.type)({\n            jsonrpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_4__.literal)(\"2.0\"),\n            id: (0,superstruct__WEBPACK_IMPORTED_MODULE_4__.string)(),\n            result\n        }),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_4__.type)({\n            jsonrpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_4__.literal)(\"2.0\"),\n            id: (0,superstruct__WEBPACK_IMPORTED_MODULE_4__.string)(),\n            error: (0,superstruct__WEBPACK_IMPORTED_MODULE_4__.type)({\n                code: (0,superstruct__WEBPACK_IMPORTED_MODULE_4__.unknown)(),\n                message: (0,superstruct__WEBPACK_IMPORTED_MODULE_4__.string)(),\n                data: (0,superstruct__WEBPACK_IMPORTED_MODULE_4__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_4__.any)())\n            })\n        })\n    ]);\n}\n// copy from @solana/web3.js\nfunction jsonRpcResultAndContext(value) {\n    return jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_4__.type)({\n        context: (0,superstruct__WEBPACK_IMPORTED_MODULE_4__.type)({\n            slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_4__.number)()\n        }),\n        value\n    }));\n}\n// copy from @solana/web3.js\nconst SimulatedTransactionResponseStruct = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_4__.type)({\n    err: (0,superstruct__WEBPACK_IMPORTED_MODULE_4__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_4__.union)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_4__.type)({}),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_4__.string)()\n    ])),\n    logs: (0,superstruct__WEBPACK_IMPORTED_MODULE_4__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_4__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_4__.string)())),\n    accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_4__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_4__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_4__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_4__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_4__.type)({\n        executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_4__.boolean)(),\n        owner: (0,superstruct__WEBPACK_IMPORTED_MODULE_4__.string)(),\n        lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_4__.number)(),\n        data: (0,superstruct__WEBPACK_IMPORTED_MODULE_4__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_4__.string)()),\n        rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_4__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_4__.number)())\n    }))))),\n    unitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_4__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_4__.number)())\n})); //# sourceMappingURL=rpc.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3V0aWxzL3JwYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBNkY7QUFDakQ7QUFDWTtBQUNYO0FBQ2lHO0FBQzlJOzs7Q0FHQyxHQUNNLGVBQWVvQixPQUFPQyxTQUFTLEVBQUVDLFFBQVEsRUFBRUMsSUFBSSxFQUFFQyxRQUFRO0lBQzVESCxZQUFZakIsb0VBQWdCQSxDQUFDaUI7SUFDN0IsSUFBSSxDQUFDRyxVQUFVO1FBQ1hBLFdBQVduQix5REFBV0E7SUFDMUI7SUFDQSxNQUFNb0IsS0FBSyxJQUFJekIsd0RBQVdBO0lBQzFCeUIsR0FBR0MsR0FBRyxDQUFDLElBQUl6QixtRUFBc0JBLENBQUM7UUFDOUJvQjtRQUNBTSxNQUFNTCxhQUFhLFFBQVFBLGFBQWEsS0FBSyxJQUFJQSxXQUFXLEVBQUU7UUFDOURDO0lBQ0o7SUFDQSxJQUFJQyxTQUFTSSxjQUFjLEtBQUtDLFdBQVc7UUFDdkMsTUFBTSxJQUFJQyxNQUFNO0lBQ3BCO0lBQ0EsT0FBTyxNQUFNTixTQUFTSSxjQUFjLENBQUNILElBQUksRUFBRTtBQUMvQztBQUNBLE1BQU1NLDhCQUE4QjtBQUM3QixlQUFlQyxvQkFBb0JDLFVBQVUsRUFBRUMsVUFBVSxFQUFFQyxVQUFVO0lBQ3hFLE1BQU1DLFVBQVUsTUFBTUMsOEJBQThCSixZQUFZQyxZQUFZQztJQUM1RSxPQUFPQyxRQUFRRSxHQUFHLENBQUMsQ0FBQ0M7UUFDaEIsT0FBT0EsU0FDRDtZQUFFQyxXQUFXRCxPQUFPQyxTQUFTO1lBQUVDLFNBQVNGLE9BQU9FLE9BQU87UUFBQyxJQUN2RDtJQUNWO0FBQ0o7QUFDTyxlQUFlSiw4QkFBOEJKLFVBQVUsRUFBRUMsVUFBVSxFQUFFQyxVQUFVO0lBQ2xGLElBQUlELFdBQVdRLE1BQU0sSUFBSVgsNkJBQTZCO1FBQ2xELE9BQU8sTUFBTVksa0NBQWtDVixZQUFZQyxZQUFZQztJQUMzRSxPQUNLO1FBQ0QsTUFB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QUFVUixxREFBUUEsQ0FBQ0MscURBQVFBLENBQUNMLGtEQUFLQSxDQUFDSyxxREFBUUEsQ0FBQ1IsaURBQUlBLENBQUM7UUFDNUM0RixZQUFZeEYsb0RBQU9BO1FBQ25CeUYsT0FBTzNGLG1EQUFNQTtRQUNiNEYsVUFBVTdGLG1EQUFNQTtRQUNoQmUsTUFBTWIsa0RBQUtBLENBQUNELG1EQUFNQTtRQUNsQjZGLFdBQVd4RixxREFBUUEsQ0FBQ04sbURBQU1BO0lBQzlCO0lBQ0ErRixlQUFlekYscURBQVFBLENBQUNOLG1EQUFNQTtBQUNsQyxLQUNBLCtCQUErQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGNvcmFsLXh5ei9hbmNob3IvZGlzdC9lc20vdXRpbHMvcnBjLmpzP2RiMGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVHJhbnNhY3Rpb24sIFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24sIFNlbmRUcmFuc2FjdGlvbkVycm9yLCB9IGZyb20gXCJAc29sYW5hL3dlYjMuanNcIjtcbmltcG9ydCB7IGNodW5rcyB9IGZyb20gXCIuLi91dGlscy9jb21tb24uanNcIjtcbmltcG9ydCB7IHRyYW5zbGF0ZUFkZHJlc3MgfSBmcm9tIFwiLi4vcHJvZ3JhbS9jb21tb24uanNcIjtcbmltcG9ydCB7IGdldFByb3ZpZGVyIH0gZnJvbSBcIi4uL3Byb3ZpZGVyLmpzXCI7XG5pbXBvcnQgeyB0eXBlIGFzIHBpY2ssIG51bWJlciwgc3RyaW5nLCBhcnJheSwgYm9vbGVhbiwgbGl0ZXJhbCwgdW5pb24sIG9wdGlvbmFsLCBudWxsYWJsZSwgY29lcmNlLCBjcmVhdGUsIHVua25vd24sIGFueSwgfSBmcm9tIFwic3VwZXJzdHJ1Y3RcIjtcbi8qKlxuICogU2VuZHMgYSB0cmFuc2FjdGlvbiB0byBhIHByb2dyYW0gd2l0aCB0aGUgZ2l2ZW4gYWNjb3VudHMgYW5kIGluc3RydWN0aW9uXG4gKiBkYXRhLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW52b2tlKHByb2dyYW1JZCwgYWNjb3VudHMsIGRhdGEsIHByb3ZpZGVyKSB7XG4gICAgcHJvZ3JhbUlkID0gdHJhbnNsYXRlQWRkcmVzcyhwcm9ncmFtSWQpO1xuICAgIGlmICghcHJvdmlkZXIpIHtcbiAgICAgICAgcHJvdmlkZXIgPSBnZXRQcm92aWRlcigpO1xuICAgIH1cbiAgICBjb25zdCB0eCA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgIHR4LmFkZChuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICAgIHByb2dyYW1JZCxcbiAgICAgICAga2V5czogYWNjb3VudHMgIT09IG51bGwgJiYgYWNjb3VudHMgIT09IHZvaWQgMCA/IGFjY291bnRzIDogW10sXG4gICAgICAgIGRhdGEsXG4gICAgfSkpO1xuICAgIGlmIChwcm92aWRlci5zZW5kQW5kQ29uZmlybSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgZnVuY3Rpb24gcmVxdWlyZXMgJ1Byb3ZpZGVyLnNlbmRBbmRDb25maXJtJyB0byBiZSBpbXBsZW1lbnRlZC5cIik7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5zZW5kQW5kQ29uZmlybSh0eCwgW10pO1xufVxuY29uc3QgR0VUX01VTFRJUExFX0FDQ09VTlRTX0xJTUlUID0gOTk7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0TXVsdGlwbGVBY2NvdW50cyhjb25uZWN0aW9uLCBwdWJsaWNLZXlzLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGdldE11bHRpcGxlQWNjb3VudHNBbmRDb250ZXh0KGNvbm5lY3Rpb24sIHB1YmxpY0tleXMsIGNvbW1pdG1lbnQpO1xuICAgIHJldHVybiByZXN1bHRzLm1hcCgocmVzdWx0KSA9PiB7XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgICAgID8geyBwdWJsaWNLZXk6IHJlc3VsdC5wdWJsaWNLZXksIGFjY291bnQ6IHJlc3VsdC5hY2NvdW50IH1cbiAgICAgICAgICAgIDogbnVsbDtcbiAgICB9KTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRNdWx0aXBsZUFjY291bnRzQW5kQ29udGV4dChjb25uZWN0aW9uLCBwdWJsaWNLZXlzLCBjb21taXRtZW50KSB7XG4gICAgaWYgKHB1YmxpY0tleXMubGVuZ3RoIDw9IEdFVF9NVUxUSVBMRV9BQ0NPVU5UU19MSU1JVCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgZ2V0TXVsdGlwbGVBY2NvdW50c0FuZENvbnRleHRDb3JlKGNvbm5lY3Rpb24sIHB1YmxpY0tleXMsIGNvbW1pdG1lbnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgYmF0Y2hlcyA9IGNodW5rcyhwdWJsaWNLZXlzLCBHRVRfTVVMVElQTEVfQUNDT1VOVFNfTElNSVQpO1xuICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoYmF0Y2hlcy5tYXAoKGJhdGNoKSA9PiBnZXRNdWx0aXBsZUFjY291bnRzQW5kQ29udGV4dENvcmUoY29ubmVjdGlvbiwgYmF0Y2gsIGNvbW1pdG1lbnQpKSk7XG4gICAgICAgIHJldHVybiByZXN1bHRzLmZsYXQoKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRNdWx0aXBsZUFjY291bnRzQW5kQ29udGV4dENvcmUoY29ubmVjdGlvbiwgcHVibGljS2V5cywgY29tbWl0bWVudE92ZXJyaWRlKSB7XG4gICAgY29uc3QgY29tbWl0bWVudCA9IGNvbW1pdG1lbnRPdmVycmlkZSAhPT0gbnVsbCAmJiBjb21taXRtZW50T3ZlcnJpZGUgIT09IHZvaWQgMCA/IGNvbW1pdG1lbnRPdmVycmlkZSA6IGNvbm5lY3Rpb24uY29tbWl0bWVudDtcbiAgICBjb25zdCB7IHZhbHVlOiBhY2NvdW50SW5mb3MsIGNvbnRleHQgfSA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0TXVsdGlwbGVBY2NvdW50c0luZm9BbmRDb250ZXh0KHB1YmxpY0tleXMsIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IGFjY291bnRzID0gYWNjb3VudEluZm9zLm1hcCgoYWNjb3VudCwgaWR4KSA9PiB7XG4gICAgICAgIGlmIChhY2NvdW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHVibGljS2V5OiBwdWJsaWNLZXlzW2lkeF0sXG4gICAgICAgICAgICBhY2NvdW50LFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWNjb3VudHM7XG59XG4vLyBjb3B5IGZyb20gQHNvbGFuYS93ZWIzLmpzIHRoYXQgaGFzIGEgY29tbWl0bWVudCBwYXJhbVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNpbXVsYXRlVHJhbnNhY3Rpb24oY29ubmVjdGlvbiwgdHJhbnNhY3Rpb24sIHNpZ25lcnMsIGNvbW1pdG1lbnQsIGluY2x1ZGVBY2NvdW50cykge1xuICAgIHZhciBfYTtcbiAgICBpZiAoc2lnbmVycyAmJiBzaWduZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uc2lnbiguLi5zaWduZXJzKTtcbiAgICB9XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIGNvbnN0IG1lc3NhZ2UgPSB0cmFuc2FjdGlvbi5fY29tcGlsZSgpO1xuICAgIGNvbnN0IHNpZ25EYXRhID0gbWVzc2FnZS5zZXJpYWxpemUoKTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgY29uc3Qgd2lyZVRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb24uX3NlcmlhbGl6ZShzaWduRGF0YSk7XG4gICAgY29uc3QgZW5jb2RlZFRyYW5zYWN0aW9uID0gd2lyZVRyYW5zYWN0aW9uLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgZW5jb2Rpbmc6IFwiYmFzZTY0XCIsXG4gICAgICAgIGNvbW1pdG1lbnQ6IGNvbW1pdG1lbnQgIT09IG51bGwgJiYgY29tbWl0bWVudCAhPT0gdm9pZCAwID8gY29tbWl0bWVudCA6IGNvbm5lY3Rpb24uY29tbWl0bWVudCxcbiAgICB9O1xuICAgIGlmIChpbmNsdWRlQWNjb3VudHMpIHtcbiAgICAgICAgY29uc3QgYWRkcmVzc2VzID0gKEFycmF5LmlzQXJyYXkoaW5jbHVkZUFjY291bnRzKSA/IGluY2x1ZGVBY2NvdW50cyA6IG1lc3NhZ2Uubm9uUHJvZ3JhbUlkcygpKS5tYXAoKGtleSkgPT4ga2V5LnRvQmFzZTU4KCkpO1xuICAgICAgICBjb25maWdbXCJhY2NvdW50c1wiXSA9IHtcbiAgICAgICAgICAgIGVuY29kaW5nOiBcImJhc2U2NFwiLFxuICAgICAgICAgICAgYWRkcmVzc2VzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoc2lnbmVycyAmJiBzaWduZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uZmlnLnNpZ1ZlcmlmeSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGFyZ3MgPSBbZW5jb2RlZFRyYW5zYWN0aW9uLCBjb25maWddO1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCBjb25uZWN0aW9uLl9ycGNSZXF1ZXN0KFwic2ltdWxhdGVUcmFuc2FjdGlvblwiLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBTaW11bGF0ZWRUcmFuc2FjdGlvblJlc3BvbnNlU3RydWN0KTtcbiAgICBpZiAoXCJlcnJvclwiIGluIHJlcykge1xuICAgICAgICBsZXQgbG9ncztcbiAgICAgICAgaWYgKFwiZGF0YVwiIGluIHJlcy5lcnJvcikge1xuICAgICAgICAgICAgbG9ncyA9IChfYSA9IHJlcy5lcnJvci5kYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9ncztcbiAgICAgICAgICAgIGlmIChsb2dzICYmIEFycmF5LmlzQXJyYXkobG9ncykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFjZUluZGVudCA9IFwiXFxuICAgIFwiO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvZ1RyYWNlID0gdHJhY2VJbmRlbnQgKyBsb2dzLmpvaW4odHJhY2VJbmRlbnQpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IocmVzLmVycm9yLm1lc3NhZ2UsIGxvZ1RyYWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgU2VuZFRyYW5zYWN0aW9uRXJyb3IoXCJmYWlsZWQgdG8gc2ltdWxhdGUgdHJhbnNhY3Rpb246IFwiICsgcmVzLmVycm9yLm1lc3NhZ2UsIGxvZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbn1cbi8vIGNvcHkgZnJvbSBAc29sYW5hL3dlYjMuanNcbmZ1bmN0aW9uIGpzb25ScGNSZXN1bHQoc2NoZW1hKSB7XG4gICAgcmV0dXJuIGNvZXJjZShjcmVhdGVScGNSZXN1bHQoc2NoZW1hKSwgVW5rbm93blJwY1Jlc3VsdCwgKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmIChcImVycm9yXCIgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4udmFsdWUsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiBjcmVhdGUodmFsdWUucmVzdWx0LCBzY2hlbWEpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLy8gY29weSBmcm9tIEBzb2xhbmEvd2ViMy5qc1xuY29uc3QgVW5rbm93blJwY1Jlc3VsdCA9IGNyZWF0ZVJwY1Jlc3VsdCh1bmtub3duKCkpO1xuLy8gY29weSBmcm9tIEBzb2xhbmEvd2ViMy5qc1xuZnVuY3Rpb24gY3JlYXRlUnBjUmVzdWx0KHJlc3VsdCkge1xuICAgIHJldHVybiB1bmlvbihbXG4gICAgICAgIHBpY2soe1xuICAgICAgICAgICAganNvbnJwYzogbGl0ZXJhbChcIjIuMFwiKSxcbiAgICAgICAgICAgIGlkOiBzdHJpbmcoKSxcbiAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgfSksXG4gICAgICAgIHBpY2soe1xuICAgICAgICAgICAganNvbnJwYzogbGl0ZXJhbChcIjIuMFwiKSxcbiAgICAgICAgICAgIGlkOiBzdHJpbmcoKSxcbiAgICAgICAgICAgIGVycm9yOiBwaWNrKHtcbiAgICAgICAgICAgICAgICBjb2RlOiB1bmtub3duKCksXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgZGF0YTogb3B0aW9uYWwoYW55KCkpLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0pLFxuICAgIF0pO1xufVxuLy8gY29weSBmcm9tIEBzb2xhbmEvd2ViMy5qc1xuZnVuY3Rpb24ganNvblJwY1Jlc3VsdEFuZENvbnRleHQodmFsdWUpIHtcbiAgICByZXR1cm4ganNvblJwY1Jlc3VsdChwaWNrKHtcbiAgICAgICAgY29udGV4dDogcGljayh7XG4gICAgICAgICAgICBzbG90OiBudW1iZXIoKSxcbiAgICAgICAgfSksXG4gICAgICAgIHZhbHVlLFxuICAgIH0pKTtcbn1cbi8vIGNvcHkgZnJvbSBAc29sYW5hL3dlYjMuanNcbmNvbnN0IFNpbXVsYXRlZFRyYW5zYWN0aW9uUmVzcG9uc2VTdHJ1Y3QgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChwaWNrKHtcbiAgICBlcnI6IG51bGxhYmxlKHVuaW9uKFtwaWNrKHt9KSwgc3RyaW5nKCldKSksXG4gICAgbG9nczogbnVsbGFibGUoYXJyYXkoc3RyaW5nKCkpKSxcbiAgICBhY2NvdW50czogb3B0aW9uYWwobnVsbGFibGUoYXJyYXkobnVsbGFibGUocGljayh7XG4gICAgICAgIGV4ZWN1dGFibGU6IGJvb2xlYW4oKSxcbiAgICAgICAgb3duZXI6IHN0cmluZygpLFxuICAgICAgICBsYW1wb3J0czogbnVtYmVyKCksXG4gICAgICAgIGRhdGE6IGFycmF5KHN0cmluZygpKSxcbiAgICAgICAgcmVudEVwb2NoOiBvcHRpb25hbChudW1iZXIoKSksXG4gICAgfSkpKSkpLFxuICAgIHVuaXRzQ29uc3VtZWQ6IG9wdGlvbmFsKG51bWJlcigpKSxcbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJwYy5qcy5tYXAiXSwibmFtZXMiOlsiVHJhbnNhY3Rpb24iLCJUcmFuc2FjdGlvbkluc3RydWN0aW9uIiwiU2VuZFRyYW5zYWN0aW9uRXJyb3IiLCJjaHVua3MiLCJ0cmFuc2xhdGVBZGRyZXNzIiwiZ2V0UHJvdmlkZXIiLCJ0eXBlIiwicGljayIsIm51bWJlciIsInN0cmluZyIsImFycmF5IiwiYm9vbGVhbiIsImxpdGVyYWwiLCJ1bmlvbiIsIm9wdGlvbmFsIiwibnVsbGFibGUiLCJjb2VyY2UiLCJjcmVhdGUiLCJ1bmtub3duIiwiYW55IiwiaW52b2tlIiwicHJvZ3JhbUlkIiwiYWNjb3VudHMiLCJkYXRhIiwicHJvdmlkZXIiLCJ0eCIsImFkZCIsImtleXMiLCJzZW5kQW5kQ29uZmlybSIsInVuZGVmaW5lZCIsIkVycm9yIiwiR0VUX01VTFRJUExFX0FDQ09VTlRTX0xJTUlUIiwiZ2V0TXVsdGlwbGVBY2NvdW50cyIsImNvbm5lY3Rpb24iLCJwdWJsaWNLZXlzIiwiY29tbWl0bWVudCIsInJlc3VsdHMiLCJnZXRNdWx0aXBsZUFjY291bnRzQW5kQ29udGV4dCIsIm1hcCIsInJlc3VsdCIsInB1YmxpY0tleSIsImFjY291bnQiLCJsZW5ndGgiLCJnZXRNdWx0aXBsZUFjY291bnRzQW5kQ29udGV4dENvcmUiLCJiYXRjaGVzIiwiUHJvbWlzZSIsImFsbCIsImJhdGNoIiwiZmxhdCIsImNvbW1pdG1lbnRPdmVycmlkZSIsInZhbHVlIiwiYWNjb3VudEluZm9zIiwiY29udGV4dCIsImdldE11bHRpcGxlQWNjb3VudHNJbmZvQW5kQ29udGV4dCIsImlkeCIsInNpbXVsYXRlVHJhbnNhY3Rpb24iLCJ0cmFuc2FjdGlvbiIsInNpZ25lcnMiLCJpbmNsdWRlQWNjb3VudHMiLCJfYSIsInNpZ24iLCJtZXNzYWdlIiwiX2NvbXBpbGUiLCJzaWduRGF0YSIsInNlcmlhbGl6ZSIsIndpcmVUcmFuc2FjdGlvbiIsIl9zZXJpYWxpemUiLCJlbmNvZGVkVHJhbnNhY3Rpb24iLCJ0b1N0cmluZyIsImNvbmZpZyIsImVuY29kaW5nIiwiYWRkcmVzc2VzIiwiQXJyYXkiLCJpc0FycmF5Iiwibm9uUHJvZ3JhbUlkcyIsImtleSIsInRvQmFzZTU4Iiwic2lnVmVyaWZ5IiwiYXJncyIsInVuc2FmZVJlcyIsIl9ycGNSZXF1ZXN0IiwicmVzIiwiU2ltdWxhdGVkVHJhbnNhY3Rpb25SZXNwb25zZVN0cnVjdCIsImxvZ3MiLCJlcnJvciIsInRyYWNlSW5kZW50IiwibG9nVHJhY2UiLCJqb2luIiwiY29uc29sZSIsImpzb25ScGNSZXN1bHQiLCJzY2hlbWEiLCJjcmVhdGVScGNSZXN1bHQiLCJVbmtub3duUnBjUmVzdWx0IiwianNvbnJwYyIsImlkIiwiY29kZSIsImpzb25ScGNSZXN1bHRBbmRDb250ZXh0Iiwic2xvdCIsImVyciIsImV4ZWN1dGFibGUiLCJvd25lciIsImxhbXBvcnRzIiwicmVudEVwb2NoIiwidW5pdHNDb25zdW1lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/rpc.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/sha256.js":
/*!******************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/utils/sha256.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hash: () => (/* binding */ hash)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/../node_modules/@noble/hashes/esm/sha256.js\");\n\nfunction hash(data) {\n    return new TextDecoder().decode((0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__.sha256)(data));\n} //# sourceMappingURL=sha256.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3V0aWxzL3NoYTI1Ni5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE4QztBQUN2QyxTQUFTQyxLQUFLQyxJQUFJO0lBQ3JCLE9BQU8sSUFBSUMsY0FBY0MsTUFBTSxDQUFDSiw0REFBTUEsQ0FBQ0U7QUFDM0MsRUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3V0aWxzL3NoYTI1Ni5qcz9lYjVmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNoYTI1NiB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3NoYTI1NlwiO1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2goZGF0YSkge1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoc2hhMjU2KGRhdGEpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTI1Ni5qcy5tYXAiXSwibmFtZXMiOlsic2hhMjU2IiwiaGFzaCIsImRhdGEiLCJUZXh0RGVjb2RlciIsImRlY29kZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/sha256.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/token.js":
/*!*****************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/utils/token.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ASSOCIATED_PROGRAM_ID: () => (/* binding */ ASSOCIATED_PROGRAM_ID),\n/* harmony export */   TOKEN_PROGRAM_ID: () => (/* binding */ TOKEN_PROGRAM_ID),\n/* harmony export */   associatedAddress: () => (/* binding */ associatedAddress)\n/* harmony export */ });\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/node_modules/@solana/web3.js/lib/index.esm.js\");\n\nconst TOKEN_PROGRAM_ID = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(\"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\");\nconst ASSOCIATED_PROGRAM_ID = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(\"ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL\");\nfunction associatedAddress({ mint, owner }) {\n    return _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey.findProgramAddressSync([\n        owner.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        mint.toBuffer()\n    ], ASSOCIATED_PROGRAM_ID)[0];\n} //# sourceMappingURL=token.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3V0aWxzL3Rva2VuLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNEM7QUFDckMsTUFBTUMsbUJBQW1CLElBQUlELHNEQUFTQSxDQUFDLCtDQUErQztBQUN0RixNQUFNRSx3QkFBd0IsSUFBSUYsc0RBQVNBLENBQUMsZ0RBQWdEO0FBQzVGLFNBQVNHLGtCQUFrQixFQUFFQyxJQUFJLEVBQUVDLEtBQUssRUFBRztJQUM5QyxPQUFPTCxzREFBU0EsQ0FBQ00sc0JBQXNCLENBQUM7UUFBQ0QsTUFBTUUsUUFBUTtRQUFJTixpQkFBaUJNLFFBQVE7UUFBSUgsS0FBS0csUUFBUTtLQUFHLEVBQUVMLHNCQUFzQixDQUFDLEVBQUU7QUFDdkksRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3V0aWxzL3Rva2VuLmpzPzc4NTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUHVibGljS2V5IH0gZnJvbSBcIkBzb2xhbmEvd2ViMy5qc1wiO1xuZXhwb3J0IGNvbnN0IFRPS0VOX1BST0dSQU1fSUQgPSBuZXcgUHVibGljS2V5KFwiVG9rZW5rZWdRZmVaeWlOd0FKYk5iR0tQRlhDV3VCdmY5U3M2MjNWUTVEQVwiKTtcbmV4cG9ydCBjb25zdCBBU1NPQ0lBVEVEX1BST0dSQU1fSUQgPSBuZXcgUHVibGljS2V5KFwiQVRva2VuR1B2YmRHVnhyMWIyaHZaYnNpcVc1eFdIMjVlZlROc0xKQThrbkxcIik7XG5leHBvcnQgZnVuY3Rpb24gYXNzb2NpYXRlZEFkZHJlc3MoeyBtaW50LCBvd25lciwgfSkge1xuICAgIHJldHVybiBQdWJsaWNLZXkuZmluZFByb2dyYW1BZGRyZXNzU3luYyhbb3duZXIudG9CdWZmZXIoKSwgVE9LRU5fUFJPR1JBTV9JRC50b0J1ZmZlcigpLCBtaW50LnRvQnVmZmVyKCldLCBBU1NPQ0lBVEVEX1BST0dSQU1fSUQpWzBdO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9rZW4uanMubWFwIl0sIm5hbWVzIjpbIlB1YmxpY0tleSIsIlRPS0VOX1BST0dSQU1fSUQiLCJBU1NPQ0lBVEVEX1BST0dSQU1fSUQiLCJhc3NvY2lhdGVkQWRkcmVzcyIsIm1pbnQiLCJvd25lciIsImZpbmRQcm9ncmFtQWRkcmVzc1N5bmMiLCJ0b0J1ZmZlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/token.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/workspace.js":
/*!***************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/dist/esm/workspace.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var toml__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! toml */ \"(ssr)/../node_modules/toml/index.js\");\n/* harmony import */ var toml__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(toml__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var snake_case__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! snake-case */ \"(ssr)/../node_modules/snake-case/dist.es2015/index.js\");\n/* harmony import */ var _program_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./program/index.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/program/index.js\");\n/* harmony import */ var _utils_common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/common.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/utils/common.js\");\n\n\n\n\n/**\n * The `workspace` namespace provides a convenience API to automatically\n * search for and deserialize [[Program]] objects defined by compiled IDLs\n * in an Anchor workspace.\n *\n * This API is for Node only.\n */ const workspace = new Proxy({}, {\n    get (workspaceCache, programName) {\n        var _a, _b;\n        if (_utils_common_js__WEBPACK_IMPORTED_MODULE_2__.isBrowser) {\n            throw new Error(\"Workspaces aren't available in the browser\");\n        }\n        // Converting `programName` to snake_case enables the ability to use any\n        // of the following to access the workspace program:\n        // `workspace.myProgram`, `workspace.MyProgram`, `workspace[\"my-program\"]`...\n        programName = (0,snake_case__WEBPACK_IMPORTED_MODULE_3__.snakeCase)(programName);\n        // Check whether the program name contains any digits\n        if (/\\d/.test(programName)) {\n            // Numbers cannot be properly converted from camelCase to snake_case,\n            // e.g. if the `programName` is `myProgram2`, the actual program name could\n            // be `my_program2` or `my_program_2`. This implementation assumes the\n            // latter as the default and always converts to `_numbers`.\n            //\n            // A solution to the conversion of program names with numbers in them\n            // would be to always convert the `programName` to camelCase instead of\n            // snake_case. The problem with this approach is that it would require\n            // converting everything else e.g. program names in Anchor.toml and IDL\n            // file names which are both snake_case.\n            programName = programName.replace(/\\d+/g, (match)=>\"_\" + match).replace(\"__\", \"_\");\n        }\n        // Return early if the program is in cache\n        if (workspaceCache[programName]) return workspaceCache[programName];\n        const fs = __webpack_require__(/*! fs */ \"fs\");\n        const path = __webpack_require__(/*! path */ \"path\");\n        // Override the workspace programs if the user put them in the config.\n        const anchorToml = toml__WEBPACK_IMPORTED_MODULE_0__.parse(fs.readFileSync(\"Anchor.toml\"));\n        const clusterId = anchorToml.provider.cluster;\n        const programEntry = (_b = (_a = anchorToml.programs) === null || _a === void 0 ? void 0 : _a[clusterId]) === null || _b === void 0 ? void 0 : _b[programName];\n        let idlPath;\n        let programId;\n        if (typeof programEntry === \"object\" && programEntry.idl) {\n            idlPath = programEntry.idl;\n            programId = programEntry.address;\n        } else {\n            idlPath = path.join(\"target\", \"idl\", `${programName}.json`);\n        }\n        if (!fs.existsSync(idlPath)) {\n            throw new Error(`${idlPath} doesn't exist. Did you run \\`anchor build\\`?`);\n        }\n        const idl = JSON.parse(fs.readFileSync(idlPath));\n        if (programId) {\n            idl.address = programId;\n        }\n        workspaceCache[programName] = new _program_index_js__WEBPACK_IMPORTED_MODULE_1__.Program(idl);\n        return workspaceCache[programName];\n    }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (workspace); //# sourceMappingURL=workspace.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL2Rpc3QvZXNtL3dvcmtzcGFjZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBNkI7QUFDVTtBQUNNO0FBQ0M7QUFDOUM7Ozs7OztDQU1DLEdBQ0QsTUFBTUksWUFBWSxJQUFJQyxNQUFNLENBQUMsR0FBRztJQUM1QkMsS0FBSUMsY0FBYyxFQUFFQyxXQUFXO1FBQzNCLElBQUlDLElBQUlDO1FBQ1IsSUFBSVAsdURBQVNBLEVBQUU7WUFDWCxNQUFNLElBQUlRLE1BQU07UUFDcEI7UUFDQSx3RUFBd0U7UUFDeEUsb0RBQW9EO1FBQ3BELDZFQUE2RTtRQUM3RUgsY0FBY1AscURBQVNBLENBQUNPO1FBQ3hCLHFEQUFxRDtRQUNyRCxJQUFJLEtBQUtJLElBQUksQ0FBQ0osY0FBYztZQUN4QixxRUFBcUU7WUFDckUsMkVBQTJFO1lBQzNFLHNFQUFzRTtZQUN0RSwyREFBMkQ7WUFDM0QsRUFBRTtZQUNGLHFFQUFxRTtZQUNyRSx1RUFBdUU7WUFDdkUsc0VBQXNFO1lBQ3RFLHVFQUF1RTtZQUN2RSx3Q0FBd0M7WUFDeENBLGNBQWNBLFlBQ1RLLE9BQU8sQ0FBQyxRQUFRLENBQUNDLFFBQVUsTUFBTUEsT0FDakNELE9BQU8sQ0FBQyxNQUFNO1FBQ3ZCO1FBQ0EsMENBQTBDO1FBQzFDLElBQUlOLGNBQWMsQ0FBQ0MsWUFBWSxFQUMzQixPQUFPRCxjQUFjLENBQUNDLFlBQVk7UUFDdEMsTUFBTU8sS0FBS0MsbUJBQU9BLENBQUMsY0FBSTtRQUN2QixNQUFNQyxPQUFPRCxtQkFBT0EsQ0FBQyxrQkFBTTtRQUMzQixzRUFBc0U7UUFDdEUsTUFBTUUsYUFBYWxCLHVDQUFVLENBQUNlLEdBQUdLLFlBQVksQ0FBQztRQUM5QyxNQUFNQyxZQUFZSCxXQUFXSSxRQUFRLENBQUNDLE9BQU87UUFDN0MsTUFBTUMsZUFBZSxDQUFDZCxLQUFLLENBQUNELEtBQUtTLFdBQVdPLFFBQVEsTUFBTSxRQUFRaEIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxFQUFFLENBQUNZLFVBQVUsTUFBTSxRQUFRWCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEVBQUUsQ0FBQ0YsWUFBWTtRQUM5SixJQUFJa0I7UUFDSixJQUFJQztRQUNKLElBQUksT0FBT0gsaUJBQWlCLFlBQVlBLGFBQWFJLEdBQUcsRUFBRTtZQUN0REYsVUFBVUYsYUFBYUksR0FBRztZQUMxQkQsWUFBWUgsYUFBYUssT0FBTztRQUNwQyxPQUNLO1lBQ0RILFVBQVVULEtBQUthLElBQUksQ0FBQyxVQUFVLE9BQU8sQ0FBQyxFQUFFdEIsWUFBWSxLQUFLLENBQUM7UUFDOUQ7UUFDQSxJQUFJLENBQUNPLEdBQUdnQixVQUFVLENBQUNMLFVBQVU7WUFDekIsTUFBTSxJQUFJZixNQUFNLENBQUMsRUFBRWUsUUFBUSw2Q0FBNkMsQ0FBQztRQUM3RTtRQUNBLE1BQU1FLE1BQU1JLEtBQUtiLEtBQUssQ0FBQ0osR0FBR0ssWUFBWSxDQUFDTTtRQUN2QyxJQUFJQyxXQUFXO1lBQ1hDLElBQUlDLE9BQU8sR0FBR0Y7UUFDbEI7UUFDQXBCLGNBQWMsQ0FBQ0MsWUFBWSxHQUFHLElBQUlOLHNEQUFPQSxDQUFDMEI7UUFDMUMsT0FBT3JCLGNBQWMsQ0FBQ0MsWUFBWTtJQUN0QztBQUNKO0FBQ0EsaUVBQWVKLFNBQVNBLEVBQUMsQ0FDekIscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AY29yYWwteHl6L2FuY2hvci9kaXN0L2VzbS93b3Jrc3BhY2UuanM/NTQzOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB0b21sIGZyb20gXCJ0b21sXCI7XG5pbXBvcnQgeyBzbmFrZUNhc2UgfSBmcm9tIFwic25ha2UtY2FzZVwiO1xuaW1wb3J0IHsgUHJvZ3JhbSB9IGZyb20gXCIuL3Byb2dyYW0vaW5kZXguanNcIjtcbmltcG9ydCB7IGlzQnJvd3NlciB9IGZyb20gXCIuL3V0aWxzL2NvbW1vbi5qc1wiO1xuLyoqXG4gKiBUaGUgYHdvcmtzcGFjZWAgbmFtZXNwYWNlIHByb3ZpZGVzIGEgY29udmVuaWVuY2UgQVBJIHRvIGF1dG9tYXRpY2FsbHlcbiAqIHNlYXJjaCBmb3IgYW5kIGRlc2VyaWFsaXplIFtbUHJvZ3JhbV1dIG9iamVjdHMgZGVmaW5lZCBieSBjb21waWxlZCBJRExzXG4gKiBpbiBhbiBBbmNob3Igd29ya3NwYWNlLlxuICpcbiAqIFRoaXMgQVBJIGlzIGZvciBOb2RlIG9ubHkuXG4gKi9cbmNvbnN0IHdvcmtzcGFjZSA9IG5ldyBQcm94eSh7fSwge1xuICAgIGdldCh3b3Jrc3BhY2VDYWNoZSwgcHJvZ3JhbU5hbWUpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKGlzQnJvd3Nlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV29ya3NwYWNlcyBhcmVuJ3QgYXZhaWxhYmxlIGluIHRoZSBicm93c2VyXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnRpbmcgYHByb2dyYW1OYW1lYCB0byBzbmFrZV9jYXNlIGVuYWJsZXMgdGhlIGFiaWxpdHkgdG8gdXNlIGFueVxuICAgICAgICAvLyBvZiB0aGUgZm9sbG93aW5nIHRvIGFjY2VzcyB0aGUgd29ya3NwYWNlIHByb2dyYW06XG4gICAgICAgIC8vIGB3b3Jrc3BhY2UubXlQcm9ncmFtYCwgYHdvcmtzcGFjZS5NeVByb2dyYW1gLCBgd29ya3NwYWNlW1wibXktcHJvZ3JhbVwiXWAuLi5cbiAgICAgICAgcHJvZ3JhbU5hbWUgPSBzbmFrZUNhc2UocHJvZ3JhbU5hbWUpO1xuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBwcm9ncmFtIG5hbWUgY29udGFpbnMgYW55IGRpZ2l0c1xuICAgICAgICBpZiAoL1xcZC8udGVzdChwcm9ncmFtTmFtZSkpIHtcbiAgICAgICAgICAgIC8vIE51bWJlcnMgY2Fubm90IGJlIHByb3Blcmx5IGNvbnZlcnRlZCBmcm9tIGNhbWVsQ2FzZSB0byBzbmFrZV9jYXNlLFxuICAgICAgICAgICAgLy8gZS5nLiBpZiB0aGUgYHByb2dyYW1OYW1lYCBpcyBgbXlQcm9ncmFtMmAsIHRoZSBhY3R1YWwgcHJvZ3JhbSBuYW1lIGNvdWxkXG4gICAgICAgICAgICAvLyBiZSBgbXlfcHJvZ3JhbTJgIG9yIGBteV9wcm9ncmFtXzJgLiBUaGlzIGltcGxlbWVudGF0aW9uIGFzc3VtZXMgdGhlXG4gICAgICAgICAgICAvLyBsYXR0ZXIgYXMgdGhlIGRlZmF1bHQgYW5kIGFsd2F5cyBjb252ZXJ0cyB0byBgX251bWJlcnNgLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEEgc29sdXRpb24gdG8gdGhlIGNvbnZlcnNpb24gb2YgcHJvZ3JhbSBuYW1lcyB3aXRoIG51bWJlcnMgaW4gdGhlbVxuICAgICAgICAgICAgLy8gd291bGQgYmUgdG8gYWx3YXlzIGNvbnZlcnQgdGhlIGBwcm9ncmFtTmFtZWAgdG8gY2FtZWxDYXNlIGluc3RlYWQgb2ZcbiAgICAgICAgICAgIC8vIHNuYWtlX2Nhc2UuIFRoZSBwcm9ibGVtIHdpdGggdGhpcyBhcHByb2FjaCBpcyB0aGF0IGl0IHdvdWxkIHJlcXVpcmVcbiAgICAgICAgICAgIC8vIGNvbnZlcnRpbmcgZXZlcnl0aGluZyBlbHNlIGUuZy4gcHJvZ3JhbSBuYW1lcyBpbiBBbmNob3IudG9tbCBhbmQgSURMXG4gICAgICAgICAgICAvLyBmaWxlIG5hbWVzIHdoaWNoIGFyZSBib3RoIHNuYWtlX2Nhc2UuXG4gICAgICAgICAgICBwcm9ncmFtTmFtZSA9IHByb2dyYW1OYW1lXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcZCsvZywgKG1hdGNoKSA9PiBcIl9cIiArIG1hdGNoKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKFwiX19cIiwgXCJfXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiBlYXJseSBpZiB0aGUgcHJvZ3JhbSBpcyBpbiBjYWNoZVxuICAgICAgICBpZiAod29ya3NwYWNlQ2FjaGVbcHJvZ3JhbU5hbWVdKVxuICAgICAgICAgICAgcmV0dXJuIHdvcmtzcGFjZUNhY2hlW3Byb2dyYW1OYW1lXTtcbiAgICAgICAgY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XG4gICAgICAgIGNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbiAgICAgICAgLy8gT3ZlcnJpZGUgdGhlIHdvcmtzcGFjZSBwcm9ncmFtcyBpZiB0aGUgdXNlciBwdXQgdGhlbSBpbiB0aGUgY29uZmlnLlxuICAgICAgICBjb25zdCBhbmNob3JUb21sID0gdG9tbC5wYXJzZShmcy5yZWFkRmlsZVN5bmMoXCJBbmNob3IudG9tbFwiKSk7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJJZCA9IGFuY2hvclRvbWwucHJvdmlkZXIuY2x1c3RlcjtcbiAgICAgICAgY29uc3QgcHJvZ3JhbUVudHJ5ID0gKF9iID0gKF9hID0gYW5jaG9yVG9tbC5wcm9ncmFtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2NsdXN0ZXJJZF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltwcm9ncmFtTmFtZV07XG4gICAgICAgIGxldCBpZGxQYXRoO1xuICAgICAgICBsZXQgcHJvZ3JhbUlkO1xuICAgICAgICBpZiAodHlwZW9mIHByb2dyYW1FbnRyeSA9PT0gXCJvYmplY3RcIiAmJiBwcm9ncmFtRW50cnkuaWRsKSB7XG4gICAgICAgICAgICBpZGxQYXRoID0gcHJvZ3JhbUVudHJ5LmlkbDtcbiAgICAgICAgICAgIHByb2dyYW1JZCA9IHByb2dyYW1FbnRyeS5hZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWRsUGF0aCA9IHBhdGguam9pbihcInRhcmdldFwiLCBcImlkbFwiLCBgJHtwcm9ncmFtTmFtZX0uanNvbmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZnMuZXhpc3RzU3luYyhpZGxQYXRoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2lkbFBhdGh9IGRvZXNuJ3QgZXhpc3QuIERpZCB5b3UgcnVuIFxcYGFuY2hvciBidWlsZFxcYD9gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZGwgPSBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYyhpZGxQYXRoKSk7XG4gICAgICAgIGlmIChwcm9ncmFtSWQpIHtcbiAgICAgICAgICAgIGlkbC5hZGRyZXNzID0gcHJvZ3JhbUlkO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtzcGFjZUNhY2hlW3Byb2dyYW1OYW1lXSA9IG5ldyBQcm9ncmFtKGlkbCk7XG4gICAgICAgIHJldHVybiB3b3Jrc3BhY2VDYWNoZVtwcm9ncmFtTmFtZV07XG4gICAgfSxcbn0pO1xuZXhwb3J0IGRlZmF1bHQgd29ya3NwYWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d29ya3NwYWNlLmpzLm1hcCJdLCJuYW1lcyI6WyJ0b21sIiwic25ha2VDYXNlIiwiUHJvZ3JhbSIsImlzQnJvd3NlciIsIndvcmtzcGFjZSIsIlByb3h5IiwiZ2V0Iiwid29ya3NwYWNlQ2FjaGUiLCJwcm9ncmFtTmFtZSIsIl9hIiwiX2IiLCJFcnJvciIsInRlc3QiLCJyZXBsYWNlIiwibWF0Y2giLCJmcyIsInJlcXVpcmUiLCJwYXRoIiwiYW5jaG9yVG9tbCIsInBhcnNlIiwicmVhZEZpbGVTeW5jIiwiY2x1c3RlcklkIiwicHJvdmlkZXIiLCJjbHVzdGVyIiwicHJvZ3JhbUVudHJ5IiwicHJvZ3JhbXMiLCJpZGxQYXRoIiwicHJvZ3JhbUlkIiwiaWRsIiwiYWRkcmVzcyIsImpvaW4iLCJleGlzdHNTeW5jIiwiSlNPTiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/dist/esm/workspace.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/node_modules/@coral-xyz/borsh/dist/index.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/node_modules/@coral-xyz/borsh/dist/index.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.map = exports.array = exports.rustEnum = exports.str = exports.vecU8 = exports.tagged = exports.vec = exports.bool = exports.option = exports.publicKey = exports.i256 = exports.u256 = exports.i128 = exports.u128 = exports.i64 = exports.u64 = exports.struct = exports.f64 = exports.f32 = exports.i32 = exports.u32 = exports.i16 = exports.u16 = exports.i8 = exports.u8 = void 0;\nconst buffer_layout_1 = __webpack_require__(/*! buffer-layout */ \"(ssr)/../node_modules/buffer-layout/lib/Layout.js\");\nconst web3_js_1 = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/node_modules/@solana/web3.js/lib/index.esm.js\");\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"(ssr)/../node_modules/bn.js/lib/bn.js\"));\nvar buffer_layout_2 = __webpack_require__(/*! buffer-layout */ \"(ssr)/../node_modules/buffer-layout/lib/Layout.js\");\nObject.defineProperty(exports, \"u8\", ({\n    enumerable: true,\n    get: function() {\n        return buffer_layout_2.u8;\n    }\n}));\nObject.defineProperty(exports, \"i8\", ({\n    enumerable: true,\n    get: function() {\n        return buffer_layout_2.s8;\n    }\n}));\nObject.defineProperty(exports, \"u16\", ({\n    enumerable: true,\n    get: function() {\n        return buffer_layout_2.u16;\n    }\n}));\nObject.defineProperty(exports, \"i16\", ({\n    enumerable: true,\n    get: function() {\n        return buffer_layout_2.s16;\n    }\n}));\nObject.defineProperty(exports, \"u32\", ({\n    enumerable: true,\n    get: function() {\n        return buffer_layout_2.u32;\n    }\n}));\nObject.defineProperty(exports, \"i32\", ({\n    enumerable: true,\n    get: function() {\n        return buffer_layout_2.s32;\n    }\n}));\nObject.defineProperty(exports, \"f32\", ({\n    enumerable: true,\n    get: function() {\n        return buffer_layout_2.f32;\n    }\n}));\nObject.defineProperty(exports, \"f64\", ({\n    enumerable: true,\n    get: function() {\n        return buffer_layout_2.f64;\n    }\n}));\nObject.defineProperty(exports, \"struct\", ({\n    enumerable: true,\n    get: function() {\n        return buffer_layout_2.struct;\n    }\n}));\nclass BNLayout extends buffer_layout_1.Layout {\n    constructor(span, signed, property){\n        super(span, property);\n        this.blob = (0, buffer_layout_1.blob)(span);\n        this.signed = signed;\n    }\n    decode(b, offset = 0) {\n        const num = new bn_js_1.default(this.blob.decode(b, offset), 10, \"le\");\n        if (this.signed) {\n            return num.fromTwos(this.span * 8).clone();\n        }\n        return num;\n    }\n    encode(src, b, offset = 0) {\n        if (this.signed) {\n            src = src.toTwos(this.span * 8);\n        }\n        return this.blob.encode(src.toArrayLike(Buffer, \"le\", this.span), b, offset);\n    }\n}\nfunction u64(property) {\n    return new BNLayout(8, false, property);\n}\nexports.u64 = u64;\nfunction i64(property) {\n    return new BNLayout(8, true, property);\n}\nexports.i64 = i64;\nfunction u128(property) {\n    return new BNLayout(16, false, property);\n}\nexports.u128 = u128;\nfunction i128(property) {\n    return new BNLayout(16, true, property);\n}\nexports.i128 = i128;\nfunction u256(property) {\n    return new BNLayout(32, false, property);\n}\nexports.u256 = u256;\nfunction i256(property) {\n    return new BNLayout(32, true, property);\n}\nexports.i256 = i256;\nclass WrappedLayout extends buffer_layout_1.Layout {\n    constructor(layout, decoder, encoder, property){\n        super(layout.span, property);\n        this.layout = layout;\n        this.decoder = decoder;\n        this.encoder = encoder;\n    }\n    decode(b, offset) {\n        return this.decoder(this.layout.decode(b, offset));\n    }\n    encode(src, b, offset) {\n        return this.layout.encode(this.encoder(src), b, offset);\n    }\n    getSpan(b, offset) {\n        return this.layout.getSpan(b, offset);\n    }\n}\nfunction publicKey(property) {\n    return new WrappedLayout((0, buffer_layout_1.blob)(32), (b)=>new web3_js_1.PublicKey(b), (key)=>key.toBuffer(), property);\n}\nexports.publicKey = publicKey;\nclass OptionLayout extends buffer_layout_1.Layout {\n    constructor(layout, property){\n        super(-1, property);\n        this.layout = layout;\n        this.discriminator = (0, buffer_layout_1.u8)();\n    }\n    encode(src, b, offset = 0) {\n        if (src === null || src === undefined) {\n            return this.discriminator.encode(0, b, offset);\n        }\n        this.discriminator.encode(1, b, offset);\n        return this.layout.encode(src, b, offset + 1) + 1;\n    }\n    decode(b, offset = 0) {\n        const discriminator = this.discriminator.decode(b, offset);\n        if (discriminator === 0) {\n            return null;\n        } else if (discriminator === 1) {\n            return this.layout.decode(b, offset + 1);\n        }\n        throw new Error(\"Invalid option \" + this.property);\n    }\n    getSpan(b, offset = 0) {\n        const discriminator = this.discriminator.decode(b, offset);\n        if (discriminator === 0) {\n            return 1;\n        } else if (discriminator === 1) {\n            return this.layout.getSpan(b, offset + 1) + 1;\n        }\n        throw new Error(\"Invalid option \" + this.property);\n    }\n}\nfunction option(layout, property) {\n    return new OptionLayout(layout, property);\n}\nexports.option = option;\nfunction bool(property) {\n    return new WrappedLayout((0, buffer_layout_1.u8)(), decodeBool, encodeBool, property);\n}\nexports.bool = bool;\nfunction decodeBool(value) {\n    if (value === 0) {\n        return false;\n    } else if (value === 1) {\n        return true;\n    }\n    throw new Error(\"Invalid bool: \" + value);\n}\nfunction encodeBool(value) {\n    return value ? 1 : 0;\n}\nfunction vec(elementLayout, property) {\n    const length = (0, buffer_layout_1.u32)(\"length\");\n    const layout = (0, buffer_layout_1.struct)([\n        length,\n        (0, buffer_layout_1.seq)(elementLayout, (0, buffer_layout_1.offset)(length, -length.span), \"values\")\n    ]);\n    return new WrappedLayout(layout, ({ values })=>values, (values)=>({\n            values\n        }), property);\n}\nexports.vec = vec;\nfunction tagged(tag, layout, property) {\n    const wrappedLayout = (0, buffer_layout_1.struct)([\n        u64(\"tag\"),\n        layout.replicate(\"data\")\n    ]);\n    function decodeTag({ tag: receivedTag, data }) {\n        if (!receivedTag.eq(tag)) {\n            throw new Error(\"Invalid tag, expected: \" + tag.toString(\"hex\") + \", got: \" + receivedTag.toString(\"hex\"));\n        }\n        return data;\n    }\n    return new WrappedLayout(wrappedLayout, decodeTag, (data)=>({\n            tag,\n            data\n        }), property);\n}\nexports.tagged = tagged;\nfunction vecU8(property) {\n    const length = (0, buffer_layout_1.u32)(\"length\");\n    const layout = (0, buffer_layout_1.struct)([\n        length,\n        (0, buffer_layout_1.blob)((0, buffer_layout_1.offset)(length, -length.span), \"data\")\n    ]);\n    return new WrappedLayout(layout, ({ data })=>data, (data)=>({\n            data\n        }), property);\n}\nexports.vecU8 = vecU8;\nfunction str(property) {\n    return new WrappedLayout(vecU8(), (data)=>data.toString(\"utf-8\"), (s)=>Buffer.from(s, \"utf-8\"), property);\n}\nexports.str = str;\nfunction rustEnum(variants, property, discriminant) {\n    const unionLayout = (0, buffer_layout_1.union)(discriminant !== null && discriminant !== void 0 ? discriminant : (0, buffer_layout_1.u8)(), property);\n    variants.forEach((variant, index)=>unionLayout.addVariant(index, variant, variant.property));\n    return unionLayout;\n}\nexports.rustEnum = rustEnum;\nfunction array(elementLayout, length, property) {\n    const layout = (0, buffer_layout_1.struct)([\n        (0, buffer_layout_1.seq)(elementLayout, length, \"values\")\n    ]);\n    return new WrappedLayout(layout, ({ values })=>values, (values)=>({\n            values\n        }), property);\n}\nexports.array = array;\nclass MapEntryLayout extends buffer_layout_1.Layout {\n    constructor(keyLayout, valueLayout, property){\n        super(keyLayout.span + valueLayout.span, property);\n        this.keyLayout = keyLayout;\n        this.valueLayout = valueLayout;\n    }\n    decode(b, offset) {\n        offset = offset || 0;\n        const key = this.keyLayout.decode(b, offset);\n        const value = this.valueLayout.decode(b, offset + this.keyLayout.getSpan(b, offset));\n        return [\n            key,\n            value\n        ];\n    }\n    encode(src, b, offset) {\n        offset = offset || 0;\n        const keyBytes = this.keyLayout.encode(src[0], b, offset);\n        const valueBytes = this.valueLayout.encode(src[1], b, offset + keyBytes);\n        return keyBytes + valueBytes;\n    }\n    getSpan(b, offset) {\n        return this.keyLayout.getSpan(b, offset) + this.valueLayout.getSpan(b, offset);\n    }\n}\nfunction map(keyLayout, valueLayout, property) {\n    const length = (0, buffer_layout_1.u32)(\"length\");\n    const layout = (0, buffer_layout_1.struct)([\n        length,\n        (0, buffer_layout_1.seq)(new MapEntryLayout(keyLayout, valueLayout), (0, buffer_layout_1.offset)(length, -length.span), \"values\")\n    ]);\n    return new WrappedLayout(layout, ({ values })=>new Map(values), (values)=>({\n            values: Array.from(values.entries())\n        }), property);\n}\nexports.map = map; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL25vZGVfbW9kdWxlcy9AY29yYWwteHl6L2JvcnNoL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsSUFBSyxJQUFJLElBQUksQ0FBQ0EsZUFBZSxJQUFLLFNBQVVDLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FFLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxXQUFXLEdBQUdBLGFBQWEsR0FBR0EsZ0JBQWdCLEdBQUdBLFdBQVcsR0FBR0EsYUFBYSxHQUFHQSxjQUFjLEdBQUdBLFdBQVcsR0FBR0EsWUFBWSxHQUFHQSxjQUFjLEdBQUdBLGlCQUFpQixHQUFHQSxZQUFZLEdBQUdBLFlBQVksR0FBR0EsWUFBWSxHQUFHQSxZQUFZLEdBQUdBLFdBQVcsR0FBR0EsV0FBVyxHQUFHQSxjQUFjLEdBQUdBLFdBQVcsR0FBR0EsV0FBVyxHQUFHQSxXQUFXLEdBQUdBLFdBQVcsR0FBR0EsV0FBVyxHQUFHQSxXQUFXLEdBQUdBLFVBQVUsR0FBR0EsVUFBVSxHQUFHLEtBQUs7QUFDOVgsTUFBTTJCLGtCQUFrQkMsbUJBQU9BLENBQUMsd0VBQWU7QUFDL0MsTUFBTUMsWUFBWUQsbUJBQU9BLENBQUMsOEdBQWlCO0FBQzNDLE1BQU1FLFVBQVVuQyxnQkFBZ0JpQyxtQkFBT0EsQ0FBQyxvREFBTztBQUMvQyxJQUFJRyxrQkFBa0JILG1CQUFPQSxDQUFDLHdFQUFlO0FBQzdDOUIsc0NBQXFDO0lBQUVrQyxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRixnQkFBZ0JMLEVBQUU7SUFBRTtBQUFFLENBQUMsRUFBQztBQUMzRzVCLHNDQUFxQztJQUFFa0MsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0YsZ0JBQWdCRyxFQUFFO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFD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QUFNLENBQUNDLEdBQUcsQ0FBQyxFQUFFLEVBQUVQLEdBQUdDLFNBQVNpRDtRQUMvRCxPQUFPQSxXQUFXQztJQUN0QjtJQUNBcEMsUUFBUWYsQ0FBQyxFQUFFQyxNQUFNLEVBQUU7UUFDZixPQUFRLElBQUksQ0FBQytDLFNBQVMsQ0FBQ2pDLE9BQU8sQ0FBQ2YsR0FBR0MsVUFBVSxJQUFJLENBQUNnRCxXQUFXLENBQUNsQyxPQUFPLENBQUNmLEdBQUdDO0lBQzVFO0FBQ0o7QUFDQSxTQUFTNUMsSUFBSTJGLFNBQVMsRUFBRUMsV0FBVyxFQUFFcEQsUUFBUTtJQUN6QyxNQUFNNkIsU0FBUyxDQUFDLEdBQUc1QyxnQkFBZ0JMLEdBQUcsRUFBRTtJQUN4QyxNQUFNbUMsU0FBUyxDQUFDLEdBQUc5QixnQkFBZ0JULE1BQU0sRUFBRTtRQUN2Q3FEO1FBQ0MsSUFBRzVDLGdCQUFnQjZDLEdBQUcsRUFBRSxJQUFJb0IsZUFBZUMsV0FBV0MsY0FBYyxDQUFDLEdBQUduRSxnQkFBZ0JtQixNQUFNLEVBQUV5QixRQUFRLENBQUNBLE9BQU8vQixJQUFJLEdBQUc7S0FDM0g7SUFDRCxPQUFPLElBQUlnQixjQUFjQyxRQUFRLENBQUMsRUFBRWdCLE1BQU0sRUFBRSxHQUFLLElBQUl3QixJQUFJeEIsU0FBUyxDQUFDQSxTQUFZO1lBQUVBLFFBQVF5QixNQUFNZixJQUFJLENBQUNWLE9BQU8wQixPQUFPO1FBQUksSUFBSXpEO0FBQzlIO0FBQ0ExQyxXQUFXLEdBQUdFLEtBQ2QsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AY29yYWwteHl6L2FuY2hvci9ub2RlX21vZHVsZXMvQGNvcmFsLXh5ei9ib3JzaC9kaXN0L2luZGV4LmpzPzU0NTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1hcCA9IGV4cG9ydHMuYXJyYXkgPSBleHBvcnRzLnJ1c3RFbnVtID0gZXhwb3J0cy5zdHIgPSBleHBvcnRzLnZlY1U4ID0gZXhwb3J0cy50YWdnZWQgPSBleHBvcnRzLnZlYyA9IGV4cG9ydHMuYm9vbCA9IGV4cG9ydHMub3B0aW9uID0gZXhwb3J0cy5wdWJsaWNLZXkgPSBleHBvcnRzLmkyNTYgPSBleHBvcnRzLnUyNTYgPSBleHBvcnRzLmkxMjggPSBleHBvcnRzLnUxMjggPSBleHBvcnRzLmk2NCA9IGV4cG9ydHMudTY0ID0gZXhwb3J0cy5zdHJ1Y3QgPSBleHBvcnRzLmY2NCA9IGV4cG9ydHMuZjMyID0gZXhwb3J0cy5pMzIgPSBleHBvcnRzLnUzMiA9IGV4cG9ydHMuaTE2ID0gZXhwb3J0cy51MTYgPSBleHBvcnRzLmk4ID0gZXhwb3J0cy51OCA9IHZvaWQgMDtcbmNvbnN0IGJ1ZmZlcl9sYXlvdXRfMSA9IHJlcXVpcmUoXCJidWZmZXItbGF5b3V0XCIpO1xuY29uc3Qgd2ViM19qc18xID0gcmVxdWlyZShcIkBzb2xhbmEvd2ViMy5qc1wiKTtcbmNvbnN0IGJuX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJuLmpzXCIpKTtcbnZhciBidWZmZXJfbGF5b3V0XzIgPSByZXF1aXJlKFwiYnVmZmVyLWxheW91dFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInU4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBidWZmZXJfbGF5b3V0XzIudTg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpOFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnVmZmVyX2xheW91dF8yLnM4OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidTE2XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBidWZmZXJfbGF5b3V0XzIudTE2OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaTE2XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBidWZmZXJfbGF5b3V0XzIuczE2OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidTMyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBidWZmZXJfbGF5b3V0XzIudTMyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaTMyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBidWZmZXJfbGF5b3V0XzIuczMyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZjMyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBidWZmZXJfbGF5b3V0XzIuZjMyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZjY0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBidWZmZXJfbGF5b3V0XzIuZjY0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RydWN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBidWZmZXJfbGF5b3V0XzIuc3RydWN0OyB9IH0pO1xuY2xhc3MgQk5MYXlvdXQgZXh0ZW5kcyBidWZmZXJfbGF5b3V0XzEuTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBzaWduZWQsIHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIHByb3BlcnR5KTtcbiAgICAgICAgdGhpcy5ibG9iID0gKDAsIGJ1ZmZlcl9sYXlvdXRfMS5ibG9iKShzcGFuKTtcbiAgICAgICAgdGhpcy5zaWduZWQgPSBzaWduZWQ7XG4gICAgfVxuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IG51bSA9IG5ldyBibl9qc18xLmRlZmF1bHQodGhpcy5ibG9iLmRlY29kZShiLCBvZmZzZXQpLCAxMCwgXCJsZVwiKTtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtLmZyb21Ud29zKHRoaXMuc3BhbiAqIDgpLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICB9XG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBpZiAodGhpcy5zaWduZWQpIHtcbiAgICAgICAgICAgIHNyYyA9IHNyYy50b1R3b3ModGhpcy5zcGFuICogOCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYmxvYi5lbmNvZGUoc3JjLnRvQXJyYXlMaWtlKEJ1ZmZlciwgXCJsZVwiLCB0aGlzLnNwYW4pLCBiLCBvZmZzZXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHU2NChwcm9wZXJ0eSkge1xuICAgIHJldHVybiBuZXcgQk5MYXlvdXQoOCwgZmFsc2UsIHByb3BlcnR5KTtcbn1cbmV4cG9ydHMudTY0ID0gdTY0O1xuZnVuY3Rpb24gaTY0KHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIG5ldyBCTkxheW91dCg4LCB0cnVlLCBwcm9wZXJ0eSk7XG59XG5leHBvcnRzLmk2NCA9IGk2NDtcbmZ1bmN0aW9uIHUxMjgocHJvcGVydHkpIHtcbiAgICByZXR1cm4gbmV3IEJOTGF5b3V0KDE2LCBmYWxzZSwgcHJvcGVydHkpO1xufVxuZXhwb3J0cy51MTI4ID0gdTEyODtcbmZ1bmN0aW9uIGkxMjgocHJvcGVydHkpIHtcbiAgICByZXR1cm4gbmV3IEJOTGF5b3V0KDE2LCB0cnVlLCBwcm9wZXJ0eSk7XG59XG5leHBvcnRzLmkxMjggPSBpMTI4O1xuZnVuY3Rpb24gdTI1Nihwcm9wZXJ0eSkge1xuICAgIHJldHVybiBuZXcgQk5MYXlvdXQoMzIsIGZhbHNlLCBwcm9wZXJ0eSk7XG59XG5leHBvcnRzLnUyNTYgPSB1MjU2O1xuZnVuY3Rpb24gaTI1Nihwcm9wZXJ0eSkge1xuICAgIHJldHVybiBuZXcgQk5MYXlvdXQoMzIsIHRydWUsIHByb3BlcnR5KTtcbn1cbmV4cG9ydHMuaTI1NiA9IGkyNTY7XG5jbGFzcyBXcmFwcGVkTGF5b3V0IGV4dGVuZHMgYnVmZmVyX2xheW91dF8xLkxheW91dCB7XG4gICAgY29uc3RydWN0b3IobGF5b3V0LCBkZWNvZGVyLCBlbmNvZGVyLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcihsYXlvdXQuc3BhbiwgcHJvcGVydHkpO1xuICAgICAgICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgICAgICAgdGhpcy5kZWNvZGVyID0gZGVjb2RlcjtcbiAgICAgICAgdGhpcy5lbmNvZGVyID0gZW5jb2RlcjtcbiAgICB9XG4gICAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVyKHRoaXMubGF5b3V0LmRlY29kZShiLCBvZmZzZXQpKTtcbiAgICB9XG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheW91dC5lbmNvZGUodGhpcy5lbmNvZGVyKHNyYyksIGIsIG9mZnNldCk7XG4gICAgfVxuICAgIGdldFNwYW4oYiwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheW91dC5nZXRTcGFuKGIsIG9mZnNldCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcHVibGljS2V5KHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIG5ldyBXcmFwcGVkTGF5b3V0KCgwLCBidWZmZXJfbGF5b3V0XzEuYmxvYikoMzIpLCAoYikgPT4gbmV3IHdlYjNfanNfMS5QdWJsaWNLZXkoYiksIChrZXkpID0+IGtleS50b0J1ZmZlcigpLCBwcm9wZXJ0eSk7XG59XG5leHBvcnRzLnB1YmxpY0tleSA9IHB1YmxpY0tleTtcbmNsYXNzIE9wdGlvbkxheW91dCBleHRlbmRzIGJ1ZmZlcl9sYXlvdXRfMS5MYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKGxheW91dCwgcHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoLTEsIHByb3BlcnR5KTtcbiAgICAgICAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gICAgICAgIHRoaXMuZGlzY3JpbWluYXRvciA9ICgwLCBidWZmZXJfbGF5b3V0XzEudTgpKCk7XG4gICAgfVxuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgaWYgKHNyYyA9PT0gbnVsbCB8fCBzcmMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzY3JpbWluYXRvci5lbmNvZGUoMCwgYiwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc2NyaW1pbmF0b3IuZW5jb2RlKDEsIGIsIG9mZnNldCk7XG4gICAgICAgIHJldHVybiB0aGlzLmxheW91dC5lbmNvZGUoc3JjLCBiLCBvZmZzZXQgKyAxKSArIDE7XG4gICAgfVxuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3IgPSB0aGlzLmRpc2NyaW1pbmF0b3IuZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgICAgIGlmIChkaXNjcmltaW5hdG9yID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaXNjcmltaW5hdG9yID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYXlvdXQuZGVjb2RlKGIsIG9mZnNldCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgb3B0aW9uIFwiICsgdGhpcy5wcm9wZXJ0eSk7XG4gICAgfVxuICAgIGdldFNwYW4oYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yID0gdGhpcy5kaXNjcmltaW5hdG9yLmRlY29kZShiLCBvZmZzZXQpO1xuICAgICAgICBpZiAoZGlzY3JpbWluYXRvciA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGlzY3JpbWluYXRvciA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0LmdldFNwYW4oYiwgb2Zmc2V0ICsgMSkgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgb3B0aW9uIFwiICsgdGhpcy5wcm9wZXJ0eSk7XG4gICAgfVxufVxuZnVuY3Rpb24gb3B0aW9uKGxheW91dCwgcHJvcGVydHkpIHtcbiAgICByZXR1cm4gbmV3IE9wdGlvbkxheW91dChsYXlvdXQsIHByb3BlcnR5KTtcbn1cbmV4cG9ydHMub3B0aW9uID0gb3B0aW9uO1xuZnVuY3Rpb24gYm9vbChwcm9wZXJ0eSkge1xuICAgIHJldHVybiBuZXcgV3JhcHBlZExheW91dCgoMCwgYnVmZmVyX2xheW91dF8xLnU4KSgpLCBkZWNvZGVCb29sLCBlbmNvZGVCb29sLCBwcm9wZXJ0eSk7XG59XG5leHBvcnRzLmJvb2wgPSBib29sO1xuZnVuY3Rpb24gZGVjb2RlQm9vbCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlID09PSAxKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJvb2w6IFwiICsgdmFsdWUpO1xufVxuZnVuY3Rpb24gZW5jb2RlQm9vbCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA/IDEgOiAwO1xufVxuZnVuY3Rpb24gdmVjKGVsZW1lbnRMYXlvdXQsIHByb3BlcnR5KSB7XG4gICAgY29uc3QgbGVuZ3RoID0gKDAsIGJ1ZmZlcl9sYXlvdXRfMS51MzIpKFwibGVuZ3RoXCIpO1xuICAgIGNvbnN0IGxheW91dCA9ICgwLCBidWZmZXJfbGF5b3V0XzEuc3RydWN0KShbXG4gICAgICAgIGxlbmd0aCxcbiAgICAgICAgKDAsIGJ1ZmZlcl9sYXlvdXRfMS5zZXEpKGVsZW1lbnRMYXlvdXQsICgwLCBidWZmZXJfbGF5b3V0XzEub2Zmc2V0KShsZW5ndGgsIC1sZW5ndGguc3BhbiksIFwidmFsdWVzXCIpLFxuICAgIF0pO1xuICAgIHJldHVybiBuZXcgV3JhcHBlZExheW91dChsYXlvdXQsICh7IHZhbHVlcyB9KSA9PiB2YWx1ZXMsICh2YWx1ZXMpID0+ICh7IHZhbHVlcyB9KSwgcHJvcGVydHkpO1xufVxuZXhwb3J0cy52ZWMgPSB2ZWM7XG5mdW5jdGlvbiB0YWdnZWQodGFnLCBsYXlvdXQsIHByb3BlcnR5KSB7XG4gICAgY29uc3Qgd3JhcHBlZExheW91dCA9ICgwLCBidWZmZXJfbGF5b3V0XzEuc3RydWN0KShbXG4gICAgICAgIHU2NChcInRhZ1wiKSxcbiAgICAgICAgbGF5b3V0LnJlcGxpY2F0ZShcImRhdGFcIiksXG4gICAgXSk7XG4gICAgZnVuY3Rpb24gZGVjb2RlVGFnKHsgdGFnOiByZWNlaXZlZFRhZywgZGF0YSB9KSB7XG4gICAgICAgIGlmICghcmVjZWl2ZWRUYWcuZXEodGFnKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0YWcsIGV4cGVjdGVkOiBcIiArXG4gICAgICAgICAgICAgICAgdGFnLnRvU3RyaW5nKFwiaGV4XCIpICtcbiAgICAgICAgICAgICAgICBcIiwgZ290OiBcIiArXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWRUYWcudG9TdHJpbmcoXCJoZXhcIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFdyYXBwZWRMYXlvdXQod3JhcHBlZExheW91dCwgZGVjb2RlVGFnLCAoZGF0YSkgPT4gKHsgdGFnLCBkYXRhIH0pLCBwcm9wZXJ0eSk7XG59XG5leHBvcnRzLnRhZ2dlZCA9IHRhZ2dlZDtcbmZ1bmN0aW9uIHZlY1U4KHByb3BlcnR5KSB7XG4gICAgY29uc3QgbGVuZ3RoID0gKDAsIGJ1ZmZlcl9sYXlvdXRfMS51MzIpKFwibGVuZ3RoXCIpO1xuICAgIGNvbnN0IGxheW91dCA9ICgwLCBidWZmZXJfbGF5b3V0XzEuc3RydWN0KShbXG4gICAgICAgIGxlbmd0aCxcbiAgICAgICAgKDAsIGJ1ZmZlcl9sYXlvdXRfMS5ibG9iKSgoMCwgYnVmZmVyX2xheW91dF8xLm9mZnNldCkobGVuZ3RoLCAtbGVuZ3RoLnNwYW4pLCBcImRhdGFcIiksXG4gICAgXSk7XG4gICAgcmV0dXJuIG5ldyBXcmFwcGVkTGF5b3V0KGxheW91dCwgKHsgZGF0YSB9KSA9PiBkYXRhLCAoZGF0YSkgPT4gKHsgZGF0YSB9KSwgcHJvcGVydHkpO1xufVxuZXhwb3J0cy52ZWNVOCA9IHZlY1U4O1xuZnVuY3Rpb24gc3RyKHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIG5ldyBXcmFwcGVkTGF5b3V0KHZlY1U4KCksIChkYXRhKSA9PiBkYXRhLnRvU3RyaW5nKFwidXRmLThcIiksIChzKSA9PiBCdWZmZXIuZnJvbShzLCBcInV0Zi04XCIpLCBwcm9wZXJ0eSk7XG59XG5leHBvcnRzLnN0ciA9IHN0cjtcbmZ1bmN0aW9uIHJ1c3RFbnVtKHZhcmlhbnRzLCBwcm9wZXJ0eSwgZGlzY3JpbWluYW50KSB7XG4gICAgY29uc3QgdW5pb25MYXlvdXQgPSAoMCwgYnVmZmVyX2xheW91dF8xLnVuaW9uKShkaXNjcmltaW5hbnQgIT09IG51bGwgJiYgZGlzY3JpbWluYW50ICE9PSB2b2lkIDAgPyBkaXNjcmltaW5hbnQgOiAoMCwgYnVmZmVyX2xheW91dF8xLnU4KSgpLCBwcm9wZXJ0eSk7XG4gICAgdmFyaWFudHMuZm9yRWFjaCgodmFyaWFudCwgaW5kZXgpID0+IHVuaW9uTGF5b3V0LmFkZFZhcmlhbnQoaW5kZXgsIHZhcmlhbnQsIHZhcmlhbnQucHJvcGVydHkpKTtcbiAgICByZXR1cm4gdW5pb25MYXlvdXQ7XG59XG5leHBvcnRzLnJ1c3RFbnVtID0gcnVzdEVudW07XG5mdW5jdGlvbiBhcnJheShlbGVtZW50TGF5b3V0LCBsZW5ndGgsIHByb3BlcnR5KSB7XG4gICAgY29uc3QgbGF5b3V0ID0gKDAsIGJ1ZmZlcl9sYXlvdXRfMS5zdHJ1Y3QpKFtcbiAgICAgICAgKDAsIGJ1ZmZlcl9sYXlvdXRfMS5zZXEpKGVsZW1lbnRMYXlvdXQsIGxlbmd0aCwgXCJ2YWx1ZXNcIiksXG4gICAgXSk7XG4gICAgcmV0dXJuIG5ldyBXcmFwcGVkTGF5b3V0KGxheW91dCwgKHsgdmFsdWVzIH0pID0+IHZhbHVlcywgKHZhbHVlcykgPT4gKHsgdmFsdWVzIH0pLCBwcm9wZXJ0eSk7XG59XG5leHBvcnRzLmFycmF5ID0gYXJyYXk7XG5jbGFzcyBNYXBFbnRyeUxheW91dCBleHRlbmRzIGJ1ZmZlcl9sYXlvdXRfMS5MYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKGtleUxheW91dCwgdmFsdWVMYXlvdXQsIHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKGtleUxheW91dC5zcGFuICsgdmFsdWVMYXlvdXQuc3BhbiwgcHJvcGVydHkpO1xuICAgICAgICB0aGlzLmtleUxheW91dCA9IGtleUxheW91dDtcbiAgICAgICAgdGhpcy52YWx1ZUxheW91dCA9IHZhbHVlTGF5b3V0O1xuICAgIH1cbiAgICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmtleUxheW91dC5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnZhbHVlTGF5b3V0LmRlY29kZShiLCBvZmZzZXQgKyB0aGlzLmtleUxheW91dC5nZXRTcGFuKGIsIG9mZnNldCkpO1xuICAgICAgICByZXR1cm4gW2tleSwgdmFsdWVdO1xuICAgIH1cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgICAgIGNvbnN0IGtleUJ5dGVzID0gdGhpcy5rZXlMYXlvdXQuZW5jb2RlKHNyY1swXSwgYiwgb2Zmc2V0KTtcbiAgICAgICAgY29uc3QgdmFsdWVCeXRlcyA9IHRoaXMudmFsdWVMYXlvdXQuZW5jb2RlKHNyY1sxXSwgYiwgb2Zmc2V0ICsga2V5Qnl0ZXMpO1xuICAgICAgICByZXR1cm4ga2V5Qnl0ZXMgKyB2YWx1ZUJ5dGVzO1xuICAgIH1cbiAgICBnZXRTcGFuKGIsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gKHRoaXMua2V5TGF5b3V0LmdldFNwYW4oYiwgb2Zmc2V0KSArIHRoaXMudmFsdWVMYXlvdXQuZ2V0U3BhbihiLCBvZmZzZXQpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYXAoa2V5TGF5b3V0LCB2YWx1ZUxheW91dCwgcHJvcGVydHkpIHtcbiAgICBjb25zdCBsZW5ndGggPSAoMCwgYnVmZmVyX2xheW91dF8xLnUzMikoXCJsZW5ndGhcIik7XG4gICAgY29uc3QgbGF5b3V0ID0gKDAsIGJ1ZmZlcl9sYXlvdXRfMS5zdHJ1Y3QpKFtcbiAgICAgICAgbGVuZ3RoLFxuICAgICAgICAoMCwgYnVmZmVyX2xheW91dF8xLnNlcSkobmV3IE1hcEVudHJ5TGF5b3V0KGtleUxheW91dCwgdmFsdWVMYXlvdXQpLCAoMCwgYnVmZmVyX2xheW91dF8xLm9mZnNldCkobGVuZ3RoLCAtbGVuZ3RoLnNwYW4pLCBcInZhbHVlc1wiKSxcbiAgICBdKTtcbiAgICByZXR1cm4gbmV3IFdyYXBwZWRMYXlvdXQobGF5b3V0LCAoeyB2YWx1ZXMgfSkgPT4gbmV3IE1hcCh2YWx1ZXMpLCAodmFsdWVzKSA9PiAoeyB2YWx1ZXM6IEFycmF5LmZyb20odmFsdWVzLmVudHJpZXMoKSkgfSksIHByb3BlcnR5KTtcbn1cbmV4cG9ydHMubWFwID0gbWFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1hcCIsImFycmF5IiwicnVzdEVudW0iLCJzdHIiLCJ2ZWNVOCIsInRhZ2dlZCIsInZlYyIsImJvb2wiLCJvcHRpb24iLCJwdWJsaWNLZXkiLCJpMjU2IiwidTI1NiIsImkxMjgiLCJ1MTI4IiwiaTY0IiwidTY0Iiwic3RydWN0IiwiZjY0IiwiZjMyIiwiaTMyIiwidTMyIiwiaTE2IiwidTE2IiwiaTgiLCJ1OCIsImJ1ZmZlcl9sYXlvdXRfMSIsInJlcXVpcmUiLCJ3ZWIzX2pzXzEiLCJibl9qc18xIiwiYnVmZmVyX2xheW91dF8yIiwiZW51bWVyYWJsZSIsImdldCIsInM4IiwiczE2IiwiczMyIiwiQk5MYXlvdXQiLCJMYXlvdXQiLCJjb25zdHJ1Y3RvciIsInNwYW4iLCJzaWduZWQiLCJwcm9wZXJ0eSIsImJsb2IiLCJkZWNvZGUiLCJiIiwib2Zmc2V0IiwibnVtIiwiZGVmYXVsdCIsImZyb21Ud29zIiwiY2xvbmUiLCJlbmNvZGUiLCJzcmMiLCJ0b1R3b3MiLCJ0b0FycmF5TGlrZSIsIkJ1ZmZlciIsIldyYXBwZWRMYXlvdXQiLCJsYXlvdXQiLCJkZWNvZGVyIiwiZW5jb2RlciIsImdldFNwYW4iLCJQdWJsaWNLZXkiLCJrZXkiLCJ0b0J1ZmZlciIsIk9wdGlvbkxheW91dCIsImRpc2NyaW1pbmF0b3IiLCJ1bmRlZmluZWQiLCJFcnJvciIsImRlY29kZUJvb2wiLCJlbmNvZGVCb29sIiwiZWxlbWVudExheW91dCIsImxlbmd0aCIsInNlcSIsInZhbHVlcyIsInRhZyIsIndyYXBwZWRMYXlvdXQiLCJyZXBsaWNhdGUiLCJkZWNvZGVUYWciLCJyZWNlaXZlZFRhZyIsImRhdGEiLCJlcSIsInRvU3RyaW5nIiwicyIsImZyb20iLCJ2YXJpYW50cyIsImRpc2NyaW1pbmFudCIsInVuaW9uTGF5b3V0IiwidW5pb24iLCJmb3JFYWNoIiwidmFyaWFudCIsImluZGV4IiwiYWRkVmFyaWFudCIsIk1hcEVudHJ5TGF5b3V0Iiwia2V5TGF5b3V0IiwidmFsdWVMYXlvdXQiLCJrZXlCeXRlcyIsInZhbHVlQnl0ZXMiLCJNYXAiLCJBcnJheSIsImVudHJpZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/node_modules/@coral-xyz/borsh/dist/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/node_modules/@solana/web3.js/lib/index.esm.js":
/*!***************************************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/node_modules/@solana/web3.js/lib/index.esm.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Account: () => (/* binding */ Account),\n/* harmony export */   AddressLookupTableAccount: () => (/* binding */ AddressLookupTableAccount),\n/* harmony export */   AddressLookupTableInstruction: () => (/* binding */ AddressLookupTableInstruction),\n/* harmony export */   AddressLookupTableProgram: () => (/* binding */ AddressLookupTableProgram),\n/* harmony export */   Authorized: () => (/* binding */ Authorized),\n/* harmony export */   BLOCKHASH_CACHE_TIMEOUT_MS: () => (/* binding */ BLOCKHASH_CACHE_TIMEOUT_MS),\n/* harmony export */   BPF_LOADER_DEPRECATED_PROGRAM_ID: () => (/* binding */ BPF_LOADER_DEPRECATED_PROGRAM_ID),\n/* harmony export */   BPF_LOADER_PROGRAM_ID: () => (/* binding */ BPF_LOADER_PROGRAM_ID),\n/* harmony export */   BpfLoader: () => (/* binding */ BpfLoader),\n/* harmony export */   COMPUTE_BUDGET_INSTRUCTION_LAYOUTS: () => (/* binding */ COMPUTE_BUDGET_INSTRUCTION_LAYOUTS),\n/* harmony export */   ComputeBudgetInstruction: () => (/* binding */ ComputeBudgetInstruction),\n/* harmony export */   ComputeBudgetProgram: () => (/* binding */ ComputeBudgetProgram),\n/* harmony export */   Connection: () => (/* binding */ Connection),\n/* harmony export */   Ed25519Program: () => (/* binding */ Ed25519Program),\n/* harmony export */   Enum: () => (/* binding */ Enum),\n/* harmony export */   EpochSchedule: () => (/* binding */ EpochSchedule),\n/* harmony export */   FeeCalculatorLayout: () => (/* binding */ FeeCalculatorLayout),\n/* harmony export */   Keypair: () => (/* binding */ Keypair),\n/* harmony export */   LAMPORTS_PER_SOL: () => (/* binding */ LAMPORTS_PER_SOL),\n/* harmony export */   LOOKUP_TABLE_INSTRUCTION_LAYOUTS: () => (/* binding */ LOOKUP_TABLE_INSTRUCTION_LAYOUTS),\n/* harmony export */   Loader: () => (/* binding */ Loader),\n/* harmony export */   Lockup: () => (/* binding */ Lockup),\n/* harmony export */   MAX_SEED_LENGTH: () => (/* binding */ MAX_SEED_LENGTH),\n/* harmony export */   Message: () => (/* binding */ Message),\n/* harmony export */   MessageAccountKeys: () => (/* binding */ MessageAccountKeys),\n/* harmony export */   MessageV0: () => (/* binding */ MessageV0),\n/* harmony export */   NONCE_ACCOUNT_LENGTH: () => (/* binding */ NONCE_ACCOUNT_LENGTH),\n/* harmony export */   NonceAccount: () => (/* binding */ NonceAccount),\n/* harmony export */   PACKET_DATA_SIZE: () => (/* binding */ PACKET_DATA_SIZE),\n/* harmony export */   PUBLIC_KEY_LENGTH: () => (/* binding */ PUBLIC_KEY_LENGTH),\n/* harmony export */   PublicKey: () => (/* binding */ PublicKey),\n/* harmony export */   SIGNATURE_LENGTH_IN_BYTES: () => (/* binding */ SIGNATURE_LENGTH_IN_BYTES),\n/* harmony export */   SOLANA_SCHEMA: () => (/* binding */ SOLANA_SCHEMA),\n/* harmony export */   STAKE_CONFIG_ID: () => (/* binding */ STAKE_CONFIG_ID),\n/* harmony export */   STAKE_INSTRUCTION_LAYOUTS: () => (/* binding */ STAKE_INSTRUCTION_LAYOUTS),\n/* harmony export */   SYSTEM_INSTRUCTION_LAYOUTS: () => (/* binding */ SYSTEM_INSTRUCTION_LAYOUTS),\n/* harmony export */   SYSVAR_CLOCK_PUBKEY: () => (/* binding */ SYSVAR_CLOCK_PUBKEY),\n/* harmony export */   SYSVAR_EPOCH_SCHEDULE_PUBKEY: () => (/* binding */ SYSVAR_EPOCH_SCHEDULE_PUBKEY),\n/* harmony export */   SYSVAR_INSTRUCTIONS_PUBKEY: () => (/* binding */ SYSVAR_INSTRUCTIONS_PUBKEY),\n/* harmony export */   SYSVAR_RECENT_BLOCKHASHES_PUBKEY: () => (/* binding */ SYSVAR_RECENT_BLOCKHASHES_PUBKEY),\n/* harmony export */   SYSVAR_RENT_PUBKEY: () => (/* binding */ SYSVAR_RENT_PUBKEY),\n/* harmony export */   SYSVAR_REWARDS_PUBKEY: () => (/* binding */ SYSVAR_REWARDS_PUBKEY),\n/* harmony export */   SYSVAR_SLOT_HASHES_PUBKEY: () => (/* binding */ SYSVAR_SLOT_HASHES_PUBKEY),\n/* harmony export */   SYSVAR_SLOT_HISTORY_PUBKEY: () => (/* binding */ SYSVAR_SLOT_HISTORY_PUBKEY),\n/* harmony export */   SYSVAR_STAKE_HISTORY_PUBKEY: () => (/* binding */ SYSVAR_STAKE_HISTORY_PUBKEY),\n/* harmony export */   Secp256k1Program: () => (/* binding */ Secp256k1Program),\n/* harmony export */   SendTransactionError: () => (/* binding */ SendTransactionError),\n/* harmony export */   SolanaJSONRPCError: () => (/* binding */ SolanaJSONRPCError),\n/* harmony export */   SolanaJSONRPCErrorCode: () => (/* binding */ SolanaJSONRPCErrorCode),\n/* harmony export */   StakeAuthorizationLayout: () => (/* binding */ StakeAuthorizationLayout),\n/* harmony export */   StakeInstruction: () => (/* binding */ StakeInstruction),\n/* harmony export */   StakeProgram: () => (/* binding */ StakeProgram),\n/* harmony export */   Struct: () => (/* binding */ Struct),\n/* harmony export */   SystemInstruction: () => (/* binding */ SystemInstruction),\n/* harmony export */   SystemProgram: () => (/* binding */ SystemProgram),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   TransactionExpiredBlockheightExceededError: () => (/* binding */ TransactionExpiredBlockheightExceededError),\n/* harmony export */   TransactionExpiredNonceInvalidError: () => (/* binding */ TransactionExpiredNonceInvalidError),\n/* harmony export */   TransactionExpiredTimeoutError: () => (/* binding */ TransactionExpiredTimeoutError),\n/* harmony export */   TransactionInstruction: () => (/* binding */ TransactionInstruction),\n/* harmony export */   TransactionMessage: () => (/* binding */ TransactionMessage),\n/* harmony export */   TransactionStatus: () => (/* binding */ TransactionStatus),\n/* harmony export */   VALIDATOR_INFO_KEY: () => (/* binding */ VALIDATOR_INFO_KEY),\n/* harmony export */   VERSION_PREFIX_MASK: () => (/* binding */ VERSION_PREFIX_MASK),\n/* harmony export */   VOTE_PROGRAM_ID: () => (/* binding */ VOTE_PROGRAM_ID),\n/* harmony export */   ValidatorInfo: () => (/* binding */ ValidatorInfo),\n/* harmony export */   VersionedMessage: () => (/* binding */ VersionedMessage),\n/* harmony export */   VersionedTransaction: () => (/* binding */ VersionedTransaction),\n/* harmony export */   VoteAccount: () => (/* binding */ VoteAccount),\n/* harmony export */   VoteAuthorizationLayout: () => (/* binding */ VoteAuthorizationLayout),\n/* harmony export */   VoteInit: () => (/* binding */ VoteInit),\n/* harmony export */   VoteInstruction: () => (/* binding */ VoteInstruction),\n/* harmony export */   VoteProgram: () => (/* binding */ VoteProgram),\n/* harmony export */   clusterApiUrl: () => (/* binding */ clusterApiUrl),\n/* harmony export */   sendAndConfirmRawTransaction: () => (/* binding */ sendAndConfirmRawTransaction),\n/* harmony export */   sendAndConfirmTransaction: () => (/* binding */ sendAndConfirmTransaction)\n/* harmony export */ });\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(buffer__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @noble/curves/ed25519 */ \"(ssr)/../node_modules/@noble/curves/esm/ed25519.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bn.js */ \"(ssr)/../node_modules/bn.js/lib/bn.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(bn_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bs58 */ \"(ssr)/../node_modules/@coral-xyz/anchor/node_modules/bs58/index.js\");\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(bs58__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/../node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var borsh__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! borsh */ \"(ssr)/../node_modules/borsh/lib/index.js\");\n/* harmony import */ var borsh__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(borsh__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @solana/buffer-layout */ \"(ssr)/../node_modules/@solana/buffer-layout/lib/Layout.js\");\n/* harmony import */ var bigint_buffer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! bigint-buffer */ \"(ssr)/../node_modules/bigint-buffer/dist/node.js\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! http */ \"http\");\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(http__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! https */ \"https\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(https__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var superstruct__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! superstruct */ \"(ssr)/../node_modules/@coral-xyz/anchor/node_modules/@solana/web3.js/node_modules/superstruct/dist/index.mjs\");\n/* harmony import */ var jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! jayson/lib/client/browser */ \"(ssr)/../node_modules/jayson/lib/client/browser/index.js\");\n/* harmony import */ var jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! node-fetch */ \"(ssr)/../node_modules/node-fetch/lib/index.mjs\");\n/* harmony import */ var rpc_websockets__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! rpc-websockets */ \"(ssr)/../node_modules/@coral-xyz/anchor/node_modules/rpc-websockets/dist/index.mjs\");\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/../node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/../node_modules/@noble/curves/esm/secp256k1.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * A 64 byte secret key, the first 32 bytes of which is the\n * private scalar and the last 32 bytes is the public key.\n * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/\n */ /**\n * Ed25519 Keypair\n */ const generatePrivateKey = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_12__.ed25519.utils.randomPrivateKey;\nconst generateKeypair = ()=>{\n    const privateScalar = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_12__.ed25519.utils.randomPrivateKey();\n    const publicKey = getPublicKey(privateScalar);\n    const secretKey = new Uint8Array(64);\n    secretKey.set(privateScalar);\n    secretKey.set(publicKey, 32);\n    return {\n        publicKey,\n        secretKey\n    };\n};\nconst getPublicKey = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_12__.ed25519.getPublicKey;\nfunction isOnCurve(publicKey) {\n    try {\n        _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_12__.ed25519.ExtendedPoint.fromHex(publicKey);\n        return true;\n    } catch  {\n        return false;\n    }\n}\nconst sign = (message, secretKey)=>_noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_12__.ed25519.sign(message, secretKey.slice(0, 32));\nconst verify = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_12__.ed25519.verify;\nconst toBuffer = (arr)=>{\n    if (buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.isBuffer(arr)) {\n        return arr;\n    } else if (arr instanceof Uint8Array) {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);\n    } else {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(arr);\n    }\n};\n// Class wrapping a plain object\nclass Struct {\n    constructor(properties){\n        Object.assign(this, properties);\n    }\n    encode() {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from((0,borsh__WEBPACK_IMPORTED_MODULE_3__.serialize)(SOLANA_SCHEMA, this));\n    }\n    static decode(data) {\n        return (0,borsh__WEBPACK_IMPORTED_MODULE_3__.deserialize)(SOLANA_SCHEMA, this, data);\n    }\n    static decodeUnchecked(data) {\n        return (0,borsh__WEBPACK_IMPORTED_MODULE_3__.deserializeUnchecked)(SOLANA_SCHEMA, this, data);\n    }\n}\n// Class representing a Rust-compatible enum, since enums are only strings or\n// numbers in pure JS\nclass Enum extends Struct {\n    constructor(properties){\n        super(properties);\n        this.enum = \"\";\n        if (Object.keys(properties).length !== 1) {\n            throw new Error(\"Enum can only take single value\");\n        }\n        Object.keys(properties).map((key)=>{\n            this.enum = key;\n        });\n    }\n}\nconst SOLANA_SCHEMA = new Map();\nvar _PublicKey;\n/**\n * Maximum length of derived pubkey seed\n */ const MAX_SEED_LENGTH = 32;\n/**\n * Size of public key in bytes\n */ const PUBLIC_KEY_LENGTH = 32;\n/**\n * Value to be converted into public key\n */ /**\n * JSON object representation of PublicKey class\n */ function isPublicKeyData(value) {\n    return value._bn !== undefined;\n}\n// local counter used by PublicKey.unique()\nlet uniquePublicKeyCounter = 1;\n/**\n * A public key\n */ class PublicKey extends Struct {\n    /**\n   * Create a new PublicKey object\n   * @param value ed25519 public key as buffer or base-58 encoded string\n   */ constructor(value){\n        super({});\n        /** @internal */ this._bn = void 0;\n        if (isPublicKeyData(value)) {\n            this._bn = value._bn;\n        } else {\n            if (typeof value === \"string\") {\n                // assume base 58 encoding by default\n                const decoded = bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(value);\n                if (decoded.length != PUBLIC_KEY_LENGTH) {\n                    throw new Error(`Invalid public key input`);\n                }\n                this._bn = new (bn_js__WEBPACK_IMPORTED_MODULE_1___default())(decoded);\n            } else {\n                this._bn = new (bn_js__WEBPACK_IMPORTED_MODULE_1___default())(value);\n            }\n            if (this._bn.byteLength() > PUBLIC_KEY_LENGTH) {\n                throw new Error(`Invalid public key input`);\n            }\n        }\n    }\n    /**\n   * Returns a unique PublicKey for tests and benchmarks using a counter\n   */ static unique() {\n        const key = new PublicKey(uniquePublicKeyCounter);\n        uniquePublicKeyCounter += 1;\n        return new PublicKey(key.toBuffer());\n    }\n    /**\n   * Default public key value. The base58-encoded string representation is all ones (as seen below)\n   * The underlying BN number is 32 bytes that are all zeros\n   */ /**\n   * Checks if two publicKeys are equal\n   */ equals(publicKey) {\n        return this._bn.eq(publicKey._bn);\n    }\n    /**\n   * Return the base-58 representation of the public key\n   */ toBase58() {\n        return bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(this.toBytes());\n    }\n    toJSON() {\n        return this.toBase58();\n    }\n    /**\n   * Return the byte array representation of the public key in big endian\n   */ toBytes() {\n        const buf = this.toBuffer();\n        return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n    }\n    /**\n   * Return the Buffer representation of the public key in big endian\n   */ toBuffer() {\n        const b = this._bn.toArrayLike(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer);\n        if (b.length === PUBLIC_KEY_LENGTH) {\n            return b;\n        }\n        const zeroPad = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(32);\n        b.copy(zeroPad, 32 - b.length);\n        return zeroPad;\n    }\n    get [Symbol.toStringTag]() {\n        return `PublicKey(${this.toString()})`;\n    }\n    /**\n   * Return the base-58 representation of the public key\n   */ toString() {\n        return this.toBase58();\n    }\n    /**\n   * Derive a public key from another key, a seed, and a program ID.\n   * The program ID will also serve as the owner of the public key, giving\n   * it permission to write data to the account.\n   */ /* eslint-disable require-await */ static async createWithSeed(fromPublicKey, seed, programId) {\n        const buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([\n            fromPublicKey.toBuffer(),\n            buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(seed),\n            programId.toBuffer()\n        ]);\n        const publicKeyBytes = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_13__.sha256)(buffer);\n        return new PublicKey(publicKeyBytes);\n    }\n    /**\n   * Derive a program address from seeds and a program ID.\n   */ /* eslint-disable require-await */ static createProgramAddressSync(seeds, programId) {\n        let buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(0);\n        seeds.forEach(function(seed) {\n            if (seed.length > MAX_SEED_LENGTH) {\n                throw new TypeError(`Max seed length exceeded`);\n            }\n            buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([\n                buffer,\n                toBuffer(seed)\n            ]);\n        });\n        buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([\n            buffer,\n            programId.toBuffer(),\n            buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(\"ProgramDerivedAddress\")\n        ]);\n        const publicKeyBytes = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_13__.sha256)(buffer);\n        if (isOnCurve(publicKeyBytes)) {\n            throw new Error(`Invalid seeds, address must fall off the curve`);\n        }\n        return new PublicKey(publicKeyBytes);\n    }\n    /**\n   * Async version of createProgramAddressSync\n   * For backwards compatibility\n   *\n   * @deprecated Use {@link createProgramAddressSync} instead\n   */ /* eslint-disable require-await */ static async createProgramAddress(seeds, programId) {\n        return this.createProgramAddressSync(seeds, programId);\n    }\n    /**\n   * Find a valid program address\n   *\n   * Valid program addresses must fall off the ed25519 curve.  This function\n   * iterates a nonce until it finds one that when combined with the seeds\n   * results in a valid program address.\n   */ static findProgramAddressSync(seeds, programId) {\n        let nonce = 255;\n        let address;\n        while(nonce != 0){\n            try {\n                const seedsWithNonce = seeds.concat(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([\n                    nonce\n                ]));\n                address = this.createProgramAddressSync(seedsWithNonce, programId);\n            } catch (err) {\n                if (err instanceof TypeError) {\n                    throw err;\n                }\n                nonce--;\n                continue;\n            }\n            return [\n                address,\n                nonce\n            ];\n        }\n        throw new Error(`Unable to find a viable program address nonce`);\n    }\n    /**\n   * Async version of findProgramAddressSync\n   * For backwards compatibility\n   *\n   * @deprecated Use {@link findProgramAddressSync} instead\n   */ static async findProgramAddress(seeds, programId) {\n        return this.findProgramAddressSync(seeds, programId);\n    }\n    /**\n   * Check that a pubkey is on the ed25519 curve.\n   */ static isOnCurve(pubkeyData) {\n        const pubkey = new PublicKey(pubkeyData);\n        return isOnCurve(pubkey.toBytes());\n    }\n}\n_PublicKey = PublicKey;\nPublicKey.default = new _PublicKey(\"11111111111111111111111111111111\");\nSOLANA_SCHEMA.set(PublicKey, {\n    kind: \"struct\",\n    fields: [\n        [\n            \"_bn\",\n            \"u256\"\n        ]\n    ]\n});\n/**\n * An account key pair (public and secret keys).\n *\n * @deprecated since v1.10.0, please use {@link Keypair} instead.\n */ class Account {\n    /**\n   * Create a new Account object\n   *\n   * If the secretKey parameter is not provided a new key pair is randomly\n   * created for the account\n   *\n   * @param secretKey Secret key for the account\n   */ constructor(secretKey){\n        /** @internal */ this._publicKey = void 0;\n        /** @internal */ this._secretKey = void 0;\n        if (secretKey) {\n            const secretKeyBuffer = toBuffer(secretKey);\n            if (secretKey.length !== 64) {\n                throw new Error(\"bad secret key size\");\n            }\n            this._publicKey = secretKeyBuffer.slice(32, 64);\n            this._secretKey = secretKeyBuffer.slice(0, 32);\n        } else {\n            this._secretKey = toBuffer(generatePrivateKey());\n            this._publicKey = toBuffer(getPublicKey(this._secretKey));\n        }\n    }\n    /**\n   * The public key for this account\n   */ get publicKey() {\n        return new PublicKey(this._publicKey);\n    }\n    /**\n   * The **unencrypted** secret key for this account. The first 32 bytes\n   * is the private scalar and the last 32 bytes is the public key.\n   * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/\n   */ get secretKey() {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([\n            this._secretKey,\n            this._publicKey\n        ], 64);\n    }\n}\nconst BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey(\"BPFLoader1111111111111111111111111111111111\");\n/**\n * Maximum over-the-wire size of a Transaction\n *\n * 1280 is IPv6 minimum MTU\n * 40 bytes is the size of the IPv6 header\n * 8 bytes is the size of the fragment header\n */ const PACKET_DATA_SIZE = 1280 - 40 - 8;\nconst VERSION_PREFIX_MASK = 0x7f;\nconst SIGNATURE_LENGTH_IN_BYTES = 64;\nclass TransactionExpiredBlockheightExceededError extends Error {\n    constructor(signature){\n        super(`Signature ${signature} has expired: block height exceeded.`);\n        this.signature = void 0;\n        this.signature = signature;\n    }\n}\nObject.defineProperty(TransactionExpiredBlockheightExceededError.prototype, \"name\", {\n    value: \"TransactionExpiredBlockheightExceededError\"\n});\nclass TransactionExpiredTimeoutError extends Error {\n    constructor(signature, timeoutSeconds){\n        super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is ` + \"unknown if it succeeded or failed. Check signature \" + `${signature} using the Solana Explorer or CLI tools.`);\n        this.signature = void 0;\n        this.signature = signature;\n    }\n}\nObject.defineProperty(TransactionExpiredTimeoutError.prototype, \"name\", {\n    value: \"TransactionExpiredTimeoutError\"\n});\nclass TransactionExpiredNonceInvalidError extends Error {\n    constructor(signature){\n        super(`Signature ${signature} has expired: the nonce is no longer valid.`);\n        this.signature = void 0;\n        this.signature = signature;\n    }\n}\nObject.defineProperty(TransactionExpiredNonceInvalidError.prototype, \"name\", {\n    value: \"TransactionExpiredNonceInvalidError\"\n});\nclass MessageAccountKeys {\n    constructor(staticAccountKeys, accountKeysFromLookups){\n        this.staticAccountKeys = void 0;\n        this.accountKeysFromLookups = void 0;\n        this.staticAccountKeys = staticAccountKeys;\n        this.accountKeysFromLookups = accountKeysFromLookups;\n    }\n    keySegments() {\n        const keySegments = [\n            this.staticAccountKeys\n        ];\n        if (this.accountKeysFromLookups) {\n            keySegments.push(this.accountKeysFromLookups.writable);\n            keySegments.push(this.accountKeysFromLookups.readonly);\n        }\n        return keySegments;\n    }\n    get(index) {\n        for (const keySegment of this.keySegments()){\n            if (index < keySegment.length) {\n                return keySegment[index];\n            } else {\n                index -= keySegment.length;\n            }\n        }\n        return;\n    }\n    get length() {\n        return this.keySegments().flat().length;\n    }\n    compileInstructions(instructions) {\n        // Bail early if any account indexes would overflow a u8\n        const U8_MAX = 255;\n        if (this.length > U8_MAX + 1) {\n            throw new Error(\"Account index overflow encountered during compilation\");\n        }\n        const keyIndexMap = new Map();\n        this.keySegments().flat().forEach((key, index)=>{\n            keyIndexMap.set(key.toBase58(), index);\n        });\n        const findKeyIndex = (key)=>{\n            const keyIndex = keyIndexMap.get(key.toBase58());\n            if (keyIndex === undefined) throw new Error(\"Encountered an unknown instruction account key during compilation\");\n            return keyIndex;\n        };\n        return instructions.map((instruction)=>{\n            return {\n                programIdIndex: findKeyIndex(instruction.programId),\n                accountKeyIndexes: instruction.keys.map((meta)=>findKeyIndex(meta.pubkey)),\n                data: instruction.data\n            };\n        });\n    }\n}\n/**\n * Layout for a public key\n */ const publicKey = (property = \"publicKey\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(32, property);\n};\n/**\n * Layout for a signature\n */ const signature = (property = \"signature\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(64, property);\n};\n/**\n * Layout for a Rust String type\n */ const rustString = (property = \"string\")=>{\n    const rsl = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"length\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"lengthPadding\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"chars\")\n    ], property);\n    const _decode = rsl.decode.bind(rsl);\n    const _encode = rsl.encode.bind(rsl);\n    const rslShim = rsl;\n    rslShim.decode = (b, offset)=>{\n        const data = _decode(b, offset);\n        return data[\"chars\"].toString();\n    };\n    rslShim.encode = (str, b, offset)=>{\n        const data = {\n            chars: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(str, \"utf8\")\n        };\n        return _encode(data, b, offset);\n    };\n    rslShim.alloc = (str)=>{\n        return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32().span + _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32().span + buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(str, \"utf8\").length;\n    };\n    return rslShim;\n};\n/**\n * Layout for an Authorized object\n */ const authorized = (property = \"authorized\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        publicKey(\"staker\"),\n        publicKey(\"withdrawer\")\n    ], property);\n};\n/**\n * Layout for a Lockup object\n */ const lockup = (property = \"lockup\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"unixTimestamp\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"epoch\"),\n        publicKey(\"custodian\")\n    ], property);\n};\n/**\n *  Layout for a VoteInit object\n */ const voteInit = (property = \"voteInit\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        publicKey(\"nodePubkey\"),\n        publicKey(\"authorizedVoter\"),\n        publicKey(\"authorizedWithdrawer\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"commission\")\n    ], property);\n};\n/**\n *  Layout for a VoteAuthorizeWithSeedArgs object\n */ const voteAuthorizeWithSeedArgs = (property = \"voteAuthorizeWithSeedArgs\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"voteAuthorizationType\"),\n        publicKey(\"currentAuthorityDerivedKeyOwnerPubkey\"),\n        rustString(\"currentAuthorityDerivedKeySeed\"),\n        publicKey(\"newAuthorized\")\n    ], property);\n};\nfunction getAlloc(type, fields) {\n    const getItemAlloc = (item)=>{\n        if (item.span >= 0) {\n            return item.span;\n        } else if (typeof item.alloc === \"function\") {\n            return item.alloc(fields[item.property]);\n        } else if (\"count\" in item && \"elementLayout\" in item) {\n            const field = fields[item.property];\n            if (Array.isArray(field)) {\n                return field.length * getItemAlloc(item.elementLayout);\n            }\n        } else if (\"fields\" in item) {\n            // This is a `Structure` whose size needs to be recursively measured.\n            return getAlloc({\n                layout: item\n            }, fields[item.property]);\n        }\n        // Couldn't determine allocated size of layout\n        return 0;\n    };\n    let alloc = 0;\n    type.layout.fields.forEach((item)=>{\n        alloc += getItemAlloc(item);\n    });\n    return alloc;\n}\nfunction decodeLength(bytes) {\n    let len = 0;\n    let size = 0;\n    for(;;){\n        let elem = bytes.shift();\n        len |= (elem & 0x7f) << size * 7;\n        size += 1;\n        if ((elem & 0x80) === 0) {\n            break;\n        }\n    }\n    return len;\n}\nfunction encodeLength(bytes, len) {\n    let rem_len = len;\n    for(;;){\n        let elem = rem_len & 0x7f;\n        rem_len >>= 7;\n        if (rem_len == 0) {\n            bytes.push(elem);\n            break;\n        } else {\n            elem |= 0x80;\n            bytes.push(elem);\n        }\n    }\n}\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(message || \"Assertion failed\");\n    }\n}\nclass CompiledKeys {\n    constructor(payer, keyMetaMap){\n        this.payer = void 0;\n        this.keyMetaMap = void 0;\n        this.payer = payer;\n        this.keyMetaMap = keyMetaMap;\n    }\n    static compile(instructions, payer) {\n        const keyMetaMap = new Map();\n        const getOrInsertDefault = (pubkey)=>{\n            const address = pubkey.toBase58();\n            let keyMeta = keyMetaMap.get(address);\n            if (keyMeta === undefined) {\n                keyMeta = {\n                    isSigner: false,\n                    isWritable: false,\n                    isInvoked: false\n                };\n                keyMetaMap.set(address, keyMeta);\n            }\n            return keyMeta;\n        };\n        const payerKeyMeta = getOrInsertDefault(payer);\n        payerKeyMeta.isSigner = true;\n        payerKeyMeta.isWritable = true;\n        for (const ix of instructions){\n            getOrInsertDefault(ix.programId).isInvoked = true;\n            for (const accountMeta of ix.keys){\n                const keyMeta = getOrInsertDefault(accountMeta.pubkey);\n                keyMeta.isSigner ||= accountMeta.isSigner;\n                keyMeta.isWritable ||= accountMeta.isWritable;\n            }\n        }\n        return new CompiledKeys(payer, keyMetaMap);\n    }\n    getMessageComponents() {\n        const mapEntries = [\n            ...this.keyMetaMap.entries()\n        ];\n        assert(mapEntries.length <= 256, \"Max static account keys length exceeded\");\n        const writableSigners = mapEntries.filter(([, meta])=>meta.isSigner && meta.isWritable);\n        const readonlySigners = mapEntries.filter(([, meta])=>meta.isSigner && !meta.isWritable);\n        const writableNonSigners = mapEntries.filter(([, meta])=>!meta.isSigner && meta.isWritable);\n        const readonlyNonSigners = mapEntries.filter(([, meta])=>!meta.isSigner && !meta.isWritable);\n        const header = {\n            numRequiredSignatures: writableSigners.length + readonlySigners.length,\n            numReadonlySignedAccounts: readonlySigners.length,\n            numReadonlyUnsignedAccounts: readonlyNonSigners.length\n        };\n        // sanity checks\n        {\n            assert(writableSigners.length > 0, \"Expected at least one writable signer key\");\n            const [payerAddress] = writableSigners[0];\n            assert(payerAddress === this.payer.toBase58(), \"Expected first writable signer key to be the fee payer\");\n        }\n        const staticAccountKeys = [\n            ...writableSigners.map(([address])=>new PublicKey(address)),\n            ...readonlySigners.map(([address])=>new PublicKey(address)),\n            ...writableNonSigners.map(([address])=>new PublicKey(address)),\n            ...readonlyNonSigners.map(([address])=>new PublicKey(address))\n        ];\n        return [\n            header,\n            staticAccountKeys\n        ];\n    }\n    extractTableLookup(lookupTable) {\n        const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta)=>!keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);\n        const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta)=>!keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);\n        // Don't extract lookup if no keys were found\n        if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {\n            return;\n        }\n        return [\n            {\n                accountKey: lookupTable.key,\n                writableIndexes,\n                readonlyIndexes\n            },\n            {\n                writable: drainedWritableKeys,\n                readonly: drainedReadonlyKeys\n            }\n        ];\n    }\n    /** @internal */ drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {\n        const lookupTableIndexes = new Array();\n        const drainedKeys = new Array();\n        for (const [address, keyMeta] of this.keyMetaMap.entries()){\n            if (keyMetaFilter(keyMeta)) {\n                const key = new PublicKey(address);\n                const lookupTableIndex = lookupTableEntries.findIndex((entry)=>entry.equals(key));\n                if (lookupTableIndex >= 0) {\n                    assert(lookupTableIndex < 256, \"Max lookup table index exceeded\");\n                    lookupTableIndexes.push(lookupTableIndex);\n                    drainedKeys.push(key);\n                    this.keyMetaMap.delete(address);\n                }\n            }\n        }\n        return [\n            lookupTableIndexes,\n            drainedKeys\n        ];\n    }\n}\nconst END_OF_BUFFER_ERROR_MESSAGE = \"Reached end of buffer unexpectedly\";\n/**\n * Delegates to `Array#shift`, but throws if the array is zero-length.\n */ function guardedShift(byteArray) {\n    if (byteArray.length === 0) {\n        throw new Error(END_OF_BUFFER_ERROR_MESSAGE);\n    }\n    return byteArray.shift();\n}\n/**\n * Delegates to `Array#splice`, but throws if the section being spliced out extends past the end of\n * the array.\n */ function guardedSplice(byteArray, ...args) {\n    const [start] = args;\n    if (args.length === 2 // Implies that `deleteCount` was supplied\n     ? start + (args[1] ?? 0) > byteArray.length : start >= byteArray.length) {\n        throw new Error(END_OF_BUFFER_ERROR_MESSAGE);\n    }\n    return byteArray.splice(...args);\n}\n/**\n * An instruction to execute by a program\n *\n * @property {number} programIdIndex\n * @property {number[]} accounts\n * @property {string} data\n */ /**\n * Message constructor arguments\n */ /**\n * List of instructions to be processed atomically\n */ class Message {\n    constructor(args){\n        this.header = void 0;\n        this.accountKeys = void 0;\n        this.recentBlockhash = void 0;\n        this.instructions = void 0;\n        this.indexToProgramIds = new Map();\n        this.header = args.header;\n        this.accountKeys = args.accountKeys.map((account)=>new PublicKey(account));\n        this.recentBlockhash = args.recentBlockhash;\n        this.instructions = args.instructions;\n        this.instructions.forEach((ix)=>this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));\n    }\n    get version() {\n        return \"legacy\";\n    }\n    get staticAccountKeys() {\n        return this.accountKeys;\n    }\n    get compiledInstructions() {\n        return this.instructions.map((ix)=>({\n                programIdIndex: ix.programIdIndex,\n                accountKeyIndexes: ix.accounts,\n                data: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(ix.data)\n            }));\n    }\n    get addressTableLookups() {\n        return [];\n    }\n    getAccountKeys() {\n        return new MessageAccountKeys(this.staticAccountKeys);\n    }\n    static compile(args) {\n        const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);\n        const [header, staticAccountKeys] = compiledKeys.getMessageComponents();\n        const accountKeys = new MessageAccountKeys(staticAccountKeys);\n        const instructions = accountKeys.compileInstructions(args.instructions).map((ix)=>({\n                programIdIndex: ix.programIdIndex,\n                accounts: ix.accountKeyIndexes,\n                data: bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(ix.data)\n            }));\n        return new Message({\n            header,\n            accountKeys: staticAccountKeys,\n            recentBlockhash: args.recentBlockhash,\n            instructions\n        });\n    }\n    isAccountSigner(index) {\n        return index < this.header.numRequiredSignatures;\n    }\n    isAccountWritable(index) {\n        const numSignedAccounts = this.header.numRequiredSignatures;\n        if (index >= this.header.numRequiredSignatures) {\n            const unsignedAccountIndex = index - numSignedAccounts;\n            const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;\n            const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;\n            return unsignedAccountIndex < numWritableUnsignedAccounts;\n        } else {\n            const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;\n            return index < numWritableSignedAccounts;\n        }\n    }\n    isProgramId(index) {\n        return this.indexToProgramIds.has(index);\n    }\n    programIds() {\n        return [\n            ...this.indexToProgramIds.values()\n        ];\n    }\n    nonProgramIds() {\n        return this.accountKeys.filter((_, index)=>!this.isProgramId(index));\n    }\n    serialize() {\n        const numKeys = this.accountKeys.length;\n        let keyCount = [];\n        encodeLength(keyCount, numKeys);\n        const instructions = this.instructions.map((instruction)=>{\n            const { accounts, programIdIndex } = instruction;\n            const data = Array.from(bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(instruction.data));\n            let keyIndicesCount = [];\n            encodeLength(keyIndicesCount, accounts.length);\n            let dataCount = [];\n            encodeLength(dataCount, data.length);\n            return {\n                programIdIndex,\n                keyIndicesCount: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(keyIndicesCount),\n                keyIndices: accounts,\n                dataLength: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(dataCount),\n                data\n            };\n        });\n        let instructionCount = [];\n        encodeLength(instructionCount, instructions.length);\n        let instructionBuffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(PACKET_DATA_SIZE);\n        buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(instructionCount).copy(instructionBuffer);\n        let instructionBufferLength = instructionCount.length;\n        instructions.forEach((instruction)=>{\n            const instructionLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"programIdIndex\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(instruction.keyIndicesCount.length, \"keyIndicesCount\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"keyIndex\"), instruction.keyIndices.length, \"keyIndices\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(instruction.dataLength.length, \"dataLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"userdatum\"), instruction.data.length, \"data\")\n            ]);\n            const length = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);\n            instructionBufferLength += length;\n        });\n        instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);\n        const signDataLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(1, \"numRequiredSignatures\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(1, \"numReadonlySignedAccounts\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(1, \"numReadonlyUnsignedAccounts\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(keyCount.length, \"keyCount\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(\"key\"), numKeys, \"keys\"),\n            publicKey(\"recentBlockhash\")\n        ]);\n        const transaction = {\n            numRequiredSignatures: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([\n                this.header.numRequiredSignatures\n            ]),\n            numReadonlySignedAccounts: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([\n                this.header.numReadonlySignedAccounts\n            ]),\n            numReadonlyUnsignedAccounts: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([\n                this.header.numReadonlyUnsignedAccounts\n            ]),\n            keyCount: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(keyCount),\n            keys: this.accountKeys.map((key)=>toBuffer(key.toBytes())),\n            recentBlockhash: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(this.recentBlockhash)\n        };\n        let signData = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(2048);\n        const length = signDataLayout.encode(transaction, signData);\n        instructionBuffer.copy(signData, length);\n        return signData.slice(0, length + instructionBuffer.length);\n    }\n    /**\n   * Decode a compiled message into a Message object.\n   */ static from(buffer) {\n        // Slice up wire data\n        let byteArray = [\n            ...buffer\n        ];\n        const numRequiredSignatures = guardedShift(byteArray);\n        if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) {\n            throw new Error(\"Versioned messages must be deserialized with VersionedMessage.deserialize()\");\n        }\n        const numReadonlySignedAccounts = guardedShift(byteArray);\n        const numReadonlyUnsignedAccounts = guardedShift(byteArray);\n        const accountCount = decodeLength(byteArray);\n        let accountKeys = [];\n        for(let i = 0; i < accountCount; i++){\n            const account = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);\n            accountKeys.push(new PublicKey(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(account)));\n        }\n        const recentBlockhash = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);\n        const instructionCount = decodeLength(byteArray);\n        let instructions = [];\n        for(let i = 0; i < instructionCount; i++){\n            const programIdIndex = guardedShift(byteArray);\n            const accountCount = decodeLength(byteArray);\n            const accounts = guardedSplice(byteArray, 0, accountCount);\n            const dataLength = decodeLength(byteArray);\n            const dataSlice = guardedSplice(byteArray, 0, dataLength);\n            const data = bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(dataSlice));\n            instructions.push({\n                programIdIndex,\n                accounts,\n                data\n            });\n        }\n        const messageArgs = {\n            header: {\n                numRequiredSignatures,\n                numReadonlySignedAccounts,\n                numReadonlyUnsignedAccounts\n            },\n            recentBlockhash: bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(recentBlockhash)),\n            accountKeys,\n            instructions\n        };\n        return new Message(messageArgs);\n    }\n}\n/**\n * Message constructor arguments\n */ class MessageV0 {\n    constructor(args){\n        this.header = void 0;\n        this.staticAccountKeys = void 0;\n        this.recentBlockhash = void 0;\n        this.compiledInstructions = void 0;\n        this.addressTableLookups = void 0;\n        this.header = args.header;\n        this.staticAccountKeys = args.staticAccountKeys;\n        this.recentBlockhash = args.recentBlockhash;\n        this.compiledInstructions = args.compiledInstructions;\n        this.addressTableLookups = args.addressTableLookups;\n    }\n    get version() {\n        return 0;\n    }\n    get numAccountKeysFromLookups() {\n        let count = 0;\n        for (const lookup of this.addressTableLookups){\n            count += lookup.readonlyIndexes.length + lookup.writableIndexes.length;\n        }\n        return count;\n    }\n    getAccountKeys(args) {\n        let accountKeysFromLookups;\n        if (args && \"accountKeysFromLookups\" in args && args.accountKeysFromLookups) {\n            if (this.numAccountKeysFromLookups != args.accountKeysFromLookups.writable.length + args.accountKeysFromLookups.readonly.length) {\n                throw new Error(\"Failed to get account keys because of a mismatch in the number of account keys from lookups\");\n            }\n            accountKeysFromLookups = args.accountKeysFromLookups;\n        } else if (args && \"addressLookupTableAccounts\" in args && args.addressLookupTableAccounts) {\n            accountKeysFromLookups = this.resolveAddressTableLookups(args.addressLookupTableAccounts);\n        } else if (this.addressTableLookups.length > 0) {\n            throw new Error(\"Failed to get account keys because address table lookups were not resolved\");\n        }\n        return new MessageAccountKeys(this.staticAccountKeys, accountKeysFromLookups);\n    }\n    isAccountSigner(index) {\n        return index < this.header.numRequiredSignatures;\n    }\n    isAccountWritable(index) {\n        const numSignedAccounts = this.header.numRequiredSignatures;\n        const numStaticAccountKeys = this.staticAccountKeys.length;\n        if (index >= numStaticAccountKeys) {\n            const lookupAccountKeysIndex = index - numStaticAccountKeys;\n            const numWritableLookupAccountKeys = this.addressTableLookups.reduce((count, lookup)=>count + lookup.writableIndexes.length, 0);\n            return lookupAccountKeysIndex < numWritableLookupAccountKeys;\n        } else if (index >= this.header.numRequiredSignatures) {\n            const unsignedAccountIndex = index - numSignedAccounts;\n            const numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;\n            const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;\n            return unsignedAccountIndex < numWritableUnsignedAccounts;\n        } else {\n            const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;\n            return index < numWritableSignedAccounts;\n        }\n    }\n    resolveAddressTableLookups(addressLookupTableAccounts) {\n        const accountKeysFromLookups = {\n            writable: [],\n            readonly: []\n        };\n        for (const tableLookup of this.addressTableLookups){\n            const tableAccount = addressLookupTableAccounts.find((account)=>account.key.equals(tableLookup.accountKey));\n            if (!tableAccount) {\n                throw new Error(`Failed to find address lookup table account for table key ${tableLookup.accountKey.toBase58()}`);\n            }\n            for (const index of tableLookup.writableIndexes){\n                if (index < tableAccount.state.addresses.length) {\n                    accountKeysFromLookups.writable.push(tableAccount.state.addresses[index]);\n                } else {\n                    throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);\n                }\n            }\n            for (const index of tableLookup.readonlyIndexes){\n                if (index < tableAccount.state.addresses.length) {\n                    accountKeysFromLookups.readonly.push(tableAccount.state.addresses[index]);\n                } else {\n                    throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);\n                }\n            }\n        }\n        return accountKeysFromLookups;\n    }\n    static compile(args) {\n        const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);\n        const addressTableLookups = new Array();\n        const accountKeysFromLookups = {\n            writable: new Array(),\n            readonly: new Array()\n        };\n        const lookupTableAccounts = args.addressLookupTableAccounts || [];\n        for (const lookupTable of lookupTableAccounts){\n            const extractResult = compiledKeys.extractTableLookup(lookupTable);\n            if (extractResult !== undefined) {\n                const [addressTableLookup, { writable, readonly }] = extractResult;\n                addressTableLookups.push(addressTableLookup);\n                accountKeysFromLookups.writable.push(...writable);\n                accountKeysFromLookups.readonly.push(...readonly);\n            }\n        }\n        const [header, staticAccountKeys] = compiledKeys.getMessageComponents();\n        const accountKeys = new MessageAccountKeys(staticAccountKeys, accountKeysFromLookups);\n        const compiledInstructions = accountKeys.compileInstructions(args.instructions);\n        return new MessageV0({\n            header,\n            staticAccountKeys,\n            recentBlockhash: args.recentBlockhash,\n            compiledInstructions,\n            addressTableLookups\n        });\n    }\n    serialize() {\n        const encodedStaticAccountKeysLength = Array();\n        encodeLength(encodedStaticAccountKeysLength, this.staticAccountKeys.length);\n        const serializedInstructions = this.serializeInstructions();\n        const encodedInstructionsLength = Array();\n        encodeLength(encodedInstructionsLength, this.compiledInstructions.length);\n        const serializedAddressTableLookups = this.serializeAddressTableLookups();\n        const encodedAddressTableLookupsLength = Array();\n        encodeLength(encodedAddressTableLookupsLength, this.addressTableLookups.length);\n        const messageLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"prefix\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numRequiredSignatures\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numReadonlySignedAccounts\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numReadonlyUnsignedAccounts\")\n            ], \"header\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedStaticAccountKeysLength.length, \"staticAccountKeysLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(), this.staticAccountKeys.length, \"staticAccountKeys\"),\n            publicKey(\"recentBlockhash\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedInstructionsLength.length, \"instructionsLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(serializedInstructions.length, \"serializedInstructions\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedAddressTableLookupsLength.length, \"addressTableLookupsLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(serializedAddressTableLookups.length, \"serializedAddressTableLookups\")\n        ]);\n        const serializedMessage = new Uint8Array(PACKET_DATA_SIZE);\n        const MESSAGE_VERSION_0_PREFIX = 1 << 7;\n        const serializedMessageLength = messageLayout.encode({\n            prefix: MESSAGE_VERSION_0_PREFIX,\n            header: this.header,\n            staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),\n            staticAccountKeys: this.staticAccountKeys.map((key)=>key.toBytes()),\n            recentBlockhash: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(this.recentBlockhash),\n            instructionsLength: new Uint8Array(encodedInstructionsLength),\n            serializedInstructions,\n            addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),\n            serializedAddressTableLookups\n        }, serializedMessage);\n        return serializedMessage.slice(0, serializedMessageLength);\n    }\n    serializeInstructions() {\n        let serializedLength = 0;\n        const serializedInstructions = new Uint8Array(PACKET_DATA_SIZE);\n        for (const instruction of this.compiledInstructions){\n            const encodedAccountKeyIndexesLength = Array();\n            encodeLength(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);\n            const encodedDataLength = Array();\n            encodeLength(encodedDataLength, instruction.data.length);\n            const instructionLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"programIdIndex\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedAccountKeyIndexesLength.length, \"encodedAccountKeyIndexesLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(), instruction.accountKeyIndexes.length, \"accountKeyIndexes\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedDataLength.length, \"encodedDataLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(instruction.data.length, \"data\")\n            ]);\n            serializedLength += instructionLayout.encode({\n                programIdIndex: instruction.programIdIndex,\n                encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),\n                accountKeyIndexes: instruction.accountKeyIndexes,\n                encodedDataLength: new Uint8Array(encodedDataLength),\n                data: instruction.data\n            }, serializedInstructions, serializedLength);\n        }\n        return serializedInstructions.slice(0, serializedLength);\n    }\n    serializeAddressTableLookups() {\n        let serializedLength = 0;\n        const serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE);\n        for (const lookup of this.addressTableLookups){\n            const encodedWritableIndexesLength = Array();\n            encodeLength(encodedWritableIndexesLength, lookup.writableIndexes.length);\n            const encodedReadonlyIndexesLength = Array();\n            encodeLength(encodedReadonlyIndexesLength, lookup.readonlyIndexes.length);\n            const addressTableLookupLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                publicKey(\"accountKey\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedWritableIndexesLength.length, \"encodedWritableIndexesLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(), lookup.writableIndexes.length, \"writableIndexes\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedReadonlyIndexesLength.length, \"encodedReadonlyIndexesLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(), lookup.readonlyIndexes.length, \"readonlyIndexes\")\n            ]);\n            serializedLength += addressTableLookupLayout.encode({\n                accountKey: lookup.accountKey.toBytes(),\n                encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),\n                writableIndexes: lookup.writableIndexes,\n                encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),\n                readonlyIndexes: lookup.readonlyIndexes\n            }, serializedAddressTableLookups, serializedLength);\n        }\n        return serializedAddressTableLookups.slice(0, serializedLength);\n    }\n    static deserialize(serializedMessage) {\n        let byteArray = [\n            ...serializedMessage\n        ];\n        const prefix = guardedShift(byteArray);\n        const maskedPrefix = prefix & VERSION_PREFIX_MASK;\n        assert(prefix !== maskedPrefix, `Expected versioned message but received legacy message`);\n        const version = maskedPrefix;\n        assert(version === 0, `Expected versioned message with version 0 but found version ${version}`);\n        const header = {\n            numRequiredSignatures: guardedShift(byteArray),\n            numReadonlySignedAccounts: guardedShift(byteArray),\n            numReadonlyUnsignedAccounts: guardedShift(byteArray)\n        };\n        const staticAccountKeys = [];\n        const staticAccountKeysLength = decodeLength(byteArray);\n        for(let i = 0; i < staticAccountKeysLength; i++){\n            staticAccountKeys.push(new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH)));\n        }\n        const recentBlockhash = bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));\n        const instructionCount = decodeLength(byteArray);\n        const compiledInstructions = [];\n        for(let i = 0; i < instructionCount; i++){\n            const programIdIndex = guardedShift(byteArray);\n            const accountKeyIndexesLength = decodeLength(byteArray);\n            const accountKeyIndexes = guardedSplice(byteArray, 0, accountKeyIndexesLength);\n            const dataLength = decodeLength(byteArray);\n            const data = new Uint8Array(guardedSplice(byteArray, 0, dataLength));\n            compiledInstructions.push({\n                programIdIndex,\n                accountKeyIndexes,\n                data\n            });\n        }\n        const addressTableLookupsCount = decodeLength(byteArray);\n        const addressTableLookups = [];\n        for(let i = 0; i < addressTableLookupsCount; i++){\n            const accountKey = new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));\n            const writableIndexesLength = decodeLength(byteArray);\n            const writableIndexes = guardedSplice(byteArray, 0, writableIndexesLength);\n            const readonlyIndexesLength = decodeLength(byteArray);\n            const readonlyIndexes = guardedSplice(byteArray, 0, readonlyIndexesLength);\n            addressTableLookups.push({\n                accountKey,\n                writableIndexes,\n                readonlyIndexes\n            });\n        }\n        return new MessageV0({\n            header,\n            staticAccountKeys,\n            recentBlockhash,\n            compiledInstructions,\n            addressTableLookups\n        });\n    }\n}\n// eslint-disable-next-line no-redeclare\nconst VersionedMessage = {\n    deserializeMessageVersion (serializedMessage) {\n        const prefix = serializedMessage[0];\n        const maskedPrefix = prefix & VERSION_PREFIX_MASK;\n        // if the highest bit of the prefix is not set, the message is not versioned\n        if (maskedPrefix === prefix) {\n            return \"legacy\";\n        }\n        // the lower 7 bits of the prefix indicate the message version\n        return maskedPrefix;\n    },\n    deserialize: (serializedMessage)=>{\n        const version = VersionedMessage.deserializeMessageVersion(serializedMessage);\n        if (version === \"legacy\") {\n            return Message.from(serializedMessage);\n        }\n        if (version === 0) {\n            return MessageV0.deserialize(serializedMessage);\n        } else {\n            throw new Error(`Transaction message version ${version} deserialization is not supported`);\n        }\n    }\n};\n/** @internal */ /**\n * Transaction signature as base-58 encoded string\n */ let TransactionStatus = /*#__PURE__*/ function(TransactionStatus) {\n    TransactionStatus[TransactionStatus[\"BLOCKHEIGHT_EXCEEDED\"] = 0] = \"BLOCKHEIGHT_EXCEEDED\";\n    TransactionStatus[TransactionStatus[\"PROCESSED\"] = 1] = \"PROCESSED\";\n    TransactionStatus[TransactionStatus[\"TIMED_OUT\"] = 2] = \"TIMED_OUT\";\n    TransactionStatus[TransactionStatus[\"NONCE_INVALID\"] = 3] = \"NONCE_INVALID\";\n    return TransactionStatus;\n}({});\n/**\n * Default (empty) signature\n */ const DEFAULT_SIGNATURE = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);\n/**\n * Account metadata used to define instructions\n */ /**\n * List of TransactionInstruction object fields that may be initialized at construction\n */ /**\n * Configuration object for Transaction.serialize()\n */ /**\n * @internal\n */ /**\n * Transaction Instruction class\n */ class TransactionInstruction {\n    constructor(opts){\n        /**\n     * Public keys to include in this transaction\n     * Boolean represents whether this pubkey needs to sign the transaction\n     */ this.keys = void 0;\n        /**\n     * Program Id to execute\n     */ this.programId = void 0;\n        /**\n     * Program input\n     */ this.data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(0);\n        this.programId = opts.programId;\n        this.keys = opts.keys;\n        if (opts.data) {\n            this.data = opts.data;\n        }\n    }\n    /**\n   * @internal\n   */ toJSON() {\n        return {\n            keys: this.keys.map(({ pubkey, isSigner, isWritable })=>({\n                    pubkey: pubkey.toJSON(),\n                    isSigner,\n                    isWritable\n                })),\n            programId: this.programId.toJSON(),\n            data: [\n                ...this.data\n            ]\n        };\n    }\n}\n/**\n * Pair of signature and corresponding public key\n */ /**\n * List of Transaction object fields that may be initialized at construction\n */ // For backward compatibility; an unfortunate consequence of being\n// forced to over-export types by the documentation generator.\n// See https://github.com/solana-labs/solana/pull/25820\n/**\n * Blockhash-based transactions have a lifetime that are defined by\n * the blockhash they include. Any transaction whose blockhash is\n * too old will be rejected.\n */ /**\n * Use these options to construct a durable nonce transaction.\n */ /**\n * Nonce information to be used to build an offline Transaction.\n */ /**\n * @internal\n */ /**\n * Transaction class\n */ class Transaction {\n    /**\n   * The first (payer) Transaction signature\n   *\n   * @returns {Buffer | null} Buffer of payer's signature\n   */ get signature() {\n        if (this.signatures.length > 0) {\n            return this.signatures[0].signature;\n        }\n        return null;\n    }\n    /**\n   * The transaction fee payer\n   */ // Construct a transaction with a blockhash and lastValidBlockHeight\n    // Construct a transaction using a durable nonce\n    /**\n   * @deprecated `TransactionCtorFields` has been deprecated and will be removed in a future version.\n   * Please supply a `TransactionBlockhashCtor` instead.\n   */ /**\n   * Construct an empty Transaction\n   */ constructor(opts){\n        /**\n     * Signatures for the transaction.  Typically created by invoking the\n     * `sign()` method\n     */ this.signatures = [];\n        this.feePayer = void 0;\n        /**\n     * The instructions to atomically execute\n     */ this.instructions = [];\n        /**\n     * A recent transaction id. Must be populated by the caller\n     */ this.recentBlockhash = void 0;\n        /**\n     * the last block chain can advance to before tx is declared expired\n     * */ this.lastValidBlockHeight = void 0;\n        /**\n     * Optional Nonce information. If populated, transaction will use a durable\n     * Nonce hash instead of a recentBlockhash. Must be populated by the caller\n     */ this.nonceInfo = void 0;\n        /**\n     * If this is a nonce transaction this represents the minimum slot from which\n     * to evaluate if the nonce has advanced when attempting to confirm the\n     * transaction. This protects against a case where the transaction confirmation\n     * logic loads the nonce account from an old slot and assumes the mismatch in\n     * nonce value implies that the nonce has been advanced.\n     */ this.minNonceContextSlot = void 0;\n        /**\n     * @internal\n     */ this._message = void 0;\n        /**\n     * @internal\n     */ this._json = void 0;\n        if (!opts) {\n            return;\n        }\n        if (opts.feePayer) {\n            this.feePayer = opts.feePayer;\n        }\n        if (opts.signatures) {\n            this.signatures = opts.signatures;\n        }\n        if (Object.prototype.hasOwnProperty.call(opts, \"nonceInfo\")) {\n            const { minContextSlot, nonceInfo } = opts;\n            this.minNonceContextSlot = minContextSlot;\n            this.nonceInfo = nonceInfo;\n        } else if (Object.prototype.hasOwnProperty.call(opts, \"lastValidBlockHeight\")) {\n            const { blockhash, lastValidBlockHeight } = opts;\n            this.recentBlockhash = blockhash;\n            this.lastValidBlockHeight = lastValidBlockHeight;\n        } else {\n            const { recentBlockhash, nonceInfo } = opts;\n            if (nonceInfo) {\n                this.nonceInfo = nonceInfo;\n            }\n            this.recentBlockhash = recentBlockhash;\n        }\n    }\n    /**\n   * @internal\n   */ toJSON() {\n        return {\n            recentBlockhash: this.recentBlockhash || null,\n            feePayer: this.feePayer ? this.feePayer.toJSON() : null,\n            nonceInfo: this.nonceInfo ? {\n                nonce: this.nonceInfo.nonce,\n                nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()\n            } : null,\n            instructions: this.instructions.map((instruction)=>instruction.toJSON()),\n            signers: this.signatures.map(({ publicKey })=>{\n                return publicKey.toJSON();\n            })\n        };\n    }\n    /**\n   * Add one or more instructions to this Transaction\n   *\n   * @param {Array< Transaction | TransactionInstruction | TransactionInstructionCtorFields >} items - Instructions to add to the Transaction\n   */ add(...items) {\n        if (items.length === 0) {\n            throw new Error(\"No instructions\");\n        }\n        items.forEach((item)=>{\n            if (\"instructions\" in item) {\n                this.instructions = this.instructions.concat(item.instructions);\n            } else if (\"data\" in item && \"programId\" in item && \"keys\" in item) {\n                this.instructions.push(item);\n            } else {\n                this.instructions.push(new TransactionInstruction(item));\n            }\n        });\n        return this;\n    }\n    /**\n   * Compile transaction data\n   */ compileMessage() {\n        if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {\n            return this._message;\n        }\n        let recentBlockhash;\n        let instructions;\n        if (this.nonceInfo) {\n            recentBlockhash = this.nonceInfo.nonce;\n            if (this.instructions[0] != this.nonceInfo.nonceInstruction) {\n                instructions = [\n                    this.nonceInfo.nonceInstruction,\n                    ...this.instructions\n                ];\n            } else {\n                instructions = this.instructions;\n            }\n        } else {\n            recentBlockhash = this.recentBlockhash;\n            instructions = this.instructions;\n        }\n        if (!recentBlockhash) {\n            throw new Error(\"Transaction recentBlockhash required\");\n        }\n        if (instructions.length < 1) {\n            console.warn(\"No instructions provided\");\n        }\n        let feePayer;\n        if (this.feePayer) {\n            feePayer = this.feePayer;\n        } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {\n            // Use implicit fee payer\n            feePayer = this.signatures[0].publicKey;\n        } else {\n            throw new Error(\"Transaction fee payer required\");\n        }\n        for(let i = 0; i < instructions.length; i++){\n            if (instructions[i].programId === undefined) {\n                throw new Error(`Transaction instruction index ${i} has undefined program id`);\n            }\n        }\n        const programIds = [];\n        const accountMetas = [];\n        instructions.forEach((instruction)=>{\n            instruction.keys.forEach((accountMeta)=>{\n                accountMetas.push({\n                    ...accountMeta\n                });\n            });\n            const programId = instruction.programId.toString();\n            if (!programIds.includes(programId)) {\n                programIds.push(programId);\n            }\n        });\n        // Append programID account metas\n        programIds.forEach((programId)=>{\n            accountMetas.push({\n                pubkey: new PublicKey(programId),\n                isSigner: false,\n                isWritable: false\n            });\n        });\n        // Cull duplicate account metas\n        const uniqueMetas = [];\n        accountMetas.forEach((accountMeta)=>{\n            const pubkeyString = accountMeta.pubkey.toString();\n            const uniqueIndex = uniqueMetas.findIndex((x)=>{\n                return x.pubkey.toString() === pubkeyString;\n            });\n            if (uniqueIndex > -1) {\n                uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;\n                uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;\n            } else {\n                uniqueMetas.push(accountMeta);\n            }\n        });\n        // Sort. Prioritizing first by signer, then by writable\n        uniqueMetas.sort(function(x, y) {\n            if (x.isSigner !== y.isSigner) {\n                // Signers always come before non-signers\n                return x.isSigner ? -1 : 1;\n            }\n            if (x.isWritable !== y.isWritable) {\n                // Writable accounts always come before read-only accounts\n                return x.isWritable ? -1 : 1;\n            }\n            // Otherwise, sort by pubkey, stringwise.\n            const options = {\n                localeMatcher: \"best fit\",\n                usage: \"sort\",\n                sensitivity: \"variant\",\n                ignorePunctuation: false,\n                numeric: false,\n                caseFirst: \"lower\"\n            };\n            return x.pubkey.toBase58().localeCompare(y.pubkey.toBase58(), \"en\", options);\n        });\n        // Move fee payer to the front\n        const feePayerIndex = uniqueMetas.findIndex((x)=>{\n            return x.pubkey.equals(feePayer);\n        });\n        if (feePayerIndex > -1) {\n            const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);\n            payerMeta.isSigner = true;\n            payerMeta.isWritable = true;\n            uniqueMetas.unshift(payerMeta);\n        } else {\n            uniqueMetas.unshift({\n                pubkey: feePayer,\n                isSigner: true,\n                isWritable: true\n            });\n        }\n        // Disallow unknown signers\n        for (const signature of this.signatures){\n            const uniqueIndex = uniqueMetas.findIndex((x)=>{\n                return x.pubkey.equals(signature.publicKey);\n            });\n            if (uniqueIndex > -1) {\n                if (!uniqueMetas[uniqueIndex].isSigner) {\n                    uniqueMetas[uniqueIndex].isSigner = true;\n                    console.warn(\"Transaction references a signature that is unnecessary, \" + \"only the fee payer and instruction signer accounts should sign a transaction. \" + \"This behavior is deprecated and will throw an error in the next major version release.\");\n                }\n            } else {\n                throw new Error(`unknown signer: ${signature.publicKey.toString()}`);\n            }\n        }\n        let numRequiredSignatures = 0;\n        let numReadonlySignedAccounts = 0;\n        let numReadonlyUnsignedAccounts = 0;\n        // Split out signing from non-signing keys and count header values\n        const signedKeys = [];\n        const unsignedKeys = [];\n        uniqueMetas.forEach(({ pubkey, isSigner, isWritable })=>{\n            if (isSigner) {\n                signedKeys.push(pubkey.toString());\n                numRequiredSignatures += 1;\n                if (!isWritable) {\n                    numReadonlySignedAccounts += 1;\n                }\n            } else {\n                unsignedKeys.push(pubkey.toString());\n                if (!isWritable) {\n                    numReadonlyUnsignedAccounts += 1;\n                }\n            }\n        });\n        const accountKeys = signedKeys.concat(unsignedKeys);\n        const compiledInstructions = instructions.map((instruction)=>{\n            const { data, programId } = instruction;\n            return {\n                programIdIndex: accountKeys.indexOf(programId.toString()),\n                accounts: instruction.keys.map((meta)=>accountKeys.indexOf(meta.pubkey.toString())),\n                data: bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(data)\n            };\n        });\n        compiledInstructions.forEach((instruction)=>{\n            assert(instruction.programIdIndex >= 0);\n            instruction.accounts.forEach((keyIndex)=>assert(keyIndex >= 0));\n        });\n        return new Message({\n            header: {\n                numRequiredSignatures,\n                numReadonlySignedAccounts,\n                numReadonlyUnsignedAccounts\n            },\n            accountKeys,\n            recentBlockhash,\n            instructions: compiledInstructions\n        });\n    }\n    /**\n   * @internal\n   */ _compile() {\n        const message = this.compileMessage();\n        const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);\n        if (this.signatures.length === signedKeys.length) {\n            const valid = this.signatures.every((pair, index)=>{\n                return signedKeys[index].equals(pair.publicKey);\n            });\n            if (valid) return message;\n        }\n        this.signatures = signedKeys.map((publicKey)=>({\n                signature: null,\n                publicKey\n            }));\n        return message;\n    }\n    /**\n   * Get a buffer of the Transaction data that need to be covered by signatures\n   */ serializeMessage() {\n        return this._compile().serialize();\n    }\n    /**\n   * Get the estimated fee associated with a transaction\n   *\n   * @param {Connection} connection Connection to RPC Endpoint.\n   *\n   * @returns {Promise<number | null>} The estimated fee for the transaction\n   */ async getEstimatedFee(connection) {\n        return (await connection.getFeeForMessage(this.compileMessage())).value;\n    }\n    /**\n   * Specify the public keys which will be used to sign the Transaction.\n   * The first signer will be used as the transaction fee payer account.\n   *\n   * Signatures can be added with either `partialSign` or `addSignature`\n   *\n   * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be\n   * specified and it can be set in the Transaction constructor or with the\n   * `feePayer` property.\n   */ setSigners(...signers) {\n        if (signers.length === 0) {\n            throw new Error(\"No signers\");\n        }\n        const seen = new Set();\n        this.signatures = signers.filter((publicKey)=>{\n            const key = publicKey.toString();\n            if (seen.has(key)) {\n                return false;\n            } else {\n                seen.add(key);\n                return true;\n            }\n        }).map((publicKey)=>({\n                signature: null,\n                publicKey\n            }));\n    }\n    /**\n   * Sign the Transaction with the specified signers. Multiple signatures may\n   * be applied to a Transaction. The first signature is considered \"primary\"\n   * and is used identify and confirm transactions.\n   *\n   * If the Transaction `feePayer` is not set, the first signer will be used\n   * as the transaction fee payer account.\n   *\n   * Transaction fields should not be modified after the first call to `sign`,\n   * as doing so may invalidate the signature and cause the Transaction to be\n   * rejected.\n   *\n   * The Transaction must be assigned a valid `recentBlockhash` before invoking this method\n   *\n   * @param {Array<Signer>} signers Array of signers that will sign the transaction\n   */ sign(...signers) {\n        if (signers.length === 0) {\n            throw new Error(\"No signers\");\n        }\n        // Dedupe signers\n        const seen = new Set();\n        const uniqueSigners = [];\n        for (const signer of signers){\n            const key = signer.publicKey.toString();\n            if (seen.has(key)) {\n                continue;\n            } else {\n                seen.add(key);\n                uniqueSigners.push(signer);\n            }\n        }\n        this.signatures = uniqueSigners.map((signer)=>({\n                signature: null,\n                publicKey: signer.publicKey\n            }));\n        const message = this._compile();\n        this._partialSign(message, ...uniqueSigners);\n    }\n    /**\n   * Partially sign a transaction with the specified accounts. All accounts must\n   * correspond to either the fee payer or a signer account in the transaction\n   * instructions.\n   *\n   * All the caveats from the `sign` method apply to `partialSign`\n   *\n   * @param {Array<Signer>} signers Array of signers that will sign the transaction\n   */ partialSign(...signers) {\n        if (signers.length === 0) {\n            throw new Error(\"No signers\");\n        }\n        // Dedupe signers\n        const seen = new Set();\n        const uniqueSigners = [];\n        for (const signer of signers){\n            const key = signer.publicKey.toString();\n            if (seen.has(key)) {\n                continue;\n            } else {\n                seen.add(key);\n                uniqueSigners.push(signer);\n            }\n        }\n        const message = this._compile();\n        this._partialSign(message, ...uniqueSigners);\n    }\n    /**\n   * @internal\n   */ _partialSign(message, ...signers) {\n        const signData = message.serialize();\n        signers.forEach((signer)=>{\n            const signature = sign(signData, signer.secretKey);\n            this._addSignature(signer.publicKey, toBuffer(signature));\n        });\n    }\n    /**\n   * Add an externally created signature to a transaction. The public key\n   * must correspond to either the fee payer or a signer account in the transaction\n   * instructions.\n   *\n   * @param {PublicKey} pubkey Public key that will be added to the transaction.\n   * @param {Buffer} signature An externally created signature to add to the transaction.\n   */ addSignature(pubkey, signature) {\n        this._compile(); // Ensure signatures array is populated\n        this._addSignature(pubkey, signature);\n    }\n    /**\n   * @internal\n   */ _addSignature(pubkey, signature) {\n        assert(signature.length === 64);\n        const index = this.signatures.findIndex((sigpair)=>pubkey.equals(sigpair.publicKey));\n        if (index < 0) {\n            throw new Error(`unknown signer: ${pubkey.toString()}`);\n        }\n        this.signatures[index].signature = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signature);\n    }\n    /**\n   * Verify signatures of a Transaction\n   * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.\n   * If no boolean is provided, we expect a fully signed Transaction by default.\n   *\n   * @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction\n   */ verifySignatures(requireAllSignatures = true) {\n        const signatureErrors = this._getMessageSignednessErrors(this.serializeMessage(), requireAllSignatures);\n        return !signatureErrors;\n    }\n    /**\n   * @internal\n   */ _getMessageSignednessErrors(message, requireAllSignatures) {\n        const errors = {};\n        for (const { signature, publicKey } of this.signatures){\n            if (signature === null) {\n                if (requireAllSignatures) {\n                    (errors.missing ||= []).push(publicKey);\n                }\n            } else {\n                if (!verify(signature, message, publicKey.toBytes())) {\n                    (errors.invalid ||= []).push(publicKey);\n                }\n            }\n        }\n        return errors.invalid || errors.missing ? errors : undefined;\n    }\n    /**\n   * Serialize the Transaction in the wire format.\n   *\n   * @param {Buffer} [config] Config of transaction.\n   *\n   * @returns {Buffer} Signature of transaction in wire format.\n   */ serialize(config) {\n        const { requireAllSignatures, verifySignatures } = Object.assign({\n            requireAllSignatures: true,\n            verifySignatures: true\n        }, config);\n        const signData = this.serializeMessage();\n        if (verifySignatures) {\n            const sigErrors = this._getMessageSignednessErrors(signData, requireAllSignatures);\n            if (sigErrors) {\n                let errorMessage = \"Signature verification failed.\";\n                if (sigErrors.invalid) {\n                    errorMessage += `\\nInvalid signature for public key${sigErrors.invalid.length === 1 ? \"\" : \"(s)\"} [\\`${sigErrors.invalid.map((p)=>p.toBase58()).join(\"`, `\")}\\`].`;\n                }\n                if (sigErrors.missing) {\n                    errorMessage += `\\nMissing signature for public key${sigErrors.missing.length === 1 ? \"\" : \"(s)\"} [\\`${sigErrors.missing.map((p)=>p.toBase58()).join(\"`, `\")}\\`].`;\n                }\n                throw new Error(errorMessage);\n            }\n        }\n        return this._serialize(signData);\n    }\n    /**\n   * @internal\n   */ _serialize(signData) {\n        const { signatures } = this;\n        const signatureCount = [];\n        encodeLength(signatureCount, signatures.length);\n        const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;\n        const wireTransaction = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(transactionLength);\n        assert(signatures.length < 256);\n        buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signatureCount).copy(wireTransaction, 0);\n        signatures.forEach(({ signature }, index)=>{\n            if (signature !== null) {\n                assert(signature.length === 64, `signature has invalid length`);\n                buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signature).copy(wireTransaction, signatureCount.length + index * 64);\n            }\n        });\n        signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);\n        assert(wireTransaction.length <= PACKET_DATA_SIZE, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`);\n        return wireTransaction;\n    }\n    /**\n   * Deprecated method\n   * @internal\n   */ get keys() {\n        assert(this.instructions.length === 1);\n        return this.instructions[0].keys.map((keyObj)=>keyObj.pubkey);\n    }\n    /**\n   * Deprecated method\n   * @internal\n   */ get programId() {\n        assert(this.instructions.length === 1);\n        return this.instructions[0].programId;\n    }\n    /**\n   * Deprecated method\n   * @internal\n   */ get data() {\n        assert(this.instructions.length === 1);\n        return this.instructions[0].data;\n    }\n    /**\n   * Parse a wire transaction into a Transaction object.\n   *\n   * @param {Buffer | Uint8Array | Array<number>} buffer Signature of wire Transaction\n   *\n   * @returns {Transaction} Transaction associated with the signature\n   */ static from(buffer) {\n        // Slice up wire data\n        let byteArray = [\n            ...buffer\n        ];\n        const signatureCount = decodeLength(byteArray);\n        let signatures = [];\n        for(let i = 0; i < signatureCount; i++){\n            const signature = guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES);\n            signatures.push(bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signature)));\n        }\n        return Transaction.populate(Message.from(byteArray), signatures);\n    }\n    /**\n   * Populate Transaction object from message and signatures\n   *\n   * @param {Message} message Message of transaction\n   * @param {Array<string>} signatures List of signatures to assign to the transaction\n   *\n   * @returns {Transaction} The populated Transaction\n   */ static populate(message, signatures = []) {\n        const transaction = new Transaction();\n        transaction.recentBlockhash = message.recentBlockhash;\n        if (message.header.numRequiredSignatures > 0) {\n            transaction.feePayer = message.accountKeys[0];\n        }\n        signatures.forEach((signature, index)=>{\n            const sigPubkeyPair = {\n                signature: signature == bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(DEFAULT_SIGNATURE) ? null : bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(signature),\n                publicKey: message.accountKeys[index]\n            };\n            transaction.signatures.push(sigPubkeyPair);\n        });\n        message.instructions.forEach((instruction)=>{\n            const keys = instruction.accounts.map((account)=>{\n                const pubkey = message.accountKeys[account];\n                return {\n                    pubkey,\n                    isSigner: transaction.signatures.some((keyObj)=>keyObj.publicKey.toString() === pubkey.toString()) || message.isAccountSigner(account),\n                    isWritable: message.isAccountWritable(account)\n                };\n            });\n            transaction.instructions.push(new TransactionInstruction({\n                keys,\n                programId: message.accountKeys[instruction.programIdIndex],\n                data: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(instruction.data)\n            }));\n        });\n        transaction._message = message;\n        transaction._json = transaction.toJSON();\n        return transaction;\n    }\n}\nclass TransactionMessage {\n    constructor(args){\n        this.payerKey = void 0;\n        this.instructions = void 0;\n        this.recentBlockhash = void 0;\n        this.payerKey = args.payerKey;\n        this.instructions = args.instructions;\n        this.recentBlockhash = args.recentBlockhash;\n    }\n    static decompile(message, args) {\n        const { header, compiledInstructions, recentBlockhash } = message;\n        const { numRequiredSignatures, numReadonlySignedAccounts, numReadonlyUnsignedAccounts } = header;\n        const numWritableSignedAccounts = numRequiredSignatures - numReadonlySignedAccounts;\n        assert(numWritableSignedAccounts > 0, \"Message header is invalid\");\n        const numWritableUnsignedAccounts = message.staticAccountKeys.length - numRequiredSignatures - numReadonlyUnsignedAccounts;\n        assert(numWritableUnsignedAccounts >= 0, \"Message header is invalid\");\n        const accountKeys = message.getAccountKeys(args);\n        const payerKey = accountKeys.get(0);\n        if (payerKey === undefined) {\n            throw new Error(\"Failed to decompile message because no account keys were found\");\n        }\n        const instructions = [];\n        for (const compiledIx of compiledInstructions){\n            const keys = [];\n            for (const keyIndex of compiledIx.accountKeyIndexes){\n                const pubkey = accountKeys.get(keyIndex);\n                if (pubkey === undefined) {\n                    throw new Error(`Failed to find key for account key index ${keyIndex}`);\n                }\n                const isSigner = keyIndex < numRequiredSignatures;\n                let isWritable;\n                if (isSigner) {\n                    isWritable = keyIndex < numWritableSignedAccounts;\n                } else if (keyIndex < accountKeys.staticAccountKeys.length) {\n                    isWritable = keyIndex - numRequiredSignatures < numWritableUnsignedAccounts;\n                } else {\n                    isWritable = keyIndex - accountKeys.staticAccountKeys.length < // accountKeysFromLookups cannot be undefined because we already found a pubkey for this index above\n                    accountKeys.accountKeysFromLookups.writable.length;\n                }\n                keys.push({\n                    pubkey,\n                    isSigner: keyIndex < header.numRequiredSignatures,\n                    isWritable\n                });\n            }\n            const programId = accountKeys.get(compiledIx.programIdIndex);\n            if (programId === undefined) {\n                throw new Error(`Failed to find program id for program id index ${compiledIx.programIdIndex}`);\n            }\n            instructions.push(new TransactionInstruction({\n                programId,\n                data: toBuffer(compiledIx.data),\n                keys\n            }));\n        }\n        return new TransactionMessage({\n            payerKey,\n            instructions,\n            recentBlockhash\n        });\n    }\n    compileToLegacyMessage() {\n        return Message.compile({\n            payerKey: this.payerKey,\n            recentBlockhash: this.recentBlockhash,\n            instructions: this.instructions\n        });\n    }\n    compileToV0Message(addressLookupTableAccounts) {\n        return MessageV0.compile({\n            payerKey: this.payerKey,\n            recentBlockhash: this.recentBlockhash,\n            instructions: this.instructions,\n            addressLookupTableAccounts\n        });\n    }\n}\n/**\n * Versioned transaction class\n */ class VersionedTransaction {\n    get version() {\n        return this.message.version;\n    }\n    constructor(message, signatures){\n        this.signatures = void 0;\n        this.message = void 0;\n        if (signatures !== undefined) {\n            assert(signatures.length === message.header.numRequiredSignatures, \"Expected signatures length to be equal to the number of required signatures\");\n            this.signatures = signatures;\n        } else {\n            const defaultSignatures = [];\n            for(let i = 0; i < message.header.numRequiredSignatures; i++){\n                defaultSignatures.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));\n            }\n            this.signatures = defaultSignatures;\n        }\n        this.message = message;\n    }\n    serialize() {\n        const serializedMessage = this.message.serialize();\n        const encodedSignaturesLength = Array();\n        encodeLength(encodedSignaturesLength, this.signatures.length);\n        const transactionLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedSignaturesLength.length, \"encodedSignaturesLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(signature(), this.signatures.length, \"signatures\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(serializedMessage.length, \"serializedMessage\")\n        ]);\n        const serializedTransaction = new Uint8Array(2048);\n        const serializedTransactionLength = transactionLayout.encode({\n            encodedSignaturesLength: new Uint8Array(encodedSignaturesLength),\n            signatures: this.signatures,\n            serializedMessage\n        }, serializedTransaction);\n        return serializedTransaction.slice(0, serializedTransactionLength);\n    }\n    static deserialize(serializedTransaction) {\n        let byteArray = [\n            ...serializedTransaction\n        ];\n        const signatures = [];\n        const signaturesLength = decodeLength(byteArray);\n        for(let i = 0; i < signaturesLength; i++){\n            signatures.push(new Uint8Array(guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES)));\n        }\n        const message = VersionedMessage.deserialize(new Uint8Array(byteArray));\n        return new VersionedTransaction(message, signatures);\n    }\n    sign(signers) {\n        const messageData = this.message.serialize();\n        const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);\n        for (const signer of signers){\n            const signerIndex = signerPubkeys.findIndex((pubkey)=>pubkey.equals(signer.publicKey));\n            assert(signerIndex >= 0, `Cannot sign with non signer key ${signer.publicKey.toBase58()}`);\n            this.signatures[signerIndex] = sign(messageData, signer.secretKey);\n        }\n    }\n    addSignature(publicKey, signature) {\n        assert(signature.byteLength === 64, \"Signature must be 64 bytes long\");\n        const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);\n        const signerIndex = signerPubkeys.findIndex((pubkey)=>pubkey.equals(publicKey));\n        assert(signerIndex >= 0, `Can not add signature; \\`${publicKey.toBase58()}\\` is not required to sign this transaction`);\n        this.signatures[signerIndex] = signature;\n    }\n}\n// TODO: These constants should be removed in favor of reading them out of a\n// Syscall account\n/**\n * @internal\n */ const NUM_TICKS_PER_SECOND = 160;\n/**\n * @internal\n */ const DEFAULT_TICKS_PER_SLOT = 64;\n/**\n * @internal\n */ const NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;\n/**\n * @internal\n */ const MS_PER_SLOT = 1000 / NUM_SLOTS_PER_SECOND;\nconst SYSVAR_CLOCK_PUBKEY = new PublicKey(\"SysvarC1ock11111111111111111111111111111111\");\nconst SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey(\"SysvarEpochSchedu1e111111111111111111111111\");\nconst SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey(\"Sysvar1nstructions1111111111111111111111111\");\nconst SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey(\"SysvarRecentB1ockHashes11111111111111111111\");\nconst SYSVAR_RENT_PUBKEY = new PublicKey(\"SysvarRent111111111111111111111111111111111\");\nconst SYSVAR_REWARDS_PUBKEY = new PublicKey(\"SysvarRewards111111111111111111111111111111\");\nconst SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey(\"SysvarS1otHashes111111111111111111111111111\");\nconst SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey(\"SysvarS1otHistory11111111111111111111111111\");\nconst SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey(\"SysvarStakeHistory1111111111111111111111111\");\nclass SendTransactionError extends Error {\n    constructor({ action, signature, transactionMessage, logs }){\n        const maybeLogsOutput = logs ? `Logs: \\n${JSON.stringify(logs.slice(-10), null, 2)}. ` : \"\";\n        const guideText = \"\\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.\";\n        let message;\n        switch(action){\n            case \"send\":\n                message = `Transaction ${signature} resulted in an error. \\n` + `${transactionMessage}. ` + maybeLogsOutput + guideText;\n                break;\n            case \"simulate\":\n                message = `Simulation failed. \\nMessage: ${transactionMessage}. \\n` + maybeLogsOutput + guideText;\n                break;\n            default:\n                {\n                    message = `Unknown action '${((a)=>a)(action)}'`;\n                }\n        }\n        super(message);\n        this.signature = void 0;\n        this.transactionMessage = void 0;\n        this.transactionLogs = void 0;\n        this.signature = signature;\n        this.transactionMessage = transactionMessage;\n        this.transactionLogs = logs ? logs : undefined;\n    }\n    get transactionError() {\n        return {\n            message: this.transactionMessage,\n            logs: Array.isArray(this.transactionLogs) ? this.transactionLogs : undefined\n        };\n    }\n    /* @deprecated Use `await getLogs()` instead */ get logs() {\n        const cachedLogs = this.transactionLogs;\n        if (cachedLogs != null && typeof cachedLogs === \"object\" && \"then\" in cachedLogs) {\n            return undefined;\n        }\n        return cachedLogs;\n    }\n    async getLogs(connection) {\n        if (!Array.isArray(this.transactionLogs)) {\n            this.transactionLogs = new Promise((resolve, reject)=>{\n                connection.getTransaction(this.signature).then((tx)=>{\n                    if (tx && tx.meta && tx.meta.logMessages) {\n                        const logs = tx.meta.logMessages;\n                        this.transactionLogs = logs;\n                        resolve(logs);\n                    } else {\n                        reject(new Error(\"Log messages not found\"));\n                    }\n                }).catch(reject);\n            });\n        }\n        return await this.transactionLogs;\n    }\n}\n// Keep in sync with client/src/rpc_custom_errors.rs\n// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/\nconst SolanaJSONRPCErrorCode = {\n    JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,\n    JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,\n    JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,\n    JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,\n    JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,\n    JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,\n    JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,\n    JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,\n    JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,\n    JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,\n    JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,\n    JSON_RPC_SCAN_ERROR: -32012,\n    JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,\n    JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,\n    JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,\n    JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016\n};\nclass SolanaJSONRPCError extends Error {\n    constructor({ code, message, data }, customMessage){\n        super(customMessage != null ? `${customMessage}: ${message}` : message);\n        this.code = void 0;\n        this.data = void 0;\n        this.code = code;\n        this.data = data;\n        this.name = \"SolanaJSONRPCError\";\n    }\n}\n/**\n * Sign, send and confirm a transaction.\n *\n * If `commitment` option is not specified, defaults to 'max' commitment.\n *\n * @param {Connection} connection\n * @param {Transaction} transaction\n * @param {Array<Signer>} signers\n * @param {ConfirmOptions} [options]\n * @returns {Promise<TransactionSignature>}\n */ async function sendAndConfirmTransaction(connection, transaction, signers, options) {\n    const sendOptions = options && {\n        skipPreflight: options.skipPreflight,\n        preflightCommitment: options.preflightCommitment || options.commitment,\n        maxRetries: options.maxRetries,\n        minContextSlot: options.minContextSlot\n    };\n    const signature = await connection.sendTransaction(transaction, signers, sendOptions);\n    let status;\n    if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) {\n        status = (await connection.confirmTransaction({\n            abortSignal: options?.abortSignal,\n            signature: signature,\n            blockhash: transaction.recentBlockhash,\n            lastValidBlockHeight: transaction.lastValidBlockHeight\n        }, options && options.commitment)).value;\n    } else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {\n        const { nonceInstruction } = transaction.nonceInfo;\n        const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;\n        status = (await connection.confirmTransaction({\n            abortSignal: options?.abortSignal,\n            minContextSlot: transaction.minNonceContextSlot,\n            nonceAccountPubkey,\n            nonceValue: transaction.nonceInfo.nonce,\n            signature\n        }, options && options.commitment)).value;\n    } else {\n        if (options?.abortSignal != null) {\n            console.warn(\"sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was \" + \"supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` \" + \"or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.\");\n        }\n        status = (await connection.confirmTransaction(signature, options && options.commitment)).value;\n    }\n    if (status.err) {\n        if (signature != null) {\n            throw new SendTransactionError({\n                action: \"send\",\n                signature: signature,\n                transactionMessage: `Status: (${JSON.stringify(status)})`\n            });\n        }\n        throw new Error(`Transaction ${signature} failed (${JSON.stringify(status)})`);\n    }\n    return signature;\n}\n// zzz\nfunction sleep(ms) {\n    return new Promise((resolve)=>setTimeout(resolve, ms));\n}\n/**\n * @internal\n */ /**\n * Populate a buffer of instruction data using an InstructionType\n * @internal\n */ function encodeData(type, fields) {\n    const allocLength = type.layout.span >= 0 ? type.layout.span : getAlloc(type, fields);\n    const data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(allocLength);\n    const layoutFields = Object.assign({\n        instruction: type.index\n    }, fields);\n    type.layout.encode(layoutFields, data);\n    return data;\n}\n/**\n * Decode instruction data buffer using an InstructionType\n * @internal\n */ function decodeData$1(type, buffer) {\n    let data;\n    try {\n        data = type.layout.decode(buffer);\n    } catch (err) {\n        throw new Error(\"invalid instruction; \" + err);\n    }\n    if (data.instruction !== type.index) {\n        throw new Error(`invalid instruction; instruction index mismatch ${data.instruction} != ${type.index}`);\n    }\n    return data;\n}\n/**\n * https://github.com/solana-labs/solana/blob/90bedd7e067b5b8f3ddbb45da00a4e9cabb22c62/sdk/src/fee_calculator.rs#L7-L11\n *\n * @internal\n */ const FeeCalculatorLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"lamportsPerSignature\");\n/**\n * Calculator for transaction fees.\n *\n * @deprecated Deprecated since Solana v1.8.0.\n */ /**\n * See https://github.com/solana-labs/solana/blob/0ea2843ec9cdc517572b8e62c959f41b55cf4453/sdk/src/nonce_state.rs#L29-L32\n *\n * @internal\n */ const NonceAccountLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"version\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"state\"),\n    publicKey(\"authorizedPubkey\"),\n    publicKey(\"nonce\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        FeeCalculatorLayout\n    ], \"feeCalculator\")\n]);\nconst NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;\n/**\n * A durable nonce is a 32 byte value encoded as a base58 string.\n */ /**\n * NonceAccount class\n */ class NonceAccount {\n    /**\n   * @internal\n   */ constructor(args){\n        this.authorizedPubkey = void 0;\n        this.nonce = void 0;\n        this.feeCalculator = void 0;\n        this.authorizedPubkey = args.authorizedPubkey;\n        this.nonce = args.nonce;\n        this.feeCalculator = args.feeCalculator;\n    }\n    /**\n   * Deserialize NonceAccount from the account data.\n   *\n   * @param buffer account data\n   * @return NonceAccount\n   */ static fromAccountData(buffer) {\n        const nonceAccount = NonceAccountLayout.decode(toBuffer(buffer), 0);\n        return new NonceAccount({\n            authorizedPubkey: new PublicKey(nonceAccount.authorizedPubkey),\n            nonce: new PublicKey(nonceAccount.nonce).toString(),\n            feeCalculator: nonceAccount.feeCalculator\n        });\n    }\n}\nconst encodeDecode = (layout)=>{\n    const decode = layout.decode.bind(layout);\n    const encode = layout.encode.bind(layout);\n    return {\n        decode,\n        encode\n    };\n};\nconst bigInt = (length)=>(property)=>{\n        const layout = (0,_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob)(length, property);\n        const { encode, decode } = encodeDecode(layout);\n        const bigIntLayout = layout;\n        bigIntLayout.decode = (buffer, offset)=>{\n            const src = decode(buffer, offset);\n            return (0,bigint_buffer__WEBPACK_IMPORTED_MODULE_5__.toBigIntLE)(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(src));\n        };\n        bigIntLayout.encode = (bigInt, buffer, offset)=>{\n            const src = (0,bigint_buffer__WEBPACK_IMPORTED_MODULE_5__.toBufferLE)(bigInt, length);\n            return encode(src, buffer, offset);\n        };\n        return bigIntLayout;\n    };\nconst u64 = bigInt(8);\n/**\n * Create account system transaction params\n */ /**\n * Transfer system transaction params\n */ /**\n * Assign system transaction params\n */ /**\n * Create account with seed system transaction params\n */ /**\n * Create nonce account system transaction params\n */ /**\n * Create nonce account with seed system transaction params\n */ /**\n * Initialize nonce account system instruction params\n */ /**\n * Advance nonce account system instruction params\n */ /**\n * Withdraw nonce account system transaction params\n */ /**\n * Authorize nonce account system transaction params\n */ /**\n * Allocate account system transaction params\n */ /**\n * Allocate account with seed system transaction params\n */ /**\n * Assign account with seed system transaction params\n */ /**\n * Transfer with seed system transaction params\n */ /** Decoded transfer system transaction instruction */ /** Decoded transferWithSeed system transaction instruction */ /**\n * System Instruction class\n */ class SystemInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Decode a system instruction and retrieve the instruction type.\n   */ static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\");\n        const typeIndex = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [ixType, layout] of Object.entries(SYSTEM_INSTRUCTION_LAYOUTS)){\n            if (layout.index == typeIndex) {\n                type = ixType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Instruction type incorrect; not a SystemInstruction\");\n        }\n        return type;\n    }\n    /**\n   * Decode a create account system instruction and retrieve the instruction params.\n   */ static decodeCreateAccount(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { lamports, space, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Create, instruction.data);\n        return {\n            fromPubkey: instruction.keys[0].pubkey,\n            newAccountPubkey: instruction.keys[1].pubkey,\n            lamports,\n            space,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode a transfer system instruction and retrieve the instruction params.\n   */ static decodeTransfer(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { lamports } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Transfer, instruction.data);\n        return {\n            fromPubkey: instruction.keys[0].pubkey,\n            toPubkey: instruction.keys[1].pubkey,\n            lamports\n        };\n    }\n    /**\n   * Decode a transfer with seed system instruction and retrieve the instruction params.\n   */ static decodeTransferWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { lamports, seed, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed, instruction.data);\n        return {\n            fromPubkey: instruction.keys[0].pubkey,\n            basePubkey: instruction.keys[1].pubkey,\n            toPubkey: instruction.keys[2].pubkey,\n            lamports,\n            seed,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode an allocate system instruction and retrieve the instruction params.\n   */ static decodeAllocate(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 1);\n        const { space } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Allocate, instruction.data);\n        return {\n            accountPubkey: instruction.keys[0].pubkey,\n            space\n        };\n    }\n    /**\n   * Decode an allocate with seed system instruction and retrieve the instruction params.\n   */ static decodeAllocateWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 1);\n        const { base, seed, space, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed, instruction.data);\n        return {\n            accountPubkey: instruction.keys[0].pubkey,\n            basePubkey: new PublicKey(base),\n            seed,\n            space,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode an assign system instruction and retrieve the instruction params.\n   */ static decodeAssign(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 1);\n        const { programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Assign, instruction.data);\n        return {\n            accountPubkey: instruction.keys[0].pubkey,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode an assign with seed system instruction and retrieve the instruction params.\n   */ static decodeAssignWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 1);\n        const { base, seed, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed, instruction.data);\n        return {\n            accountPubkey: instruction.keys[0].pubkey,\n            basePubkey: new PublicKey(base),\n            seed,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode a create account with seed system instruction and retrieve the instruction params.\n   */ static decodeCreateWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { base, seed, lamports, space, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, instruction.data);\n        return {\n            fromPubkey: instruction.keys[0].pubkey,\n            newAccountPubkey: instruction.keys[1].pubkey,\n            basePubkey: new PublicKey(base),\n            seed,\n            lamports,\n            space,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode a nonce initialize system instruction and retrieve the instruction params.\n   */ static decodeNonceInitialize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { authorized } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, instruction.data);\n        return {\n            noncePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: new PublicKey(authorized)\n        };\n    }\n    /**\n   * Decode a nonce advance system instruction and retrieve the instruction params.\n   */ static decodeNonceAdvance(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, instruction.data);\n        return {\n            noncePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey\n        };\n    }\n    /**\n   * Decode a nonce withdraw system instruction and retrieve the instruction params.\n   */ static decodeNonceWithdraw(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 5);\n        const { lamports } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, instruction.data);\n        return {\n            noncePubkey: instruction.keys[0].pubkey,\n            toPubkey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[4].pubkey,\n            lamports\n        };\n    }\n    /**\n   * Decode a nonce authorize system instruction and retrieve the instruction params.\n   */ static decodeNonceAuthorize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { authorized } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, instruction.data);\n        return {\n            noncePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[1].pubkey,\n            newAuthorizedPubkey: new PublicKey(authorized)\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(SystemProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not SystemProgram\");\n        }\n    }\n    /**\n   * @internal\n   */ static checkKeyLength(keys, expectedLength) {\n        if (keys.length < expectedLength) {\n            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n        }\n    }\n}\n/**\n * An enumeration of valid SystemInstructionType's\n */ /**\n * An enumeration of valid system InstructionType's\n * @internal\n */ const SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({\n    Create: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"space\"),\n            publicKey(\"programId\")\n        ])\n    },\n    Assign: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"programId\")\n        ])\n    },\n    Transfer: {\n        index: 2,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            u64(\"lamports\")\n        ])\n    },\n    CreateWithSeed: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"base\"),\n            rustString(\"seed\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"space\"),\n            publicKey(\"programId\")\n        ])\n    },\n    AdvanceNonceAccount: {\n        index: 4,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    WithdrawNonceAccount: {\n        index: 5,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\")\n        ])\n    },\n    InitializeNonceAccount: {\n        index: 6,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"authorized\")\n        ])\n    },\n    AuthorizeNonceAccount: {\n        index: 7,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"authorized\")\n        ])\n    },\n    Allocate: {\n        index: 8,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"space\")\n        ])\n    },\n    AllocateWithSeed: {\n        index: 9,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"base\"),\n            rustString(\"seed\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"space\"),\n            publicKey(\"programId\")\n        ])\n    },\n    AssignWithSeed: {\n        index: 10,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"base\"),\n            rustString(\"seed\"),\n            publicKey(\"programId\")\n        ])\n    },\n    TransferWithSeed: {\n        index: 11,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            u64(\"lamports\"),\n            rustString(\"seed\"),\n            publicKey(\"programId\")\n        ])\n    },\n    UpgradeNonceAccount: {\n        index: 12,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    }\n});\n/**\n * Factory class for transactions to interact with the System program\n */ class SystemProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the System program\n   */ /**\n   * Generate a transaction instruction that creates a new account\n   */ static createAccount(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.Create;\n        const data = encodeData(type, {\n            lamports: params.lamports,\n            space: params.space,\n            programId: toBuffer(params.programId.toBuffer())\n        });\n        return new TransactionInstruction({\n            keys: [\n                {\n                    pubkey: params.fromPubkey,\n                    isSigner: true,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.newAccountPubkey,\n                    isSigner: true,\n                    isWritable: true\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that transfers lamports from one account to another\n   */ static transfer(params) {\n        let data;\n        let keys;\n        if (\"basePubkey\" in params) {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;\n            data = encodeData(type, {\n                lamports: BigInt(params.lamports),\n                seed: params.seed,\n                programId: toBuffer(params.programId.toBuffer())\n            });\n            keys = [\n                {\n                    pubkey: params.fromPubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.basePubkey,\n                    isSigner: true,\n                    isWritable: false\n                },\n                {\n                    pubkey: params.toPubkey,\n                    isSigner: false,\n                    isWritable: true\n                }\n            ];\n        } else {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;\n            data = encodeData(type, {\n                lamports: BigInt(params.lamports)\n            });\n            keys = [\n                {\n                    pubkey: params.fromPubkey,\n                    isSigner: true,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.toPubkey,\n                    isSigner: false,\n                    isWritable: true\n                }\n            ];\n        }\n        return new TransactionInstruction({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that assigns an account to a program\n   */ static assign(params) {\n        let data;\n        let keys;\n        if (\"basePubkey\" in params) {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;\n            data = encodeData(type, {\n                base: toBuffer(params.basePubkey.toBuffer()),\n                seed: params.seed,\n                programId: toBuffer(params.programId.toBuffer())\n            });\n            keys = [\n                {\n                    pubkey: params.accountPubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.basePubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ];\n        } else {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.Assign;\n            data = encodeData(type, {\n                programId: toBuffer(params.programId.toBuffer())\n            });\n            keys = [\n                {\n                    pubkey: params.accountPubkey,\n                    isSigner: true,\n                    isWritable: true\n                }\n            ];\n        }\n        return new TransactionInstruction({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that creates a new account at\n   *   an address generated with `from`, a seed, and programId\n   */ static createAccountWithSeed(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;\n        const data = encodeData(type, {\n            base: toBuffer(params.basePubkey.toBuffer()),\n            seed: params.seed,\n            lamports: params.lamports,\n            space: params.space,\n            programId: toBuffer(params.programId.toBuffer())\n        });\n        let keys = [\n            {\n                pubkey: params.fromPubkey,\n                isSigner: true,\n                isWritable: true\n            },\n            {\n                pubkey: params.newAccountPubkey,\n                isSigner: false,\n                isWritable: true\n            }\n        ];\n        if (!params.basePubkey.equals(params.fromPubkey)) {\n            keys.push({\n                pubkey: params.basePubkey,\n                isSigner: true,\n                isWritable: false\n            });\n        }\n        return new TransactionInstruction({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction that creates a new Nonce account\n   */ static createNonceAccount(params) {\n        const transaction = new Transaction();\n        if (\"basePubkey\" in params && \"seed\" in params) {\n            transaction.add(SystemProgram.createAccountWithSeed({\n                fromPubkey: params.fromPubkey,\n                newAccountPubkey: params.noncePubkey,\n                basePubkey: params.basePubkey,\n                seed: params.seed,\n                lamports: params.lamports,\n                space: NONCE_ACCOUNT_LENGTH,\n                programId: this.programId\n            }));\n        } else {\n            transaction.add(SystemProgram.createAccount({\n                fromPubkey: params.fromPubkey,\n                newAccountPubkey: params.noncePubkey,\n                lamports: params.lamports,\n                space: NONCE_ACCOUNT_LENGTH,\n                programId: this.programId\n            }));\n        }\n        const initParams = {\n            noncePubkey: params.noncePubkey,\n            authorizedPubkey: params.authorizedPubkey\n        };\n        transaction.add(this.nonceInitialize(initParams));\n        return transaction;\n    }\n    /**\n   * Generate an instruction to initialize a Nonce account\n   */ static nonceInitialize(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;\n        const data = encodeData(type, {\n            authorized: toBuffer(params.authorizedPubkey.toBuffer())\n        });\n        const instructionData = {\n            keys: [\n                {\n                    pubkey: params.noncePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        };\n        return new TransactionInstruction(instructionData);\n    }\n    /**\n   * Generate an instruction to advance the nonce in a Nonce account\n   */ static nonceAdvance(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;\n        const data = encodeData(type);\n        const instructionData = {\n            keys: [\n                {\n                    pubkey: params.noncePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: params.authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        };\n        return new TransactionInstruction(instructionData);\n    }\n    /**\n   * Generate a transaction instruction that withdraws lamports from a Nonce account\n   */ static nonceWithdraw(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;\n        const data = encodeData(type, {\n            lamports: params.lamports\n        });\n        return new TransactionInstruction({\n            keys: [\n                {\n                    pubkey: params.noncePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.toPubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: params.authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that authorizes a new PublicKey as the authority\n   * on a Nonce account.\n   */ static nonceAuthorize(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;\n        const data = encodeData(type, {\n            authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())\n        });\n        return new TransactionInstruction({\n            keys: [\n                {\n                    pubkey: params.noncePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that allocates space in an account without funding\n   */ static allocate(params) {\n        let data;\n        let keys;\n        if (\"basePubkey\" in params) {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;\n            data = encodeData(type, {\n                base: toBuffer(params.basePubkey.toBuffer()),\n                seed: params.seed,\n                space: params.space,\n                programId: toBuffer(params.programId.toBuffer())\n            });\n            keys = [\n                {\n                    pubkey: params.accountPubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.basePubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ];\n        } else {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;\n            data = encodeData(type, {\n                space: params.space\n            });\n            keys = [\n                {\n                    pubkey: params.accountPubkey,\n                    isSigner: true,\n                    isWritable: true\n                }\n            ];\n        }\n        return new TransactionInstruction({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n}\nSystemProgram.programId = new PublicKey(\"11111111111111111111111111111111\");\n// Keep program chunks under PACKET_DATA_SIZE, leaving enough room for the\n// rest of the Transaction fields\n//\n// TODO: replace 300 with a proper constant for the size of the other\n// Transaction fields\nconst CHUNK_SIZE = PACKET_DATA_SIZE - 300;\n/**\n * Program loader interface\n */ class Loader {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Amount of program data placed in each load Transaction\n   */ /**\n   * Minimum number of signatures required to load a program not including\n   * retries\n   *\n   * Can be used to calculate transaction fees\n   */ static getMinNumSignatures(dataLength) {\n        return 2 * // Every transaction requires two signatures (payer + program)\n        (Math.ceil(dataLength / Loader.chunkSize) + 1 + // Add one for Create transaction\n        1 // Add one for Finalize transaction\n        );\n    }\n    /**\n   * Loads a generic program\n   *\n   * @param connection The connection to use\n   * @param payer System account that pays to load the program\n   * @param program Account to load the program into\n   * @param programId Public key that identifies the loader\n   * @param data Program octets\n   * @return true if program was loaded successfully, false if program was already loaded\n   */ static async load(connection, payer, program, programId, data) {\n        {\n            const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length);\n            // Fetch program account info to check if it has already been created\n            const programInfo = await connection.getAccountInfo(program.publicKey, \"confirmed\");\n            let transaction = null;\n            if (programInfo !== null) {\n                if (programInfo.executable) {\n                    console.error(\"Program load failed, account is already executable\");\n                    return false;\n                }\n                if (programInfo.data.length !== data.length) {\n                    transaction = transaction || new Transaction();\n                    transaction.add(SystemProgram.allocate({\n                        accountPubkey: program.publicKey,\n                        space: data.length\n                    }));\n                }\n                if (!programInfo.owner.equals(programId)) {\n                    transaction = transaction || new Transaction();\n                    transaction.add(SystemProgram.assign({\n                        accountPubkey: program.publicKey,\n                        programId\n                    }));\n                }\n                if (programInfo.lamports < balanceNeeded) {\n                    transaction = transaction || new Transaction();\n                    transaction.add(SystemProgram.transfer({\n                        fromPubkey: payer.publicKey,\n                        toPubkey: program.publicKey,\n                        lamports: balanceNeeded - programInfo.lamports\n                    }));\n                }\n            } else {\n                transaction = new Transaction().add(SystemProgram.createAccount({\n                    fromPubkey: payer.publicKey,\n                    newAccountPubkey: program.publicKey,\n                    lamports: balanceNeeded > 0 ? balanceNeeded : 1,\n                    space: data.length,\n                    programId\n                }));\n            }\n            // If the account is already created correctly, skip this step\n            // and proceed directly to loading instructions\n            if (transaction !== null) {\n                await sendAndConfirmTransaction(connection, transaction, [\n                    payer,\n                    program\n                ], {\n                    commitment: \"confirmed\"\n                });\n            }\n        }\n        const dataLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"offset\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"bytesLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"bytesLengthPadding\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"byte\"), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"bytes\")\n        ]);\n        const chunkSize = Loader.chunkSize;\n        let offset = 0;\n        let array = data;\n        let transactions = [];\n        while(array.length > 0){\n            const bytes = array.slice(0, chunkSize);\n            const data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(chunkSize + 16);\n            dataLayout.encode({\n                instruction: 0,\n                // Load instruction\n                offset,\n                bytes: bytes,\n                bytesLength: 0,\n                bytesLengthPadding: 0\n            }, data);\n            const transaction = new Transaction().add({\n                keys: [\n                    {\n                        pubkey: program.publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    }\n                ],\n                programId,\n                data\n            });\n            transactions.push(sendAndConfirmTransaction(connection, transaction, [\n                payer,\n                program\n            ], {\n                commitment: \"confirmed\"\n            }));\n            // Delay between sends in an attempt to reduce rate limit errors\n            if (connection._rpcEndpoint.includes(\"solana.com\")) {\n                const REQUESTS_PER_SECOND = 4;\n                await sleep(1000 / REQUESTS_PER_SECOND);\n            }\n            offset += chunkSize;\n            array = array.slice(chunkSize);\n        }\n        await Promise.all(transactions);\n        // Finalize the account loaded with program data for execution\n        {\n            const dataLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n            ]);\n            const data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(dataLayout.span);\n            dataLayout.encode({\n                instruction: 1 // Finalize instruction\n            }, data);\n            const transaction = new Transaction().add({\n                keys: [\n                    {\n                        pubkey: program.publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: SYSVAR_RENT_PUBKEY,\n                        isSigner: false,\n                        isWritable: false\n                    }\n                ],\n                programId,\n                data\n            });\n            const deployCommitment = \"processed\";\n            const finalizeSignature = await connection.sendTransaction(transaction, [\n                payer,\n                program\n            ], {\n                preflightCommitment: deployCommitment\n            });\n            const { context, value } = await connection.confirmTransaction({\n                signature: finalizeSignature,\n                lastValidBlockHeight: transaction.lastValidBlockHeight,\n                blockhash: transaction.recentBlockhash\n            }, deployCommitment);\n            if (value.err) {\n                throw new Error(`Transaction ${finalizeSignature} failed (${JSON.stringify(value)})`);\n            }\n            // We prevent programs from being usable until the slot after their deployment.\n            // See https://github.com/solana-labs/solana/pull/29654\n            while(true // eslint-disable-line no-constant-condition\n            ){\n                try {\n                    const currentSlot = await connection.getSlot({\n                        commitment: deployCommitment\n                    });\n                    if (currentSlot > context.slot) {\n                        break;\n                    }\n                } catch  {\n                /* empty */ }\n                await new Promise((resolve)=>setTimeout(resolve, Math.round(MS_PER_SLOT / 2)));\n            }\n        }\n        // success\n        return true;\n    }\n}\nLoader.chunkSize = CHUNK_SIZE;\n/**\n * @deprecated Deprecated since Solana v1.17.20.\n */ const BPF_LOADER_PROGRAM_ID = new PublicKey(\"BPFLoader2111111111111111111111111111111111\");\n/**\n * Factory class for transactions to interact with a program loader\n *\n * @deprecated Deprecated since Solana v1.17.20.\n */ class BpfLoader {\n    /**\n   * Minimum number of signatures required to load a program not including\n   * retries\n   *\n   * Can be used to calculate transaction fees\n   */ static getMinNumSignatures(dataLength) {\n        return Loader.getMinNumSignatures(dataLength);\n    }\n    /**\n   * Load a SBF program\n   *\n   * @param connection The connection to use\n   * @param payer Account that will pay program loading fees\n   * @param program Account to load the program into\n   * @param elf The entire ELF containing the SBF program\n   * @param loaderProgramId The program id of the BPF loader to use\n   * @return true if program was loaded successfully, false if program was already loaded\n   */ static load(connection, payer, program, elf, loaderProgramId) {\n        return Loader.load(connection, payer, program, loaderProgramId, elf);\n    }\n}\nfunction getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nvar agentkeepalive = {\n    exports: {}\n};\n/**\n * Helpers.\n */ var ms;\nvar hasRequiredMs;\nfunction requireMs() {\n    if (hasRequiredMs) return ms;\n    hasRequiredMs = 1;\n    var s = 1000;\n    var m = s * 60;\n    var h = m * 60;\n    var d = h * 24;\n    var w = d * 7;\n    var y = d * 365.25;\n    /**\n\t * Parse or format the given `val`.\n\t *\n\t * Options:\n\t *\n\t *  - `long` verbose formatting [false]\n\t *\n\t * @param {String|Number} val\n\t * @param {Object} [options]\n\t * @throws {Error} throw an error if val is not a non-empty string or a number\n\t * @return {String|Number}\n\t * @api public\n\t */ ms = function(val, options) {\n        options = options || {};\n        var type = typeof val;\n        if (type === \"string\" && val.length > 0) {\n            return parse(val);\n        } else if (type === \"number\" && isFinite(val)) {\n            return options.long ? fmtLong(val) : fmtShort(val);\n        }\n        throw new Error(\"val is not a non-empty string or a valid number. val=\" + JSON.stringify(val));\n    };\n    /**\n\t * Parse the given `str` and return milliseconds.\n\t *\n\t * @param {String} str\n\t * @return {Number}\n\t * @api private\n\t */ function parse(str) {\n        str = String(str);\n        if (str.length > 100) {\n            return;\n        }\n        var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);\n        if (!match) {\n            return;\n        }\n        var n = parseFloat(match[1]);\n        var type = (match[2] || \"ms\").toLowerCase();\n        switch(type){\n            case \"years\":\n            case \"year\":\n            case \"yrs\":\n            case \"yr\":\n            case \"y\":\n                return n * y;\n            case \"weeks\":\n            case \"week\":\n            case \"w\":\n                return n * w;\n            case \"days\":\n            case \"day\":\n            case \"d\":\n                return n * d;\n            case \"hours\":\n            case \"hour\":\n            case \"hrs\":\n            case \"hr\":\n            case \"h\":\n                return n * h;\n            case \"minutes\":\n            case \"minute\":\n            case \"mins\":\n            case \"min\":\n            case \"m\":\n                return n * m;\n            case \"seconds\":\n            case \"second\":\n            case \"secs\":\n            case \"sec\":\n            case \"s\":\n                return n * s;\n            case \"milliseconds\":\n            case \"millisecond\":\n            case \"msecs\":\n            case \"msec\":\n            case \"ms\":\n                return n;\n            default:\n                return undefined;\n        }\n    }\n    /**\n\t * Short format for `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {String}\n\t * @api private\n\t */ function fmtShort(ms) {\n        var msAbs = Math.abs(ms);\n        if (msAbs >= d) {\n            return Math.round(ms / d) + \"d\";\n        }\n        if (msAbs >= h) {\n            return Math.round(ms / h) + \"h\";\n        }\n        if (msAbs >= m) {\n            return Math.round(ms / m) + \"m\";\n        }\n        if (msAbs >= s) {\n            return Math.round(ms / s) + \"s\";\n        }\n        return ms + \"ms\";\n    }\n    /**\n\t * Long format for `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {String}\n\t * @api private\n\t */ function fmtLong(ms) {\n        var msAbs = Math.abs(ms);\n        if (msAbs >= d) {\n            return plural(ms, msAbs, d, \"day\");\n        }\n        if (msAbs >= h) {\n            return plural(ms, msAbs, h, \"hour\");\n        }\n        if (msAbs >= m) {\n            return plural(ms, msAbs, m, \"minute\");\n        }\n        if (msAbs >= s) {\n            return plural(ms, msAbs, s, \"second\");\n        }\n        return ms + \" ms\";\n    }\n    /**\n\t * Pluralization helper.\n\t */ function plural(ms, msAbs, n, name) {\n        var isPlural = msAbs >= n * 1.5;\n        return Math.round(ms / n) + \" \" + name + (isPlural ? \"s\" : \"\");\n    }\n    return ms;\n}\n/*!\n * humanize-ms - index.js\n * Copyright(c) 2014 dead_horse <dead_horse@qq.com>\n * MIT Licensed\n */ var humanizeMs;\nvar hasRequiredHumanizeMs;\nfunction requireHumanizeMs() {\n    if (hasRequiredHumanizeMs) return humanizeMs;\n    hasRequiredHumanizeMs = 1;\n    /**\n\t * Module dependencies.\n\t */ var util = (util__WEBPACK_IMPORTED_MODULE_6___default());\n    var ms = /*@__PURE__*/ requireMs();\n    humanizeMs = function(t) {\n        if (typeof t === \"number\") return t;\n        var r = ms(t);\n        if (r === undefined) {\n            var err = new Error(util.format(\"humanize-ms(%j) result undefined\", t));\n            console.warn(err.stack);\n        }\n        return r;\n    };\n    return humanizeMs;\n}\nvar constants;\nvar hasRequiredConstants;\nfunction requireConstants() {\n    if (hasRequiredConstants) return constants;\n    hasRequiredConstants = 1;\n    constants = {\n        // agent\n        CURRENT_ID: Symbol(\"agentkeepalive#currentId\"),\n        CREATE_ID: Symbol(\"agentkeepalive#createId\"),\n        INIT_SOCKET: Symbol(\"agentkeepalive#initSocket\"),\n        CREATE_HTTPS_CONNECTION: Symbol(\"agentkeepalive#createHttpsConnection\"),\n        // socket\n        SOCKET_CREATED_TIME: Symbol(\"agentkeepalive#socketCreatedTime\"),\n        SOCKET_NAME: Symbol(\"agentkeepalive#socketName\"),\n        SOCKET_REQUEST_COUNT: Symbol(\"agentkeepalive#socketRequestCount\"),\n        SOCKET_REQUEST_FINISHED_COUNT: Symbol(\"agentkeepalive#socketRequestFinishedCount\")\n    };\n    return constants;\n}\nvar agent;\nvar hasRequiredAgent;\nfunction requireAgent() {\n    if (hasRequiredAgent) return agent;\n    hasRequiredAgent = 1;\n    const OriginalAgent = (http__WEBPACK_IMPORTED_MODULE_7___default().Agent);\n    const ms = /*@__PURE__*/ requireHumanizeMs();\n    const debug = util__WEBPACK_IMPORTED_MODULE_6___default().debuglog(\"agentkeepalive\");\n    const { INIT_SOCKET, CURRENT_ID, CREATE_ID, SOCKET_CREATED_TIME, SOCKET_NAME, SOCKET_REQUEST_COUNT, SOCKET_REQUEST_FINISHED_COUNT } = /*@__PURE__*/ requireConstants();\n    // OriginalAgent come from\n    // - https://github.com/nodejs/node/blob/v8.12.0/lib/_http_agent.js\n    // - https://github.com/nodejs/node/blob/v10.12.0/lib/_http_agent.js\n    // node <= 10\n    let defaultTimeoutListenerCount = 1;\n    const majorVersion = parseInt(process.version.split(\".\", 1)[0].substring(1));\n    if (majorVersion >= 11 && majorVersion <= 12) {\n        defaultTimeoutListenerCount = 2;\n    } else if (majorVersion >= 13) {\n        defaultTimeoutListenerCount = 3;\n    }\n    function deprecate(message) {\n        console.log(\"[agentkeepalive:deprecated] %s\", message);\n    }\n    class Agent extends OriginalAgent {\n        constructor(options){\n            options = options || {};\n            options.keepAlive = options.keepAlive !== false;\n            // default is keep-alive and 4s free socket timeout\n            // see https://medium.com/ssense-tech/reduce-networking-errors-in-nodejs-23b4eb9f2d83\n            if (options.freeSocketTimeout === undefined) {\n                options.freeSocketTimeout = 4000;\n            }\n            // Legacy API: keepAliveTimeout should be rename to `freeSocketTimeout`\n            if (options.keepAliveTimeout) {\n                deprecate(\"options.keepAliveTimeout is deprecated, please use options.freeSocketTimeout instead\");\n                options.freeSocketTimeout = options.keepAliveTimeout;\n                delete options.keepAliveTimeout;\n            }\n            // Legacy API: freeSocketKeepAliveTimeout should be rename to `freeSocketTimeout`\n            if (options.freeSocketKeepAliveTimeout) {\n                deprecate(\"options.freeSocketKeepAliveTimeout is deprecated, please use options.freeSocketTimeout instead\");\n                options.freeSocketTimeout = options.freeSocketKeepAliveTimeout;\n                delete options.freeSocketKeepAliveTimeout;\n            }\n            // Sets the socket to timeout after timeout milliseconds of inactivity on the socket.\n            // By default is double free socket timeout.\n            if (options.timeout === undefined) {\n                // make sure socket default inactivity timeout >= 8s\n                options.timeout = Math.max(options.freeSocketTimeout * 2, 8000);\n            }\n            // support humanize format\n            options.timeout = ms(options.timeout);\n            options.freeSocketTimeout = ms(options.freeSocketTimeout);\n            options.socketActiveTTL = options.socketActiveTTL ? ms(options.socketActiveTTL) : 0;\n            super(options);\n            this[CURRENT_ID] = 0;\n            // create socket success counter\n            this.createSocketCount = 0;\n            this.createSocketCountLastCheck = 0;\n            this.createSocketErrorCount = 0;\n            this.createSocketErrorCountLastCheck = 0;\n            this.closeSocketCount = 0;\n            this.closeSocketCountLastCheck = 0;\n            // socket error event count\n            this.errorSocketCount = 0;\n            this.errorSocketCountLastCheck = 0;\n            // request finished counter\n            this.requestCount = 0;\n            this.requestCountLastCheck = 0;\n            // including free socket timeout counter\n            this.timeoutSocketCount = 0;\n            this.timeoutSocketCountLastCheck = 0;\n            this.on(\"free\", (socket)=>{\n                // https://github.com/nodejs/node/pull/32000\n                // Node.js native agent will check socket timeout eqs agent.options.timeout.\n                // Use the ttl or freeSocketTimeout to overwrite.\n                const timeout = this.calcSocketTimeout(socket);\n                if (timeout > 0 && socket.timeout !== timeout) {\n                    socket.setTimeout(timeout);\n                }\n            });\n        }\n        get freeSocketKeepAliveTimeout() {\n            deprecate(\"agent.freeSocketKeepAliveTimeout is deprecated, please use agent.options.freeSocketTimeout instead\");\n            return this.options.freeSocketTimeout;\n        }\n        get timeout() {\n            deprecate(\"agent.timeout is deprecated, please use agent.options.timeout instead\");\n            return this.options.timeout;\n        }\n        get socketActiveTTL() {\n            deprecate(\"agent.socketActiveTTL is deprecated, please use agent.options.socketActiveTTL instead\");\n            return this.options.socketActiveTTL;\n        }\n        calcSocketTimeout(socket) {\n            /**\n\t     * return <= 0: should free socket\n\t     * return > 0: should update socket timeout\n\t     * return undefined: not find custom timeout\n\t     */ let freeSocketTimeout = this.options.freeSocketTimeout;\n            const socketActiveTTL = this.options.socketActiveTTL;\n            if (socketActiveTTL) {\n                // check socketActiveTTL\n                const aliveTime = Date.now() - socket[SOCKET_CREATED_TIME];\n                const diff = socketActiveTTL - aliveTime;\n                if (diff <= 0) {\n                    return diff;\n                }\n                if (freeSocketTimeout && diff < freeSocketTimeout) {\n                    freeSocketTimeout = diff;\n                }\n            }\n            // set freeSocketTimeout\n            if (freeSocketTimeout) {\n                // set free keepalive timer\n                // try to use socket custom freeSocketTimeout first, support headers['keep-alive']\n                // https://github.com/node-modules/urllib/blob/b76053020923f4d99a1c93cf2e16e0c5ba10bacf/lib/urllib.js#L498\n                const customFreeSocketTimeout = socket.freeSocketTimeout || socket.freeSocketKeepAliveTimeout;\n                return customFreeSocketTimeout || freeSocketTimeout;\n            }\n        }\n        keepSocketAlive(socket) {\n            const result = super.keepSocketAlive(socket);\n            // should not keepAlive, do nothing\n            if (!result) return result;\n            const customTimeout = this.calcSocketTimeout(socket);\n            if (typeof customTimeout === \"undefined\") {\n                return true;\n            }\n            if (customTimeout <= 0) {\n                debug(\"%s(requests: %s, finished: %s) free but need to destroy by TTL, request count %s, diff is %s\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], customTimeout);\n                return false;\n            }\n            if (socket.timeout !== customTimeout) {\n                socket.setTimeout(customTimeout);\n            }\n            return true;\n        }\n        // only call on addRequest\n        reuseSocket(...args) {\n            // reuseSocket(socket, req)\n            super.reuseSocket(...args);\n            const socket = args[0];\n            const req = args[1];\n            req.reusedSocket = true;\n            const agentTimeout = this.options.timeout;\n            if (getSocketTimeout(socket) !== agentTimeout) {\n                // reset timeout before use\n                socket.setTimeout(agentTimeout);\n                debug(\"%s reset timeout to %sms\", socket[SOCKET_NAME], agentTimeout);\n            }\n            socket[SOCKET_REQUEST_COUNT]++;\n            debug(\"%s(requests: %s, finished: %s) reuse on addRequest, timeout %sms\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], getSocketTimeout(socket));\n        }\n        [CREATE_ID]() {\n            const id = this[CURRENT_ID]++;\n            if (this[CURRENT_ID] === Number.MAX_SAFE_INTEGER) this[CURRENT_ID] = 0;\n            return id;\n        }\n        [INIT_SOCKET](socket, options) {\n            // bugfix here.\n            // https on node 8, 10 won't set agent.options.timeout by default\n            // TODO: need to fix on node itself\n            if (options.timeout) {\n                const timeout = getSocketTimeout(socket);\n                if (!timeout) {\n                    socket.setTimeout(options.timeout);\n                }\n            }\n            if (this.options.keepAlive) {\n                // Disable Nagle's algorithm: http://blog.caustik.com/2012/04/08/scaling-node-js-to-100k-concurrent-connections/\n                // https://fengmk2.com/benchmark/nagle-algorithm-delayed-ack-mock.html\n                socket.setNoDelay(true);\n            }\n            this.createSocketCount++;\n            if (this.options.socketActiveTTL) {\n                socket[SOCKET_CREATED_TIME] = Date.now();\n            }\n            // don't show the hole '-----BEGIN CERTIFICATE----' key string\n            socket[SOCKET_NAME] = `sock[${this[CREATE_ID]()}#${options._agentKey}]`.split(\"-----BEGIN\", 1)[0];\n            socket[SOCKET_REQUEST_COUNT] = 1;\n            socket[SOCKET_REQUEST_FINISHED_COUNT] = 0;\n            installListeners(this, socket, options);\n        }\n        createConnection(options, oncreate) {\n            let called = false;\n            const onNewCreate = (err, socket)=>{\n                if (called) return;\n                called = true;\n                if (err) {\n                    this.createSocketErrorCount++;\n                    return oncreate(err);\n                }\n                this[INIT_SOCKET](socket, options);\n                oncreate(err, socket);\n            };\n            const newSocket = super.createConnection(options, onNewCreate);\n            if (newSocket) onNewCreate(null, newSocket);\n            return newSocket;\n        }\n        get statusChanged() {\n            const changed = this.createSocketCount !== this.createSocketCountLastCheck || this.createSocketErrorCount !== this.createSocketErrorCountLastCheck || this.closeSocketCount !== this.closeSocketCountLastCheck || this.errorSocketCount !== this.errorSocketCountLastCheck || this.timeoutSocketCount !== this.timeoutSocketCountLastCheck || this.requestCount !== this.requestCountLastCheck;\n            if (changed) {\n                this.createSocketCountLastCheck = this.createSocketCount;\n                this.createSocketErrorCountLastCheck = this.createSocketErrorCount;\n                this.closeSocketCountLastCheck = this.closeSocketCount;\n                this.errorSocketCountLastCheck = this.errorSocketCount;\n                this.timeoutSocketCountLastCheck = this.timeoutSocketCount;\n                this.requestCountLastCheck = this.requestCount;\n            }\n            return changed;\n        }\n        getCurrentStatus() {\n            return {\n                createSocketCount: this.createSocketCount,\n                createSocketErrorCount: this.createSocketErrorCount,\n                closeSocketCount: this.closeSocketCount,\n                errorSocketCount: this.errorSocketCount,\n                timeoutSocketCount: this.timeoutSocketCount,\n                requestCount: this.requestCount,\n                freeSockets: inspect(this.freeSockets),\n                sockets: inspect(this.sockets),\n                requests: inspect(this.requests)\n            };\n        }\n    }\n    // node 8 don't has timeout attribute on socket\n    // https://github.com/nodejs/node/pull/21204/files#diff-e6ef024c3775d787c38487a6309e491dR408\n    function getSocketTimeout(socket) {\n        return socket.timeout || socket._idleTimeout;\n    }\n    function installListeners(agent, socket, options) {\n        debug(\"%s create, timeout %sms\", socket[SOCKET_NAME], getSocketTimeout(socket));\n        // listener socket events: close, timeout, error, free\n        function onFree() {\n            // create and socket.emit('free') logic\n            // https://github.com/nodejs/node/blob/master/lib/_http_agent.js#L311\n            // no req on the socket, it should be the new socket\n            if (!socket._httpMessage && socket[SOCKET_REQUEST_COUNT] === 1) return;\n            socket[SOCKET_REQUEST_FINISHED_COUNT]++;\n            agent.requestCount++;\n            debug(\"%s(requests: %s, finished: %s) free\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);\n            // should reuse on pedding requests?\n            const name = agent.getName(options);\n            if (socket.writable && agent.requests[name] && agent.requests[name].length) {\n                // will be reuse on agent free listener\n                socket[SOCKET_REQUEST_COUNT]++;\n                debug(\"%s(requests: %s, finished: %s) will be reuse on agent free event\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);\n            }\n        }\n        socket.on(\"free\", onFree);\n        function onClose(isError) {\n            debug(\"%s(requests: %s, finished: %s) close, isError: %s\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], isError);\n            agent.closeSocketCount++;\n        }\n        socket.on(\"close\", onClose);\n        // start socket timeout handler\n        function onTimeout() {\n            // onTimeout and emitRequestTimeout(_http_client.js)\n            // https://github.com/nodejs/node/blob/v12.x/lib/_http_client.js#L711\n            const listenerCount = socket.listeners(\"timeout\").length;\n            // node <= 10, default listenerCount is 1, onTimeout\n            // 11 < node <= 12, default listenerCount is 2, onTimeout and emitRequestTimeout\n            // node >= 13, default listenerCount is 3, onTimeout,\n            //   onTimeout(https://github.com/nodejs/node/pull/32000/files#diff-5f7fb0850412c6be189faeddea6c5359R333)\n            //   and emitRequestTimeout\n            const timeout = getSocketTimeout(socket);\n            const req = socket._httpMessage;\n            const reqTimeoutListenerCount = req && req.listeners(\"timeout\").length || 0;\n            debug(\"%s(requests: %s, finished: %s) timeout after %sms, listeners %s, defaultTimeoutListenerCount %s, hasHttpRequest %s, HttpRequest timeoutListenerCount %s\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], timeout, listenerCount, defaultTimeoutListenerCount, !!req, reqTimeoutListenerCount);\n            if (debug.enabled) {\n                debug(\"timeout listeners: %s\", socket.listeners(\"timeout\").map((f)=>f.name).join(\", \"));\n            }\n            agent.timeoutSocketCount++;\n            const name = agent.getName(options);\n            if (agent.freeSockets[name] && agent.freeSockets[name].indexOf(socket) !== -1) {\n                // free socket timeout, destroy quietly\n                socket.destroy();\n                // Remove it from freeSockets list immediately to prevent new requests\n                // from being sent through this socket.\n                agent.removeSocket(socket, options);\n                debug(\"%s is free, destroy quietly\", socket[SOCKET_NAME]);\n            } else {\n                // if there is no any request socket timeout handler,\n                // agent need to handle socket timeout itself.\n                //\n                // custom request socket timeout handle logic must follow these rules:\n                //  1. Destroy socket first\n                //  2. Must emit socket 'agentRemove' event tell agent remove socket\n                //     from freeSockets list immediately.\n                //     Otherise you may be get 'socket hang up' error when reuse\n                //     free socket and timeout happen in the same time.\n                if (reqTimeoutListenerCount === 0) {\n                    const error = new Error(\"Socket timeout\");\n                    error.code = \"ERR_SOCKET_TIMEOUT\";\n                    error.timeout = timeout;\n                    // must manually call socket.end() or socket.destroy() to end the connection.\n                    // https://nodejs.org/dist/latest-v10.x/docs/api/net.html#net_socket_settimeout_timeout_callback\n                    socket.destroy(error);\n                    agent.removeSocket(socket, options);\n                    debug(\"%s destroy with timeout error\", socket[SOCKET_NAME]);\n                }\n            }\n        }\n        socket.on(\"timeout\", onTimeout);\n        function onError(err) {\n            const listenerCount = socket.listeners(\"error\").length;\n            debug(\"%s(requests: %s, finished: %s) error: %s, listenerCount: %s\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], err, listenerCount);\n            agent.errorSocketCount++;\n            if (listenerCount === 1) {\n                // if socket don't contain error event handler, don't catch it, emit it again\n                debug(\"%s emit uncaught error event\", socket[SOCKET_NAME]);\n                socket.removeListener(\"error\", onError);\n                socket.emit(\"error\", err);\n            }\n        }\n        socket.on(\"error\", onError);\n        function onRemove() {\n            debug(\"%s(requests: %s, finished: %s) agentRemove\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);\n            // We need this function for cases like HTTP 'upgrade'\n            // (defined by WebSockets) where we need to remove a socket from the\n            // pool because it'll be locked up indefinitely\n            socket.removeListener(\"close\", onClose);\n            socket.removeListener(\"error\", onError);\n            socket.removeListener(\"free\", onFree);\n            socket.removeListener(\"timeout\", onTimeout);\n            socket.removeListener(\"agentRemove\", onRemove);\n        }\n        socket.on(\"agentRemove\", onRemove);\n    }\n    agent = Agent;\n    function inspect(obj) {\n        const res = {};\n        for(const key in obj){\n            res[key] = obj[key].length;\n        }\n        return res;\n    }\n    return agent;\n}\nvar https_agent;\nvar hasRequiredHttps_agent;\nfunction requireHttps_agent() {\n    if (hasRequiredHttps_agent) return https_agent;\n    hasRequiredHttps_agent = 1;\n    const OriginalHttpsAgent = (https__WEBPACK_IMPORTED_MODULE_8___default().Agent);\n    const HttpAgent = /*@__PURE__*/ requireAgent();\n    const { INIT_SOCKET, CREATE_HTTPS_CONNECTION } = /*@__PURE__*/ requireConstants();\n    class HttpsAgent extends HttpAgent {\n        constructor(options){\n            super(options);\n            this.defaultPort = 443;\n            this.protocol = \"https:\";\n            this.maxCachedSessions = this.options.maxCachedSessions;\n            /* istanbul ignore next */ if (this.maxCachedSessions === undefined) {\n                this.maxCachedSessions = 100;\n            }\n            this._sessionCache = {\n                map: {},\n                list: []\n            };\n        }\n        createConnection(options, oncreate) {\n            const socket = this[CREATE_HTTPS_CONNECTION](options, oncreate);\n            this[INIT_SOCKET](socket, options);\n            return socket;\n        }\n    }\n    // https://github.com/nodejs/node/blob/master/lib/https.js#L89\n    HttpsAgent.prototype[CREATE_HTTPS_CONNECTION] = OriginalHttpsAgent.prototype.createConnection;\n    [\n        \"getName\",\n        \"_getSession\",\n        \"_cacheSession\",\n        // https://github.com/nodejs/node/pull/4982\n        \"_evictSession\"\n    ].forEach(function(method) {\n        /* istanbul ignore next */ if (typeof OriginalHttpsAgent.prototype[method] === \"function\") {\n            HttpsAgent.prototype[method] = OriginalHttpsAgent.prototype[method];\n        }\n    });\n    https_agent = HttpsAgent;\n    return https_agent;\n}\nvar hasRequiredAgentkeepalive;\nfunction requireAgentkeepalive() {\n    if (hasRequiredAgentkeepalive) return agentkeepalive.exports;\n    hasRequiredAgentkeepalive = 1;\n    agentkeepalive.exports = /*@__PURE__*/ requireAgent();\n    agentkeepalive.exports.HttpsAgent = /*@__PURE__*/ requireHttps_agent();\n    agentkeepalive.exports.constants = /*@__PURE__*/ requireConstants();\n    return agentkeepalive.exports;\n}\nvar agentkeepaliveExports = /*@__PURE__*/ requireAgentkeepalive();\nvar HttpKeepAliveAgent = /*@__PURE__*/ getDefaultExportFromCjs(agentkeepaliveExports);\nvar fastStableStringify$1;\nvar hasRequiredFastStableStringify;\nfunction requireFastStableStringify() {\n    if (hasRequiredFastStableStringify) return fastStableStringify$1;\n    hasRequiredFastStableStringify = 1;\n    var objToString = Object.prototype.toString;\n    var objKeys = Object.keys || function(obj) {\n        var keys = [];\n        for(var name in obj){\n            keys.push(name);\n        }\n        return keys;\n    };\n    function stringify(val, isArrayProp) {\n        var i, max, str, keys, key, propVal, toStr;\n        if (val === true) {\n            return \"true\";\n        }\n        if (val === false) {\n            return \"false\";\n        }\n        switch(typeof val){\n            case \"object\":\n                if (val === null) {\n                    return null;\n                } else if (val.toJSON && typeof val.toJSON === \"function\") {\n                    return stringify(val.toJSON(), isArrayProp);\n                } else {\n                    toStr = objToString.call(val);\n                    if (toStr === \"[object Array]\") {\n                        str = \"[\";\n                        max = val.length - 1;\n                        for(i = 0; i < max; i++){\n                            str += stringify(val[i], true) + \",\";\n                        }\n                        if (max > -1) {\n                            str += stringify(val[i], true);\n                        }\n                        return str + \"]\";\n                    } else if (toStr === \"[object Object]\") {\n                        // only object is left\n                        keys = objKeys(val).sort();\n                        max = keys.length;\n                        str = \"\";\n                        i = 0;\n                        while(i < max){\n                            key = keys[i];\n                            propVal = stringify(val[key], false);\n                            if (propVal !== undefined) {\n                                if (str) {\n                                    str += \",\";\n                                }\n                                str += JSON.stringify(key) + \":\" + propVal;\n                            }\n                            i++;\n                        }\n                        return \"{\" + str + \"}\";\n                    } else {\n                        return JSON.stringify(val);\n                    }\n                }\n            case \"function\":\n            case \"undefined\":\n                return isArrayProp ? null : undefined;\n            case \"string\":\n                return JSON.stringify(val);\n            default:\n                return isFinite(val) ? val : null;\n        }\n    }\n    fastStableStringify$1 = function(val) {\n        var returnVal = stringify(val, false);\n        if (returnVal !== undefined) {\n            return \"\" + returnVal;\n        }\n    };\n    return fastStableStringify$1;\n}\nvar fastStableStringifyExports = /*@__PURE__*/ requireFastStableStringify();\nvar fastStableStringify = /*@__PURE__*/ getDefaultExportFromCjs(fastStableStringifyExports);\nconst MINIMUM_SLOT_PER_EPOCH = 32;\n// Returns the number of trailing zeros in the binary representation of self.\nfunction trailingZeros(n) {\n    let trailingZeros = 0;\n    while(n > 1){\n        n /= 2;\n        trailingZeros++;\n    }\n    return trailingZeros;\n}\n// Returns the smallest power of two greater than or equal to n\nfunction nextPowerOfTwo(n) {\n    if (n === 0) return 1;\n    n--;\n    n |= n >> 1;\n    n |= n >> 2;\n    n |= n >> 4;\n    n |= n >> 8;\n    n |= n >> 16;\n    n |= n >> 32;\n    return n + 1;\n}\n/**\n * Epoch schedule\n * (see https://docs.solana.com/terminology#epoch)\n * Can be retrieved with the {@link Connection.getEpochSchedule} method\n */ class EpochSchedule {\n    constructor(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot){\n        /** The maximum number of slots in each epoch */ this.slotsPerEpoch = void 0;\n        /** The number of slots before beginning of an epoch to calculate a leader schedule for that epoch */ this.leaderScheduleSlotOffset = void 0;\n        /** Indicates whether epochs start short and grow */ this.warmup = void 0;\n        /** The first epoch with `slotsPerEpoch` slots */ this.firstNormalEpoch = void 0;\n        /** The first slot of `firstNormalEpoch` */ this.firstNormalSlot = void 0;\n        this.slotsPerEpoch = slotsPerEpoch;\n        this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;\n        this.warmup = warmup;\n        this.firstNormalEpoch = firstNormalEpoch;\n        this.firstNormalSlot = firstNormalSlot;\n    }\n    getEpoch(slot) {\n        return this.getEpochAndSlotIndex(slot)[0];\n    }\n    getEpochAndSlotIndex(slot) {\n        if (slot < this.firstNormalSlot) {\n            const epoch = trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1;\n            const epochLen = this.getSlotsInEpoch(epoch);\n            const slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH);\n            return [\n                epoch,\n                slotIndex\n            ];\n        } else {\n            const normalSlotIndex = slot - this.firstNormalSlot;\n            const normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);\n            const epoch = this.firstNormalEpoch + normalEpochIndex;\n            const slotIndex = normalSlotIndex % this.slotsPerEpoch;\n            return [\n                epoch,\n                slotIndex\n            ];\n        }\n    }\n    getFirstSlotInEpoch(epoch) {\n        if (epoch <= this.firstNormalEpoch) {\n            return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;\n        } else {\n            return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;\n        }\n    }\n    getLastSlotInEpoch(epoch) {\n        return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;\n    }\n    getSlotsInEpoch(epoch) {\n        if (epoch < this.firstNormalEpoch) {\n            return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));\n        } else {\n            return this.slotsPerEpoch;\n        }\n    }\n}\nvar fetchImpl = typeof globalThis.fetch === \"function\" ? // The Fetch API is supported experimentally in Node 17.5+ and natively in Node 18+.\nglobalThis.fetch : // Otherwise use the polyfill.\nasync function(input, init) {\n    const processedInput = typeof input === \"string\" && input.slice(0, 2) === \"//\" ? \"https:\" + input : input;\n    return await node_fetch__WEBPACK_IMPORTED_MODULE_10__[\"default\"](processedInput, init);\n};\nclass RpcWebSocketClient extends rpc_websockets__WEBPACK_IMPORTED_MODULE_11__.CommonClient {\n    constructor(address, options, generate_request_id){\n        const webSocketFactory = (url)=>{\n            const rpc = (0,rpc_websockets__WEBPACK_IMPORTED_MODULE_11__.WebSocket)(url, {\n                autoconnect: true,\n                max_reconnects: 5,\n                reconnect: true,\n                reconnect_interval: 1000,\n                ...options\n            });\n            if (\"socket\" in rpc) {\n                this.underlyingSocket = rpc.socket;\n            } else {\n                this.underlyingSocket = rpc;\n            }\n            return rpc;\n        };\n        super(webSocketFactory, address, options, generate_request_id);\n        this.underlyingSocket = void 0;\n    }\n    call(...args) {\n        const readyState = this.underlyingSocket?.readyState;\n        if (readyState === 1 /* WebSocket.OPEN */ ) {\n            return super.call(...args);\n        }\n        return Promise.reject(new Error(\"Tried to call a JSON-RPC method `\" + args[0] + \"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was \" + readyState + \")\"));\n    }\n    notify(...args) {\n        const readyState = this.underlyingSocket?.readyState;\n        if (readyState === 1 /* WebSocket.OPEN */ ) {\n            return super.notify(...args);\n        }\n        return Promise.reject(new Error(\"Tried to send a JSON-RPC notification `\" + args[0] + \"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was \" + readyState + \")\"));\n    }\n}\n/**\n * @internal\n */ /**\n * Decode account data buffer using an AccountType\n * @internal\n */ function decodeData(type, data) {\n    let decoded;\n    try {\n        decoded = type.layout.decode(data);\n    } catch (err) {\n        throw new Error(\"invalid instruction; \" + err);\n    }\n    if (decoded.typeIndex !== type.index) {\n        throw new Error(`invalid account data; account type mismatch ${decoded.typeIndex} != ${type.index}`);\n    }\n    return decoded;\n}\n/// The serialized size of lookup table metadata\nconst LOOKUP_TABLE_META_SIZE = 56;\nclass AddressLookupTableAccount {\n    constructor(args){\n        this.key = void 0;\n        this.state = void 0;\n        this.key = args.key;\n        this.state = args.state;\n    }\n    isActive() {\n        const U64_MAX = BigInt(\"0xffffffffffffffff\");\n        return this.state.deactivationSlot === U64_MAX;\n    }\n    static deserialize(accountData) {\n        const meta = decodeData(LookupTableMetaLayout, accountData);\n        const serializedAddressesLen = accountData.length - LOOKUP_TABLE_META_SIZE;\n        assert(serializedAddressesLen >= 0, \"lookup table is invalid\");\n        assert(serializedAddressesLen % 32 === 0, \"lookup table is invalid\");\n        const numSerializedAddresses = serializedAddressesLen / 32;\n        const { addresses } = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(), numSerializedAddresses, \"addresses\")\n        ]).decode(accountData.slice(LOOKUP_TABLE_META_SIZE));\n        return {\n            deactivationSlot: meta.deactivationSlot,\n            lastExtendedSlot: meta.lastExtendedSlot,\n            lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,\n            authority: meta.authority.length !== 0 ? new PublicKey(meta.authority[0]) : undefined,\n            addresses: addresses.map((address)=>new PublicKey(address))\n        };\n    }\n}\nconst LookupTableMetaLayout = {\n    index: 1,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"typeIndex\"),\n        u64(\"deactivationSlot\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"lastExtendedSlot\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"lastExtendedStartIndex\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(),\n        // option\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(), -1), \"authority\")\n    ])\n};\nconst URL_RE = /^[^:]+:\\/\\/([^:[]+|\\[[^\\]]+\\])(:\\d+)?(.*)/i;\nfunction makeWebsocketUrl(endpoint) {\n    const matches = endpoint.match(URL_RE);\n    if (matches == null) {\n        throw TypeError(`Failed to validate endpoint URL \\`${endpoint}\\``);\n    }\n    const [_, // eslint-disable-line @typescript-eslint/no-unused-vars\n    hostish, portWithColon, rest] = matches;\n    const protocol = endpoint.startsWith(\"https:\") ? \"wss:\" : \"ws:\";\n    const startPort = portWithColon == null ? null : parseInt(portWithColon.slice(1), 10);\n    const websocketPort = // Only shift the port by +1 as a convention for ws(s) only if given endpoint\n    // is explicitly specifying the endpoint port (HTTP-based RPC), assuming\n    // we're directly trying to connect to agave-validator's ws listening port.\n    // When the endpoint omits the port, we're connecting to the protocol\n    // default ports: http(80) or https(443) and it's assumed we're behind a reverse\n    // proxy which manages WebSocket upgrade and backend port redirection.\n    startPort == null ? \"\" : `:${startPort + 1}`;\n    return `${protocol}//${hostish}${websocketPort}${rest}`;\n}\nconst PublicKeyFromString = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.coerce)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.instance)(PublicKey), (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(), (value)=>new PublicKey(value));\nconst RawAccountDataResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.tuple)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"base64\")\n]);\nconst BufferFromRawAccountData = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.coerce)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.instance)(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer), RawAccountDataResult, (value)=>buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value[0], \"base64\"));\n/**\n * Attempt to use a recent blockhash for up to 30 seconds\n * @internal\n */ const BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1000;\n/**\n * HACK.\n * Copied from rpc-websockets/dist/lib/client.\n * Otherwise, `yarn build` fails with:\n * https://gist.github.com/steveluscher/c057eca81d479ef705cdb53162f9971d\n */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /**\n * @internal\n * Every subscription contains the args used to open the subscription with\n * the server, and a list of callers interested in notifications.\n */ /**\n * @internal\n * A subscription may be in various states of connectedness. Only when it is\n * fully connected will it have a server subscription id associated with it.\n * This id can be returned to the server to unsubscribe the client entirely.\n */ /**\n * A type that encapsulates a subscription's RPC method\n * names and notification (callback) signature.\n */ /**\n * @internal\n * Utility type that keeps tagged unions intact while omitting properties.\n */ /**\n * @internal\n * This type represents a single subscribable 'topic.' It's made up of:\n *\n * - The args used to open the subscription with the server,\n * - The state of the subscription, in terms of its connectedness, and\n * - The set of callbacks to call when the server publishes notifications\n *\n * This record gets indexed by `SubscriptionConfigHash` and is used to\n * set up subscriptions, fan out notifications, and track subscription state.\n */ /**\n * @internal\n */ /**\n * Extra contextual information for RPC responses\n */ /**\n * Options for sending transactions\n */ /**\n * Options for confirming transactions\n */ /**\n * Options for getConfirmedSignaturesForAddress2\n */ /**\n * Options for getSignaturesForAddress\n */ /**\n * RPC Response with extra contextual information\n */ /**\n * A strategy for confirming transactions that uses the last valid\n * block height for a given blockhash to check for transaction expiration.\n */ /**\n * A strategy for confirming durable nonce transactions.\n */ /**\n * Properties shared by all transaction confirmation strategies\n */ /**\n * This type represents all transaction confirmation strategies\n */ /* @internal */ function assertEndpointUrl(putativeUrl) {\n    if (/^https?:/.test(putativeUrl) === false) {\n        throw new TypeError(\"Endpoint URL must start with `http:` or `https:`.\");\n    }\n    return putativeUrl;\n}\n/** @internal */ function extractCommitmentFromConfig(commitmentOrConfig) {\n    let commitment;\n    let config;\n    if (typeof commitmentOrConfig === \"string\") {\n        commitment = commitmentOrConfig;\n    } else if (commitmentOrConfig) {\n        const { commitment: specifiedCommitment, ...specifiedConfig } = commitmentOrConfig;\n        commitment = specifiedCommitment;\n        config = specifiedConfig;\n    }\n    return {\n        commitment,\n        config\n    };\n}\n/**\n * @internal\n */ function applyDefaultMemcmpEncodingToFilters(filters) {\n    return filters.map((filter)=>\"memcmp\" in filter ? {\n            ...filter,\n            memcmp: {\n                ...filter.memcmp,\n                encoding: filter.memcmp.encoding ?? \"base58\"\n            }\n        } : filter);\n}\n/**\n * @internal\n */ function createRpcResult(result) {\n    return (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            jsonrpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"2.0\"),\n            id: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n            result\n        }),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            jsonrpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"2.0\"),\n            id: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n            error: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n                code: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.unknown)(),\n                message: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n                data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.any)())\n            })\n        })\n    ]);\n}\nconst UnknownRpcResult = createRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.unknown)());\n/**\n * @internal\n */ function jsonRpcResult(schema) {\n    return (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.coerce)(createRpcResult(schema), UnknownRpcResult, (value)=>{\n        if (\"error\" in value) {\n            return value;\n        } else {\n            return {\n                ...value,\n                result: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(value.result, schema)\n            };\n        }\n    });\n}\n/**\n * @internal\n */ function jsonRpcResultAndContext(value) {\n    return jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        context: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n        }),\n        value\n    }));\n}\n/**\n * @internal\n */ function notificationResultAndContext(value) {\n    return (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        context: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n        }),\n        value\n    });\n}\n/**\n * @internal\n */ function versionedMessageFromResponse(version, response) {\n    if (version === 0) {\n        return new MessageV0({\n            header: response.header,\n            staticAccountKeys: response.accountKeys.map((accountKey)=>new PublicKey(accountKey)),\n            recentBlockhash: response.recentBlockhash,\n            compiledInstructions: response.instructions.map((ix)=>({\n                    programIdIndex: ix.programIdIndex,\n                    accountKeyIndexes: ix.accounts,\n                    data: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(ix.data)\n                })),\n            addressTableLookups: response.addressTableLookups\n        });\n    } else {\n        return new Message(response);\n    }\n}\n/**\n * The level of commitment desired when querying state\n * <pre>\n *   'processed': Query the most recent block which has reached 1 confirmation by the connected node\n *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster\n *   'finalized': Query the most recent block which has been finalized by the cluster\n * </pre>\n */ // Deprecated as of v1.5.5\n/**\n * A subset of Commitment levels, which are at least optimistically confirmed\n * <pre>\n *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster\n *   'finalized': Query the most recent block which has been finalized by the cluster\n * </pre>\n */ /**\n * Filter for largest accounts query\n * <pre>\n *   'circulating':    Return the largest accounts that are part of the circulating supply\n *   'nonCirculating': Return the largest accounts that are not part of the circulating supply\n * </pre>\n */ /**\n * Configuration object for changing `getAccountInfo` query behavior\n */ /**\n * Configuration object for changing `getBalance` query behavior\n */ /**\n * Configuration object for changing `getBlock` query behavior\n */ /**\n * Configuration object for changing `getBlock` query behavior\n */ /**\n * Configuration object for changing `getStakeMinimumDelegation` query behavior\n */ /**\n * Configuration object for changing `getBlockHeight` query behavior\n */ /**\n * Configuration object for changing `getEpochInfo` query behavior\n */ /**\n * Configuration object for changing `getInflationReward` query behavior\n */ /**\n * Configuration object for changing `getLatestBlockhash` query behavior\n */ /**\n * Configuration object for changing `isBlockhashValid` query behavior\n */ /**\n * Configuration object for changing `getSlot` query behavior\n */ /**\n * Configuration object for changing `getSlotLeader` query behavior\n */ /**\n * Configuration object for changing `getTransaction` query behavior\n */ /**\n * Configuration object for changing `getTransaction` query behavior\n */ /**\n * Configuration object for changing `getLargestAccounts` query behavior\n */ /**\n * Configuration object for changing `getSupply` request behavior\n */ /**\n * Configuration object for changing query behavior\n */ /**\n * Information describing a cluster node\n */ /**\n * Information describing a vote account\n */ /**\n * A collection of cluster vote accounts\n */ /**\n * Network Inflation\n * (see https://docs.solana.com/implemented-proposals/ed_overview)\n */ const GetInflationGovernorResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    foundation: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    foundationTerm: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    initial: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    taper: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    terminal: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * The inflation reward for an epoch\n */ /**\n * Expected JSON RPC response for the \"getInflationReward\" message\n */ const GetInflationRewardResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    epoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    effectiveSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    amount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    postBalance: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    commission: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()))\n}))));\n/**\n * Configuration object for changing `getRecentPrioritizationFees` query behavior\n */ /**\n * Expected JSON RPC response for the \"getRecentPrioritizationFees\" message\n */ const GetRecentPrioritizationFeesResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    prioritizationFee: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n}));\n/**\n * Expected JSON RPC response for the \"getInflationRate\" message\n */ const GetInflationRateResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    total: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    validator: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    foundation: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    epoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * Information about the current epoch\n */ const GetEpochInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    epoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    slotIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    slotsInEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    absoluteSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    transactionCount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n});\nconst GetEpochScheduleResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    slotsPerEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    leaderScheduleSlotOffset: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    warmup: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n    firstNormalEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    firstNormalSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * Leader schedule\n * (see https://docs.solana.com/terminology#leader-schedule)\n */ const GetLeaderScheduleResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.record)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n/**\n * Transaction error or null\n */ const TransactionErrorResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({}),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n]));\n/**\n * Signature status for a transaction\n */ const SignatureStatusResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    err: TransactionErrorResult\n});\n/**\n * Transaction signature received notification\n */ const SignatureReceivedResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"receivedSignature\");\n/**\n * Version info for a node\n */ const VersionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    \"solana-core\": (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    \"feature-set\": (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n});\nconst ParsedInstructionStruct = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    program: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    programId: PublicKeyFromString,\n    parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.unknown)()\n});\nconst PartiallyDecodedInstructionStruct = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    programId: PublicKeyFromString,\n    accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PublicKeyFromString),\n    data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n});\nconst SimulatedTransactionResponseStruct = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    err: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({}),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n    ])),\n    logs: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)())),\n    accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n        owner: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n        lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n        rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n    }))))),\n    unitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    returnData: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n        data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.tuple)([\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"base64\")\n        ])\n    }))),\n    innerInstructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        index: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n            ParsedInstructionStruct,\n            PartiallyDecodedInstructionStruct\n        ]))\n    }))))\n}));\n/**\n * Metadata for a parsed confirmed transaction on the ledger\n *\n * @deprecated Deprecated since RPC v1.8.0. Please use {@link ParsedTransactionMeta} instead.\n */ /**\n * Collection of addresses loaded by a transaction using address table lookups\n */ /**\n * Metadata for a parsed transaction on the ledger\n */ /**\n * Metadata for a confirmed transaction on the ledger\n */ /**\n * A processed transaction from the RPC API\n */ /**\n * A processed transaction from the RPC API\n */ /**\n * A processed transaction message from the RPC API\n */ /**\n * A confirmed transaction on the ledger\n *\n * @deprecated Deprecated since RPC v1.8.0.\n */ /**\n * A partially decoded transaction instruction\n */ /**\n * A parsed transaction message account\n */ /**\n * A parsed transaction instruction\n */ /**\n * A parsed address table lookup\n */ /**\n * A parsed transaction message\n */ /**\n * A parsed transaction\n */ /**\n * A parsed and confirmed transaction on the ledger\n *\n * @deprecated Deprecated since RPC v1.8.0. Please use {@link ParsedTransactionWithMeta} instead.\n */ /**\n * A parsed transaction on the ledger with meta\n */ /**\n * A processed block fetched from the RPC API\n */ /**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `accounts`\n */ /**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `none`\n */ /**\n * A block with parsed transactions\n */ /**\n * A block with parsed transactions where the `transactionDetails` mode is `accounts`\n */ /**\n * A block with parsed transactions where the `transactionDetails` mode is `none`\n */ /**\n * A processed block fetched from the RPC API\n */ /**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `accounts`\n */ /**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `none`\n */ /**\n * A confirmed block on the ledger\n *\n * @deprecated Deprecated since RPC v1.8.0.\n */ /**\n * A Block on the ledger with signatures only\n */ /**\n * recent block production information\n */ /**\n * Expected JSON RPC response for the \"getBlockProduction\" message\n */ const BlockProductionResponseStruct = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    byIdentity: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.record)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())),\n    range: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        firstSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        lastSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    })\n}));\n/**\n * A performance sample\n */ function createRpcClient(url, httpHeaders, customFetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent) {\n    const fetch = customFetch ? customFetch : fetchImpl;\n    let agent;\n    {\n        if (httpAgent == null) {\n            {\n                const agentOptions = {\n                    // One second fewer than the Solana RPC's keepalive timeout.\n                    // Read more: https://github.com/solana-labs/solana/issues/27859#issuecomment-1340097889\n                    freeSocketTimeout: 19000,\n                    keepAlive: true,\n                    maxSockets: 25\n                };\n                if (url.startsWith(\"https:\")) {\n                    agent = new agentkeepaliveExports.HttpsAgent(agentOptions);\n                } else {\n                    agent = new HttpKeepAliveAgent(agentOptions);\n                }\n            }\n        } else {\n            if (httpAgent !== false) {\n                const isHttps = url.startsWith(\"https:\");\n                if (isHttps && !(httpAgent instanceof https__WEBPACK_IMPORTED_MODULE_8__.Agent)) {\n                    throw new Error(\"The endpoint `\" + url + \"` can only be paired with an `https.Agent`. You have, instead, supplied an \" + \"`http.Agent` through `httpAgent`.\");\n                } else if (!isHttps && httpAgent instanceof https__WEBPACK_IMPORTED_MODULE_8__.Agent) {\n                    throw new Error(\"The endpoint `\" + url + \"` can only be paired with an `http.Agent`. You have, instead, supplied an \" + \"`https.Agent` through `httpAgent`.\");\n                }\n                agent = httpAgent;\n            }\n        }\n    }\n    let fetchWithMiddleware;\n    if (fetchMiddleware) {\n        fetchWithMiddleware = async (info, init)=>{\n            const modifiedFetchArgs = await new Promise((resolve, reject)=>{\n                try {\n                    fetchMiddleware(info, init, (modifiedInfo, modifiedInit)=>resolve([\n                            modifiedInfo,\n                            modifiedInit\n                        ]));\n                } catch (error) {\n                    reject(error);\n                }\n            });\n            return await fetch(...modifiedFetchArgs);\n        };\n    }\n    const clientBrowser = new (jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_9___default())(async (request, callback)=>{\n        const options = {\n            method: \"POST\",\n            body: request,\n            agent,\n            headers: Object.assign({\n                \"Content-Type\": \"application/json\"\n            }, httpHeaders || {}, COMMON_HTTP_HEADERS)\n        };\n        try {\n            let too_many_requests_retries = 5;\n            let res;\n            let waitTime = 500;\n            for(;;){\n                if (fetchWithMiddleware) {\n                    res = await fetchWithMiddleware(url, options);\n                } else {\n                    res = await fetch(url, options);\n                }\n                if (res.status !== 429 /* Too many requests */ ) {\n                    break;\n                }\n                if (disableRetryOnRateLimit === true) {\n                    break;\n                }\n                too_many_requests_retries -= 1;\n                if (too_many_requests_retries === 0) {\n                    break;\n                }\n                console.error(`Server responded with ${res.status} ${res.statusText}.  Retrying after ${waitTime}ms delay...`);\n                await sleep(waitTime);\n                waitTime *= 2;\n            }\n            const text = await res.text();\n            if (res.ok) {\n                callback(null, text);\n            } else {\n                callback(new Error(`${res.status} ${res.statusText}: ${text}`));\n            }\n        } catch (err) {\n            if (err instanceof Error) callback(err);\n        }\n    }, {});\n    return clientBrowser;\n}\nfunction createRpcRequest(client) {\n    return (method, args)=>{\n        return new Promise((resolve, reject)=>{\n            client.request(method, args, (err, response)=>{\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                resolve(response);\n            });\n        });\n    };\n}\nfunction createRpcBatchRequest(client) {\n    return (requests)=>{\n        return new Promise((resolve, reject)=>{\n            // Do nothing if requests is empty\n            if (requests.length === 0) resolve([]);\n            const batch = requests.map((params)=>{\n                return client.request(params.methodName, params.args);\n            });\n            client.request(batch, (err, response)=>{\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                resolve(response);\n            });\n        });\n    };\n}\n/**\n * Expected JSON RPC response for the \"getInflationGovernor\" message\n */ const GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);\n/**\n * Expected JSON RPC response for the \"getInflationRate\" message\n */ const GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult);\n/**\n * Expected JSON RPC response for the \"getRecentPrioritizationFees\" message\n */ const GetRecentPrioritizationFeesRpcResult = jsonRpcResult(GetRecentPrioritizationFeesResult);\n/**\n * Expected JSON RPC response for the \"getEpochInfo\" message\n */ const GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);\n/**\n * Expected JSON RPC response for the \"getEpochSchedule\" message\n */ const GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);\n/**\n * Expected JSON RPC response for the \"getLeaderSchedule\" message\n */ const GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);\n/**\n * Expected JSON RPC response for the \"minimumLedgerSlot\" and \"getFirstAvailableBlock\" messages\n */ const SlotRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)());\n/**\n * Supply\n */ /**\n * Expected JSON RPC response for the \"getSupply\" message\n */ const GetSupplyRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    total: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    circulating: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    nonCirculating: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    nonCirculatingAccounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PublicKeyFromString)\n}));\n/**\n * Token amount object which returns a token amount in different formats\n * for various client use cases.\n */ /**\n * Expected JSON RPC structure for token amounts\n */ const TokenAmountResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    amount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    uiAmount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    decimals: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    uiAmountString: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)())\n});\n/**\n * Token address and balance.\n */ /**\n * Expected JSON RPC response for the \"getTokenLargestAccounts\" message\n */ const GetTokenLargestAccountsResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    address: PublicKeyFromString,\n    amount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    uiAmount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    decimals: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    uiAmountString: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)())\n})));\n/**\n * Expected JSON RPC response for the \"getTokenAccountsByOwner\" message\n */ const GetTokenAccountsByOwner = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: PublicKeyFromString,\n    account: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n        owner: PublicKeyFromString,\n        lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        data: BufferFromRawAccountData,\n        rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    })\n})));\nconst ParsedAccountDataResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    program: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.unknown)(),\n    space: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * Expected JSON RPC response for the \"getTokenAccountsByOwner\" message with parsed data\n */ const GetParsedTokenAccountsByOwner = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: PublicKeyFromString,\n    account: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n        owner: PublicKeyFromString,\n        lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        data: ParsedAccountDataResult,\n        rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    })\n})));\n/**\n * Pair of an account address and its balance\n */ /**\n * Expected JSON RPC response for the \"getLargestAccounts\" message\n */ const GetLargestAccountsRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    address: PublicKeyFromString\n})));\n/**\n * @internal\n */ const AccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n    owner: PublicKeyFromString,\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    data: BufferFromRawAccountData,\n    rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * @internal\n */ const KeyedAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: PublicKeyFromString,\n    account: AccountInfoResult\n});\nconst ParsedOrRawAccountData = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.coerce)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.instance)(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer),\n    ParsedAccountDataResult\n]), (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    RawAccountDataResult,\n    ParsedAccountDataResult\n]), (value)=>{\n    if (Array.isArray(value)) {\n        return (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(value, BufferFromRawAccountData);\n    } else {\n        return value;\n    }\n});\n/**\n * @internal\n */ const ParsedAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n    owner: PublicKeyFromString,\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    data: ParsedOrRawAccountData,\n    rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\nconst KeyedParsedAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: PublicKeyFromString,\n    account: ParsedAccountInfoResult\n});\n/**\n * @internal\n */ const StakeActivationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    state: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"active\"),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"inactive\"),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"activating\"),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"deactivating\")\n    ]),\n    active: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    inactive: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * Expected JSON RPC response for the \"getConfirmedSignaturesForAddress2\" message\n */ const GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    signature: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    err: TransactionErrorResult,\n    memo: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()))\n})));\n/**\n * Expected JSON RPC response for the \"getSignaturesForAddress\" message\n */ const GetSignaturesForAddressRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    signature: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    err: TransactionErrorResult,\n    memo: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()))\n})));\n/***\n * Expected JSON RPC response for the \"accountNotification\" message\n */ const AccountNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    result: notificationResultAndContext(AccountInfoResult)\n});\n/**\n * @internal\n */ const ProgramAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: PublicKeyFromString,\n    account: AccountInfoResult\n});\n/***\n * Expected JSON RPC response for the \"programNotification\" message\n */ const ProgramAccountNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    result: notificationResultAndContext(ProgramAccountInfoResult)\n});\n/**\n * @internal\n */ const SlotInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    parent: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    root: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * Expected JSON RPC response for the \"slotNotification\" message\n */ const SlotNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    result: SlotInfoResult\n});\n/**\n * Slot updates which can be used for tracking the live progress of a cluster.\n * - `\"firstShredReceived\"`: connected node received the first shred of a block.\n * Indicates that a new block that is being produced.\n * - `\"completed\"`: connected node has received all shreds of a block. Indicates\n * a block was recently produced.\n * - `\"optimisticConfirmation\"`: block was optimistically confirmed by the\n * cluster. It is not guaranteed that an optimistic confirmation notification\n * will be sent for every finalized blocks.\n * - `\"root\"`: the connected node rooted this block.\n * - `\"createdBank\"`: the connected node has started validating this block.\n * - `\"frozen\"`: the connected node has validated this block.\n * - `\"dead\"`: the connected node failed to validate this block.\n */ /**\n * @internal\n */ const SlotUpdateResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        type: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"firstShredReceived\"),\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"completed\"),\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"optimisticConfirmation\"),\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"root\")\n        ]),\n        slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    }),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        type: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"createdBank\"),\n        parent: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    }),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        type: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"frozen\"),\n        slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        stats: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            numTransactionEntries: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n            numSuccessfulTransactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n            numFailedTransactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n            maxTransactionsPerEntry: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n        })\n    }),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        type: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"dead\"),\n        slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        err: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n    })\n]);\n/**\n * Expected JSON RPC response for the \"slotsUpdatesNotification\" message\n */ const SlotUpdateNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    result: SlotUpdateResult\n});\n/**\n * Expected JSON RPC response for the \"signatureNotification\" message\n */ const SignatureNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    result: notificationResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n        SignatureStatusResult,\n        SignatureReceivedResult\n    ]))\n});\n/**\n * Expected JSON RPC response for the \"rootNotification\" message\n */ const RootNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    result: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\nconst ContactInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    gossip: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    tpu: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    rpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)())\n});\nconst VoteAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    votePubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    nodePubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    activatedStake: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    epochVoteAccount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n    epochCredits: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.tuple)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    ])),\n    commission: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    lastVote: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    rootSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n});\n/**\n * Expected JSON RPC response for the \"getVoteAccounts\" message\n */ const GetVoteAccounts = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    current: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(VoteAccountInfoResult),\n    delinquent: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(VoteAccountInfoResult)\n}));\nconst ConfirmationStatus = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"processed\"),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"confirmed\"),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"finalized\")\n]);\nconst SignatureStatusResponse = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    confirmations: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    err: TransactionErrorResult,\n    confirmationStatus: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(ConfirmationStatus)\n});\n/**\n * Expected JSON RPC response for the \"getSignatureStatuses\" message\n */ const GetSignatureStatusesRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(SignatureStatusResponse)));\n/**\n * Expected JSON RPC response for the \"getMinimumBalanceForRentExemption\" message\n */ const GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)());\nconst AddressTableLookupStruct = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    accountKey: PublicKeyFromString,\n    writableIndexes: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    readonlyIndexes: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n});\nconst ConfirmedTransactionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    message: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        accountKeys: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n        header: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            numRequiredSignatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n            numReadonlySignedAccounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n            numReadonlyUnsignedAccounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n        }),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n            data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n            programIdIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n        })),\n        recentBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n        addressTableLookups: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(AddressTableLookupStruct))\n    })\n});\nconst AnnotatedAccountKey = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: PublicKeyFromString,\n    signer: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n    writable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n    source: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"transaction\"),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"lookupTable\")\n    ]))\n});\nconst ConfirmedTransactionAccountsModeResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    accountKeys: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(AnnotatedAccountKey),\n    signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)())\n});\nconst ParsedInstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.unknown)(),\n    program: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    programId: PublicKeyFromString\n});\nconst RawInstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PublicKeyFromString),\n    data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    programId: PublicKeyFromString\n});\nconst InstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    RawInstructionResult,\n    ParsedInstructionResult\n]);\nconst UnknownInstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.unknown)(),\n        program: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n        programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n    }),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n        data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n        programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n    })\n]);\nconst ParsedOrRawInstruction = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.coerce)(InstructionResult, UnknownInstructionResult, (value)=>{\n    if (\"accounts\" in value) {\n        return (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(value, RawInstructionResult);\n    } else {\n        return (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(value, ParsedInstructionResult);\n    }\n});\n/**\n * @internal\n */ const ParsedConfirmedTransactionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    message: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        accountKeys: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(AnnotatedAccountKey),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(ParsedOrRawInstruction),\n        recentBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n        addressTableLookups: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(AddressTableLookupStruct)))\n    })\n});\nconst TokenBalanceResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    accountIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    mint: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    owner: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    uiTokenAmount: TokenAmountResult\n});\nconst LoadedAddressesResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    writable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PublicKeyFromString),\n    readonly: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PublicKeyFromString)\n});\n/**\n * @internal\n */ const ConfirmedTransactionMetaResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    err: TransactionErrorResult,\n    fee: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    innerInstructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        index: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n            data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n            programIdIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n        }))\n    })))),\n    preBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    postBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    logMessages: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()))),\n    preTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(TokenBalanceResult))),\n    postTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(TokenBalanceResult))),\n    loadedAddresses: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(LoadedAddressesResult),\n    computeUnitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n});\n/**\n * @internal\n */ const ParsedConfirmedTransactionMetaResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    err: TransactionErrorResult,\n    fee: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    innerInstructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        index: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(ParsedOrRawInstruction)\n    })))),\n    preBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    postBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    logMessages: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()))),\n    preTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(TokenBalanceResult))),\n    postTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(TokenBalanceResult))),\n    loadedAddresses: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(LoadedAddressesResult),\n    computeUnitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n});\nconst TransactionVersionStruct = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(0),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"legacy\")\n]);\n/** @internal */ const RewardsResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    postBalance: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    rewardType: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    commission: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()))\n});\n/**\n * Expected JSON RPC response for the \"getBlock\" message\n */ const GetBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        transaction: ConfirmedTransactionResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ConfirmedTransactionMetaResult),\n        version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(TransactionVersionStruct)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getBlock\" message when `transactionDetails` is `none`\n */ const GetNoneModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getBlock\" message when `transactionDetails` is `accounts`\n */ const GetAccountsModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        transaction: ConfirmedTransactionAccountsModeResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ConfirmedTransactionMetaResult),\n        version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(TransactionVersionStruct)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message\n */ const GetParsedBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        transaction: ParsedConfirmedTransactionResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ParsedConfirmedTransactionMetaResult),\n        version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(TransactionVersionStruct)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message  when `transactionDetails` is `accounts`\n */ const GetParsedAccountsModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        transaction: ConfirmedTransactionAccountsModeResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ParsedConfirmedTransactionMetaResult),\n        version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(TransactionVersionStruct)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message  when `transactionDetails` is `none`\n */ const GetParsedNoneModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getConfirmedBlock\" message\n *\n * @deprecated Deprecated since RPC v1.8.0. Please use {@link GetBlockRpcResult} instead.\n */ const GetConfirmedBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        transaction: ConfirmedTransactionResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ConfirmedTransactionMetaResult)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getBlock\" message\n */ const GetBlockSignaturesRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getTransaction\" message\n */ const GetTransactionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ConfirmedTransactionMetaResult),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())),\n    transaction: ConfirmedTransactionResult,\n    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(TransactionVersionStruct)\n})));\n/**\n * Expected parsed JSON RPC response for the \"getTransaction\" message\n */ const GetParsedTransactionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    transaction: ParsedConfirmedTransactionResult,\n    meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ParsedConfirmedTransactionMetaResult),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())),\n    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(TransactionVersionStruct)\n})));\n/**\n * Expected JSON RPC response for the \"getLatestBlockhash\" message\n */ const GetLatestBlockhashRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    lastValidBlockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n}));\n/**\n * Expected JSON RPC response for the \"isBlockhashValid\" message\n */ const IsBlockhashValidRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)());\nconst PerfSampleResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    numTransactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    numSlots: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    samplePeriodSecs: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/*\n * Expected JSON RPC response for \"getRecentPerformanceSamples\" message\n */ const GetRecentPerformanceSamplesRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PerfSampleResult));\n/**\n * Expected JSON RPC response for the \"getFeeCalculatorForBlockhash\" message\n */ const GetFeeCalculatorRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    feeCalculator: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        lamportsPerSignature: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    })\n})));\n/**\n * Expected JSON RPC response for the \"requestAirdrop\" message\n */ const RequestAirdropRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)());\n/**\n * Expected JSON RPC response for the \"sendTransaction\" message\n */ const SendTransactionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)());\n/**\n * Information about the latest slot being processed by a node\n */ /**\n * Parsed account data\n */ /**\n * Stake Activation data\n */ /**\n * Data slice argument for getProgramAccounts\n */ /**\n * Memory comparison filter for getProgramAccounts\n */ /**\n * Data size comparison filter for getProgramAccounts\n */ /**\n * A filter object for getProgramAccounts\n */ /**\n * Configuration object for getProgramAccounts requests\n */ /**\n * Configuration object for getParsedProgramAccounts\n */ /**\n * Configuration object for getMultipleAccounts\n */ /**\n * Configuration object for `getStakeActivation`\n */ /**\n * Configuration object for `getStakeActivation`\n */ /**\n * Configuration object for `getStakeActivation`\n */ /**\n * Configuration object for `getNonce`\n */ /**\n * Configuration object for `getNonceAndContext`\n */ /**\n * Information describing an account\n */ /**\n * Account information identified by pubkey\n */ /**\n * Callback function for account change notifications\n */ /**\n * Callback function for program account change notifications\n */ /**\n * Callback function for slot change notifications\n */ /**\n * Callback function for slot update notifications\n */ /**\n * Callback function for signature status notifications\n */ /**\n * Signature status notification with transaction result\n */ /**\n * Signature received notification\n */ /**\n * Callback function for signature notifications\n */ /**\n * Signature subscription options\n */ /**\n * Callback function for root change notifications\n */ /**\n * @internal\n */ const LogsResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    err: TransactionErrorResult,\n    logs: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    signature: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n});\n/**\n * Logs result.\n */ /**\n * Expected JSON RPC response for the \"logsNotification\" message.\n */ const LogsNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    result: notificationResultAndContext(LogsResult),\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * Filter for log subscriptions.\n */ /**\n * Callback function for log notifications.\n */ /**\n * Signature result\n */ /**\n * Transaction error\n */ /**\n * Transaction confirmation status\n * <pre>\n *   'processed': Transaction landed in a block which has reached 1 confirmation by the connected node\n *   'confirmed': Transaction landed in a block which has reached 1 confirmation by the cluster\n *   'finalized': Transaction landed in a block which has been finalized by the cluster\n * </pre>\n */ /**\n * Signature status\n */ /**\n * A confirmed signature with its status\n */ /**\n * An object defining headers to be passed to the RPC server\n */ /**\n * The type of the JavaScript `fetch()` API\n */ /**\n * A callback used to augment the outgoing HTTP request\n */ /**\n * Configuration for instantiating a Connection\n */ /** @internal */ const COMMON_HTTP_HEADERS = {\n    \"solana-client\": `js/${\"1.0.0-maintenance\"}`\n};\n/**\n * A connection to a fullnode JSON RPC endpoint\n */ class Connection {\n    /**\n   * Establish a JSON RPC connection\n   *\n   * @param endpoint URL to the fullnode JSON RPC endpoint\n   * @param commitmentOrConfig optional default commitment level or optional ConnectionConfig configuration object\n   */ constructor(endpoint, _commitmentOrConfig){\n        /** @internal */ this._commitment = void 0;\n        /** @internal */ this._confirmTransactionInitialTimeout = void 0;\n        /** @internal */ this._rpcEndpoint = void 0;\n        /** @internal */ this._rpcWsEndpoint = void 0;\n        /** @internal */ this._rpcClient = void 0;\n        /** @internal */ this._rpcRequest = void 0;\n        /** @internal */ this._rpcBatchRequest = void 0;\n        /** @internal */ this._rpcWebSocket = void 0;\n        /** @internal */ this._rpcWebSocketConnected = false;\n        /** @internal */ this._rpcWebSocketHeartbeat = null;\n        /** @internal */ this._rpcWebSocketIdleTimeout = null;\n        /** @internal\n     * A number that we increment every time an active connection closes.\n     * Used to determine whether the same socket connection that was open\n     * when an async operation started is the same one that's active when\n     * its continuation fires.\n     *\n     */ this._rpcWebSocketGeneration = 0;\n        /** @internal */ this._disableBlockhashCaching = false;\n        /** @internal */ this._pollingBlockhash = false;\n        /** @internal */ this._blockhashInfo = {\n            latestBlockhash: null,\n            lastFetch: 0,\n            transactionSignatures: [],\n            simulatedSignatures: []\n        };\n        /** @internal */ this._nextClientSubscriptionId = 0;\n        /** @internal */ this._subscriptionDisposeFunctionsByClientSubscriptionId = {};\n        /** @internal */ this._subscriptionHashByClientSubscriptionId = {};\n        /** @internal */ this._subscriptionStateChangeCallbacksByHash = {};\n        /** @internal */ this._subscriptionCallbacksByServerSubscriptionId = {};\n        /** @internal */ this._subscriptionsByHash = {};\n        /**\n     * Special case.\n     * After a signature is processed, RPCs automatically dispose of the\n     * subscription on the server side. We need to track which of these\n     * subscriptions have been disposed in such a way, so that we know\n     * whether the client is dealing with a not-yet-processed signature\n     * (in which case we must tear down the server subscription) or an\n     * already-processed signature (in which case the client can simply\n     * clear out the subscription locally without telling the server).\n     *\n     * NOTE: There is a proposal to eliminate this special case, here:\n     * https://github.com/solana-labs/solana/issues/18892\n     */ /** @internal */ this._subscriptionsAutoDisposedByRpc = new Set();\n        /*\n     * Returns the current block height of the node\n     */ this.getBlockHeight = (()=>{\n            const requestPromises = {};\n            return async (commitmentOrConfig)=>{\n                const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n                const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n                const requestHash = fastStableStringify(args);\n                requestPromises[requestHash] = requestPromises[requestHash] ?? (async ()=>{\n                    try {\n                        const unsafeRes = await this._rpcRequest(\"getBlockHeight\", args);\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n                        if (\"error\" in res) {\n                            throw new SolanaJSONRPCError(res.error, \"failed to get block height information\");\n                        }\n                        return res.result;\n                    } finally{\n                        delete requestPromises[requestHash];\n                    }\n                })();\n                return await requestPromises[requestHash];\n            };\n        })();\n        let wsEndpoint;\n        let httpHeaders;\n        let fetch;\n        let fetchMiddleware;\n        let disableRetryOnRateLimit;\n        let httpAgent;\n        if (_commitmentOrConfig && typeof _commitmentOrConfig === \"string\") {\n            this._commitment = _commitmentOrConfig;\n        } else if (_commitmentOrConfig) {\n            this._commitment = _commitmentOrConfig.commitment;\n            this._confirmTransactionInitialTimeout = _commitmentOrConfig.confirmTransactionInitialTimeout;\n            wsEndpoint = _commitmentOrConfig.wsEndpoint;\n            httpHeaders = _commitmentOrConfig.httpHeaders;\n            fetch = _commitmentOrConfig.fetch;\n            fetchMiddleware = _commitmentOrConfig.fetchMiddleware;\n            disableRetryOnRateLimit = _commitmentOrConfig.disableRetryOnRateLimit;\n            httpAgent = _commitmentOrConfig.httpAgent;\n        }\n        this._rpcEndpoint = assertEndpointUrl(endpoint);\n        this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint);\n        this._rpcClient = createRpcClient(endpoint, httpHeaders, fetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent);\n        this._rpcRequest = createRpcRequest(this._rpcClient);\n        this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);\n        this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {\n            autoconnect: false,\n            max_reconnects: Infinity\n        });\n        this._rpcWebSocket.on(\"open\", this._wsOnOpen.bind(this));\n        this._rpcWebSocket.on(\"error\", this._wsOnError.bind(this));\n        this._rpcWebSocket.on(\"close\", this._wsOnClose.bind(this));\n        this._rpcWebSocket.on(\"accountNotification\", this._wsOnAccountNotification.bind(this));\n        this._rpcWebSocket.on(\"programNotification\", this._wsOnProgramAccountNotification.bind(this));\n        this._rpcWebSocket.on(\"slotNotification\", this._wsOnSlotNotification.bind(this));\n        this._rpcWebSocket.on(\"slotsUpdatesNotification\", this._wsOnSlotUpdatesNotification.bind(this));\n        this._rpcWebSocket.on(\"signatureNotification\", this._wsOnSignatureNotification.bind(this));\n        this._rpcWebSocket.on(\"rootNotification\", this._wsOnRootNotification.bind(this));\n        this._rpcWebSocket.on(\"logsNotification\", this._wsOnLogsNotification.bind(this));\n    }\n    /**\n   * The default commitment used for requests\n   */ get commitment() {\n        return this._commitment;\n    }\n    /**\n   * The RPC endpoint\n   */ get rpcEndpoint() {\n        return this._rpcEndpoint;\n    }\n    /**\n   * Fetch the balance for the specified public key, return with context\n   */ async getBalanceAndContext(publicKey, commitmentOrConfig) {\n        /** @internal */ const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getBalance\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get balance for ${publicKey.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the balance for the specified public key\n   */ async getBalance(publicKey, commitmentOrConfig) {\n        return await this.getBalanceAndContext(publicKey, commitmentOrConfig).then((x)=>x.value).catch((e)=>{\n            throw new Error(\"failed to get balance of account \" + publicKey.toBase58() + \": \" + e);\n        });\n    }\n    /**\n   * Fetch the estimated production time of a block\n   */ async getBlockTime(slot) {\n        const unsafeRes = await this._rpcRequest(\"getBlockTime\", [\n            slot\n        ]);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get block time for slot ${slot}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the lowest slot that the node has information about in its ledger.\n   * This value may increase over time if the node is configured to purge older ledger data\n   */ async getMinimumLedgerSlot() {\n        const unsafeRes = await this._rpcRequest(\"minimumLedgerSlot\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get minimum ledger slot\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the slot of the lowest confirmed block that has not been purged from the ledger\n   */ async getFirstAvailableBlock() {\n        const unsafeRes = await this._rpcRequest(\"getFirstAvailableBlock\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, SlotRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get first available block\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch information about the current supply\n   */ async getSupply(config) {\n        let configArg = {};\n        if (typeof config === \"string\") {\n            configArg = {\n                commitment: config\n            };\n        } else if (config) {\n            configArg = {\n                ...config,\n                commitment: config && config.commitment || this.commitment\n            };\n        } else {\n            configArg = {\n                commitment: this.commitment\n            };\n        }\n        const unsafeRes = await this._rpcRequest(\"getSupply\", [\n            configArg\n        ]);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetSupplyRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get supply\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current supply of a token mint\n   */ async getTokenSupply(tokenMintAddress, commitment) {\n        const args = this._buildArgs([\n            tokenMintAddress.toBase58()\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getTokenSupply\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get token supply\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current balance of a token account\n   */ async getTokenAccountBalance(tokenAddress, commitment) {\n        const args = this._buildArgs([\n            tokenAddress.toBase58()\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getTokenAccountBalance\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get token account balance\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the token accounts owned by the specified account\n   *\n   * @return {Promise<RpcResponseAndContext<GetProgramAccountsResponse>}\n   */ async getTokenAccountsByOwner(ownerAddress, filter, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        let _args = [\n            ownerAddress.toBase58()\n        ];\n        if (\"mint\" in filter) {\n            _args.push({\n                mint: filter.mint.toBase58()\n            });\n        } else {\n            _args.push({\n                programId: filter.programId.toBase58()\n            });\n        }\n        const args = this._buildArgs(_args, commitment, \"base64\", config);\n        const unsafeRes = await this._rpcRequest(\"getTokenAccountsByOwner\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetTokenAccountsByOwner);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch parsed token accounts owned by the specified account\n   *\n   * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<ParsedAccountData>}>>>}\n   */ async getParsedTokenAccountsByOwner(ownerAddress, filter, commitment) {\n        let _args = [\n            ownerAddress.toBase58()\n        ];\n        if (\"mint\" in filter) {\n            _args.push({\n                mint: filter.mint.toBase58()\n            });\n        } else {\n            _args.push({\n                programId: filter.programId.toBase58()\n            });\n        }\n        const args = this._buildArgs(_args, commitment, \"jsonParsed\");\n        const unsafeRes = await this._rpcRequest(\"getTokenAccountsByOwner\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedTokenAccountsByOwner);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the 20 largest accounts with their current balances\n   */ async getLargestAccounts(config) {\n        const arg = {\n            ...config,\n            commitment: config && config.commitment || this.commitment\n        };\n        const args = arg.filter || arg.commitment ? [\n            arg\n        ] : [];\n        const unsafeRes = await this._rpcRequest(\"getLargestAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetLargestAccountsRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get largest accounts\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the 20 largest token accounts with their current balances\n   * for a given mint.\n   */ async getTokenLargestAccounts(mintAddress, commitment) {\n        const args = this._buildArgs([\n            mintAddress.toBase58()\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getTokenLargestAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetTokenLargestAccountsResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get token largest accounts\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the account info for the specified public key, return with context\n   */ async getAccountInfoAndContext(publicKey, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment, \"base64\", config);\n        const unsafeRes = await this._rpcRequest(\"getAccountInfo\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(AccountInfoResult)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch parsed account info for the specified public key\n   */ async getParsedAccountInfo(publicKey, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getAccountInfo\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ParsedAccountInfoResult)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the account info for the specified public key\n   */ async getAccountInfo(publicKey, commitmentOrConfig) {\n        try {\n            const res = await this.getAccountInfoAndContext(publicKey, commitmentOrConfig);\n            return res.value;\n        } catch (e) {\n            throw new Error(\"failed to get info about account \" + publicKey.toBase58() + \": \" + e);\n        }\n    }\n    /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context\n   */ async getMultipleParsedAccounts(publicKeys, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const keys = publicKeys.map((key)=>key.toBase58());\n        const args = this._buildArgs([\n            keys\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getMultipleAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ParsedAccountInfoResult))));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context\n   */ async getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const keys = publicKeys.map((key)=>key.toBase58());\n        const args = this._buildArgs([\n            keys\n        ], commitment, \"base64\", config);\n        const unsafeRes = await this._rpcRequest(\"getMultipleAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(AccountInfoResult))));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys\n   */ async getMultipleAccountsInfo(publicKeys, commitmentOrConfig) {\n        const res = await this.getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig);\n        return res.value;\n    }\n    /**\n   * Returns epoch activation information for a stake account that has been delegated\n   *\n   * @deprecated Deprecated since RPC v1.18; will be removed in a future version.\n   */ async getStakeActivation(publicKey, commitmentOrConfig, epoch) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment, undefined /* encoding */ , {\n            ...config,\n            epoch: epoch != null ? epoch : config?.epoch\n        });\n        const unsafeRes = await this._rpcRequest(\"getStakeActivation\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult(StakeActivationResult));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get Stake Activation ${publicKey.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the accounts owned by the specified program id\n   *\n   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>}\n   */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    async getProgramAccounts(programId, configOrCommitment) {\n        const { commitment, config } = extractCommitmentFromConfig(configOrCommitment);\n        const { encoding, ...configWithoutEncoding } = config || {};\n        const args = this._buildArgs([\n            programId.toBase58()\n        ], commitment, encoding || \"base64\", {\n            ...configWithoutEncoding,\n            ...configWithoutEncoding.filters ? {\n                filters: applyDefaultMemcmpEncodingToFilters(configWithoutEncoding.filters)\n            } : null\n        });\n        const unsafeRes = await this._rpcRequest(\"getProgramAccounts\", args);\n        const baseSchema = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(KeyedAccountInfoResult);\n        const res = configWithoutEncoding.withContext === true ? (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext(baseSchema)) : (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult(baseSchema));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch and parse all the accounts owned by the specified program id\n   *\n   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer | ParsedAccountData>}>>}\n   */ async getParsedProgramAccounts(programId, configOrCommitment) {\n        const { commitment, config } = extractCommitmentFromConfig(configOrCommitment);\n        const args = this._buildArgs([\n            programId.toBase58()\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getProgramAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(KeyedParsedAccountInfoResult)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);\n        }\n        return res.result;\n    }\n    /** @deprecated Instead, call `confirmTransaction` and pass in {@link TransactionConfirmationStrategy} */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    async confirmTransaction(strategy, commitment) {\n        let rawSignature;\n        if (typeof strategy == \"string\") {\n            rawSignature = strategy;\n        } else {\n            const config = strategy;\n            if (config.abortSignal?.aborted) {\n                return Promise.reject(config.abortSignal.reason);\n            }\n            rawSignature = config.signature;\n        }\n        let decodedSignature;\n        try {\n            decodedSignature = bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(rawSignature);\n        } catch (err) {\n            throw new Error(\"signature must be base58 encoded: \" + rawSignature);\n        }\n        assert(decodedSignature.length === 64, \"signature has invalid length\");\n        if (typeof strategy === \"string\") {\n            return await this.confirmTransactionUsingLegacyTimeoutStrategy({\n                commitment: commitment || this.commitment,\n                signature: rawSignature\n            });\n        } else if (\"lastValidBlockHeight\" in strategy) {\n            return await this.confirmTransactionUsingBlockHeightExceedanceStrategy({\n                commitment: commitment || this.commitment,\n                strategy\n            });\n        } else {\n            return await this.confirmTransactionUsingDurableNonceStrategy({\n                commitment: commitment || this.commitment,\n                strategy\n            });\n        }\n    }\n    getCancellationPromise(signal) {\n        return new Promise((_, reject)=>{\n            if (signal == null) {\n                return;\n            }\n            if (signal.aborted) {\n                reject(signal.reason);\n            } else {\n                signal.addEventListener(\"abort\", ()=>{\n                    reject(signal.reason);\n                });\n            }\n        });\n    }\n    getTransactionConfirmationPromise({ commitment, signature }) {\n        let signatureSubscriptionId;\n        let disposeSignatureSubscriptionStateChangeObserver;\n        let done = false;\n        const confirmationPromise = new Promise((resolve, reject)=>{\n            try {\n                signatureSubscriptionId = this.onSignature(signature, (result, context)=>{\n                    signatureSubscriptionId = undefined;\n                    const response = {\n                        context,\n                        value: result\n                    };\n                    resolve({\n                        __type: TransactionStatus.PROCESSED,\n                        response\n                    });\n                }, commitment);\n                const subscriptionSetupPromise = new Promise((resolveSubscriptionSetup)=>{\n                    if (signatureSubscriptionId == null) {\n                        resolveSubscriptionSetup();\n                    } else {\n                        disposeSignatureSubscriptionStateChangeObserver = this._onSubscriptionStateChange(signatureSubscriptionId, (nextState)=>{\n                            if (nextState === \"subscribed\") {\n                                resolveSubscriptionSetup();\n                            }\n                        });\n                    }\n                });\n                (async ()=>{\n                    await subscriptionSetupPromise;\n                    if (done) return;\n                    const response = await this.getSignatureStatus(signature);\n                    if (done) return;\n                    if (response == null) {\n                        return;\n                    }\n                    const { context, value } = response;\n                    if (value == null) {\n                        return;\n                    }\n                    if (value?.err) {\n                        reject(value.err);\n                    } else {\n                        switch(commitment){\n                            case \"confirmed\":\n                            case \"single\":\n                            case \"singleGossip\":\n                                {\n                                    if (value.confirmationStatus === \"processed\") {\n                                        return;\n                                    }\n                                    break;\n                                }\n                            case \"finalized\":\n                            case \"max\":\n                            case \"root\":\n                                {\n                                    if (value.confirmationStatus === \"processed\" || value.confirmationStatus === \"confirmed\") {\n                                        return;\n                                    }\n                                    break;\n                                }\n                            // exhaust enums to ensure full coverage\n                            case \"processed\":\n                            case \"recent\":\n                        }\n                        done = true;\n                        resolve({\n                            __type: TransactionStatus.PROCESSED,\n                            response: {\n                                context,\n                                value\n                            }\n                        });\n                    }\n                })();\n            } catch (err) {\n                reject(err);\n            }\n        });\n        const abortConfirmation = ()=>{\n            if (disposeSignatureSubscriptionStateChangeObserver) {\n                disposeSignatureSubscriptionStateChangeObserver();\n                disposeSignatureSubscriptionStateChangeObserver = undefined;\n            }\n            if (signatureSubscriptionId != null) {\n                this.removeSignatureListener(signatureSubscriptionId);\n                signatureSubscriptionId = undefined;\n            }\n        };\n        return {\n            abortConfirmation,\n            confirmationPromise\n        };\n    }\n    async confirmTransactionUsingBlockHeightExceedanceStrategy({ commitment, strategy: { abortSignal, lastValidBlockHeight, signature } }) {\n        let done = false;\n        const expiryPromise = new Promise((resolve)=>{\n            const checkBlockHeight = async ()=>{\n                try {\n                    const blockHeight = await this.getBlockHeight(commitment);\n                    return blockHeight;\n                } catch (_e) {\n                    return -1;\n                }\n            };\n            (async ()=>{\n                let currentBlockHeight = await checkBlockHeight();\n                if (done) return;\n                while(currentBlockHeight <= lastValidBlockHeight){\n                    await sleep(1000);\n                    if (done) return;\n                    currentBlockHeight = await checkBlockHeight();\n                    if (done) return;\n                }\n                resolve({\n                    __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED\n                });\n            })();\n        });\n        const { abortConfirmation, confirmationPromise } = this.getTransactionConfirmationPromise({\n            commitment,\n            signature\n        });\n        const cancellationPromise = this.getCancellationPromise(abortSignal);\n        let result;\n        try {\n            const outcome = await Promise.race([\n                cancellationPromise,\n                confirmationPromise,\n                expiryPromise\n            ]);\n            if (outcome.__type === TransactionStatus.PROCESSED) {\n                result = outcome.response;\n            } else {\n                throw new TransactionExpiredBlockheightExceededError(signature);\n            }\n        } finally{\n            done = true;\n            abortConfirmation();\n        }\n        return result;\n    }\n    async confirmTransactionUsingDurableNonceStrategy({ commitment, strategy: { abortSignal, minContextSlot, nonceAccountPubkey, nonceValue, signature } }) {\n        let done = false;\n        const expiryPromise = new Promise((resolve)=>{\n            let currentNonceValue = nonceValue;\n            let lastCheckedSlot = null;\n            const getCurrentNonceValue = async ()=>{\n                try {\n                    const { context, value: nonceAccount } = await this.getNonceAndContext(nonceAccountPubkey, {\n                        commitment,\n                        minContextSlot\n                    });\n                    lastCheckedSlot = context.slot;\n                    return nonceAccount?.nonce;\n                } catch (e) {\n                    // If for whatever reason we can't reach/read the nonce\n                    // account, just keep using the last-known value.\n                    return currentNonceValue;\n                }\n            };\n            (async ()=>{\n                currentNonceValue = await getCurrentNonceValue();\n                if (done) return;\n                while(true // eslint-disable-line no-constant-condition\n                ){\n                    if (nonceValue !== currentNonceValue) {\n                        resolve({\n                            __type: TransactionStatus.NONCE_INVALID,\n                            slotInWhichNonceDidAdvance: lastCheckedSlot\n                        });\n                        return;\n                    }\n                    await sleep(2000);\n                    if (done) return;\n                    currentNonceValue = await getCurrentNonceValue();\n                    if (done) return;\n                }\n            })();\n        });\n        const { abortConfirmation, confirmationPromise } = this.getTransactionConfirmationPromise({\n            commitment,\n            signature\n        });\n        const cancellationPromise = this.getCancellationPromise(abortSignal);\n        let result;\n        try {\n            const outcome = await Promise.race([\n                cancellationPromise,\n                confirmationPromise,\n                expiryPromise\n            ]);\n            if (outcome.__type === TransactionStatus.PROCESSED) {\n                result = outcome.response;\n            } else {\n                // Double check that the transaction is indeed unconfirmed.\n                let signatureStatus;\n                while(true // eslint-disable-line no-constant-condition\n                ){\n                    const status = await this.getSignatureStatus(signature);\n                    if (status == null) {\n                        break;\n                    }\n                    if (status.context.slot < (outcome.slotInWhichNonceDidAdvance ?? minContextSlot)) {\n                        await sleep(400);\n                        continue;\n                    }\n                    signatureStatus = status;\n                    break;\n                }\n                if (signatureStatus?.value) {\n                    const commitmentForStatus = commitment || \"finalized\";\n                    const { confirmationStatus } = signatureStatus.value;\n                    switch(commitmentForStatus){\n                        case \"processed\":\n                        case \"recent\":\n                            if (confirmationStatus !== \"processed\" && confirmationStatus !== \"confirmed\" && confirmationStatus !== \"finalized\") {\n                                throw new TransactionExpiredNonceInvalidError(signature);\n                            }\n                            break;\n                        case \"confirmed\":\n                        case \"single\":\n                        case \"singleGossip\":\n                            if (confirmationStatus !== \"confirmed\" && confirmationStatus !== \"finalized\") {\n                                throw new TransactionExpiredNonceInvalidError(signature);\n                            }\n                            break;\n                        case \"finalized\":\n                        case \"max\":\n                        case \"root\":\n                            if (confirmationStatus !== \"finalized\") {\n                                throw new TransactionExpiredNonceInvalidError(signature);\n                            }\n                            break;\n                        default:\n                            // Exhaustive switch.\n                            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                            ((_)=>{})(commitmentForStatus);\n                    }\n                    result = {\n                        context: signatureStatus.context,\n                        value: {\n                            err: signatureStatus.value.err\n                        }\n                    };\n                } else {\n                    throw new TransactionExpiredNonceInvalidError(signature);\n                }\n            }\n        } finally{\n            done = true;\n            abortConfirmation();\n        }\n        return result;\n    }\n    async confirmTransactionUsingLegacyTimeoutStrategy({ commitment, signature }) {\n        let timeoutId;\n        const expiryPromise = new Promise((resolve)=>{\n            let timeoutMs = this._confirmTransactionInitialTimeout || 60 * 1000;\n            switch(commitment){\n                case \"processed\":\n                case \"recent\":\n                case \"single\":\n                case \"confirmed\":\n                case \"singleGossip\":\n                    {\n                        timeoutMs = this._confirmTransactionInitialTimeout || 30 * 1000;\n                        break;\n                    }\n            }\n            timeoutId = setTimeout(()=>resolve({\n                    __type: TransactionStatus.TIMED_OUT,\n                    timeoutMs\n                }), timeoutMs);\n        });\n        const { abortConfirmation, confirmationPromise } = this.getTransactionConfirmationPromise({\n            commitment,\n            signature\n        });\n        let result;\n        try {\n            const outcome = await Promise.race([\n                confirmationPromise,\n                expiryPromise\n            ]);\n            if (outcome.__type === TransactionStatus.PROCESSED) {\n                result = outcome.response;\n            } else {\n                throw new TransactionExpiredTimeoutError(signature, outcome.timeoutMs / 1000);\n            }\n        } finally{\n            clearTimeout(timeoutId);\n            abortConfirmation();\n        }\n        return result;\n    }\n    /**\n   * Return the list of nodes that are currently participating in the cluster\n   */ async getClusterNodes() {\n        const unsafeRes = await this._rpcRequest(\"getClusterNodes\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(ContactInfoResult)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get cluster nodes\");\n        }\n        return res.result;\n    }\n    /**\n   * Return the list of nodes that are currently participating in the cluster\n   */ async getVoteAccounts(commitment) {\n        const args = this._buildArgs([], commitment);\n        const unsafeRes = await this._rpcRequest(\"getVoteAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetVoteAccounts);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get vote accounts\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current slot that the node is processing\n   */ async getSlot(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getSlot\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get slot\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current slot leader of the cluster\n   */ async getSlotLeader(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getSlotLeader\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get slot leader\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch `limit` number of slot leaders starting from `startSlot`\n   *\n   * @param startSlot fetch slot leaders starting from this slot\n   * @param limit number of slot leaders to return\n   */ async getSlotLeaders(startSlot, limit) {\n        const args = [\n            startSlot,\n            limit\n        ];\n        const unsafeRes = await this._rpcRequest(\"getSlotLeaders\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PublicKeyFromString)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get slot leaders\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current status of a signature\n   */ async getSignatureStatus(signature, config) {\n        const { context, value: values } = await this.getSignatureStatuses([\n            signature\n        ], config);\n        assert(values.length === 1);\n        const value = values[0];\n        return {\n            context,\n            value\n        };\n    }\n    /**\n   * Fetch the current statuses of a batch of signatures\n   */ async getSignatureStatuses(signatures, config) {\n        const params = [\n            signatures\n        ];\n        if (config) {\n            params.push(config);\n        }\n        const unsafeRes = await this._rpcRequest(\"getSignatureStatuses\", params);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetSignatureStatusesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get signature status\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current transaction count of the cluster\n   */ async getTransactionCount(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getTransactionCount\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get transaction count\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current total currency supply of the cluster in lamports\n   *\n   * @deprecated Deprecated since RPC v1.2.8. Please use {@link getSupply} instead.\n   */ async getTotalSupply(commitment) {\n        const result = await this.getSupply({\n            commitment,\n            excludeNonCirculatingAccountsList: true\n        });\n        return result.value.total;\n    }\n    /**\n   * Fetch the cluster InflationGovernor parameters\n   */ async getInflationGovernor(commitment) {\n        const args = this._buildArgs([], commitment);\n        const unsafeRes = await this._rpcRequest(\"getInflationGovernor\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetInflationGovernorRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get inflation\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the inflation reward for a list of addresses for an epoch\n   */ async getInflationReward(addresses, epoch, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            addresses.map((pubkey)=>pubkey.toBase58())\n        ], commitment, undefined /* encoding */ , {\n            ...config,\n            epoch: epoch != null ? epoch : config?.epoch\n        });\n        const unsafeRes = await this._rpcRequest(\"getInflationReward\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetInflationRewardResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get inflation reward\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the specific inflation values for the current epoch\n   */ async getInflationRate() {\n        const unsafeRes = await this._rpcRequest(\"getInflationRate\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetInflationRateRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get inflation rate\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the Epoch Info parameters\n   */ async getEpochInfo(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getEpochInfo\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetEpochInfoRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get epoch info\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the Epoch Schedule parameters\n   */ async getEpochSchedule() {\n        const unsafeRes = await this._rpcRequest(\"getEpochSchedule\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetEpochScheduleRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get epoch schedule\");\n        }\n        const epochSchedule = res.result;\n        return new EpochSchedule(epochSchedule.slotsPerEpoch, epochSchedule.leaderScheduleSlotOffset, epochSchedule.warmup, epochSchedule.firstNormalEpoch, epochSchedule.firstNormalSlot);\n    }\n    /**\n   * Fetch the leader schedule for the current epoch\n   * @return {Promise<RpcResponseAndContext<LeaderSchedule>>}\n   */ async getLeaderSchedule() {\n        const unsafeRes = await this._rpcRequest(\"getLeaderSchedule\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetLeaderScheduleRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get leader schedule\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the minimum balance needed to exempt an account of `dataLength`\n   * size from rent\n   */ async getMinimumBalanceForRentExemption(dataLength, commitment) {\n        const args = this._buildArgs([\n            dataLength\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getMinimumBalanceForRentExemption\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetMinimumBalanceForRentExemptionRpcResult);\n        if (\"error\" in res) {\n            console.warn(\"Unable to fetch minimum balance for rent exemption\");\n            return 0;\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a recent blockhash from the cluster, return with context\n   * @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}\n   *\n   * @deprecated Deprecated since RPC v1.9.0. Please use {@link getLatestBlockhash} instead.\n   */ async getRecentBlockhashAndContext(commitment) {\n        const { context, value: { blockhash } } = await this.getLatestBlockhashAndContext(commitment);\n        const feeCalculator = {\n            get lamportsPerSignature () {\n                throw new Error(\"The capability to fetch `lamportsPerSignature` using the `getRecentBlockhash` API is \" + \"no longer offered by the network. Use the `getFeeForMessage` API to obtain the fee \" + \"for a given message.\");\n            },\n            toJSON () {\n                return {};\n            }\n        };\n        return {\n            context,\n            value: {\n                blockhash,\n                feeCalculator\n            }\n        };\n    }\n    /**\n   * Fetch recent performance samples\n   * @return {Promise<Array<PerfSample>>}\n   */ async getRecentPerformanceSamples(limit) {\n        const unsafeRes = await this._rpcRequest(\"getRecentPerformanceSamples\", limit ? [\n            limit\n        ] : []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetRecentPerformanceSamplesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get recent performance samples\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the fee calculator for a recent blockhash from the cluster, return with context\n   *\n   * @deprecated Deprecated since RPC v1.9.0. Please use {@link getFeeForMessage} instead.\n   */ async getFeeCalculatorForBlockhash(blockhash, commitment) {\n        const args = this._buildArgs([\n            blockhash\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getFeeCalculatorForBlockhash\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetFeeCalculatorRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get fee calculator\");\n        }\n        const { context, value } = res.result;\n        return {\n            context,\n            value: value !== null ? value.feeCalculator : null\n        };\n    }\n    /**\n   * Fetch the fee for a message from the cluster, return with context\n   */ async getFeeForMessage(message, commitment) {\n        const wireMessage = toBuffer(message.serialize()).toString(\"base64\");\n        const args = this._buildArgs([\n            wireMessage\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getFeeForMessage\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get fee for message\");\n        }\n        if (res.result === null) {\n            throw new Error(\"invalid blockhash\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a list of prioritization fees from recent blocks.\n   */ async getRecentPrioritizationFees(config) {\n        const accounts = config?.lockedWritableAccounts?.map((key)=>key.toBase58());\n        const args = accounts?.length ? [\n            accounts\n        ] : [];\n        const unsafeRes = await this._rpcRequest(\"getRecentPrioritizationFees\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetRecentPrioritizationFeesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get recent prioritization fees\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a recent blockhash from the cluster\n   * @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}\n   *\n   * @deprecated Deprecated since RPC v1.8.0. Please use {@link getLatestBlockhash} instead.\n   */ async getRecentBlockhash(commitment) {\n        try {\n            const res = await this.getRecentBlockhashAndContext(commitment);\n            return res.value;\n        } catch (e) {\n            throw new Error(\"failed to get recent blockhash: \" + e);\n        }\n    }\n    /**\n   * Fetch the latest blockhash from the cluster\n   * @return {Promise<BlockhashWithExpiryBlockHeight>}\n   */ async getLatestBlockhash(commitmentOrConfig) {\n        try {\n            const res = await this.getLatestBlockhashAndContext(commitmentOrConfig);\n            return res.value;\n        } catch (e) {\n            throw new Error(\"failed to get recent blockhash: \" + e);\n        }\n    }\n    /**\n   * Fetch the latest blockhash from the cluster\n   * @return {Promise<BlockhashWithExpiryBlockHeight>}\n   */ async getLatestBlockhashAndContext(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getLatestBlockhash\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetLatestBlockhashRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get latest blockhash\");\n        }\n        return res.result;\n    }\n    /**\n   * Returns whether a blockhash is still valid or not\n   */ async isBlockhashValid(blockhash, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const args = this._buildArgs([\n            blockhash\n        ], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"isBlockhashValid\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, IsBlockhashValidRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to determine if the blockhash `\" + blockhash + \"`is valid\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the node version\n   */ async getVersion() {\n        const unsafeRes = await this._rpcRequest(\"getVersion\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult(VersionResult));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get version\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the genesis hash\n   */ async getGenesisHash() {\n        const unsafeRes = await this._rpcRequest(\"getGenesisHash\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get genesis hash\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a processed block from the cluster.\n   *\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */ /**\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Fetch a processed block from the cluster.\n   */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Fetch a processed block from the cluster.\n   */ // eslint-disable-next-line no-dupe-class-members\n    async getBlock(slot, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        try {\n            switch(config?.transactionDetails){\n                case \"accounts\":\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetAccountsModeBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n                case \"none\":\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetNoneModeBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n                default:\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        const { result } = res;\n                        return result ? {\n                            ...result,\n                            transactions: result.transactions.map(({ transaction, meta, version })=>({\n                                    meta,\n                                    transaction: {\n                                        ...transaction,\n                                        message: versionedMessageFromResponse(version, transaction.message)\n                                    },\n                                    version\n                                }))\n                        } : null;\n                    }\n            }\n        } catch (e) {\n            throw new SolanaJSONRPCError(e, \"failed to get confirmed block\");\n        }\n    }\n    /**\n   * Fetch parsed transaction details for a confirmed or finalized block\n   */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    async getParsedBlock(slot, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        try {\n            switch(config?.transactionDetails){\n                case \"accounts\":\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedAccountsModeBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n                case \"none\":\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedNoneModeBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n                default:\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n            }\n        } catch (e) {\n            throw new SolanaJSONRPCError(e, \"failed to get block\");\n        }\n    }\n    /*\n   * Returns recent block production information from the current or previous epoch\n   */ async getBlockProduction(configOrCommitment) {\n        let extra;\n        let commitment;\n        if (typeof configOrCommitment === \"string\") {\n            commitment = configOrCommitment;\n        } else if (configOrCommitment) {\n            const { commitment: c, ...rest } = configOrCommitment;\n            commitment = c;\n            extra = rest;\n        }\n        const args = this._buildArgs([], commitment, \"base64\", extra);\n        const unsafeRes = await this._rpcRequest(\"getBlockProduction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, BlockProductionResponseStruct);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get block production information\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   *\n   * @deprecated Instead, call `getTransaction` using a\n   * `GetVersionedTransactionConfig` by setting the\n   * `maxSupportedTransactionVersion` property.\n   */ /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   */ // eslint-disable-next-line no-dupe-class-members\n    async getTransaction(signature, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const args = this._buildArgsAtLeastConfirmed([\n            signature\n        ], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetTransactionRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get transaction\");\n        }\n        const result = res.result;\n        if (!result) return result;\n        return {\n            ...result,\n            transaction: {\n                ...result.transaction,\n                message: versionedMessageFromResponse(result.version, result.transaction.message)\n            }\n        };\n    }\n    /**\n   * Fetch parsed transaction details for a confirmed or finalized transaction\n   */ async getParsedTransaction(signature, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgsAtLeastConfirmed([\n            signature\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedTransactionRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get transaction\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch parsed transaction details for a batch of confirmed transactions\n   */ async getParsedTransactions(signatures, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const batch = signatures.map((signature)=>{\n            const args = this._buildArgsAtLeastConfirmed([\n                signature\n            ], commitment, \"jsonParsed\", config);\n            return {\n                methodName: \"getTransaction\",\n                args\n            };\n        });\n        const unsafeRes = await this._rpcBatchRequest(batch);\n        const res = unsafeRes.map((unsafeRes)=>{\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedTransactionRpcResult);\n            if (\"error\" in res) {\n                throw new SolanaJSONRPCError(res.error, \"failed to get transactions\");\n            }\n            return res.result;\n        });\n        return res;\n    }\n    /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link TransactionResponse}.\n   *\n   * @deprecated Instead, call `getTransactions` using a\n   * `GetVersionedTransactionConfig` by setting the\n   * `maxSupportedTransactionVersion` property.\n   */ /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link\n   * VersionedTransactionResponse}.\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link\n   * VersionedTransactionResponse}.\n   */ // eslint-disable-next-line no-dupe-class-members\n    async getTransactions(signatures, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const batch = signatures.map((signature)=>{\n            const args = this._buildArgsAtLeastConfirmed([\n                signature\n            ], commitment, undefined /* encoding */ , config);\n            return {\n                methodName: \"getTransaction\",\n                args\n            };\n        });\n        const unsafeRes = await this._rpcBatchRequest(batch);\n        const res = unsafeRes.map((unsafeRes)=>{\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetTransactionRpcResult);\n            if (\"error\" in res) {\n                throw new SolanaJSONRPCError(res.error, \"failed to get transactions\");\n            }\n            const result = res.result;\n            if (!result) return result;\n            return {\n                ...result,\n                transaction: {\n                    ...result.transaction,\n                    message: versionedMessageFromResponse(result.version, result.transaction.message)\n                }\n            };\n        });\n        return res;\n    }\n    /**\n   * Fetch a list of Transactions and transaction statuses from the cluster\n   * for a confirmed block.\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getBlock} instead.\n   */ async getConfirmedBlock(slot, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetConfirmedBlockRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get confirmed block\");\n        }\n        const result = res.result;\n        if (!result) {\n            throw new Error(\"Confirmed block \" + slot + \" not found\");\n        }\n        const block = {\n            ...result,\n            transactions: result.transactions.map(({ transaction, meta })=>{\n                const message = new Message(transaction.message);\n                return {\n                    meta,\n                    transaction: {\n                        ...transaction,\n                        message\n                    }\n                };\n            })\n        };\n        return {\n            ...block,\n            transactions: block.transactions.map(({ transaction, meta })=>{\n                return {\n                    meta,\n                    transaction: Transaction.populate(transaction.message, transaction.signatures)\n                };\n            })\n        };\n    }\n    /**\n   * Fetch confirmed blocks between two slots\n   */ async getBlocks(startSlot, endSlot, commitment) {\n        const args = this._buildArgsAtLeastConfirmed(endSlot !== undefined ? [\n            startSlot,\n            endSlot\n        ] : [\n            startSlot\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getBlocks\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get blocks\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a list of Signatures from the cluster for a block, excluding rewards\n   */ async getBlockSignatures(slot, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment, undefined, {\n            transactionDetails: \"signatures\",\n            rewards: false\n        });\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetBlockSignaturesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get block\");\n        }\n        const result = res.result;\n        if (!result) {\n            throw new Error(\"Block \" + slot + \" not found\");\n        }\n        return result;\n    }\n    /**\n   * Fetch a list of Signatures from the cluster for a confirmed block, excluding rewards\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getBlockSignatures} instead.\n   */ async getConfirmedBlockSignatures(slot, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment, undefined, {\n            transactionDetails: \"signatures\",\n            rewards: false\n        });\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetBlockSignaturesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get confirmed block\");\n        }\n        const result = res.result;\n        if (!result) {\n            throw new Error(\"Confirmed block \" + slot + \" not found\");\n        }\n        return result;\n    }\n    /**\n   * Fetch a transaction details for a confirmed transaction\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getTransaction} instead.\n   */ async getConfirmedTransaction(signature, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            signature\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetTransactionRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get transaction\");\n        }\n        const result = res.result;\n        if (!result) return result;\n        const message = new Message(result.transaction.message);\n        const signatures = result.transaction.signatures;\n        return {\n            ...result,\n            transaction: Transaction.populate(message, signatures)\n        };\n    }\n    /**\n   * Fetch parsed transaction details for a confirmed transaction\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getParsedTransaction} instead.\n   */ async getParsedConfirmedTransaction(signature, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            signature\n        ], commitment, \"jsonParsed\");\n        const unsafeRes = await this._rpcRequest(\"getTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedTransactionRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get confirmed transaction\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch parsed transaction details for a batch of confirmed transactions\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getParsedTransactions} instead.\n   */ async getParsedConfirmedTransactions(signatures, commitment) {\n        const batch = signatures.map((signature)=>{\n            const args = this._buildArgsAtLeastConfirmed([\n                signature\n            ], commitment, \"jsonParsed\");\n            return {\n                methodName: \"getTransaction\",\n                args\n            };\n        });\n        const unsafeRes = await this._rpcBatchRequest(batch);\n        const res = unsafeRes.map((unsafeRes)=>{\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedTransactionRpcResult);\n            if (\"error\" in res) {\n                throw new SolanaJSONRPCError(res.error, \"failed to get confirmed transactions\");\n            }\n            return res.result;\n        });\n        return res;\n    }\n    /**\n   * Fetch a list of all the confirmed signatures for transactions involving an address\n   * within a specified slot range. Max range allowed is 10,000 slots.\n   *\n   * @deprecated Deprecated since RPC v1.3. Please use {@link getConfirmedSignaturesForAddress2} instead.\n   *\n   * @param address queried address\n   * @param startSlot start slot, inclusive\n   * @param endSlot end slot, inclusive\n   */ async getConfirmedSignaturesForAddress(address, startSlot, endSlot) {\n        let options = {};\n        let firstAvailableBlock = await this.getFirstAvailableBlock();\n        while(!(\"until\" in options)){\n            startSlot--;\n            if (startSlot <= 0 || startSlot < firstAvailableBlock) {\n                break;\n            }\n            try {\n                const block = await this.getConfirmedBlockSignatures(startSlot, \"finalized\");\n                if (block.signatures.length > 0) {\n                    options.until = block.signatures[block.signatures.length - 1].toString();\n                }\n            } catch (err) {\n                if (err instanceof Error && err.message.includes(\"skipped\")) {\n                    continue;\n                } else {\n                    throw err;\n                }\n            }\n        }\n        let highestConfirmedRoot = await this.getSlot(\"finalized\");\n        while(!(\"before\" in options)){\n            endSlot++;\n            if (endSlot > highestConfirmedRoot) {\n                break;\n            }\n            try {\n                const block = await this.getConfirmedBlockSignatures(endSlot);\n                if (block.signatures.length > 0) {\n                    options.before = block.signatures[block.signatures.length - 1].toString();\n                }\n            } catch (err) {\n                if (err instanceof Error && err.message.includes(\"skipped\")) {\n                    continue;\n                } else {\n                    throw err;\n                }\n            }\n        }\n        const confirmedSignatureInfo = await this.getConfirmedSignaturesForAddress2(address, options);\n        return confirmedSignatureInfo.map((info)=>info.signature);\n    }\n    /**\n   * Returns confirmed signatures for transactions involving an\n   * address backwards in time from the provided signature or most recent confirmed block\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getSignaturesForAddress} instead.\n   */ async getConfirmedSignaturesForAddress2(address, options, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            address.toBase58()\n        ], commitment, undefined, options);\n        const unsafeRes = await this._rpcRequest(\"getConfirmedSignaturesForAddress2\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetConfirmedSignaturesForAddress2RpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get confirmed signatures for address\");\n        }\n        return res.result;\n    }\n    /**\n   * Returns confirmed signatures for transactions involving an\n   * address backwards in time from the provided signature or most recent confirmed block\n   *\n   *\n   * @param address queried address\n   * @param options\n   */ async getSignaturesForAddress(address, options, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            address.toBase58()\n        ], commitment, undefined, options);\n        const unsafeRes = await this._rpcRequest(\"getSignaturesForAddress\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetSignaturesForAddressRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get signatures for address\");\n        }\n        return res.result;\n    }\n    async getAddressLookupTable(accountKey, config) {\n        const { context, value: accountInfo } = await this.getAccountInfoAndContext(accountKey, config);\n        let value = null;\n        if (accountInfo !== null) {\n            value = new AddressLookupTableAccount({\n                key: accountKey,\n                state: AddressLookupTableAccount.deserialize(accountInfo.data)\n            });\n        }\n        return {\n            context,\n            value\n        };\n    }\n    /**\n   * Fetch the contents of a Nonce account from the cluster, return with context\n   */ async getNonceAndContext(nonceAccount, commitmentOrConfig) {\n        const { context, value: accountInfo } = await this.getAccountInfoAndContext(nonceAccount, commitmentOrConfig);\n        let value = null;\n        if (accountInfo !== null) {\n            value = NonceAccount.fromAccountData(accountInfo.data);\n        }\n        return {\n            context,\n            value\n        };\n    }\n    /**\n   * Fetch the contents of a Nonce account from the cluster\n   */ async getNonce(nonceAccount, commitmentOrConfig) {\n        return await this.getNonceAndContext(nonceAccount, commitmentOrConfig).then((x)=>x.value).catch((e)=>{\n            throw new Error(\"failed to get nonce for account \" + nonceAccount.toBase58() + \": \" + e);\n        });\n    }\n    /**\n   * Request an allocation of lamports to the specified address\n   *\n   * ```typescript\n   * import { Connection, PublicKey, LAMPORTS_PER_SOL } from \"@solana/web3.js\";\n   *\n   * (async () => {\n   *   const connection = new Connection(\"https://api.testnet.solana.com\", \"confirmed\");\n   *   const myAddress = new PublicKey(\"2nr1bHFT86W9tGnyvmYW4vcHKsQB3sVQfnddasz4kExM\");\n   *   const signature = await connection.requestAirdrop(myAddress, LAMPORTS_PER_SOL);\n   *   await connection.confirmTransaction(signature);\n   * })();\n   * ```\n   */ async requestAirdrop(to, lamports) {\n        const unsafeRes = await this._rpcRequest(\"requestAirdrop\", [\n            to.toBase58(),\n            lamports\n        ]);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, RequestAirdropRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `airdrop to ${to.toBase58()} failed`);\n        }\n        return res.result;\n    }\n    /**\n   * @internal\n   */ async _blockhashWithExpiryBlockHeight(disableCache) {\n        if (!disableCache) {\n            // Wait for polling to finish\n            while(this._pollingBlockhash){\n                await sleep(100);\n            }\n            const timeSinceFetch = Date.now() - this._blockhashInfo.lastFetch;\n            const expired = timeSinceFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;\n            if (this._blockhashInfo.latestBlockhash !== null && !expired) {\n                return this._blockhashInfo.latestBlockhash;\n            }\n        }\n        return await this._pollNewBlockhash();\n    }\n    /**\n   * @internal\n   */ async _pollNewBlockhash() {\n        this._pollingBlockhash = true;\n        try {\n            const startTime = Date.now();\n            const cachedLatestBlockhash = this._blockhashInfo.latestBlockhash;\n            const cachedBlockhash = cachedLatestBlockhash ? cachedLatestBlockhash.blockhash : null;\n            for(let i = 0; i < 50; i++){\n                const latestBlockhash = await this.getLatestBlockhash(\"finalized\");\n                if (cachedBlockhash !== latestBlockhash.blockhash) {\n                    this._blockhashInfo = {\n                        latestBlockhash,\n                        lastFetch: Date.now(),\n                        transactionSignatures: [],\n                        simulatedSignatures: []\n                    };\n                    return latestBlockhash;\n                }\n                // Sleep for approximately half a slot\n                await sleep(MS_PER_SLOT / 2);\n            }\n            throw new Error(`Unable to obtain a new blockhash after ${Date.now() - startTime}ms`);\n        } finally{\n            this._pollingBlockhash = false;\n        }\n    }\n    /**\n   * get the stake minimum delegation\n   */ async getStakeMinimumDelegation(config) {\n        const { commitment, config: configArg } = extractCommitmentFromConfig(config);\n        const args = this._buildArgs([], commitment, \"base64\", configArg);\n        const unsafeRes = await this._rpcRequest(\"getStakeMinimumDelegation\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get stake minimum delegation`);\n        }\n        return res.result;\n    }\n    /**\n   * Simulate a transaction\n   *\n   * @deprecated Instead, call {@link simulateTransaction} with {@link\n   * VersionedTransaction} and {@link SimulateTransactionConfig} parameters\n   */ /**\n   * Simulate a transaction\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Simulate a transaction\n   */ // eslint-disable-next-line no-dupe-class-members\n    async simulateTransaction(transactionOrMessage, configOrSigners, includeAccounts) {\n        if (\"message\" in transactionOrMessage) {\n            const versionedTx = transactionOrMessage;\n            const wireTransaction = versionedTx.serialize();\n            const encodedTransaction = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(wireTransaction).toString(\"base64\");\n            if (Array.isArray(configOrSigners) || includeAccounts !== undefined) {\n                throw new Error(\"Invalid arguments\");\n            }\n            const config = configOrSigners || {};\n            config.encoding = \"base64\";\n            if (!(\"commitment\" in config)) {\n                config.commitment = this.commitment;\n            }\n            if (configOrSigners && typeof configOrSigners === \"object\" && \"innerInstructions\" in configOrSigners) {\n                config.innerInstructions = configOrSigners.innerInstructions;\n            }\n            const args = [\n                encodedTransaction,\n                config\n            ];\n            const unsafeRes = await this._rpcRequest(\"simulateTransaction\", args);\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, SimulatedTransactionResponseStruct);\n            if (\"error\" in res) {\n                throw new Error(\"failed to simulate transaction: \" + res.error.message);\n            }\n            return res.result;\n        }\n        let transaction;\n        if (transactionOrMessage instanceof Transaction) {\n            let originalTx = transactionOrMessage;\n            transaction = new Transaction();\n            transaction.feePayer = originalTx.feePayer;\n            transaction.instructions = transactionOrMessage.instructions;\n            transaction.nonceInfo = originalTx.nonceInfo;\n            transaction.signatures = originalTx.signatures;\n        } else {\n            transaction = Transaction.populate(transactionOrMessage);\n            // HACK: this function relies on mutating the populated transaction\n            transaction._message = transaction._json = undefined;\n        }\n        if (configOrSigners !== undefined && !Array.isArray(configOrSigners)) {\n            throw new Error(\"Invalid arguments\");\n        }\n        const signers = configOrSigners;\n        if (transaction.nonceInfo && signers) {\n            transaction.sign(...signers);\n        } else {\n            let disableCache = this._disableBlockhashCaching;\n            for(;;){\n                const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);\n                transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;\n                transaction.recentBlockhash = latestBlockhash.blockhash;\n                if (!signers) break;\n                transaction.sign(...signers);\n                if (!transaction.signature) {\n                    throw new Error(\"!signature\"); // should never happen\n                }\n                const signature = transaction.signature.toString(\"base64\");\n                if (!this._blockhashInfo.simulatedSignatures.includes(signature) && !this._blockhashInfo.transactionSignatures.includes(signature)) {\n                    // The signature of this transaction has not been seen before with the\n                    // current recentBlockhash, all done. Let's break\n                    this._blockhashInfo.simulatedSignatures.push(signature);\n                    break;\n                } else {\n                    // This transaction would be treated as duplicate (its derived signature\n                    // matched to one of already recorded signatures).\n                    // So, we must fetch a new blockhash for a different signature by disabling\n                    // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).\n                    disableCache = true;\n                }\n            }\n        }\n        const message = transaction._compile();\n        const signData = message.serialize();\n        const wireTransaction = transaction._serialize(signData);\n        const encodedTransaction = wireTransaction.toString(\"base64\");\n        const config = {\n            encoding: \"base64\",\n            commitment: this.commitment\n        };\n        if (includeAccounts) {\n            const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map((key)=>key.toBase58());\n            config[\"accounts\"] = {\n                encoding: \"base64\",\n                addresses\n            };\n        }\n        if (signers) {\n            config.sigVerify = true;\n        }\n        if (configOrSigners && typeof configOrSigners === \"object\" && \"innerInstructions\" in configOrSigners) {\n            config.innerInstructions = configOrSigners.innerInstructions;\n        }\n        const args = [\n            encodedTransaction,\n            config\n        ];\n        const unsafeRes = await this._rpcRequest(\"simulateTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, SimulatedTransactionResponseStruct);\n        if (\"error\" in res) {\n            let logs;\n            if (\"data\" in res.error) {\n                logs = res.error.data.logs;\n                if (logs && Array.isArray(logs)) {\n                    const traceIndent = \"\\n    \";\n                    const logTrace = traceIndent + logs.join(traceIndent);\n                    console.error(res.error.message, logTrace);\n                }\n            }\n            throw new SendTransactionError({\n                action: \"simulate\",\n                signature: \"\",\n                transactionMessage: res.error.message,\n                logs: logs\n            });\n        }\n        return res.result;\n    }\n    /**\n   * Sign and send a transaction\n   *\n   * @deprecated Instead, call {@link sendTransaction} with a {@link\n   * VersionedTransaction}\n   */ /**\n   * Send a signed transaction\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Sign and send a transaction\n   */ // eslint-disable-next-line no-dupe-class-members\n    async sendTransaction(transaction, signersOrOptions, options) {\n        if (\"version\" in transaction) {\n            if (signersOrOptions && Array.isArray(signersOrOptions)) {\n                throw new Error(\"Invalid arguments\");\n            }\n            const wireTransaction = transaction.serialize();\n            return await this.sendRawTransaction(wireTransaction, signersOrOptions);\n        }\n        if (signersOrOptions === undefined || !Array.isArray(signersOrOptions)) {\n            throw new Error(\"Invalid arguments\");\n        }\n        const signers = signersOrOptions;\n        if (transaction.nonceInfo) {\n            transaction.sign(...signers);\n        } else {\n            let disableCache = this._disableBlockhashCaching;\n            for(;;){\n                const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);\n                transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;\n                transaction.recentBlockhash = latestBlockhash.blockhash;\n                transaction.sign(...signers);\n                if (!transaction.signature) {\n                    throw new Error(\"!signature\"); // should never happen\n                }\n                const signature = transaction.signature.toString(\"base64\");\n                if (!this._blockhashInfo.transactionSignatures.includes(signature)) {\n                    // The signature of this transaction has not been seen before with the\n                    // current recentBlockhash, all done. Let's break\n                    this._blockhashInfo.transactionSignatures.push(signature);\n                    break;\n                } else {\n                    // This transaction would be treated as duplicate (its derived signature\n                    // matched to one of already recorded signatures).\n                    // So, we must fetch a new blockhash for a different signature by disabling\n                    // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).\n                    disableCache = true;\n                }\n            }\n        }\n        const wireTransaction = transaction.serialize();\n        return await this.sendRawTransaction(wireTransaction, options);\n    }\n    /**\n   * Send a transaction that has already been signed and serialized into the\n   * wire format\n   */ async sendRawTransaction(rawTransaction, options) {\n        const encodedTransaction = toBuffer(rawTransaction).toString(\"base64\");\n        const result = await this.sendEncodedTransaction(encodedTransaction, options);\n        return result;\n    }\n    /**\n   * Send a transaction that has already been signed, serialized into the\n   * wire format, and encoded as a base64 string\n   */ async sendEncodedTransaction(encodedTransaction, options) {\n        const config = {\n            encoding: \"base64\"\n        };\n        const skipPreflight = options && options.skipPreflight;\n        const preflightCommitment = skipPreflight === true ? \"processed\" // FIXME Remove when https://github.com/anza-xyz/agave/pull/483 is deployed.\n         : options && options.preflightCommitment || this.commitment;\n        if (options && options.maxRetries != null) {\n            config.maxRetries = options.maxRetries;\n        }\n        if (options && options.minContextSlot != null) {\n            config.minContextSlot = options.minContextSlot;\n        }\n        if (skipPreflight) {\n            config.skipPreflight = skipPreflight;\n        }\n        if (preflightCommitment) {\n            config.preflightCommitment = preflightCommitment;\n        }\n        const args = [\n            encodedTransaction,\n            config\n        ];\n        const unsafeRes = await this._rpcRequest(\"sendTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, SendTransactionRpcResult);\n        if (\"error\" in res) {\n            let logs = undefined;\n            if (\"data\" in res.error) {\n                logs = res.error.data.logs;\n            }\n            throw new SendTransactionError({\n                action: skipPreflight ? \"send\" : \"simulate\",\n                signature: \"\",\n                transactionMessage: res.error.message,\n                logs: logs\n            });\n        }\n        return res.result;\n    }\n    /**\n   * @internal\n   */ _wsOnOpen() {\n        this._rpcWebSocketConnected = true;\n        this._rpcWebSocketHeartbeat = setInterval(()=>{\n            // Ping server every 5s to prevent idle timeouts\n            (async ()=>{\n                try {\n                    await this._rpcWebSocket.notify(\"ping\");\n                // eslint-disable-next-line no-empty\n                } catch  {}\n            })();\n        }, 5000);\n        this._updateSubscriptions();\n    }\n    /**\n   * @internal\n   */ _wsOnError(err) {\n        this._rpcWebSocketConnected = false;\n        console.error(\"ws error:\", err.message);\n    }\n    /**\n   * @internal\n   */ _wsOnClose(code) {\n        this._rpcWebSocketConnected = false;\n        this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER;\n        if (this._rpcWebSocketIdleTimeout) {\n            clearTimeout(this._rpcWebSocketIdleTimeout);\n            this._rpcWebSocketIdleTimeout = null;\n        }\n        if (this._rpcWebSocketHeartbeat) {\n            clearInterval(this._rpcWebSocketHeartbeat);\n            this._rpcWebSocketHeartbeat = null;\n        }\n        if (code === 1000) {\n            // explicit close, check if any subscriptions have been made since close\n            this._updateSubscriptions();\n            return;\n        }\n        // implicit close, prepare subscriptions for auto-reconnect\n        this._subscriptionCallbacksByServerSubscriptionId = {};\n        Object.entries(this._subscriptionsByHash).forEach(([hash, subscription])=>{\n            this._setSubscription(hash, {\n                ...subscription,\n                state: \"pending\"\n            });\n        });\n    }\n    /**\n   * @internal\n   */ _setSubscription(hash, nextSubscription) {\n        const prevState = this._subscriptionsByHash[hash]?.state;\n        this._subscriptionsByHash[hash] = nextSubscription;\n        if (prevState !== nextSubscription.state) {\n            const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash];\n            if (stateChangeCallbacks) {\n                stateChangeCallbacks.forEach((cb)=>{\n                    try {\n                        cb(nextSubscription.state);\n                    // eslint-disable-next-line no-empty\n                    } catch  {}\n                });\n            }\n        }\n    }\n    /**\n   * @internal\n   */ _onSubscriptionStateChange(clientSubscriptionId, callback) {\n        const hash = this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];\n        if (hash == null) {\n            return ()=>{};\n        }\n        const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash] ||= new Set();\n        stateChangeCallbacks.add(callback);\n        return ()=>{\n            stateChangeCallbacks.delete(callback);\n            if (stateChangeCallbacks.size === 0) {\n                delete this._subscriptionStateChangeCallbacksByHash[hash];\n            }\n        };\n    }\n    /**\n   * @internal\n   */ async _updateSubscriptions() {\n        if (Object.keys(this._subscriptionsByHash).length === 0) {\n            if (this._rpcWebSocketConnected) {\n                this._rpcWebSocketConnected = false;\n                this._rpcWebSocketIdleTimeout = setTimeout(()=>{\n                    this._rpcWebSocketIdleTimeout = null;\n                    try {\n                        this._rpcWebSocket.close();\n                    } catch (err) {\n                        // swallow error if socket has already been closed.\n                        if (err instanceof Error) {\n                            console.log(`Error when closing socket connection: ${err.message}`);\n                        }\n                    }\n                }, 500);\n            }\n            return;\n        }\n        if (this._rpcWebSocketIdleTimeout !== null) {\n            clearTimeout(this._rpcWebSocketIdleTimeout);\n            this._rpcWebSocketIdleTimeout = null;\n            this._rpcWebSocketConnected = true;\n        }\n        if (!this._rpcWebSocketConnected) {\n            this._rpcWebSocket.connect();\n            return;\n        }\n        const activeWebSocketGeneration = this._rpcWebSocketGeneration;\n        const isCurrentConnectionStillActive = ()=>{\n            return activeWebSocketGeneration === this._rpcWebSocketGeneration;\n        };\n        await Promise.all(// Don't be tempted to change this to `Object.entries`. We call\n        // `_updateSubscriptions` recursively when processing the state,\n        // so it's important that we look up the *current* version of\n        // each subscription, every time we process a hash.\n        Object.keys(this._subscriptionsByHash).map(async (hash)=>{\n            const subscription = this._subscriptionsByHash[hash];\n            if (subscription === undefined) {\n                // This entry has since been deleted. Skip.\n                return;\n            }\n            switch(subscription.state){\n                case \"pending\":\n                case \"unsubscribed\":\n                    if (subscription.callbacks.size === 0) {\n                        /**\n             * You can end up here when:\n             *\n             * - a subscription has recently unsubscribed\n             *   without having new callbacks added to it\n             *   while the unsubscribe was in flight, or\n             * - when a pending subscription has its\n             *   listeners removed before a request was\n             *   sent to the server.\n             *\n             * Being that nobody is interested in this\n             * subscription any longer, delete it.\n             */ delete this._subscriptionsByHash[hash];\n                        if (subscription.state === \"unsubscribed\") {\n                            delete this._subscriptionCallbacksByServerSubscriptionId[subscription.serverSubscriptionId];\n                        }\n                        await this._updateSubscriptions();\n                        return;\n                    }\n                    await (async ()=>{\n                        const { args, method } = subscription;\n                        try {\n                            this._setSubscription(hash, {\n                                ...subscription,\n                                state: \"subscribing\"\n                            });\n                            const serverSubscriptionId = await this._rpcWebSocket.call(method, args);\n                            this._setSubscription(hash, {\n                                ...subscription,\n                                serverSubscriptionId,\n                                state: \"subscribed\"\n                            });\n                            this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId] = subscription.callbacks;\n                            await this._updateSubscriptions();\n                        } catch (e) {\n                            console.error(`Received ${e instanceof Error ? \"\" : \"JSON-RPC \"}error calling \\`${method}\\``, {\n                                args,\n                                error: e\n                            });\n                            if (!isCurrentConnectionStillActive()) {\n                                return;\n                            }\n                            // TODO: Maybe add an 'errored' state or a retry limit?\n                            this._setSubscription(hash, {\n                                ...subscription,\n                                state: \"pending\"\n                            });\n                            await this._updateSubscriptions();\n                        }\n                    })();\n                    break;\n                case \"subscribed\":\n                    if (subscription.callbacks.size === 0) {\n                        // By the time we successfully set up a subscription\n                        // with the server, the client stopped caring about it.\n                        // Tear it down now.\n                        await (async ()=>{\n                            const { serverSubscriptionId, unsubscribeMethod } = subscription;\n                            if (this._subscriptionsAutoDisposedByRpc.has(serverSubscriptionId)) {\n                                /**\n                 * Special case.\n                 * If we're dealing with a subscription that has been auto-\n                 * disposed by the RPC, then we can skip the RPC call to\n                 * tear down the subscription here.\n                 *\n                 * NOTE: There is a proposal to eliminate this special case, here:\n                 * https://github.com/solana-labs/solana/issues/18892\n                 */ this._subscriptionsAutoDisposedByRpc.delete(serverSubscriptionId);\n                            } else {\n                                this._setSubscription(hash, {\n                                    ...subscription,\n                                    state: \"unsubscribing\"\n                                });\n                                this._setSubscription(hash, {\n                                    ...subscription,\n                                    state: \"unsubscribing\"\n                                });\n                                try {\n                                    await this._rpcWebSocket.call(unsubscribeMethod, [\n                                        serverSubscriptionId\n                                    ]);\n                                } catch (e) {\n                                    if (e instanceof Error) {\n                                        console.error(`${unsubscribeMethod} error:`, e.message);\n                                    }\n                                    if (!isCurrentConnectionStillActive()) {\n                                        return;\n                                    }\n                                    // TODO: Maybe add an 'errored' state or a retry limit?\n                                    this._setSubscription(hash, {\n                                        ...subscription,\n                                        state: \"subscribed\"\n                                    });\n                                    await this._updateSubscriptions();\n                                    return;\n                                }\n                            }\n                            this._setSubscription(hash, {\n                                ...subscription,\n                                state: \"unsubscribed\"\n                            });\n                            await this._updateSubscriptions();\n                        })();\n                    }\n                    break;\n            }\n        }));\n    }\n    /**\n   * @internal\n   */ _handleServerNotification(serverSubscriptionId, callbackArgs) {\n        const callbacks = this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId];\n        if (callbacks === undefined) {\n            return;\n        }\n        callbacks.forEach((cb)=>{\n            try {\n                cb(// I failed to find a way to convince TypeScript that `cb` is of type\n                // `TCallback` which is certainly compatible with `Parameters<TCallback>`.\n                // See https://github.com/microsoft/TypeScript/issues/47615\n                // @ts-ignore\n                ...callbackArgs);\n            } catch (e) {\n                console.error(e);\n            }\n        });\n    }\n    /**\n   * @internal\n   */ _wsOnAccountNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, AccountNotificationResult);\n        this._handleServerNotification(subscription, [\n            result.value,\n            result.context\n        ]);\n    }\n    /**\n   * @internal\n   */ _makeSubscription(subscriptionConfig, /**\n   * When preparing `args` for a call to `_makeSubscription`, be sure\n   * to carefully apply a default `commitment` property, if necessary.\n   *\n   * - If the user supplied a `commitment` use that.\n   * - Otherwise, if the `Connection::commitment` is set, use that.\n   * - Otherwise, set it to the RPC server default: `finalized`.\n   *\n   * This is extremely important to ensure that these two fundamentally\n   * identical subscriptions produce the same identifying hash:\n   *\n   * - A subscription made without specifying a commitment.\n   * - A subscription made where the commitment specified is the same\n   *   as the default applied to the subscription above.\n   *\n   * Example; these two subscriptions must produce the same hash:\n   *\n   * - An `accountSubscribe` subscription for `'PUBKEY'`\n   * - An `accountSubscribe` subscription for `'PUBKEY'` with commitment\n   *   `'finalized'`.\n   *\n   * See the 'making a subscription with defaulted params omitted' test\n   * in `connection-subscriptions.ts` for more.\n   */ args) {\n        const clientSubscriptionId = this._nextClientSubscriptionId++;\n        const hash = fastStableStringify([\n            subscriptionConfig.method,\n            args\n        ]);\n        const existingSubscription = this._subscriptionsByHash[hash];\n        if (existingSubscription === undefined) {\n            this._subscriptionsByHash[hash] = {\n                ...subscriptionConfig,\n                args,\n                callbacks: new Set([\n                    subscriptionConfig.callback\n                ]),\n                state: \"pending\"\n            };\n        } else {\n            existingSubscription.callbacks.add(subscriptionConfig.callback);\n        }\n        this._subscriptionHashByClientSubscriptionId[clientSubscriptionId] = hash;\n        this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId] = async ()=>{\n            delete this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];\n            delete this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];\n            const subscription = this._subscriptionsByHash[hash];\n            assert(subscription !== undefined, `Could not find a \\`Subscription\\` when tearing down client subscription #${clientSubscriptionId}`);\n            subscription.callbacks.delete(subscriptionConfig.callback);\n            await this._updateSubscriptions();\n        };\n        this._updateSubscriptions();\n        return clientSubscriptionId;\n    }\n    /**\n   * Register a callback to be invoked whenever the specified account changes\n   *\n   * @param publicKey Public key of the account to monitor\n   * @param callback Function to invoke whenever the account is changed\n   * @param config\n   * @return subscription id\n   */ /** @deprecated Instead, pass in an {@link AccountSubscriptionConfig} */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    onAccountChange(publicKey, callback, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment || this._commitment || \"finalized\", // Apply connection/server default.\n        \"base64\", config);\n        return this._makeSubscription({\n            callback,\n            method: \"accountSubscribe\",\n            unsubscribeMethod: \"accountUnsubscribe\"\n        }, args);\n    }\n    /**\n   * Deregister an account notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeAccountChangeListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"account change\");\n    }\n    /**\n   * @internal\n   */ _wsOnProgramAccountNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, ProgramAccountNotificationResult);\n        this._handleServerNotification(subscription, [\n            {\n                accountId: result.value.pubkey,\n                accountInfo: result.value.account\n            },\n            result.context\n        ]);\n    }\n    /**\n   * Register a callback to be invoked whenever accounts owned by the\n   * specified program change\n   *\n   * @param programId Public key of the program to monitor\n   * @param callback Function to invoke whenever the account is changed\n   * @param config\n   * @return subscription id\n   */ /** @deprecated Instead, pass in a {@link ProgramAccountSubscriptionConfig} */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    onProgramAccountChange(programId, callback, commitmentOrConfig, maybeFilters) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            programId.toBase58()\n        ], commitment || this._commitment || \"finalized\", // Apply connection/server default.\n        \"base64\" /* encoding */ , config ? config : maybeFilters ? {\n            filters: applyDefaultMemcmpEncodingToFilters(maybeFilters)\n        } : undefined /* extra */ );\n        return this._makeSubscription({\n            callback,\n            method: \"programSubscribe\",\n            unsubscribeMethod: \"programUnsubscribe\"\n        }, args);\n    }\n    /**\n   * Deregister an account notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeProgramAccountChangeListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"program account change\");\n    }\n    /**\n   * Registers a callback to be invoked whenever logs are emitted.\n   */ onLogs(filter, callback, commitment) {\n        const args = this._buildArgs([\n            typeof filter === \"object\" ? {\n                mentions: [\n                    filter.toString()\n                ]\n            } : filter\n        ], commitment || this._commitment || \"finalized\" // Apply connection/server default.\n        );\n        return this._makeSubscription({\n            callback,\n            method: \"logsSubscribe\",\n            unsubscribeMethod: \"logsUnsubscribe\"\n        }, args);\n    }\n    /**\n   * Deregister a logs callback.\n   *\n   * @param clientSubscriptionId client subscription id to deregister.\n   */ async removeOnLogsListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"logs\");\n    }\n    /**\n   * @internal\n   */ _wsOnLogsNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, LogsNotificationResult);\n        this._handleServerNotification(subscription, [\n            result.value,\n            result.context\n        ]);\n    }\n    /**\n   * @internal\n   */ _wsOnSlotNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, SlotNotificationResult);\n        this._handleServerNotification(subscription, [\n            result\n        ]);\n    }\n    /**\n   * Register a callback to be invoked upon slot changes\n   *\n   * @param callback Function to invoke whenever the slot changes\n   * @return subscription id\n   */ onSlotChange(callback) {\n        return this._makeSubscription({\n            callback,\n            method: \"slotSubscribe\",\n            unsubscribeMethod: \"slotUnsubscribe\"\n        }, []);\n    }\n    /**\n   * Deregister a slot notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeSlotChangeListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"slot change\");\n    }\n    /**\n   * @internal\n   */ _wsOnSlotUpdatesNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, SlotUpdateNotificationResult);\n        this._handleServerNotification(subscription, [\n            result\n        ]);\n    }\n    /**\n   * Register a callback to be invoked upon slot updates. {@link SlotUpdate}'s\n   * may be useful to track live progress of a cluster.\n   *\n   * @param callback Function to invoke whenever the slot updates\n   * @return subscription id\n   */ onSlotUpdate(callback) {\n        return this._makeSubscription({\n            callback,\n            method: \"slotsUpdatesSubscribe\",\n            unsubscribeMethod: \"slotsUpdatesUnsubscribe\"\n        }, []);\n    }\n    /**\n   * Deregister a slot update notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeSlotUpdateListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"slot update\");\n    }\n    /**\n   * @internal\n   */ async _unsubscribeClientSubscription(clientSubscriptionId, subscriptionName) {\n        const dispose = this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];\n        if (dispose) {\n            await dispose();\n        } else {\n            console.warn(\"Ignored unsubscribe request because an active subscription with id \" + `\\`${clientSubscriptionId}\\` for '${subscriptionName}' events ` + \"could not be found.\");\n        }\n    }\n    _buildArgs(args, override, encoding, extra) {\n        const commitment = override || this._commitment;\n        if (commitment || encoding || extra) {\n            let options = {};\n            if (encoding) {\n                options.encoding = encoding;\n            }\n            if (commitment) {\n                options.commitment = commitment;\n            }\n            if (extra) {\n                options = Object.assign(options, extra);\n            }\n            args.push(options);\n        }\n        return args;\n    }\n    /**\n   * @internal\n   */ _buildArgsAtLeastConfirmed(args, override, encoding, extra) {\n        const commitment = override || this._commitment;\n        if (commitment && ![\n            \"confirmed\",\n            \"finalized\"\n        ].includes(commitment)) {\n            throw new Error(\"Using Connection with default commitment: `\" + this._commitment + \"`, but method requires at least `confirmed`\");\n        }\n        return this._buildArgs(args, override, encoding, extra);\n    }\n    /**\n   * @internal\n   */ _wsOnSignatureNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, SignatureNotificationResult);\n        if (result.value !== \"receivedSignature\") {\n            /**\n       * Special case.\n       * After a signature is processed, RPCs automatically dispose of the\n       * subscription on the server side. We need to track which of these\n       * subscriptions have been disposed in such a way, so that we know\n       * whether the client is dealing with a not-yet-processed signature\n       * (in which case we must tear down the server subscription) or an\n       * already-processed signature (in which case the client can simply\n       * clear out the subscription locally without telling the server).\n       *\n       * NOTE: There is a proposal to eliminate this special case, here:\n       * https://github.com/solana-labs/solana/issues/18892\n       */ this._subscriptionsAutoDisposedByRpc.add(subscription);\n        }\n        this._handleServerNotification(subscription, result.value === \"receivedSignature\" ? [\n            {\n                type: \"received\"\n            },\n            result.context\n        ] : [\n            {\n                type: \"status\",\n                result: result.value\n            },\n            result.context\n        ]);\n    }\n    /**\n   * Register a callback to be invoked upon signature updates\n   *\n   * @param signature Transaction signature string in base 58\n   * @param callback Function to invoke on signature notifications\n   * @param commitment Specify the commitment level signature must reach before notification\n   * @return subscription id\n   */ onSignature(signature, callback, commitment) {\n        const args = this._buildArgs([\n            signature\n        ], commitment || this._commitment || \"finalized\" // Apply connection/server default.\n        );\n        const clientSubscriptionId = this._makeSubscription({\n            callback: (notification, context)=>{\n                if (notification.type === \"status\") {\n                    callback(notification.result, context);\n                    // Signatures subscriptions are auto-removed by the RPC service\n                    // so no need to explicitly send an unsubscribe message.\n                    try {\n                        this.removeSignatureListener(clientSubscriptionId);\n                    // eslint-disable-next-line no-empty\n                    } catch (_err) {\n                    // Already removed.\n                    }\n                }\n            },\n            method: \"signatureSubscribe\",\n            unsubscribeMethod: \"signatureUnsubscribe\"\n        }, args);\n        return clientSubscriptionId;\n    }\n    /**\n   * Register a callback to be invoked when a transaction is\n   * received and/or processed.\n   *\n   * @param signature Transaction signature string in base 58\n   * @param callback Function to invoke on signature notifications\n   * @param options Enable received notifications and set the commitment\n   *   level that signature must reach before notification\n   * @return subscription id\n   */ onSignatureWithOptions(signature, callback, options) {\n        const { commitment, ...extra } = {\n            ...options,\n            commitment: options && options.commitment || this._commitment || \"finalized\" // Apply connection/server default.\n        };\n        const args = this._buildArgs([\n            signature\n        ], commitment, undefined /* encoding */ , extra);\n        const clientSubscriptionId = this._makeSubscription({\n            callback: (notification, context)=>{\n                callback(notification, context);\n                // Signatures subscriptions are auto-removed by the RPC service\n                // so no need to explicitly send an unsubscribe message.\n                try {\n                    this.removeSignatureListener(clientSubscriptionId);\n                // eslint-disable-next-line no-empty\n                } catch (_err) {\n                // Already removed.\n                }\n            },\n            method: \"signatureSubscribe\",\n            unsubscribeMethod: \"signatureUnsubscribe\"\n        }, args);\n        return clientSubscriptionId;\n    }\n    /**\n   * Deregister a signature notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeSignatureListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"signature result\");\n    }\n    /**\n   * @internal\n   */ _wsOnRootNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, RootNotificationResult);\n        this._handleServerNotification(subscription, [\n            result\n        ]);\n    }\n    /**\n   * Register a callback to be invoked upon root changes\n   *\n   * @param callback Function to invoke whenever the root changes\n   * @return subscription id\n   */ onRootChange(callback) {\n        return this._makeSubscription({\n            callback,\n            method: \"rootSubscribe\",\n            unsubscribeMethod: \"rootUnsubscribe\"\n        }, []);\n    }\n    /**\n   * Deregister a root notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeRootChangeListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"root change\");\n    }\n}\n/**\n * Keypair signer interface\n */ /**\n * An account keypair used for signing transactions.\n */ class Keypair {\n    /**\n   * Create a new keypair instance.\n   * Generate random keypair if no {@link Ed25519Keypair} is provided.\n   *\n   * @param {Ed25519Keypair} keypair ed25519 keypair\n   */ constructor(keypair){\n        this._keypair = void 0;\n        this._keypair = keypair ?? generateKeypair();\n    }\n    /**\n   * Generate a new random keypair\n   *\n   * @returns {Keypair} Keypair\n   */ static generate() {\n        return new Keypair(generateKeypair());\n    }\n    /**\n   * Create a keypair from a raw secret key byte array.\n   *\n   * This method should only be used to recreate a keypair from a previously\n   * generated secret key. Generating keypairs from a random seed should be done\n   * with the {@link Keypair.fromSeed} method.\n   *\n   * @throws error if the provided secret key is invalid and validation is not skipped.\n   *\n   * @param secretKey secret key byte array\n   * @param options skip secret key validation\n   *\n   * @returns {Keypair} Keypair\n   */ static fromSecretKey(secretKey, options) {\n        if (secretKey.byteLength !== 64) {\n            throw new Error(\"bad secret key size\");\n        }\n        const publicKey = secretKey.slice(32, 64);\n        if (!options || !options.skipValidation) {\n            const privateScalar = secretKey.slice(0, 32);\n            const computedPublicKey = getPublicKey(privateScalar);\n            for(let ii = 0; ii < 32; ii++){\n                if (publicKey[ii] !== computedPublicKey[ii]) {\n                    throw new Error(\"provided secretKey is invalid\");\n                }\n            }\n        }\n        return new Keypair({\n            publicKey,\n            secretKey\n        });\n    }\n    /**\n   * Generate a keypair from a 32 byte seed.\n   *\n   * @param seed seed byte array\n   *\n   * @returns {Keypair} Keypair\n   */ static fromSeed(seed) {\n        const publicKey = getPublicKey(seed);\n        const secretKey = new Uint8Array(64);\n        secretKey.set(seed);\n        secretKey.set(publicKey, 32);\n        return new Keypair({\n            publicKey,\n            secretKey\n        });\n    }\n    /**\n   * The public key for this keypair\n   *\n   * @returns {PublicKey} PublicKey\n   */ get publicKey() {\n        return new PublicKey(this._keypair.publicKey);\n    }\n    /**\n   * The raw secret key for this keypair\n   * @returns {Uint8Array} Secret key in an array of Uint8 bytes\n   */ get secretKey() {\n        return new Uint8Array(this._keypair.secretKey);\n    }\n}\n/**\n * An enumeration of valid LookupTableInstructionType's\n */ /**\n * An enumeration of valid address lookup table InstructionType's\n * @internal\n */ const LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({\n    CreateLookupTable: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            u64(\"recentSlot\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"bumpSeed\")\n        ])\n    },\n    FreezeLookupTable: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    ExtendLookupTable: {\n        index: 2,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            u64(),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"addresses\")\n        ])\n    },\n    DeactivateLookupTable: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    CloseLookupTable: {\n        index: 4,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    }\n});\nclass AddressLookupTableInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\");\n        const index = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [layoutType, layout] of Object.entries(LOOKUP_TABLE_INSTRUCTION_LAYOUTS)){\n            if (layout.index == index) {\n                type = layoutType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Invalid Instruction. Should be a LookupTable Instruction\");\n        }\n        return type;\n    }\n    static decodeCreateLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeysLength(instruction.keys, 4);\n        const { recentSlot } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable, instruction.data);\n        return {\n            authority: instruction.keys[1].pubkey,\n            payer: instruction.keys[2].pubkey,\n            recentSlot: Number(recentSlot)\n        };\n    }\n    static decodeExtendLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        if (instruction.keys.length < 2) {\n            throw new Error(`invalid instruction; found ${instruction.keys.length} keys, expected at least 2`);\n        }\n        const { addresses } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable, instruction.data);\n        return {\n            lookupTable: instruction.keys[0].pubkey,\n            authority: instruction.keys[1].pubkey,\n            payer: instruction.keys.length > 2 ? instruction.keys[2].pubkey : undefined,\n            addresses: addresses.map((buffer)=>new PublicKey(buffer))\n        };\n    }\n    static decodeCloseLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeysLength(instruction.keys, 3);\n        return {\n            lookupTable: instruction.keys[0].pubkey,\n            authority: instruction.keys[1].pubkey,\n            recipient: instruction.keys[2].pubkey\n        };\n    }\n    static decodeFreezeLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeysLength(instruction.keys, 2);\n        return {\n            lookupTable: instruction.keys[0].pubkey,\n            authority: instruction.keys[1].pubkey\n        };\n    }\n    static decodeDeactivateLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeysLength(instruction.keys, 2);\n        return {\n            lookupTable: instruction.keys[0].pubkey,\n            authority: instruction.keys[1].pubkey\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(AddressLookupTableProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not AddressLookupTable Program\");\n        }\n    }\n    /**\n   * @internal\n   */ static checkKeysLength(keys, expectedLength) {\n        if (keys.length < expectedLength) {\n            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n        }\n    }\n}\nclass AddressLookupTableProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    static createLookupTable(params) {\n        const [lookupTableAddress, bumpSeed] = PublicKey.findProgramAddressSync([\n            params.authority.toBuffer(),\n            (0,bigint_buffer__WEBPACK_IMPORTED_MODULE_5__.toBufferLE)(BigInt(params.recentSlot), 8)\n        ], this.programId);\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable;\n        const data = encodeData(type, {\n            recentSlot: BigInt(params.recentSlot),\n            bumpSeed: bumpSeed\n        });\n        const keys = [\n            {\n                pubkey: lookupTableAddress,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            },\n            {\n                pubkey: params.payer,\n                isSigner: true,\n                isWritable: true\n            },\n            {\n                pubkey: SystemProgram.programId,\n                isSigner: false,\n                isWritable: false\n            }\n        ];\n        return [\n            new TransactionInstruction({\n                programId: this.programId,\n                keys: keys,\n                data: data\n            }),\n            lookupTableAddress\n        ];\n    }\n    static freezeLookupTable(params) {\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable;\n        const data = encodeData(type);\n        const keys = [\n            {\n                pubkey: params.lookupTable,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys: keys,\n            data: data\n        });\n    }\n    static extendLookupTable(params) {\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable;\n        const data = encodeData(type, {\n            addresses: params.addresses.map((addr)=>addr.toBytes())\n        });\n        const keys = [\n            {\n                pubkey: params.lookupTable,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        if (params.payer) {\n            keys.push({\n                pubkey: params.payer,\n                isSigner: true,\n                isWritable: true\n            }, {\n                pubkey: SystemProgram.programId,\n                isSigner: false,\n                isWritable: false\n            });\n        }\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys: keys,\n            data: data\n        });\n    }\n    static deactivateLookupTable(params) {\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable;\n        const data = encodeData(type);\n        const keys = [\n            {\n                pubkey: params.lookupTable,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys: keys,\n            data: data\n        });\n    }\n    static closeLookupTable(params) {\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable;\n        const data = encodeData(type);\n        const keys = [\n            {\n                pubkey: params.lookupTable,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            },\n            {\n                pubkey: params.recipient,\n                isSigner: false,\n                isWritable: true\n            }\n        ];\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys: keys,\n            data: data\n        });\n    }\n}\nAddressLookupTableProgram.programId = new PublicKey(\"AddressLookupTab1e1111111111111111111111111\");\n/**\n * Compute Budget Instruction class\n */ class ComputeBudgetInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Decode a compute budget instruction and retrieve the instruction type.\n   */ static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\");\n        const typeIndex = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [ixType, layout] of Object.entries(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS)){\n            if (layout.index == typeIndex) {\n                type = ixType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Instruction type incorrect; not a ComputeBudgetInstruction\");\n        }\n        return type;\n    }\n    /**\n   * Decode request units compute budget instruction and retrieve the instruction params.\n   */ static decodeRequestUnits(instruction) {\n        this.checkProgramId(instruction.programId);\n        const { units, additionalFee } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits, instruction.data);\n        return {\n            units,\n            additionalFee\n        };\n    }\n    /**\n   * Decode request heap frame compute budget instruction and retrieve the instruction params.\n   */ static decodeRequestHeapFrame(instruction) {\n        this.checkProgramId(instruction.programId);\n        const { bytes } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame, instruction.data);\n        return {\n            bytes\n        };\n    }\n    /**\n   * Decode set compute unit limit compute budget instruction and retrieve the instruction params.\n   */ static decodeSetComputeUnitLimit(instruction) {\n        this.checkProgramId(instruction.programId);\n        const { units } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit, instruction.data);\n        return {\n            units\n        };\n    }\n    /**\n   * Decode set compute unit price compute budget instruction and retrieve the instruction params.\n   */ static decodeSetComputeUnitPrice(instruction) {\n        this.checkProgramId(instruction.programId);\n        const { microLamports } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice, instruction.data);\n        return {\n            microLamports\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(ComputeBudgetProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not ComputeBudgetProgram\");\n        }\n    }\n}\n/**\n * An enumeration of valid ComputeBudgetInstructionType's\n */ /**\n * Request units instruction params\n */ /**\n * Request heap frame instruction params\n */ /**\n * Set compute unit limit instruction params\n */ /**\n * Set compute unit price instruction params\n */ /**\n * An enumeration of valid ComputeBudget InstructionType's\n * @internal\n */ const COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({\n    RequestUnits: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"units\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"additionalFee\")\n        ])\n    },\n    RequestHeapFrame: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"bytes\")\n        ])\n    },\n    SetComputeUnitLimit: {\n        index: 2,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"units\")\n        ])\n    },\n    SetComputeUnitPrice: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\"),\n            u64(\"microLamports\")\n        ])\n    }\n});\n/**\n * Factory class for transaction instructions to interact with the Compute Budget program\n */ class ComputeBudgetProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the Compute Budget program\n   */ /**\n   * @deprecated Instead, call {@link setComputeUnitLimit} and/or {@link setComputeUnitPrice}\n   */ static requestUnits(params) {\n        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits;\n        const data = encodeData(type, params);\n        return new TransactionInstruction({\n            keys: [],\n            programId: this.programId,\n            data\n        });\n    }\n    static requestHeapFrame(params) {\n        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame;\n        const data = encodeData(type, params);\n        return new TransactionInstruction({\n            keys: [],\n            programId: this.programId,\n            data\n        });\n    }\n    static setComputeUnitLimit(params) {\n        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit;\n        const data = encodeData(type, params);\n        return new TransactionInstruction({\n            keys: [],\n            programId: this.programId,\n            data\n        });\n    }\n    static setComputeUnitPrice(params) {\n        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice;\n        const data = encodeData(type, {\n            microLamports: BigInt(params.microLamports)\n        });\n        return new TransactionInstruction({\n            keys: [],\n            programId: this.programId,\n            data\n        });\n    }\n}\nComputeBudgetProgram.programId = new PublicKey(\"ComputeBudget111111111111111111111111111111\");\nconst PRIVATE_KEY_BYTES$1 = 64;\nconst PUBLIC_KEY_BYTES$1 = 32;\nconst SIGNATURE_BYTES = 64;\n/**\n * Params for creating an ed25519 instruction using a public key\n */ /**\n * Params for creating an ed25519 instruction using a private key\n */ const ED25519_INSTRUCTION_LAYOUT = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numSignatures\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"padding\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"signatureOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"signatureInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"publicKeyOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"publicKeyInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageDataOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageDataSize\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageInstructionIndex\")\n]);\nclass Ed25519Program {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the ed25519 program\n   */ /**\n   * Create an ed25519 instruction with a public key and signature. The\n   * public key must be a buffer that is 32 bytes long, and the signature\n   * must be a buffer of 64 bytes.\n   */ static createInstructionWithPublicKey(params) {\n        const { publicKey, message, signature, instructionIndex } = params;\n        assert(publicKey.length === PUBLIC_KEY_BYTES$1, `Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${publicKey.length} bytes`);\n        assert(signature.length === SIGNATURE_BYTES, `Signature must be ${SIGNATURE_BYTES} bytes but received ${signature.length} bytes`);\n        const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;\n        const signatureOffset = publicKeyOffset + publicKey.length;\n        const messageDataOffset = signatureOffset + signature.length;\n        const numSignatures = 1;\n        const instructionData = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(messageDataOffset + message.length);\n        const index = instructionIndex == null ? 0xffff // An index of `u16::MAX` makes it default to the current instruction.\n         : instructionIndex;\n        ED25519_INSTRUCTION_LAYOUT.encode({\n            numSignatures,\n            padding: 0,\n            signatureOffset,\n            signatureInstructionIndex: index,\n            publicKeyOffset,\n            publicKeyInstructionIndex: index,\n            messageDataOffset,\n            messageDataSize: message.length,\n            messageInstructionIndex: index\n        }, instructionData);\n        instructionData.fill(publicKey, publicKeyOffset);\n        instructionData.fill(signature, signatureOffset);\n        instructionData.fill(message, messageDataOffset);\n        return new TransactionInstruction({\n            keys: [],\n            programId: Ed25519Program.programId,\n            data: instructionData\n        });\n    }\n    /**\n   * Create an ed25519 instruction with a private key. The private key\n   * must be a buffer that is 64 bytes long.\n   */ static createInstructionWithPrivateKey(params) {\n        const { privateKey, message, instructionIndex } = params;\n        assert(privateKey.length === PRIVATE_KEY_BYTES$1, `Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${privateKey.length} bytes`);\n        try {\n            const keypair = Keypair.fromSecretKey(privateKey);\n            const publicKey = keypair.publicKey.toBytes();\n            const signature = sign(message, keypair.secretKey);\n            return this.createInstructionWithPublicKey({\n                publicKey,\n                message,\n                signature,\n                instructionIndex\n            });\n        } catch (error) {\n            throw new Error(`Error creating instruction; ${error}`);\n        }\n    }\n}\nEd25519Program.programId = new PublicKey(\"Ed25519SigVerify111111111111111111111111111\");\nconst ecdsaSign = (msgHash, privKey)=>{\n    const signature = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_15__.secp256k1.sign(msgHash, privKey);\n    return [\n        signature.toCompactRawBytes(),\n        signature.recovery\n    ];\n};\n_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_15__.secp256k1.utils.isValidPrivateKey;\nconst publicKeyCreate = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_15__.secp256k1.getPublicKey;\nconst PRIVATE_KEY_BYTES = 32;\nconst ETHEREUM_ADDRESS_BYTES = 20;\nconst PUBLIC_KEY_BYTES = 64;\nconst SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;\n/**\n * Params for creating an secp256k1 instruction using a public key\n */ /**\n * Params for creating an secp256k1 instruction using an Ethereum address\n */ /**\n * Params for creating an secp256k1 instruction using a private key\n */ const SECP256K1_INSTRUCTION_LAYOUT = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numSignatures\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"signatureOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"signatureInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"ethAddressOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"ethAddressInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageDataOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageDataSize\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"messageInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(20, \"ethAddress\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(64, \"signature\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"recoveryId\")\n]);\nclass Secp256k1Program {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the secp256k1 program\n   */ /**\n   * Construct an Ethereum address from a secp256k1 public key buffer.\n   * @param {Buffer} publicKey a 64 byte secp256k1 public key buffer\n   */ static publicKeyToEthAddress(publicKey) {\n        assert(publicKey.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${publicKey.length} bytes`);\n        try {\n            return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_16__.keccak_256)(toBuffer(publicKey))).slice(-ETHEREUM_ADDRESS_BYTES);\n        } catch (error) {\n            throw new Error(`Error constructing Ethereum address: ${error}`);\n        }\n    }\n    /**\n   * Create an secp256k1 instruction with a public key. The public key\n   * must be a buffer that is 64 bytes long.\n   */ static createInstructionWithPublicKey(params) {\n        const { publicKey, message, signature, recoveryId, instructionIndex } = params;\n        return Secp256k1Program.createInstructionWithEthAddress({\n            ethAddress: Secp256k1Program.publicKeyToEthAddress(publicKey),\n            message,\n            signature,\n            recoveryId,\n            instructionIndex\n        });\n    }\n    /**\n   * Create an secp256k1 instruction with an Ethereum address. The address\n   * must be a hex string or a buffer that is 20 bytes long.\n   */ static createInstructionWithEthAddress(params) {\n        const { ethAddress: rawAddress, message, signature, recoveryId, instructionIndex = 0 } = params;\n        let ethAddress;\n        if (typeof rawAddress === \"string\") {\n            if (rawAddress.startsWith(\"0x\")) {\n                ethAddress = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(rawAddress.substr(2), \"hex\");\n            } else {\n                ethAddress = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(rawAddress, \"hex\");\n            }\n        } else {\n            ethAddress = rawAddress;\n        }\n        assert(ethAddress.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ethAddress.length} bytes`);\n        const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;\n        const ethAddressOffset = dataStart;\n        const signatureOffset = dataStart + ethAddress.length;\n        const messageDataOffset = signatureOffset + signature.length + 1;\n        const numSignatures = 1;\n        const instructionData = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);\n        SECP256K1_INSTRUCTION_LAYOUT.encode({\n            numSignatures,\n            signatureOffset,\n            signatureInstructionIndex: instructionIndex,\n            ethAddressOffset,\n            ethAddressInstructionIndex: instructionIndex,\n            messageDataOffset,\n            messageDataSize: message.length,\n            messageInstructionIndex: instructionIndex,\n            signature: toBuffer(signature),\n            ethAddress: toBuffer(ethAddress),\n            recoveryId\n        }, instructionData);\n        instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);\n        return new TransactionInstruction({\n            keys: [],\n            programId: Secp256k1Program.programId,\n            data: instructionData\n        });\n    }\n    /**\n   * Create an secp256k1 instruction with a private key. The private key\n   * must be a buffer that is 32 bytes long.\n   */ static createInstructionWithPrivateKey(params) {\n        const { privateKey: pkey, message, instructionIndex } = params;\n        assert(pkey.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${pkey.length} bytes`);\n        try {\n            const privateKey = toBuffer(pkey);\n            const publicKey = publicKeyCreate(privateKey, false).slice(1); // throw away leading byte\n            const messageHash = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_16__.keccak_256)(toBuffer(message)));\n            const [signature, recoveryId] = ecdsaSign(messageHash, privateKey);\n            return this.createInstructionWithPublicKey({\n                publicKey,\n                message,\n                signature,\n                recoveryId,\n                instructionIndex\n            });\n        } catch (error) {\n            throw new Error(`Error creating instruction; ${error}`);\n        }\n    }\n}\nSecp256k1Program.programId = new PublicKey(\"KeccakSecp256k11111111111111111111111111111\");\nvar _Lockup;\n/**\n * Address of the stake config account which configures the rate\n * of stake warmup and cooldown as well as the slashing penalty.\n */ const STAKE_CONFIG_ID = new PublicKey(\"StakeConfig11111111111111111111111111111111\");\n/**\n * Stake account authority info\n */ class Authorized {\n    /**\n   * Create a new Authorized object\n   * @param staker the stake authority\n   * @param withdrawer the withdraw authority\n   */ constructor(staker, withdrawer){\n        /** stake authority */ this.staker = void 0;\n        /** withdraw authority */ this.withdrawer = void 0;\n        this.staker = staker;\n        this.withdrawer = withdrawer;\n    }\n}\n/**\n * Stake account lockup info\n */ class Lockup {\n    /**\n   * Create a new Lockup object\n   */ constructor(unixTimestamp, epoch, custodian){\n        /** Unix timestamp of lockup expiration */ this.unixTimestamp = void 0;\n        /** Epoch of lockup expiration */ this.epoch = void 0;\n        /** Lockup custodian authority */ this.custodian = void 0;\n        this.unixTimestamp = unixTimestamp;\n        this.epoch = epoch;\n        this.custodian = custodian;\n    }\n}\n_Lockup = Lockup;\nLockup.default = new _Lockup(0, 0, PublicKey.default);\n/**\n * Create stake account transaction params\n */ /**\n * Create stake account with seed transaction params\n */ /**\n * Initialize stake instruction params\n */ /**\n * Delegate stake instruction params\n */ /**\n * Authorize stake instruction params\n */ /**\n * Authorize stake instruction params using a derived key\n */ /**\n * Split stake instruction params\n */ /**\n * Split with seed transaction params\n */ /**\n * Withdraw stake instruction params\n */ /**\n * Deactivate stake instruction params\n */ /**\n * Merge stake instruction params\n */ /**\n * Stake Instruction class\n */ class StakeInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Decode a stake instruction and retrieve the instruction type.\n   */ static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\");\n        const typeIndex = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [ixType, layout] of Object.entries(STAKE_INSTRUCTION_LAYOUTS)){\n            if (layout.index == typeIndex) {\n                type = ixType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Instruction type incorrect; not a StakeInstruction\");\n        }\n        return type;\n    }\n    /**\n   * Decode a initialize stake instruction and retrieve the instruction params.\n   */ static decodeInitialize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { authorized, lockup } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Initialize, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            authorized: new Authorized(new PublicKey(authorized.staker), new PublicKey(authorized.withdrawer)),\n            lockup: new Lockup(lockup.unixTimestamp, lockup.epoch, new PublicKey(lockup.custodian))\n        };\n    }\n    /**\n   * Decode a delegate stake instruction and retrieve the instruction params.\n   */ static decodeDelegate(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 6);\n        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Delegate, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            votePubkey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[5].pubkey\n        };\n    }\n    /**\n   * Decode an authorize stake instruction and retrieve the instruction params.\n   */ static decodeAuthorize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { newAuthorized, stakeAuthorizationType } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);\n        const o = {\n            stakePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey,\n            newAuthorizedPubkey: new PublicKey(newAuthorized),\n            stakeAuthorizationType: {\n                index: stakeAuthorizationType\n            }\n        };\n        if (instruction.keys.length > 3) {\n            o.custodianPubkey = instruction.keys[3].pubkey;\n        }\n        return o;\n    }\n    /**\n   * Decode an authorize-with-seed stake instruction and retrieve the instruction params.\n   */ static decodeAuthorizeWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { newAuthorized, stakeAuthorizationType, authoritySeed, authorityOwner } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);\n        const o = {\n            stakePubkey: instruction.keys[0].pubkey,\n            authorityBase: instruction.keys[1].pubkey,\n            authoritySeed: authoritySeed,\n            authorityOwner: new PublicKey(authorityOwner),\n            newAuthorizedPubkey: new PublicKey(newAuthorized),\n            stakeAuthorizationType: {\n                index: stakeAuthorizationType\n            }\n        };\n        if (instruction.keys.length > 3) {\n            o.custodianPubkey = instruction.keys[3].pubkey;\n        }\n        return o;\n    }\n    /**\n   * Decode a split stake instruction and retrieve the instruction params.\n   */ static decodeSplit(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { lamports } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Split, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            splitStakePubkey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey,\n            lamports\n        };\n    }\n    /**\n   * Decode a merge stake instruction and retrieve the instruction params.\n   */ static decodeMerge(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Merge, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            sourceStakePubKey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[4].pubkey\n        };\n    }\n    /**\n   * Decode a withdraw stake instruction and retrieve the instruction params.\n   */ static decodeWithdraw(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 5);\n        const { lamports } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);\n        const o = {\n            stakePubkey: instruction.keys[0].pubkey,\n            toPubkey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[4].pubkey,\n            lamports\n        };\n        if (instruction.keys.length > 5) {\n            o.custodianPubkey = instruction.keys[5].pubkey;\n        }\n        return o;\n    }\n    /**\n   * Decode a deactivate stake instruction and retrieve the instruction params.\n   */ static decodeDeactivate(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Deactivate, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(StakeProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not StakeProgram\");\n        }\n    }\n    /**\n   * @internal\n   */ static checkKeyLength(keys, expectedLength) {\n        if (keys.length < expectedLength) {\n            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n        }\n    }\n}\n/**\n * An enumeration of valid StakeInstructionType's\n */ /**\n * An enumeration of valid stake InstructionType's\n * @internal\n */ const STAKE_INSTRUCTION_LAYOUTS = Object.freeze({\n    Initialize: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            authorized(),\n            lockup()\n        ])\n    },\n    Authorize: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"newAuthorized\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"stakeAuthorizationType\")\n        ])\n    },\n    Delegate: {\n        index: 2,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    Split: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\")\n        ])\n    },\n    Withdraw: {\n        index: 4,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\")\n        ])\n    },\n    Deactivate: {\n        index: 5,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    Merge: {\n        index: 7,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    AuthorizeWithSeed: {\n        index: 8,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"newAuthorized\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"stakeAuthorizationType\"),\n            rustString(\"authoritySeed\"),\n            publicKey(\"authorityOwner\")\n        ])\n    }\n});\n/**\n * Stake authorization type\n */ /**\n * An enumeration of valid StakeAuthorizationLayout's\n */ const StakeAuthorizationLayout = Object.freeze({\n    Staker: {\n        index: 0\n    },\n    Withdrawer: {\n        index: 1\n    }\n});\n/**\n * Factory class for transactions to interact with the Stake program\n */ class StakeProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the Stake program\n   */ /**\n   * Generate an Initialize instruction to add to a Stake Create transaction\n   */ static initialize(params) {\n        const { stakePubkey, authorized, lockup: maybeLockup } = params;\n        const lockup = maybeLockup || Lockup.default;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Initialize;\n        const data = encodeData(type, {\n            authorized: {\n                staker: toBuffer(authorized.staker.toBuffer()),\n                withdrawer: toBuffer(authorized.withdrawer.toBuffer())\n            },\n            lockup: {\n                unixTimestamp: lockup.unixTimestamp,\n                epoch: lockup.epoch,\n                custodian: toBuffer(lockup.custodian.toBuffer())\n            }\n        });\n        const instructionData = {\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        };\n        return new TransactionInstruction(instructionData);\n    }\n    /**\n   * Generate a Transaction that creates a new Stake account at\n   *   an address generated with `from`, a seed, and the Stake programId\n   */ static createAccountWithSeed(params) {\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.createAccountWithSeed({\n            fromPubkey: params.fromPubkey,\n            newAccountPubkey: params.stakePubkey,\n            basePubkey: params.basePubkey,\n            seed: params.seed,\n            lamports: params.lamports,\n            space: this.space,\n            programId: this.programId\n        }));\n        const { stakePubkey, authorized, lockup } = params;\n        return transaction.add(this.initialize({\n            stakePubkey,\n            authorized,\n            lockup\n        }));\n    }\n    /**\n   * Generate a Transaction that creates a new Stake account\n   */ static createAccount(params) {\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.createAccount({\n            fromPubkey: params.fromPubkey,\n            newAccountPubkey: params.stakePubkey,\n            lamports: params.lamports,\n            space: this.space,\n            programId: this.programId\n        }));\n        const { stakePubkey, authorized, lockup } = params;\n        return transaction.add(this.initialize({\n            stakePubkey,\n            authorized,\n            lockup\n        }));\n    }\n    /**\n   * Generate a Transaction that delegates Stake tokens to a validator\n   * Vote PublicKey. This transaction can also be used to redelegate Stake\n   * to a new validator Vote PublicKey.\n   */ static delegate(params) {\n        const { stakePubkey, authorizedPubkey, votePubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Delegate;\n        const data = encodeData(type);\n        return new Transaction().add({\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: votePubkey,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_CLOCK_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: STAKE_CONFIG_ID,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that authorizes a new PublicKey as Staker\n   * or Withdrawer on the Stake account.\n   */ static authorize(params) {\n        const { stakePubkey, authorizedPubkey, newAuthorizedPubkey, stakeAuthorizationType, custodianPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Authorize;\n        const data = encodeData(type, {\n            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n            stakeAuthorizationType: stakeAuthorizationType.index\n        });\n        const keys = [\n            {\n                pubkey: stakePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: authorizedPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        if (custodianPubkey) {\n            keys.push({\n                pubkey: custodianPubkey,\n                isSigner: true,\n                isWritable: false\n            });\n        }\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that authorizes a new PublicKey as Staker\n   * or Withdrawer on the Stake account.\n   */ static authorizeWithSeed(params) {\n        const { stakePubkey, authorityBase, authoritySeed, authorityOwner, newAuthorizedPubkey, stakeAuthorizationType, custodianPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;\n        const data = encodeData(type, {\n            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n            stakeAuthorizationType: stakeAuthorizationType.index,\n            authoritySeed: authoritySeed,\n            authorityOwner: toBuffer(authorityOwner.toBuffer())\n        });\n        const keys = [\n            {\n                pubkey: stakePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: authorityBase,\n                isSigner: true,\n                isWritable: false\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            }\n        ];\n        if (custodianPubkey) {\n            keys.push({\n                pubkey: custodianPubkey,\n                isSigner: true,\n                isWritable: false\n            });\n        }\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * @internal\n   */ static splitInstruction(params) {\n        const { stakePubkey, authorizedPubkey, splitStakePubkey, lamports } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Split;\n        const data = encodeData(type, {\n            lamports\n        });\n        return new TransactionInstruction({\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: splitStakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that splits Stake tokens into another stake account\n   */ static split(params, // Compute the cost of allocating the new stake account in lamports\n    rentExemptReserve) {\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.createAccount({\n            fromPubkey: params.authorizedPubkey,\n            newAccountPubkey: params.splitStakePubkey,\n            lamports: rentExemptReserve,\n            space: this.space,\n            programId: this.programId\n        }));\n        return transaction.add(this.splitInstruction(params));\n    }\n    /**\n   * Generate a Transaction that splits Stake tokens into another account\n   * derived from a base public key and seed\n   */ static splitWithSeed(params, // If this stake account is new, compute the cost of allocating it in lamports\n    rentExemptReserve) {\n        const { stakePubkey, authorizedPubkey, splitStakePubkey, basePubkey, seed, lamports } = params;\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.allocate({\n            accountPubkey: splitStakePubkey,\n            basePubkey,\n            seed,\n            space: this.space,\n            programId: this.programId\n        }));\n        if (rentExemptReserve && rentExemptReserve > 0) {\n            transaction.add(SystemProgram.transfer({\n                fromPubkey: params.authorizedPubkey,\n                toPubkey: splitStakePubkey,\n                lamports: rentExemptReserve\n            }));\n        }\n        return transaction.add(this.splitInstruction({\n            stakePubkey,\n            authorizedPubkey,\n            splitStakePubkey,\n            lamports\n        }));\n    }\n    /**\n   * Generate a Transaction that merges Stake accounts.\n   */ static merge(params) {\n        const { stakePubkey, sourceStakePubKey, authorizedPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Merge;\n        const data = encodeData(type);\n        return new Transaction().add({\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: sourceStakePubKey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_CLOCK_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that withdraws deactivated Stake tokens.\n   */ static withdraw(params) {\n        const { stakePubkey, authorizedPubkey, toPubkey, lamports, custodianPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Withdraw;\n        const data = encodeData(type, {\n            lamports\n        });\n        const keys = [\n            {\n                pubkey: stakePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: toPubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            },\n            {\n                pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            },\n            {\n                pubkey: authorizedPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        if (custodianPubkey) {\n            keys.push({\n                pubkey: custodianPubkey,\n                isSigner: true,\n                isWritable: false\n            });\n        }\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that deactivates Stake tokens.\n   */ static deactivate(params) {\n        const { stakePubkey, authorizedPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Deactivate;\n        const data = encodeData(type);\n        return new Transaction().add({\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_CLOCK_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n}\nStakeProgram.programId = new PublicKey(\"Stake11111111111111111111111111111111111111\");\n/**\n * Max space of a Stake account\n *\n * This is generated from the solana-stake-program StakeState struct as\n * `StakeStateV2::size_of()`:\n * https://docs.rs/solana-stake-program/latest/solana_stake_program/stake_state/enum.StakeStateV2.html\n */ StakeProgram.space = 200;\n/**\n * Vote account info\n */ class VoteInit {\n    /** [0, 100] */ constructor(nodePubkey, authorizedVoter, authorizedWithdrawer, commission){\n        this.nodePubkey = void 0;\n        this.authorizedVoter = void 0;\n        this.authorizedWithdrawer = void 0;\n        this.commission = void 0;\n        this.nodePubkey = nodePubkey;\n        this.authorizedVoter = authorizedVoter;\n        this.authorizedWithdrawer = authorizedWithdrawer;\n        this.commission = commission;\n    }\n}\n/**\n * Create vote account transaction params\n */ /**\n * InitializeAccount instruction params\n */ /**\n * Authorize instruction params\n */ /**\n * AuthorizeWithSeed instruction params\n */ /**\n * Withdraw from vote account transaction params\n */ /**\n * Update validator identity (node pubkey) vote account instruction params.\n */ /**\n * Vote Instruction class\n */ class VoteInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Decode a vote instruction and retrieve the instruction type.\n   */ static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\");\n        const typeIndex = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [ixType, layout] of Object.entries(VOTE_INSTRUCTION_LAYOUTS)){\n            if (layout.index == typeIndex) {\n                type = ixType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Instruction type incorrect; not a VoteInstruction\");\n        }\n        return type;\n    }\n    /**\n   * Decode an initialize vote instruction and retrieve the instruction params.\n   */ static decodeInitializeAccount(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 4);\n        const { voteInit } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, instruction.data);\n        return {\n            votePubkey: instruction.keys[0].pubkey,\n            nodePubkey: instruction.keys[3].pubkey,\n            voteInit: new VoteInit(new PublicKey(voteInit.nodePubkey), new PublicKey(voteInit.authorizedVoter), new PublicKey(voteInit.authorizedWithdrawer), voteInit.commission)\n        };\n    }\n    /**\n   * Decode an authorize instruction and retrieve the instruction params.\n   */ static decodeAuthorize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { newAuthorized, voteAuthorizationType } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);\n        return {\n            votePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey,\n            newAuthorizedPubkey: new PublicKey(newAuthorized),\n            voteAuthorizationType: {\n                index: voteAuthorizationType\n            }\n        };\n    }\n    /**\n   * Decode an authorize instruction and retrieve the instruction params.\n   */ static decodeAuthorizeWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { voteAuthorizeWithSeedArgs: { currentAuthorityDerivedKeyOwnerPubkey, currentAuthorityDerivedKeySeed, newAuthorized, voteAuthorizationType } } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);\n        return {\n            currentAuthorityDerivedKeyBasePubkey: instruction.keys[2].pubkey,\n            currentAuthorityDerivedKeyOwnerPubkey: new PublicKey(currentAuthorityDerivedKeyOwnerPubkey),\n            currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,\n            newAuthorizedPubkey: new PublicKey(newAuthorized),\n            voteAuthorizationType: {\n                index: voteAuthorizationType\n            },\n            votePubkey: instruction.keys[0].pubkey\n        };\n    }\n    /**\n   * Decode a withdraw instruction and retrieve the instruction params.\n   */ static decodeWithdraw(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { lamports } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);\n        return {\n            votePubkey: instruction.keys[0].pubkey,\n            authorizedWithdrawerPubkey: instruction.keys[2].pubkey,\n            lamports,\n            toPubkey: instruction.keys[1].pubkey\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(VoteProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not VoteProgram\");\n        }\n    }\n    /**\n   * @internal\n   */ static checkKeyLength(keys, expectedLength) {\n        if (keys.length < expectedLength) {\n            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n        }\n    }\n}\n/**\n * An enumeration of valid VoteInstructionType's\n */ /** @internal */ const VOTE_INSTRUCTION_LAYOUTS = Object.freeze({\n    InitializeAccount: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            voteInit()\n        ])\n    },\n    Authorize: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"newAuthorized\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"voteAuthorizationType\")\n        ])\n    },\n    Withdraw: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\")\n        ])\n    },\n    UpdateValidatorIdentity: {\n        index: 4,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    AuthorizeWithSeed: {\n        index: 10,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            voteAuthorizeWithSeedArgs()\n        ])\n    }\n});\n/**\n * VoteAuthorize type\n */ /**\n * An enumeration of valid VoteAuthorization layouts.\n */ const VoteAuthorizationLayout = Object.freeze({\n    Voter: {\n        index: 0\n    },\n    Withdrawer: {\n        index: 1\n    }\n});\n/**\n * Factory class for transactions to interact with the Vote program\n */ class VoteProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the Vote program\n   */ /**\n   * Generate an Initialize instruction.\n   */ static initializeAccount(params) {\n        const { votePubkey, nodePubkey, voteInit } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;\n        const data = encodeData(type, {\n            voteInit: {\n                nodePubkey: toBuffer(voteInit.nodePubkey.toBuffer()),\n                authorizedVoter: toBuffer(voteInit.authorizedVoter.toBuffer()),\n                authorizedWithdrawer: toBuffer(voteInit.authorizedWithdrawer.toBuffer()),\n                commission: voteInit.commission\n            }\n        });\n        const instructionData = {\n            keys: [\n                {\n                    pubkey: votePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_CLOCK_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: nodePubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        };\n        return new TransactionInstruction(instructionData);\n    }\n    /**\n   * Generate a transaction that creates a new Vote account.\n   */ static createAccount(params) {\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.createAccount({\n            fromPubkey: params.fromPubkey,\n            newAccountPubkey: params.votePubkey,\n            lamports: params.lamports,\n            space: this.space,\n            programId: this.programId\n        }));\n        return transaction.add(this.initializeAccount({\n            votePubkey: params.votePubkey,\n            nodePubkey: params.voteInit.nodePubkey,\n            voteInit: params.voteInit\n        }));\n    }\n    /**\n   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account.\n   */ static authorize(params) {\n        const { votePubkey, authorizedPubkey, newAuthorizedPubkey, voteAuthorizationType } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.Authorize;\n        const data = encodeData(type, {\n            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n            voteAuthorizationType: voteAuthorizationType.index\n        });\n        const keys = [\n            {\n                pubkey: votePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            },\n            {\n                pubkey: authorizedPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account\n   * where the current Voter or Withdrawer authority is a derived key.\n   */ static authorizeWithSeed(params) {\n        const { currentAuthorityDerivedKeyBasePubkey, currentAuthorityDerivedKeyOwnerPubkey, currentAuthorityDerivedKeySeed, newAuthorizedPubkey, voteAuthorizationType, votePubkey } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;\n        const data = encodeData(type, {\n            voteAuthorizeWithSeedArgs: {\n                currentAuthorityDerivedKeyOwnerPubkey: toBuffer(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),\n                currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,\n                newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n                voteAuthorizationType: voteAuthorizationType.index\n            }\n        });\n        const keys = [\n            {\n                pubkey: votePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            },\n            {\n                pubkey: currentAuthorityDerivedKeyBasePubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction to withdraw from a Vote account.\n   */ static withdraw(params) {\n        const { votePubkey, authorizedWithdrawerPubkey, lamports, toPubkey } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.Withdraw;\n        const data = encodeData(type, {\n            lamports\n        });\n        const keys = [\n            {\n                pubkey: votePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: toPubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: authorizedWithdrawerPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction to withdraw safely from a Vote account.\n   *\n   * This function was created as a safeguard for vote accounts running validators, `safeWithdraw`\n   * checks that the withdraw amount will not exceed the specified balance while leaving enough left\n   * to cover rent. If you wish to close the vote account by withdrawing the full amount, call the\n   * `withdraw` method directly.\n   */ static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {\n        if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {\n            throw new Error(\"Withdraw will leave vote account with insufficient funds.\");\n        }\n        return VoteProgram.withdraw(params);\n    }\n    /**\n   * Generate a transaction to update the validator identity (node pubkey) of a Vote account.\n   */ static updateValidatorIdentity(params) {\n        const { votePubkey, authorizedWithdrawerPubkey, nodePubkey } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.UpdateValidatorIdentity;\n        const data = encodeData(type);\n        const keys = [\n            {\n                pubkey: votePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: nodePubkey,\n                isSigner: true,\n                isWritable: false\n            },\n            {\n                pubkey: authorizedWithdrawerPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n}\nVoteProgram.programId = new PublicKey(\"Vote111111111111111111111111111111111111111\");\n/**\n * Max space of a Vote account\n *\n * This is generated from the solana-vote-program VoteState struct as\n * `VoteState::size_of()`:\n * https://docs.rs/solana-vote-program/1.9.5/solana_vote_program/vote_state/struct.VoteState.html#method.size_of\n *\n * KEEP IN SYNC WITH `VoteState::size_of()` in https://github.com/solana-labs/solana/blob/a474cb24b9238f5edcc982f65c0b37d4a1046f7e/sdk/program/src/vote/state/mod.rs#L340-L342\n */ VoteProgram.space = 3762;\nconst VALIDATOR_INFO_KEY = new PublicKey(\"Va1idator1nfo111111111111111111111111111111\");\n/**\n * @internal\n */ /**\n * Info used to identity validators.\n */ const InfoString = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    name: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    website: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    details: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    iconUrl: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    keybaseUsername: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)())\n});\n/**\n * ValidatorInfo class\n */ class ValidatorInfo {\n    /**\n   * Construct a valid ValidatorInfo\n   *\n   * @param key validator public key\n   * @param info validator information\n   */ constructor(key, info){\n        /**\n     * validator public key\n     */ this.key = void 0;\n        /**\n     * validator information\n     */ this.info = void 0;\n        this.key = key;\n        this.info = info;\n    }\n    /**\n   * Deserialize ValidatorInfo from the config account data. Exactly two config\n   * keys are required in the data.\n   *\n   * @param buffer config account data\n   * @return null if info was not found\n   */ static fromConfigData(buffer) {\n        let byteArray = [\n            ...buffer\n        ];\n        const configKeyCount = decodeLength(byteArray);\n        if (configKeyCount !== 2) return null;\n        const configKeys = [];\n        for(let i = 0; i < 2; i++){\n            const publicKey = new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));\n            const isSigner = guardedShift(byteArray) === 1;\n            configKeys.push({\n                publicKey,\n                isSigner\n            });\n        }\n        if (configKeys[0].publicKey.equals(VALIDATOR_INFO_KEY)) {\n            if (configKeys[1].isSigner) {\n                const rawInfo = rustString().decode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(byteArray));\n                const info = JSON.parse(rawInfo);\n                (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.assert)(info, InfoString);\n                return new ValidatorInfo(configKeys[1].publicKey, info);\n            }\n        }\n        return null;\n    }\n}\nconst VOTE_PROGRAM_ID = new PublicKey(\"Vote111111111111111111111111111111111111111\");\n/**\n * History of how many credits earned by the end of each epoch\n */ /**\n * See https://github.com/solana-labs/solana/blob/8a12ed029cfa38d4a45400916c2463fb82bbec8c/programs/vote_api/src/vote_state.rs#L68-L88\n *\n * @internal\n */ const VoteAccountLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n    publicKey(\"nodePubkey\"),\n    publicKey(\"authorizedWithdrawer\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"commission\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(),\n    // votes.length\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"slot\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"confirmationCount\")\n    ]), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"votes\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"rootSlotValid\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"rootSlot\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(),\n    // authorizedVoters.length\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"epoch\"),\n        publicKey(\"authorizedVoter\")\n    ]), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"authorizedVoters\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            publicKey(\"authorizedPubkey\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"epochOfLastAuthorizedSwitch\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"targetEpoch\")\n        ]), 32, \"buf\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"idx\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"isEmpty\")\n    ], \"priorVoters\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(),\n    // epochCredits.length\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"epoch\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"credits\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"prevCredits\")\n    ]), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"epochCredits\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"slot\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"timestamp\")\n    ], \"lastTimestamp\")\n]);\n/**\n * VoteAccount class\n */ class VoteAccount {\n    /**\n   * @internal\n   */ constructor(args){\n        this.nodePubkey = void 0;\n        this.authorizedWithdrawer = void 0;\n        this.commission = void 0;\n        this.rootSlot = void 0;\n        this.votes = void 0;\n        this.authorizedVoters = void 0;\n        this.priorVoters = void 0;\n        this.epochCredits = void 0;\n        this.lastTimestamp = void 0;\n        this.nodePubkey = args.nodePubkey;\n        this.authorizedWithdrawer = args.authorizedWithdrawer;\n        this.commission = args.commission;\n        this.rootSlot = args.rootSlot;\n        this.votes = args.votes;\n        this.authorizedVoters = args.authorizedVoters;\n        this.priorVoters = args.priorVoters;\n        this.epochCredits = args.epochCredits;\n        this.lastTimestamp = args.lastTimestamp;\n    }\n    /**\n   * Deserialize VoteAccount from the account data.\n   *\n   * @param buffer account data\n   * @return VoteAccount\n   */ static fromAccountData(buffer) {\n        const versionOffset = 4;\n        const va = VoteAccountLayout.decode(toBuffer(buffer), versionOffset);\n        let rootSlot = va.rootSlot;\n        if (!va.rootSlotValid) {\n            rootSlot = null;\n        }\n        return new VoteAccount({\n            nodePubkey: new PublicKey(va.nodePubkey),\n            authorizedWithdrawer: new PublicKey(va.authorizedWithdrawer),\n            commission: va.commission,\n            votes: va.votes,\n            rootSlot,\n            authorizedVoters: va.authorizedVoters.map(parseAuthorizedVoter),\n            priorVoters: getPriorVoters(va.priorVoters),\n            epochCredits: va.epochCredits,\n            lastTimestamp: va.lastTimestamp\n        });\n    }\n}\nfunction parseAuthorizedVoter({ authorizedVoter, epoch }) {\n    return {\n        epoch,\n        authorizedVoter: new PublicKey(authorizedVoter)\n    };\n}\nfunction parsePriorVoters({ authorizedPubkey, epochOfLastAuthorizedSwitch, targetEpoch }) {\n    return {\n        authorizedPubkey: new PublicKey(authorizedPubkey),\n        epochOfLastAuthorizedSwitch,\n        targetEpoch\n    };\n}\nfunction getPriorVoters({ buf, idx, isEmpty }) {\n    if (isEmpty) {\n        return [];\n    }\n    return [\n        ...buf.slice(idx + 1).map(parsePriorVoters),\n        ...buf.slice(0, idx).map(parsePriorVoters)\n    ];\n}\nconst endpoint = {\n    http: {\n        devnet: \"http://api.devnet.solana.com\",\n        testnet: \"http://api.testnet.solana.com\",\n        \"mainnet-beta\": \"http://api.mainnet-beta.solana.com/\"\n    },\n    https: {\n        devnet: \"https://api.devnet.solana.com\",\n        testnet: \"https://api.testnet.solana.com\",\n        \"mainnet-beta\": \"https://api.mainnet-beta.solana.com/\"\n    }\n};\n/**\n * Retrieves the RPC API URL for the specified cluster\n * @param {Cluster} [cluster=\"devnet\"] - The cluster name of the RPC API URL to use. Possible options: 'devnet' | 'testnet' | 'mainnet-beta'\n * @param {boolean} [tls=\"http\"] - Use TLS when connecting to cluster.\n *\n * @returns {string} URL string of the RPC endpoint\n */ function clusterApiUrl(cluster, tls) {\n    const key = tls === false ? \"http\" : \"https\";\n    if (!cluster) {\n        return endpoint[key][\"devnet\"];\n    }\n    const url = endpoint[key][cluster];\n    if (!url) {\n        throw new Error(`Unknown ${key} cluster: ${cluster}`);\n    }\n    return url;\n}\n/**\n * Send and confirm a raw transaction\n *\n * If `commitment` option is not specified, defaults to 'max' commitment.\n *\n * @param {Connection} connection\n * @param {Buffer} rawTransaction\n * @param {TransactionConfirmationStrategy} confirmationStrategy\n * @param {ConfirmOptions} [options]\n * @returns {Promise<TransactionSignature>}\n */ /**\n * @deprecated Calling `sendAndConfirmRawTransaction()` without a `confirmationStrategy`\n * is no longer supported and will be removed in a future version.\n */ // eslint-disable-next-line no-redeclare\n// eslint-disable-next-line no-redeclare\nasync function sendAndConfirmRawTransaction(connection, rawTransaction, confirmationStrategyOrConfirmOptions, maybeConfirmOptions) {\n    let confirmationStrategy;\n    let options;\n    if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, \"lastValidBlockHeight\")) {\n        confirmationStrategy = confirmationStrategyOrConfirmOptions;\n        options = maybeConfirmOptions;\n    } else if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, \"nonceValue\")) {\n        confirmationStrategy = confirmationStrategyOrConfirmOptions;\n        options = maybeConfirmOptions;\n    } else {\n        options = confirmationStrategyOrConfirmOptions;\n    }\n    const sendOptions = options && {\n        skipPreflight: options.skipPreflight,\n        preflightCommitment: options.preflightCommitment || options.commitment,\n        minContextSlot: options.minContextSlot\n    };\n    const signature = await connection.sendRawTransaction(rawTransaction, sendOptions);\n    const commitment = options && options.commitment;\n    const confirmationPromise = confirmationStrategy ? connection.confirmTransaction(confirmationStrategy, commitment) : connection.confirmTransaction(signature, commitment);\n    const status = (await confirmationPromise).value;\n    if (status.err) {\n        if (signature != null) {\n            throw new SendTransactionError({\n                action: sendOptions?.skipPreflight ? \"send\" : \"simulate\",\n                signature: signature,\n                transactionMessage: `Status: (${JSON.stringify(status)})`\n            });\n        }\n        throw new Error(`Raw transaction ${signature} failed (${JSON.stringify(status)})`);\n    }\n    return signature;\n}\n/**\n * There are 1-billion lamports in one SOL\n */ const LAMPORTS_PER_SOL = 1000000000;\n //# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbGliL2luZGV4LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFnQztBQUNnQjtBQUN6QjtBQUNDO0FBQ3NCO0FBQ3VCO0FBQ2Y7QUFDVDtBQUNVO0FBQ3pCO0FBQ0U7QUFDWTtBQUNzSTtBQUNoSTtBQUNWO0FBQ2lCO0FBQ1Q7QUFDSTtBQUVwRDs7OztDQUlDLEdBRUQ7O0NBRUMsR0FFRCxNQUFNd0MscUJBQXFCdkMsMkRBQU9BLENBQUN3QyxLQUFLLENBQUNDLGdCQUFnQjtBQUN6RCxNQUFNQyxrQkFBa0I7SUFDdEIsTUFBTUMsZ0JBQWdCM0MsMkRBQU9BLENBQUN3QyxLQUFLLENBQUNDLGdCQUFnQjtJQUNwRCxNQUFNRyxZQUFZQyxhQUFhRjtJQUMvQixNQUFNRyxZQUFZLElBQUlDLFdBQVc7SUFDakNELFVBQVVFLEdBQUcsQ0FBQ0w7SUFDZEcsVUFBVUUsR0FBRyxDQUFDSixXQUFXO0lBQ3pCLE9BQU87UUFDTEE7UUFDQUU7SUFDRjtBQUNGO0FBQ0EsTUFBTUQsZUFBZTdDLDJEQUFPQSxDQUFDNkMsWUFBWTtBQUN6QyxTQUFTSSxVQUFVTCxTQUFTO0lBQzFCLElBQUk7UUFDRjVDLDJEQUFPQSxDQUFDa0QsYUFBYSxDQUFDQyxPQUFPLENBQUNQO1FBQzlCLE9BQU87SUFDVCxFQUFFLE9BQU07UUFDTixPQUFPO0lBQ1Q7QUFDRjtBQUNBLE1BQU1RLE9BQU8sQ0FBQ0MsU0FBU1AsWUFBYzlDLDJEQUFPQSxDQUFDb0QsSUFBSSxDQUFDQyxTQUFTUCxVQUFVUSxLQUFLLENBQUMsR0FBRztBQUM5RSxNQUFNQyxTQUFTdkQsMkRBQU9BLENBQUN1RCxNQUFNO0FBRTdC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O1FBQ2QsSUFBSWdCLGFBQWEsTUFBTTtZQUNyQixNQUFNLElBQUkyVCxxQkFBcUI7Z0JBQzdCQyxRQUFRd0MsYUFBYUMsZ0JBQWdCLFNBQVM7Z0JBQzlDclcsV0FBV0E7Z0JBQ1g2VCxvQkFBb0IsQ0FBQyxTQUFTLEVBQUU5RixLQUFLQyxTQUFTLENBQUMwSSxRQUFRLENBQUMsQ0FBQztZQUMzRDtRQUNGO1FBQ0EsTUFBTSxJQUFJdGEsTUFBTSxDQUFDLGdCQUFnQixFQUFFNEQsVUFBVSxTQUFTLEVBQUUrTixLQUFLQyxTQUFTLENBQUMwSSxRQUFRLENBQUMsQ0FBQztJQUNuRjtJQUNBLE9BQU8xVztBQUNUO0FBRUE7O0NBRUMsR0FDRCxNQUFNcTJDLG1CQUFtQjtBQUU2Z0QsQ0FDdGlELHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGNvcmFsLXh5ei9hbmNob3Ivbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9saWIvaW5kZXguZXNtLmpzP2VmYTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnYnVmZmVyJztcbmltcG9ydCB7IGVkMjU1MTkgfSBmcm9tICdAbm9ibGUvY3VydmVzL2VkMjU1MTknO1xuaW1wb3J0IEJOIGZyb20gJ2JuLmpzJztcbmltcG9ydCBiczU4IGZyb20gJ2JzNTgnO1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyNTYnO1xuaW1wb3J0IHsgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSwgZGVzZXJpYWxpemVVbmNoZWNrZWQgfSBmcm9tICdib3JzaCc7XG5pbXBvcnQgKiBhcyBCdWZmZXJMYXlvdXQgZnJvbSAnQHNvbGFuYS9idWZmZXItbGF5b3V0JztcbmltcG9ydCB7IGJsb2IgfSBmcm9tICdAc29sYW5hL2J1ZmZlci1sYXlvdXQnO1xuaW1wb3J0IHsgdG9CaWdJbnRMRSwgdG9CdWZmZXJMRSB9IGZyb20gJ2JpZ2ludC1idWZmZXInO1xuaW1wb3J0IHJlcXVpcmUkJDAgZnJvbSAndXRpbCc7XG5pbXBvcnQgcmVxdWlyZSQkMCQxIGZyb20gJ2h0dHAnO1xuaW1wb3J0IHJlcXVpcmUkJDAkMiwgeyBBZ2VudCB9IGZyb20gJ2h0dHBzJztcbmltcG9ydCB7IGNvZXJjZSwgaW5zdGFuY2UsIHN0cmluZywgdHVwbGUsIGxpdGVyYWwsIHVua25vd24sIHR5cGUsIG51bWJlciwgYXJyYXksIG51bGxhYmxlLCBvcHRpb25hbCwgYm9vbGVhbiwgcmVjb3JkLCB1bmlvbiwgY3JlYXRlLCBhbnksIGFzc2VydCBhcyBhc3NlcnQkMSB9IGZyb20gJ3N1cGVyc3RydWN0JztcbmltcG9ydCBScGNDbGllbnQgZnJvbSAnamF5c29uL2xpYi9jbGllbnQvYnJvd3Nlcic7XG5pbXBvcnQgKiBhcyBub2RlRmV0Y2ggZnJvbSAnbm9kZS1mZXRjaCc7XG5pbXBvcnQgeyBDb21tb25DbGllbnQsIFdlYlNvY2tldCB9IGZyb20gJ3JwYy13ZWJzb2NrZXRzJztcbmltcG9ydCB7IGtlY2Nha18yNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTMnO1xuaW1wb3J0IHsgc2VjcDI1NmsxIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9zZWNwMjU2azEnO1xuXG4vKipcbiAqIEEgNjQgYnl0ZSBzZWNyZXQga2V5LCB0aGUgZmlyc3QgMzIgYnl0ZXMgb2Ygd2hpY2ggaXMgdGhlXG4gKiBwcml2YXRlIHNjYWxhciBhbmQgdGhlIGxhc3QgMzIgYnl0ZXMgaXMgdGhlIHB1YmxpYyBrZXkuXG4gKiBSZWFkIG1vcmU6IGh0dHBzOi8vYmxvZy5tb3ppbGxhLm9yZy93YXJuZXIvMjAxMS8xMS8yOS9lZDI1NTE5LWtleXMvXG4gKi9cblxuLyoqXG4gKiBFZDI1NTE5IEtleXBhaXJcbiAqL1xuXG5jb25zdCBnZW5lcmF0ZVByaXZhdGVLZXkgPSBlZDI1NTE5LnV0aWxzLnJhbmRvbVByaXZhdGVLZXk7XG5jb25zdCBnZW5lcmF0ZUtleXBhaXIgPSAoKSA9PiB7XG4gIGNvbnN0IHByaXZhdGVTY2FsYXIgPSBlZDI1NTE5LnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKTtcbiAgY29uc3QgcHVibGljS2V5ID0gZ2V0UHVibGljS2V5KHByaXZhdGVTY2FsYXIpO1xuICBjb25zdCBzZWNyZXRLZXkgPSBuZXcgVWludDhBcnJheSg2NCk7XG4gIHNlY3JldEtleS5zZXQocHJpdmF0ZVNjYWxhcik7XG4gIHNlY3JldEtleS5zZXQocHVibGljS2V5LCAzMik7XG4gIHJldHVybiB7XG4gICAgcHVibGljS2V5LFxuICAgIHNlY3JldEtleVxuICB9O1xufTtcbmNvbnN0IGdldFB1YmxpY0tleSA9IGVkMjU1MTkuZ2V0UHVibGljS2V5O1xuZnVuY3Rpb24gaXNPbkN1cnZlKHB1YmxpY0tleSkge1xuICB0cnkge1xuICAgIGVkMjU1MTkuRXh0ZW5kZWRQb2ludC5mcm9tSGV4KHB1YmxpY0tleSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuY29uc3Qgc2lnbiA9IChtZXNzYWdlLCBzZWNyZXRLZXkpID0+IGVkMjU1MTkuc2lnbihtZXNzYWdlLCBzZWNyZXRLZXkuc2xpY2UoMCwgMzIpKTtcbmNvbnN0IHZlcmlmeSA9IGVkMjU1MTkudmVyaWZ5O1xuXG5jb25zdCB0b0J1ZmZlciA9IGFyciA9PiB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoYXJyKSkge1xuICAgIHJldHVybiBhcnI7XG4gIH0gZWxzZSBpZiAoYXJyIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShhcnIpO1xuICB9XG59O1xuXG4vLyBDbGFzcyB3cmFwcGluZyBhIHBsYWluIG9iamVjdFxuY2xhc3MgU3RydWN0IHtcbiAgY29uc3RydWN0b3IocHJvcGVydGllcykge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgcHJvcGVydGllcyk7XG4gIH1cbiAgZW5jb2RlKCkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzZXJpYWxpemUoU09MQU5BX1NDSEVNQSwgdGhpcykpO1xuICB9XG4gIHN0YXRpYyBkZWNvZGUoZGF0YSkge1xuICAgIHJldHVybiBkZXNlcmlhbGl6ZShTT0xBTkFfU0NIRU1BLCB0aGlzLCBkYXRhKTtcbiAgfVxuICBzdGF0aWMgZGVjb2RlVW5jaGVja2VkKGRhdGEpIHtcbiAgICByZXR1cm4gZGVzZXJpYWxpemVVbmNoZWNrZWQoU09MQU5BX1NDSEVNQSwgdGhpcywgZGF0YSk7XG4gIH1cbn1cblxuLy8gQ2xhc3MgcmVwcmVzZW50aW5nIGEgUnVzdC1jb21wYXRpYmxlIGVudW0sIHNpbmNlIGVudW1zIGFyZSBvbmx5IHN0cmluZ3Mgb3Jcbi8vIG51bWJlcnMgaW4gcHVyZSBKU1xuY2xhc3MgRW51bSBleHRlbmRzIFN0cnVjdCB7XG4gIGNvbnN0cnVjdG9yKHByb3BlcnRpZXMpIHtcbiAgICBzdXBlcihwcm9wZXJ0aWVzKTtcbiAgICB0aGlzLmVudW0gPSAnJztcbiAgICBpZiAoT2JqZWN0LmtleXMocHJvcGVydGllcykubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VudW0gY2FuIG9ubHkgdGFrZSBzaW5nbGUgdmFsdWUnKTtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMocHJvcGVydGllcykubWFwKGtleSA9PiB7XG4gICAgICB0aGlzLmVudW0gPSBrZXk7XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IFNPTEFOQV9TQ0hFTUEgPSBuZXcgTWFwKCk7XG5cbnZhciBfUHVibGljS2V5O1xuXG4vKipcbiAqIE1heGltdW0gbGVuZ3RoIG9mIGRlcml2ZWQgcHVia2V5IHNlZWRcbiAqL1xuY29uc3QgTUFYX1NFRURfTEVOR1RIID0gMzI7XG5cbi8qKlxuICogU2l6ZSBvZiBwdWJsaWMga2V5IGluIGJ5dGVzXG4gKi9cbmNvbnN0IFBVQkxJQ19LRVlfTEVOR1RIID0gMzI7XG5cbi8qKlxuICogVmFsdWUgdG8gYmUgY29udmVydGVkIGludG8gcHVibGljIGtleVxuICovXG5cbi8qKlxuICogSlNPTiBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgUHVibGljS2V5IGNsYXNzXG4gKi9cblxuZnVuY3Rpb24gaXNQdWJsaWNLZXlEYXRhKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5fYm4gIT09IHVuZGVmaW5lZDtcbn1cblxuLy8gbG9jYWwgY291bnRlciB1c2VkIGJ5IFB1YmxpY0tleS51bmlxdWUoKVxubGV0IHVuaXF1ZVB1YmxpY0tleUNvdW50ZXIgPSAxO1xuXG4vKipcbiAqIEEgcHVibGljIGtleVxuICovXG5jbGFzcyBQdWJsaWNLZXkgZXh0ZW5kcyBTdHJ1Y3Qge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFB1YmxpY0tleSBvYmplY3RcbiAgICogQHBhcmFtIHZhbHVlIGVkMjU1MTkgcHVibGljIGtleSBhcyBidWZmZXIgb3IgYmFzZS01OCBlbmNvZGVkIHN0cmluZ1xuICAgKi9cbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICBzdXBlcih7fSk7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX2JuID0gdm9pZCAwO1xuICAgIGlmIChpc1B1YmxpY0tleURhdGEodmFsdWUpKSB7XG4gICAgICB0aGlzLl9ibiA9IHZhbHVlLl9ibjtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gYXNzdW1lIGJhc2UgNTggZW5jb2RpbmcgYnkgZGVmYXVsdFxuICAgICAgICBjb25zdCBkZWNvZGVkID0gYnM1OC5kZWNvZGUodmFsdWUpO1xuICAgICAgICBpZiAoZGVjb2RlZC5sZW5ndGggIT0gUFVCTElDX0tFWV9MRU5HVEgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcHVibGljIGtleSBpbnB1dGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2JuID0gbmV3IEJOKGRlY29kZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYm4gPSBuZXcgQk4odmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2JuLmJ5dGVMZW5ndGgoKSA+IFBVQkxJQ19LRVlfTEVOR1RIKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwdWJsaWMga2V5IGlucHV0YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB1bmlxdWUgUHVibGljS2V5IGZvciB0ZXN0cyBhbmQgYmVuY2htYXJrcyB1c2luZyBhIGNvdW50ZXJcbiAgICovXG4gIHN0YXRpYyB1bmlxdWUoKSB7XG4gICAgY29uc3Qga2V5ID0gbmV3IFB1YmxpY0tleSh1bmlxdWVQdWJsaWNLZXlDb3VudGVyKTtcbiAgICB1bmlxdWVQdWJsaWNLZXlDb3VudGVyICs9IDE7XG4gICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkoa2V5LnRvQnVmZmVyKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgcHVibGljIGtleSB2YWx1ZS4gVGhlIGJhc2U1OC1lbmNvZGVkIHN0cmluZyByZXByZXNlbnRhdGlvbiBpcyBhbGwgb25lcyAoYXMgc2VlbiBiZWxvdylcbiAgICogVGhlIHVuZGVybHlpbmcgQk4gbnVtYmVyIGlzIDMyIGJ5dGVzIHRoYXQgYXJlIGFsbCB6ZXJvc1xuICAgKi9cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHR3byBwdWJsaWNLZXlzIGFyZSBlcXVhbFxuICAgKi9cbiAgZXF1YWxzKHB1YmxpY0tleSkge1xuICAgIHJldHVybiB0aGlzLl9ibi5lcShwdWJsaWNLZXkuX2JuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGJhc2UtNTggcmVwcmVzZW50YXRpb24gb2YgdGhlIHB1YmxpYyBrZXlcbiAgICovXG4gIHRvQmFzZTU4KCkge1xuICAgIHJldHVybiBiczU4LmVuY29kZSh0aGlzLnRvQnl0ZXMoKSk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvQmFzZTU4KCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBieXRlIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwdWJsaWMga2V5IGluIGJpZyBlbmRpYW5cbiAgICovXG4gIHRvQnl0ZXMoKSB7XG4gICAgY29uc3QgYnVmID0gdGhpcy50b0J1ZmZlcigpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVMZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgQnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwdWJsaWMga2V5IGluIGJpZyBlbmRpYW5cbiAgICovXG4gIHRvQnVmZmVyKCkge1xuICAgIGNvbnN0IGIgPSB0aGlzLl9ibi50b0FycmF5TGlrZShCdWZmZXIpO1xuICAgIGlmIChiLmxlbmd0aCA9PT0gUFVCTElDX0tFWV9MRU5HVEgpIHtcbiAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICBjb25zdCB6ZXJvUGFkID0gQnVmZmVyLmFsbG9jKDMyKTtcbiAgICBiLmNvcHkoemVyb1BhZCwgMzIgLSBiLmxlbmd0aCk7XG4gICAgcmV0dXJuIHplcm9QYWQ7XG4gIH1cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiBgUHVibGljS2V5KCR7dGhpcy50b1N0cmluZygpfSlgO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgYmFzZS01OCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHVibGljIGtleVxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9CYXNlNTgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJpdmUgYSBwdWJsaWMga2V5IGZyb20gYW5vdGhlciBrZXksIGEgc2VlZCwgYW5kIGEgcHJvZ3JhbSBJRC5cbiAgICogVGhlIHByb2dyYW0gSUQgd2lsbCBhbHNvIHNlcnZlIGFzIHRoZSBvd25lciBvZiB0aGUgcHVibGljIGtleSwgZ2l2aW5nXG4gICAqIGl0IHBlcm1pc3Npb24gdG8gd3JpdGUgZGF0YSB0byB0aGUgYWNjb3VudC5cbiAgICovXG4gIC8qIGVzbGludC1kaXNhYmxlIHJlcXVpcmUtYXdhaXQgKi9cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZVdpdGhTZWVkKGZyb21QdWJsaWNLZXksIHNlZWQsIHByb2dyYW1JZCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW2Zyb21QdWJsaWNLZXkudG9CdWZmZXIoKSwgQnVmZmVyLmZyb20oc2VlZCksIHByb2dyYW1JZC50b0J1ZmZlcigpXSk7XG4gICAgY29uc3QgcHVibGljS2V5Qnl0ZXMgPSBzaGEyNTYoYnVmZmVyKTtcbiAgICByZXR1cm4gbmV3IFB1YmxpY0tleShwdWJsaWNLZXlCeXRlcyk7XG4gIH1cblxuICAvKipcbiAgICogRGVyaXZlIGEgcHJvZ3JhbSBhZGRyZXNzIGZyb20gc2VlZHMgYW5kIGEgcHJvZ3JhbSBJRC5cbiAgICovXG4gIC8qIGVzbGludC1kaXNhYmxlIHJlcXVpcmUtYXdhaXQgKi9cbiAgc3RhdGljIGNyZWF0ZVByb2dyYW1BZGRyZXNzU3luYyhzZWVkcywgcHJvZ3JhbUlkKSB7XG4gICAgbGV0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgICBzZWVkcy5mb3JFYWNoKGZ1bmN0aW9uIChzZWVkKSB7XG4gICAgICBpZiAoc2VlZC5sZW5ndGggPiBNQVhfU0VFRF9MRU5HVEgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTWF4IHNlZWQgbGVuZ3RoIGV4Y2VlZGVkYCk7XG4gICAgICB9XG4gICAgICBidWZmZXIgPSBCdWZmZXIuY29uY2F0KFtidWZmZXIsIHRvQnVmZmVyKHNlZWQpXSk7XG4gICAgfSk7XG4gICAgYnVmZmVyID0gQnVmZmVyLmNvbmNhdChbYnVmZmVyLCBwcm9ncmFtSWQudG9CdWZmZXIoKSwgQnVmZmVyLmZyb20oJ1Byb2dyYW1EZXJpdmVkQWRkcmVzcycpXSk7XG4gICAgY29uc3QgcHVibGljS2V5Qnl0ZXMgPSBzaGEyNTYoYnVmZmVyKTtcbiAgICBpZiAoaXNPbkN1cnZlKHB1YmxpY0tleUJ5dGVzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNlZWRzLCBhZGRyZXNzIG11c3QgZmFsbCBvZmYgdGhlIGN1cnZlYCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHVibGljS2V5KHB1YmxpY0tleUJ5dGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3luYyB2ZXJzaW9uIG9mIGNyZWF0ZVByb2dyYW1BZGRyZXNzU3luY1xuICAgKiBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBjcmVhdGVQcm9ncmFtQWRkcmVzc1N5bmN9IGluc3RlYWRcbiAgICovXG4gIC8qIGVzbGludC1kaXNhYmxlIHJlcXVpcmUtYXdhaXQgKi9cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZVByb2dyYW1BZGRyZXNzKHNlZWRzLCBwcm9ncmFtSWQpIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVQcm9ncmFtQWRkcmVzc1N5bmMoc2VlZHMsIHByb2dyYW1JZCk7XG4gIH1cblxuICAvKipcbiAgICogRmluZCBhIHZhbGlkIHByb2dyYW0gYWRkcmVzc1xuICAgKlxuICAgKiBWYWxpZCBwcm9ncmFtIGFkZHJlc3NlcyBtdXN0IGZhbGwgb2ZmIHRoZSBlZDI1NTE5IGN1cnZlLiAgVGhpcyBmdW5jdGlvblxuICAgKiBpdGVyYXRlcyBhIG5vbmNlIHVudGlsIGl0IGZpbmRzIG9uZSB0aGF0IHdoZW4gY29tYmluZWQgd2l0aCB0aGUgc2VlZHNcbiAgICogcmVzdWx0cyBpbiBhIHZhbGlkIHByb2dyYW0gYWRkcmVzcy5cbiAgICovXG4gIHN0YXRpYyBmaW5kUHJvZ3JhbUFkZHJlc3NTeW5jKHNlZWRzLCBwcm9ncmFtSWQpIHtcbiAgICBsZXQgbm9uY2UgPSAyNTU7XG4gICAgbGV0IGFkZHJlc3M7XG4gICAgd2hpbGUgKG5vbmNlICE9IDApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHNlZWRzV2l0aE5vbmNlID0gc2VlZHMuY29uY2F0KEJ1ZmZlci5mcm9tKFtub25jZV0pKTtcbiAgICAgICAgYWRkcmVzcyA9IHRoaXMuY3JlYXRlUHJvZ3JhbUFkZHJlc3NTeW5jKHNlZWRzV2l0aE5vbmNlLCBwcm9ncmFtSWQpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgbm9uY2UtLTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gW2FkZHJlc3MsIG5vbmNlXTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBhIHZpYWJsZSBwcm9ncmFtIGFkZHJlc3Mgbm9uY2VgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3luYyB2ZXJzaW9uIG9mIGZpbmRQcm9ncmFtQWRkcmVzc1N5bmNcbiAgICogRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgZmluZFByb2dyYW1BZGRyZXNzU3luY30gaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZpbmRQcm9ncmFtQWRkcmVzcyhzZWVkcywgcHJvZ3JhbUlkKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluZFByb2dyYW1BZGRyZXNzU3luYyhzZWVkcywgcHJvZ3JhbUlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB0aGF0IGEgcHVia2V5IGlzIG9uIHRoZSBlZDI1NTE5IGN1cnZlLlxuICAgKi9cbiAgc3RhdGljIGlzT25DdXJ2ZShwdWJrZXlEYXRhKSB7XG4gICAgY29uc3QgcHVia2V5ID0gbmV3IFB1YmxpY0tleShwdWJrZXlEYXRhKTtcbiAgICByZXR1cm4gaXNPbkN1cnZlKHB1YmtleS50b0J5dGVzKCkpO1xuICB9XG59XG5fUHVibGljS2V5ID0gUHVibGljS2V5O1xuUHVibGljS2V5LmRlZmF1bHQgPSBuZXcgX1B1YmxpY0tleSgnMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblNPTEFOQV9TQ0hFTUEuc2V0KFB1YmxpY0tleSwge1xuICBraW5kOiAnc3RydWN0JyxcbiAgZmllbGRzOiBbWydfYm4nLCAndTI1NiddXVxufSk7XG5cbi8qKlxuICogQW4gYWNjb3VudCBrZXkgcGFpciAocHVibGljIGFuZCBzZWNyZXQga2V5cykuXG4gKlxuICogQGRlcHJlY2F0ZWQgc2luY2UgdjEuMTAuMCwgcGxlYXNlIHVzZSB7QGxpbmsgS2V5cGFpcn0gaW5zdGVhZC5cbiAqL1xuY2xhc3MgQWNjb3VudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgQWNjb3VudCBvYmplY3RcbiAgICpcbiAgICogSWYgdGhlIHNlY3JldEtleSBwYXJhbWV0ZXIgaXMgbm90IHByb3ZpZGVkIGEgbmV3IGtleSBwYWlyIGlzIHJhbmRvbWx5XG4gICAqIGNyZWF0ZWQgZm9yIHRoZSBhY2NvdW50XG4gICAqXG4gICAqIEBwYXJhbSBzZWNyZXRLZXkgU2VjcmV0IGtleSBmb3IgdGhlIGFjY291bnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNlY3JldEtleSkge1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9wdWJsaWNLZXkgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3NlY3JldEtleSA9IHZvaWQgMDtcbiAgICBpZiAoc2VjcmV0S2V5KSB7XG4gICAgICBjb25zdCBzZWNyZXRLZXlCdWZmZXIgPSB0b0J1ZmZlcihzZWNyZXRLZXkpO1xuICAgICAgaWYgKHNlY3JldEtleS5sZW5ndGggIT09IDY0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHNlY3JldCBrZXkgc2l6ZScpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcHVibGljS2V5ID0gc2VjcmV0S2V5QnVmZmVyLnNsaWNlKDMyLCA2NCk7XG4gICAgICB0aGlzLl9zZWNyZXRLZXkgPSBzZWNyZXRLZXlCdWZmZXIuc2xpY2UoMCwgMzIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zZWNyZXRLZXkgPSB0b0J1ZmZlcihnZW5lcmF0ZVByaXZhdGVLZXkoKSk7XG4gICAgICB0aGlzLl9wdWJsaWNLZXkgPSB0b0J1ZmZlcihnZXRQdWJsaWNLZXkodGhpcy5fc2VjcmV0S2V5KSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBwdWJsaWMga2V5IGZvciB0aGlzIGFjY291bnRcbiAgICovXG4gIGdldCBwdWJsaWNLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkodGhpcy5fcHVibGljS2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgKip1bmVuY3J5cHRlZCoqIHNlY3JldCBrZXkgZm9yIHRoaXMgYWNjb3VudC4gVGhlIGZpcnN0IDMyIGJ5dGVzXG4gICAqIGlzIHRoZSBwcml2YXRlIHNjYWxhciBhbmQgdGhlIGxhc3QgMzIgYnl0ZXMgaXMgdGhlIHB1YmxpYyBrZXkuXG4gICAqIFJlYWQgbW9yZTogaHR0cHM6Ly9ibG9nLm1vemlsbGEub3JnL3dhcm5lci8yMDExLzExLzI5L2VkMjU1MTkta2V5cy9cbiAgICovXG4gIGdldCBzZWNyZXRLZXkoKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW3RoaXMuX3NlY3JldEtleSwgdGhpcy5fcHVibGljS2V5XSwgNjQpO1xuICB9XG59XG5cbmNvbnN0IEJQRl9MT0FERVJfREVQUkVDQVRFRF9QUk9HUkFNX0lEID0gbmV3IFB1YmxpY0tleSgnQlBGTG9hZGVyMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG4vKipcbiAqIE1heGltdW0gb3Zlci10aGUtd2lyZSBzaXplIG9mIGEgVHJhbnNhY3Rpb25cbiAqXG4gKiAxMjgwIGlzIElQdjYgbWluaW11bSBNVFVcbiAqIDQwIGJ5dGVzIGlzIHRoZSBzaXplIG9mIHRoZSBJUHY2IGhlYWRlclxuICogOCBieXRlcyBpcyB0aGUgc2l6ZSBvZiB0aGUgZnJhZ21lbnQgaGVhZGVyXG4gKi9cbmNvbnN0IFBBQ0tFVF9EQVRBX1NJWkUgPSAxMjgwIC0gNDAgLSA4O1xuY29uc3QgVkVSU0lPTl9QUkVGSVhfTUFTSyA9IDB4N2Y7XG5jb25zdCBTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTID0gNjQ7XG5cbmNsYXNzIFRyYW5zYWN0aW9uRXhwaXJlZEJsb2NraGVpZ2h0RXhjZWVkZWRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Ioc2lnbmF0dXJlKSB7XG4gICAgc3VwZXIoYFNpZ25hdHVyZSAke3NpZ25hdHVyZX0gaGFzIGV4cGlyZWQ6IGJsb2NrIGhlaWdodCBleGNlZWRlZC5gKTtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IHZvaWQgMDtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IHNpZ25hdHVyZTtcbiAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zYWN0aW9uRXhwaXJlZEJsb2NraGVpZ2h0RXhjZWVkZWRFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ1RyYW5zYWN0aW9uRXhwaXJlZEJsb2NraGVpZ2h0RXhjZWVkZWRFcnJvcidcbn0pO1xuY2xhc3MgVHJhbnNhY3Rpb25FeHBpcmVkVGltZW91dEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihzaWduYXR1cmUsIHRpbWVvdXRTZWNvbmRzKSB7XG4gICAgc3VwZXIoYFRyYW5zYWN0aW9uIHdhcyBub3QgY29uZmlybWVkIGluICR7dGltZW91dFNlY29uZHMudG9GaXhlZCgyKX0gc2Vjb25kcy4gSXQgaXMgYCArICd1bmtub3duIGlmIGl0IHN1Y2NlZWRlZCBvciBmYWlsZWQuIENoZWNrIHNpZ25hdHVyZSAnICsgYCR7c2lnbmF0dXJlfSB1c2luZyB0aGUgU29sYW5hIEV4cGxvcmVyIG9yIENMSSB0b29scy5gKTtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IHZvaWQgMDtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IHNpZ25hdHVyZTtcbiAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zYWN0aW9uRXhwaXJlZFRpbWVvdXRFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ1RyYW5zYWN0aW9uRXhwaXJlZFRpbWVvdXRFcnJvcidcbn0pO1xuY2xhc3MgVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHNpZ25hdHVyZSkge1xuICAgIHN1cGVyKGBTaWduYXR1cmUgJHtzaWduYXR1cmV9IGhhcyBleHBpcmVkOiB0aGUgbm9uY2UgaXMgbm8gbG9uZ2VyIHZhbGlkLmApO1xuICAgIHRoaXMuc2lnbmF0dXJlID0gdm9pZCAwO1xuICAgIHRoaXMuc2lnbmF0dXJlID0gc2lnbmF0dXJlO1xuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvcidcbn0pO1xuXG5jbGFzcyBNZXNzYWdlQWNjb3VudEtleXMge1xuICBjb25zdHJ1Y3RvcihzdGF0aWNBY2NvdW50S2V5cywgYWNjb3VudEtleXNGcm9tTG9va3Vwcykge1xuICAgIHRoaXMuc3RhdGljQWNjb3VudEtleXMgPSB2b2lkIDA7XG4gICAgdGhpcy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhdGljQWNjb3VudEtleXMgPSBzdGF0aWNBY2NvdW50S2V5cztcbiAgICB0aGlzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMgPSBhY2NvdW50S2V5c0Zyb21Mb29rdXBzO1xuICB9XG4gIGtleVNlZ21lbnRzKCkge1xuICAgIGNvbnN0IGtleVNlZ21lbnRzID0gW3RoaXMuc3RhdGljQWNjb3VudEtleXNdO1xuICAgIGlmICh0aGlzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMpIHtcbiAgICAgIGtleVNlZ21lbnRzLnB1c2godGhpcy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzLndyaXRhYmxlKTtcbiAgICAgIGtleVNlZ21lbnRzLnB1c2godGhpcy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzLnJlYWRvbmx5KTtcbiAgICB9XG4gICAgcmV0dXJuIGtleVNlZ21lbnRzO1xuICB9XG4gIGdldChpbmRleCkge1xuICAgIGZvciAoY29uc3Qga2V5U2VnbWVudCBvZiB0aGlzLmtleVNlZ21lbnRzKCkpIHtcbiAgICAgIGlmIChpbmRleCA8IGtleVNlZ21lbnQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBrZXlTZWdtZW50W2luZGV4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4IC09IGtleVNlZ21lbnQubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5rZXlTZWdtZW50cygpLmZsYXQoKS5sZW5ndGg7XG4gIH1cbiAgY29tcGlsZUluc3RydWN0aW9ucyhpbnN0cnVjdGlvbnMpIHtcbiAgICAvLyBCYWlsIGVhcmx5IGlmIGFueSBhY2NvdW50IGluZGV4ZXMgd291bGQgb3ZlcmZsb3cgYSB1OFxuICAgIGNvbnN0IFU4X01BWCA9IDI1NTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBVOF9NQVggKyAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjY291bnQgaW5kZXggb3ZlcmZsb3cgZW5jb3VudGVyZWQgZHVyaW5nIGNvbXBpbGF0aW9uJyk7XG4gICAgfVxuICAgIGNvbnN0IGtleUluZGV4TWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMua2V5U2VnbWVudHMoKS5mbGF0KCkuZm9yRWFjaCgoa2V5LCBpbmRleCkgPT4ge1xuICAgICAga2V5SW5kZXhNYXAuc2V0KGtleS50b0Jhc2U1OCgpLCBpbmRleCk7XG4gICAgfSk7XG4gICAgY29uc3QgZmluZEtleUluZGV4ID0ga2V5ID0+IHtcbiAgICAgIGNvbnN0IGtleUluZGV4ID0ga2V5SW5kZXhNYXAuZ2V0KGtleS50b0Jhc2U1OCgpKTtcbiAgICAgIGlmIChrZXlJbmRleCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoJ0VuY291bnRlcmVkIGFuIHVua25vd24gaW5zdHJ1Y3Rpb24gYWNjb3VudCBrZXkgZHVyaW5nIGNvbXBpbGF0aW9uJyk7XG4gICAgICByZXR1cm4ga2V5SW5kZXg7XG4gICAgfTtcbiAgICByZXR1cm4gaW5zdHJ1Y3Rpb25zLm1hcChpbnN0cnVjdGlvbiA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9ncmFtSWRJbmRleDogZmluZEtleUluZGV4KGluc3RydWN0aW9uLnByb2dyYW1JZCksXG4gICAgICAgIGFjY291bnRLZXlJbmRleGVzOiBpbnN0cnVjdGlvbi5rZXlzLm1hcChtZXRhID0+IGZpbmRLZXlJbmRleChtZXRhLnB1YmtleSkpLFxuICAgICAgICBkYXRhOiBpbnN0cnVjdGlvbi5kYXRhXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogTGF5b3V0IGZvciBhIHB1YmxpYyBrZXlcbiAqL1xuY29uc3QgcHVibGljS2V5ID0gKHByb3BlcnR5ID0gJ3B1YmxpY0tleScpID0+IHtcbiAgcmV0dXJuIEJ1ZmZlckxheW91dC5ibG9iKDMyLCBwcm9wZXJ0eSk7XG59O1xuXG4vKipcbiAqIExheW91dCBmb3IgYSBzaWduYXR1cmVcbiAqL1xuY29uc3Qgc2lnbmF0dXJlID0gKHByb3BlcnR5ID0gJ3NpZ25hdHVyZScpID0+IHtcbiAgcmV0dXJuIEJ1ZmZlckxheW91dC5ibG9iKDY0LCBwcm9wZXJ0eSk7XG59O1xuLyoqXG4gKiBMYXlvdXQgZm9yIGEgUnVzdCBTdHJpbmcgdHlwZVxuICovXG5jb25zdCBydXN0U3RyaW5nID0gKHByb3BlcnR5ID0gJ3N0cmluZycpID0+IHtcbiAgY29uc3QgcnNsID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignbGVuZ3RoJyksIEJ1ZmZlckxheW91dC51MzIoJ2xlbmd0aFBhZGRpbmcnKSwgQnVmZmVyTGF5b3V0LmJsb2IoQnVmZmVyTGF5b3V0Lm9mZnNldChCdWZmZXJMYXlvdXQudTMyKCksIC04KSwgJ2NoYXJzJyldLCBwcm9wZXJ0eSk7XG4gIGNvbnN0IF9kZWNvZGUgPSByc2wuZGVjb2RlLmJpbmQocnNsKTtcbiAgY29uc3QgX2VuY29kZSA9IHJzbC5lbmNvZGUuYmluZChyc2wpO1xuICBjb25zdCByc2xTaGltID0gcnNsO1xuICByc2xTaGltLmRlY29kZSA9IChiLCBvZmZzZXQpID0+IHtcbiAgICBjb25zdCBkYXRhID0gX2RlY29kZShiLCBvZmZzZXQpO1xuICAgIHJldHVybiBkYXRhWydjaGFycyddLnRvU3RyaW5nKCk7XG4gIH07XG4gIHJzbFNoaW0uZW5jb2RlID0gKHN0ciwgYiwgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIGNoYXJzOiBCdWZmZXIuZnJvbShzdHIsICd1dGY4JylcbiAgICB9O1xuICAgIHJldHVybiBfZW5jb2RlKGRhdGEsIGIsIG9mZnNldCk7XG4gIH07XG4gIHJzbFNoaW0uYWxsb2MgPSBzdHIgPT4ge1xuICAgIHJldHVybiBCdWZmZXJMYXlvdXQudTMyKCkuc3BhbiArIEJ1ZmZlckxheW91dC51MzIoKS5zcGFuICsgQnVmZmVyLmZyb20oc3RyLCAndXRmOCcpLmxlbmd0aDtcbiAgfTtcbiAgcmV0dXJuIHJzbFNoaW07XG59O1xuXG4vKipcbiAqIExheW91dCBmb3IgYW4gQXV0aG9yaXplZCBvYmplY3RcbiAqL1xuY29uc3QgYXV0aG9yaXplZCA9IChwcm9wZXJ0eSA9ICdhdXRob3JpemVkJykgPT4ge1xuICByZXR1cm4gQnVmZmVyTGF5b3V0LnN0cnVjdChbcHVibGljS2V5KCdzdGFrZXInKSwgcHVibGljS2V5KCd3aXRoZHJhd2VyJyldLCBwcm9wZXJ0eSk7XG59O1xuXG4vKipcbiAqIExheW91dCBmb3IgYSBMb2NrdXAgb2JqZWN0XG4gKi9cbmNvbnN0IGxvY2t1cCA9IChwcm9wZXJ0eSA9ICdsb2NrdXAnKSA9PiB7XG4gIHJldHVybiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQubnM2NCgndW5peFRpbWVzdGFtcCcpLCBCdWZmZXJMYXlvdXQubnM2NCgnZXBvY2gnKSwgcHVibGljS2V5KCdjdXN0b2RpYW4nKV0sIHByb3BlcnR5KTtcbn07XG5cbi8qKlxuICogIExheW91dCBmb3IgYSBWb3RlSW5pdCBvYmplY3RcbiAqL1xuY29uc3Qgdm90ZUluaXQgPSAocHJvcGVydHkgPSAndm90ZUluaXQnKSA9PiB7XG4gIHJldHVybiBCdWZmZXJMYXlvdXQuc3RydWN0KFtwdWJsaWNLZXkoJ25vZGVQdWJrZXknKSwgcHVibGljS2V5KCdhdXRob3JpemVkVm90ZXInKSwgcHVibGljS2V5KCdhdXRob3JpemVkV2l0aGRyYXdlcicpLCBCdWZmZXJMYXlvdXQudTgoJ2NvbW1pc3Npb24nKV0sIHByb3BlcnR5KTtcbn07XG5cbi8qKlxuICogIExheW91dCBmb3IgYSBWb3RlQXV0aG9yaXplV2l0aFNlZWRBcmdzIG9iamVjdFxuICovXG5jb25zdCB2b3RlQXV0aG9yaXplV2l0aFNlZWRBcmdzID0gKHByb3BlcnR5ID0gJ3ZvdGVBdXRob3JpemVXaXRoU2VlZEFyZ3MnKSA9PiB7XG4gIHJldHVybiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCd2b3RlQXV0aG9yaXphdGlvblR5cGUnKSwgcHVibGljS2V5KCdjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5JyksIHJ1c3RTdHJpbmcoJ2N1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5U2VlZCcpLCBwdWJsaWNLZXkoJ25ld0F1dGhvcml6ZWQnKV0sIHByb3BlcnR5KTtcbn07XG5mdW5jdGlvbiBnZXRBbGxvYyh0eXBlLCBmaWVsZHMpIHtcbiAgY29uc3QgZ2V0SXRlbUFsbG9jID0gaXRlbSA9PiB7XG4gICAgaWYgKGl0ZW0uc3BhbiA+PSAwKSB7XG4gICAgICByZXR1cm4gaXRlbS5zcGFuO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGl0ZW0uYWxsb2MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVtLmFsbG9jKGZpZWxkc1tpdGVtLnByb3BlcnR5XSk7XG4gICAgfSBlbHNlIGlmICgnY291bnQnIGluIGl0ZW0gJiYgJ2VsZW1lbnRMYXlvdXQnIGluIGl0ZW0pIHtcbiAgICAgIGNvbnN0IGZpZWxkID0gZmllbGRzW2l0ZW0ucHJvcGVydHldO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmllbGQpKSB7XG4gICAgICAgIHJldHVybiBmaWVsZC5sZW5ndGggKiBnZXRJdGVtQWxsb2MoaXRlbS5lbGVtZW50TGF5b3V0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCdmaWVsZHMnIGluIGl0ZW0pIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBgU3RydWN0dXJlYCB3aG9zZSBzaXplIG5lZWRzIHRvIGJlIHJlY3Vyc2l2ZWx5IG1lYXN1cmVkLlxuICAgICAgcmV0dXJuIGdldEFsbG9jKHtcbiAgICAgICAgbGF5b3V0OiBpdGVtXG4gICAgICB9LCBmaWVsZHNbaXRlbS5wcm9wZXJ0eV0pO1xuICAgIH1cbiAgICAvLyBDb3VsZG4ndCBkZXRlcm1pbmUgYWxsb2NhdGVkIHNpemUgb2YgbGF5b3V0XG4gICAgcmV0dXJuIDA7XG4gIH07XG4gIGxldCBhbGxvYyA9IDA7XG4gIHR5cGUubGF5b3V0LmZpZWxkcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgIGFsbG9jICs9IGdldEl0ZW1BbGxvYyhpdGVtKTtcbiAgfSk7XG4gIHJldHVybiBhbGxvYztcbn1cblxuZnVuY3Rpb24gZGVjb2RlTGVuZ3RoKGJ5dGVzKSB7XG4gIGxldCBsZW4gPSAwO1xuICBsZXQgc2l6ZSA9IDA7XG4gIGZvciAoOzspIHtcbiAgICBsZXQgZWxlbSA9IGJ5dGVzLnNoaWZ0KCk7XG4gICAgbGVuIHw9IChlbGVtICYgMHg3ZikgPDwgc2l6ZSAqIDc7XG4gICAgc2l6ZSArPSAxO1xuICAgIGlmICgoZWxlbSAmIDB4ODApID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxlbjtcbn1cbmZ1bmN0aW9uIGVuY29kZUxlbmd0aChieXRlcywgbGVuKSB7XG4gIGxldCByZW1fbGVuID0gbGVuO1xuICBmb3IgKDs7KSB7XG4gICAgbGV0IGVsZW0gPSByZW1fbGVuICYgMHg3ZjtcbiAgICByZW1fbGVuID4+PSA3O1xuICAgIGlmIChyZW1fbGVuID09IDApIHtcbiAgICAgIGJ5dGVzLnB1c2goZWxlbSk7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbSB8PSAweDgwO1xuICAgICAgYnl0ZXMucHVzaChlbGVtKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0IChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xuICB9XG59XG5cbmNsYXNzIENvbXBpbGVkS2V5cyB7XG4gIGNvbnN0cnVjdG9yKHBheWVyLCBrZXlNZXRhTWFwKSB7XG4gICAgdGhpcy5wYXllciA9IHZvaWQgMDtcbiAgICB0aGlzLmtleU1ldGFNYXAgPSB2b2lkIDA7XG4gICAgdGhpcy5wYXllciA9IHBheWVyO1xuICAgIHRoaXMua2V5TWV0YU1hcCA9IGtleU1ldGFNYXA7XG4gIH1cbiAgc3RhdGljIGNvbXBpbGUoaW5zdHJ1Y3Rpb25zLCBwYXllcikge1xuICAgIGNvbnN0IGtleU1ldGFNYXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZ2V0T3JJbnNlcnREZWZhdWx0ID0gcHVia2V5ID0+IHtcbiAgICAgIGNvbnN0IGFkZHJlc3MgPSBwdWJrZXkudG9CYXNlNTgoKTtcbiAgICAgIGxldCBrZXlNZXRhID0ga2V5TWV0YU1hcC5nZXQoYWRkcmVzcyk7XG4gICAgICBpZiAoa2V5TWV0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGtleU1ldGEgPSB7XG4gICAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgIGlzSW52b2tlZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAga2V5TWV0YU1hcC5zZXQoYWRkcmVzcywga2V5TWV0YSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ga2V5TWV0YTtcbiAgICB9O1xuICAgIGNvbnN0IHBheWVyS2V5TWV0YSA9IGdldE9ySW5zZXJ0RGVmYXVsdChwYXllcik7XG4gICAgcGF5ZXJLZXlNZXRhLmlzU2lnbmVyID0gdHJ1ZTtcbiAgICBwYXllcktleU1ldGEuaXNXcml0YWJsZSA9IHRydWU7XG4gICAgZm9yIChjb25zdCBpeCBvZiBpbnN0cnVjdGlvbnMpIHtcbiAgICAgIGdldE9ySW5zZXJ0RGVmYXVsdChpeC5wcm9ncmFtSWQpLmlzSW52b2tlZCA9IHRydWU7XG4gICAgICBmb3IgKGNvbnN0IGFjY291bnRNZXRhIG9mIGl4LmtleXMpIHtcbiAgICAgICAgY29uc3Qga2V5TWV0YSA9IGdldE9ySW5zZXJ0RGVmYXVsdChhY2NvdW50TWV0YS5wdWJrZXkpO1xuICAgICAgICBrZXlNZXRhLmlzU2lnbmVyIHx8PSBhY2NvdW50TWV0YS5pc1NpZ25lcjtcbiAgICAgICAga2V5TWV0YS5pc1dyaXRhYmxlIHx8PSBhY2NvdW50TWV0YS5pc1dyaXRhYmxlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IENvbXBpbGVkS2V5cyhwYXllciwga2V5TWV0YU1hcCk7XG4gIH1cbiAgZ2V0TWVzc2FnZUNvbXBvbmVudHMoKSB7XG4gICAgY29uc3QgbWFwRW50cmllcyA9IFsuLi50aGlzLmtleU1ldGFNYXAuZW50cmllcygpXTtcbiAgICBhc3NlcnQobWFwRW50cmllcy5sZW5ndGggPD0gMjU2LCAnTWF4IHN0YXRpYyBhY2NvdW50IGtleXMgbGVuZ3RoIGV4Y2VlZGVkJyk7XG4gICAgY29uc3Qgd3JpdGFibGVTaWduZXJzID0gbWFwRW50cmllcy5maWx0ZXIoKFssIG1ldGFdKSA9PiBtZXRhLmlzU2lnbmVyICYmIG1ldGEuaXNXcml0YWJsZSk7XG4gICAgY29uc3QgcmVhZG9ubHlTaWduZXJzID0gbWFwRW50cmllcy5maWx0ZXIoKFssIG1ldGFdKSA9PiBtZXRhLmlzU2lnbmVyICYmICFtZXRhLmlzV3JpdGFibGUpO1xuICAgIGNvbnN0IHdyaXRhYmxlTm9uU2lnbmVycyA9IG1hcEVudHJpZXMuZmlsdGVyKChbLCBtZXRhXSkgPT4gIW1ldGEuaXNTaWduZXIgJiYgbWV0YS5pc1dyaXRhYmxlKTtcbiAgICBjb25zdCByZWFkb25seU5vblNpZ25lcnMgPSBtYXBFbnRyaWVzLmZpbHRlcigoWywgbWV0YV0pID0+ICFtZXRhLmlzU2lnbmVyICYmICFtZXRhLmlzV3JpdGFibGUpO1xuICAgIGNvbnN0IGhlYWRlciA9IHtcbiAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlczogd3JpdGFibGVTaWduZXJzLmxlbmd0aCArIHJlYWRvbmx5U2lnbmVycy5sZW5ndGgsXG4gICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzOiByZWFkb25seVNpZ25lcnMubGVuZ3RoLFxuICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzOiByZWFkb25seU5vblNpZ25lcnMubGVuZ3RoXG4gICAgfTtcblxuICAgIC8vIHNhbml0eSBjaGVja3NcbiAgICB7XG4gICAgICBhc3NlcnQod3JpdGFibGVTaWduZXJzLmxlbmd0aCA+IDAsICdFeHBlY3RlZCBhdCBsZWFzdCBvbmUgd3JpdGFibGUgc2lnbmVyIGtleScpO1xuICAgICAgY29uc3QgW3BheWVyQWRkcmVzc10gPSB3cml0YWJsZVNpZ25lcnNbMF07XG4gICAgICBhc3NlcnQocGF5ZXJBZGRyZXNzID09PSB0aGlzLnBheWVyLnRvQmFzZTU4KCksICdFeHBlY3RlZCBmaXJzdCB3cml0YWJsZSBzaWduZXIga2V5IHRvIGJlIHRoZSBmZWUgcGF5ZXInKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhdGljQWNjb3VudEtleXMgPSBbLi4ud3JpdGFibGVTaWduZXJzLm1hcCgoW2FkZHJlc3NdKSA9PiBuZXcgUHVibGljS2V5KGFkZHJlc3MpKSwgLi4ucmVhZG9ubHlTaWduZXJzLm1hcCgoW2FkZHJlc3NdKSA9PiBuZXcgUHVibGljS2V5KGFkZHJlc3MpKSwgLi4ud3JpdGFibGVOb25TaWduZXJzLm1hcCgoW2FkZHJlc3NdKSA9PiBuZXcgUHVibGljS2V5KGFkZHJlc3MpKSwgLi4ucmVhZG9ubHlOb25TaWduZXJzLm1hcCgoW2FkZHJlc3NdKSA9PiBuZXcgUHVibGljS2V5KGFkZHJlc3MpKV07XG4gICAgcmV0dXJuIFtoZWFkZXIsIHN0YXRpY0FjY291bnRLZXlzXTtcbiAgfVxuICBleHRyYWN0VGFibGVMb29rdXAobG9va3VwVGFibGUpIHtcbiAgICBjb25zdCBbd3JpdGFibGVJbmRleGVzLCBkcmFpbmVkV3JpdGFibGVLZXlzXSA9IHRoaXMuZHJhaW5LZXlzRm91bmRJbkxvb2t1cFRhYmxlKGxvb2t1cFRhYmxlLnN0YXRlLmFkZHJlc3Nlcywga2V5TWV0YSA9PiAha2V5TWV0YS5pc1NpZ25lciAmJiAha2V5TWV0YS5pc0ludm9rZWQgJiYga2V5TWV0YS5pc1dyaXRhYmxlKTtcbiAgICBjb25zdCBbcmVhZG9ubHlJbmRleGVzLCBkcmFpbmVkUmVhZG9ubHlLZXlzXSA9IHRoaXMuZHJhaW5LZXlzRm91bmRJbkxvb2t1cFRhYmxlKGxvb2t1cFRhYmxlLnN0YXRlLmFkZHJlc3Nlcywga2V5TWV0YSA9PiAha2V5TWV0YS5pc1NpZ25lciAmJiAha2V5TWV0YS5pc0ludm9rZWQgJiYgIWtleU1ldGEuaXNXcml0YWJsZSk7XG5cbiAgICAvLyBEb24ndCBleHRyYWN0IGxvb2t1cCBpZiBubyBrZXlzIHdlcmUgZm91bmRcbiAgICBpZiAod3JpdGFibGVJbmRleGVzLmxlbmd0aCA9PT0gMCAmJiByZWFkb25seUluZGV4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBbe1xuICAgICAgYWNjb3VudEtleTogbG9va3VwVGFibGUua2V5LFxuICAgICAgd3JpdGFibGVJbmRleGVzLFxuICAgICAgcmVhZG9ubHlJbmRleGVzXG4gICAgfSwge1xuICAgICAgd3JpdGFibGU6IGRyYWluZWRXcml0YWJsZUtleXMsXG4gICAgICByZWFkb25seTogZHJhaW5lZFJlYWRvbmx5S2V5c1xuICAgIH1dO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBkcmFpbktleXNGb3VuZEluTG9va3VwVGFibGUobG9va3VwVGFibGVFbnRyaWVzLCBrZXlNZXRhRmlsdGVyKSB7XG4gICAgY29uc3QgbG9va3VwVGFibGVJbmRleGVzID0gbmV3IEFycmF5KCk7XG4gICAgY29uc3QgZHJhaW5lZEtleXMgPSBuZXcgQXJyYXkoKTtcbiAgICBmb3IgKGNvbnN0IFthZGRyZXNzLCBrZXlNZXRhXSBvZiB0aGlzLmtleU1ldGFNYXAuZW50cmllcygpKSB7XG4gICAgICBpZiAoa2V5TWV0YUZpbHRlcihrZXlNZXRhKSkge1xuICAgICAgICBjb25zdCBrZXkgPSBuZXcgUHVibGljS2V5KGFkZHJlc3MpO1xuICAgICAgICBjb25zdCBsb29rdXBUYWJsZUluZGV4ID0gbG9va3VwVGFibGVFbnRyaWVzLmZpbmRJbmRleChlbnRyeSA9PiBlbnRyeS5lcXVhbHMoa2V5KSk7XG4gICAgICAgIGlmIChsb29rdXBUYWJsZUluZGV4ID49IDApIHtcbiAgICAgICAgICBhc3NlcnQobG9va3VwVGFibGVJbmRleCA8IDI1NiwgJ01heCBsb29rdXAgdGFibGUgaW5kZXggZXhjZWVkZWQnKTtcbiAgICAgICAgICBsb29rdXBUYWJsZUluZGV4ZXMucHVzaChsb29rdXBUYWJsZUluZGV4KTtcbiAgICAgICAgICBkcmFpbmVkS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgdGhpcy5rZXlNZXRhTWFwLmRlbGV0ZShhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2xvb2t1cFRhYmxlSW5kZXhlcywgZHJhaW5lZEtleXNdO1xuICB9XG59XG5cbmNvbnN0IEVORF9PRl9CVUZGRVJfRVJST1JfTUVTU0FHRSA9ICdSZWFjaGVkIGVuZCBvZiBidWZmZXIgdW5leHBlY3RlZGx5JztcblxuLyoqXG4gKiBEZWxlZ2F0ZXMgdG8gYEFycmF5I3NoaWZ0YCwgYnV0IHRocm93cyBpZiB0aGUgYXJyYXkgaXMgemVyby1sZW5ndGguXG4gKi9cbmZ1bmN0aW9uIGd1YXJkZWRTaGlmdChieXRlQXJyYXkpIHtcbiAgaWYgKGJ5dGVBcnJheS5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoRU5EX09GX0JVRkZFUl9FUlJPUl9NRVNTQUdFKTtcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5LnNoaWZ0KCk7XG59XG5cbi8qKlxuICogRGVsZWdhdGVzIHRvIGBBcnJheSNzcGxpY2VgLCBidXQgdGhyb3dzIGlmIHRoZSBzZWN0aW9uIGJlaW5nIHNwbGljZWQgb3V0IGV4dGVuZHMgcGFzdCB0aGUgZW5kIG9mXG4gKiB0aGUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAuLi5hcmdzKSB7XG4gIGNvbnN0IFtzdGFydF0gPSBhcmdzO1xuICBpZiAoYXJncy5sZW5ndGggPT09IDIgLy8gSW1wbGllcyB0aGF0IGBkZWxldGVDb3VudGAgd2FzIHN1cHBsaWVkXG4gID8gc3RhcnQgKyAoYXJnc1sxXSA/PyAwKSA+IGJ5dGVBcnJheS5sZW5ndGggOiBzdGFydCA+PSBieXRlQXJyYXkubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKEVORF9PRl9CVUZGRVJfRVJST1JfTUVTU0FHRSk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheS5zcGxpY2UoLi4uYXJncyk7XG59XG5cbi8qKlxuICogQW4gaW5zdHJ1Y3Rpb24gdG8gZXhlY3V0ZSBieSBhIHByb2dyYW1cbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0gcHJvZ3JhbUlkSW5kZXhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IGFjY291bnRzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGF0YVxuICovXG5cbi8qKlxuICogTWVzc2FnZSBjb25zdHJ1Y3RvciBhcmd1bWVudHNcbiAqL1xuXG4vKipcbiAqIExpc3Qgb2YgaW5zdHJ1Y3Rpb25zIHRvIGJlIHByb2Nlc3NlZCBhdG9taWNhbGx5XG4gKi9cbmNsYXNzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgdGhpcy5oZWFkZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5hY2NvdW50S2V5cyA9IHZvaWQgMDtcbiAgICB0aGlzLnJlY2VudEJsb2NraGFzaCA9IHZvaWQgMDtcbiAgICB0aGlzLmluc3RydWN0aW9ucyA9IHZvaWQgMDtcbiAgICB0aGlzLmluZGV4VG9Qcm9ncmFtSWRzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuaGVhZGVyID0gYXJncy5oZWFkZXI7XG4gICAgdGhpcy5hY2NvdW50S2V5cyA9IGFyZ3MuYWNjb3VudEtleXMubWFwKGFjY291bnQgPT4gbmV3IFB1YmxpY0tleShhY2NvdW50KSk7XG4gICAgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSBhcmdzLnJlY2VudEJsb2NraGFzaDtcbiAgICB0aGlzLmluc3RydWN0aW9ucyA9IGFyZ3MuaW5zdHJ1Y3Rpb25zO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLmZvckVhY2goaXggPT4gdGhpcy5pbmRleFRvUHJvZ3JhbUlkcy5zZXQoaXgucHJvZ3JhbUlkSW5kZXgsIHRoaXMuYWNjb3VudEtleXNbaXgucHJvZ3JhbUlkSW5kZXhdKSk7XG4gIH1cbiAgZ2V0IHZlcnNpb24oKSB7XG4gICAgcmV0dXJuICdsZWdhY3knO1xuICB9XG4gIGdldCBzdGF0aWNBY2NvdW50S2V5cygpIHtcbiAgICByZXR1cm4gdGhpcy5hY2NvdW50S2V5cztcbiAgfVxuICBnZXQgY29tcGlsZWRJbnN0cnVjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zdHJ1Y3Rpb25zLm1hcChpeCA9PiAoe1xuICAgICAgcHJvZ3JhbUlkSW5kZXg6IGl4LnByb2dyYW1JZEluZGV4LFxuICAgICAgYWNjb3VudEtleUluZGV4ZXM6IGl4LmFjY291bnRzLFxuICAgICAgZGF0YTogYnM1OC5kZWNvZGUoaXguZGF0YSlcbiAgICB9KSk7XG4gIH1cbiAgZ2V0IGFkZHJlc3NUYWJsZUxvb2t1cHMoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGdldEFjY291bnRLZXlzKCkge1xuICAgIHJldHVybiBuZXcgTWVzc2FnZUFjY291bnRLZXlzKHRoaXMuc3RhdGljQWNjb3VudEtleXMpO1xuICB9XG4gIHN0YXRpYyBjb21waWxlKGFyZ3MpIHtcbiAgICBjb25zdCBjb21waWxlZEtleXMgPSBDb21waWxlZEtleXMuY29tcGlsZShhcmdzLmluc3RydWN0aW9ucywgYXJncy5wYXllcktleSk7XG4gICAgY29uc3QgW2hlYWRlciwgc3RhdGljQWNjb3VudEtleXNdID0gY29tcGlsZWRLZXlzLmdldE1lc3NhZ2VDb21wb25lbnRzKCk7XG4gICAgY29uc3QgYWNjb3VudEtleXMgPSBuZXcgTWVzc2FnZUFjY291bnRLZXlzKHN0YXRpY0FjY291bnRLZXlzKTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbnMgPSBhY2NvdW50S2V5cy5jb21waWxlSW5zdHJ1Y3Rpb25zKGFyZ3MuaW5zdHJ1Y3Rpb25zKS5tYXAoaXggPT4gKHtcbiAgICAgIHByb2dyYW1JZEluZGV4OiBpeC5wcm9ncmFtSWRJbmRleCxcbiAgICAgIGFjY291bnRzOiBpeC5hY2NvdW50S2V5SW5kZXhlcyxcbiAgICAgIGRhdGE6IGJzNTguZW5jb2RlKGl4LmRhdGEpXG4gICAgfSkpO1xuICAgIHJldHVybiBuZXcgTWVzc2FnZSh7XG4gICAgICBoZWFkZXIsXG4gICAgICBhY2NvdW50S2V5czogc3RhdGljQWNjb3VudEtleXMsXG4gICAgICByZWNlbnRCbG9ja2hhc2g6IGFyZ3MucmVjZW50QmxvY2toYXNoLFxuICAgICAgaW5zdHJ1Y3Rpb25zXG4gICAgfSk7XG4gIH1cbiAgaXNBY2NvdW50U2lnbmVyKGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4IDwgdGhpcy5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzO1xuICB9XG4gIGlzQWNjb3VudFdyaXRhYmxlKGluZGV4KSB7XG4gICAgY29uc3QgbnVtU2lnbmVkQWNjb3VudHMgPSB0aGlzLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXM7XG4gICAgaWYgKGluZGV4ID49IHRoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcykge1xuICAgICAgY29uc3QgdW5zaWduZWRBY2NvdW50SW5kZXggPSBpbmRleCAtIG51bVNpZ25lZEFjY291bnRzO1xuICAgICAgY29uc3QgbnVtVW5zaWduZWRBY2NvdW50cyA9IHRoaXMuYWNjb3VudEtleXMubGVuZ3RoIC0gbnVtU2lnbmVkQWNjb3VudHM7XG4gICAgICBjb25zdCBudW1Xcml0YWJsZVVuc2lnbmVkQWNjb3VudHMgPSBudW1VbnNpZ25lZEFjY291bnRzIC0gdGhpcy5oZWFkZXIubnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzO1xuICAgICAgcmV0dXJuIHVuc2lnbmVkQWNjb3VudEluZGV4IDwgbnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBudW1Xcml0YWJsZVNpZ25lZEFjY291bnRzID0gbnVtU2lnbmVkQWNjb3VudHMgLSB0aGlzLmhlYWRlci5udW1SZWFkb25seVNpZ25lZEFjY291bnRzO1xuICAgICAgcmV0dXJuIGluZGV4IDwgbnVtV3JpdGFibGVTaWduZWRBY2NvdW50cztcbiAgICB9XG4gIH1cbiAgaXNQcm9ncmFtSWQoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleFRvUHJvZ3JhbUlkcy5oYXMoaW5kZXgpO1xuICB9XG4gIHByb2dyYW1JZHMoKSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLmluZGV4VG9Qcm9ncmFtSWRzLnZhbHVlcygpXTtcbiAgfVxuICBub25Qcm9ncmFtSWRzKCkge1xuICAgIHJldHVybiB0aGlzLmFjY291bnRLZXlzLmZpbHRlcigoXywgaW5kZXgpID0+ICF0aGlzLmlzUHJvZ3JhbUlkKGluZGV4KSk7XG4gIH1cbiAgc2VyaWFsaXplKCkge1xuICAgIGNvbnN0IG51bUtleXMgPSB0aGlzLmFjY291bnRLZXlzLmxlbmd0aDtcbiAgICBsZXQga2V5Q291bnQgPSBbXTtcbiAgICBlbmNvZGVMZW5ndGgoa2V5Q291bnQsIG51bUtleXMpO1xuICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IHRoaXMuaW5zdHJ1Y3Rpb25zLm1hcChpbnN0cnVjdGlvbiA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFjY291bnRzLFxuICAgICAgICBwcm9ncmFtSWRJbmRleFxuICAgICAgfSA9IGluc3RydWN0aW9uO1xuICAgICAgY29uc3QgZGF0YSA9IEFycmF5LmZyb20oYnM1OC5kZWNvZGUoaW5zdHJ1Y3Rpb24uZGF0YSkpO1xuICAgICAgbGV0IGtleUluZGljZXNDb3VudCA9IFtdO1xuICAgICAgZW5jb2RlTGVuZ3RoKGtleUluZGljZXNDb3VudCwgYWNjb3VudHMubGVuZ3RoKTtcbiAgICAgIGxldCBkYXRhQ291bnQgPSBbXTtcbiAgICAgIGVuY29kZUxlbmd0aChkYXRhQ291bnQsIGRhdGEubGVuZ3RoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb2dyYW1JZEluZGV4LFxuICAgICAgICBrZXlJbmRpY2VzQ291bnQ6IEJ1ZmZlci5mcm9tKGtleUluZGljZXNDb3VudCksXG4gICAgICAgIGtleUluZGljZXM6IGFjY291bnRzLFxuICAgICAgICBkYXRhTGVuZ3RoOiBCdWZmZXIuZnJvbShkYXRhQ291bnQpLFxuICAgICAgICBkYXRhXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGxldCBpbnN0cnVjdGlvbkNvdW50ID0gW107XG4gICAgZW5jb2RlTGVuZ3RoKGluc3RydWN0aW9uQ291bnQsIGluc3RydWN0aW9ucy5sZW5ndGgpO1xuICAgIGxldCBpbnN0cnVjdGlvbkJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhQQUNLRVRfREFUQV9TSVpFKTtcbiAgICBCdWZmZXIuZnJvbShpbnN0cnVjdGlvbkNvdW50KS5jb3B5KGluc3RydWN0aW9uQnVmZmVyKTtcbiAgICBsZXQgaW5zdHJ1Y3Rpb25CdWZmZXJMZW5ndGggPSBpbnN0cnVjdGlvbkNvdW50Lmxlbmd0aDtcbiAgICBpbnN0cnVjdGlvbnMuZm9yRWFjaChpbnN0cnVjdGlvbiA9PiB7XG4gICAgICBjb25zdCBpbnN0cnVjdGlvbkxheW91dCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgncHJvZ3JhbUlkSW5kZXgnKSwgQnVmZmVyTGF5b3V0LmJsb2IoaW5zdHJ1Y3Rpb24ua2V5SW5kaWNlc0NvdW50Lmxlbmd0aCwgJ2tleUluZGljZXNDb3VudCcpLCBCdWZmZXJMYXlvdXQuc2VxKEJ1ZmZlckxheW91dC51OCgna2V5SW5kZXgnKSwgaW5zdHJ1Y3Rpb24ua2V5SW5kaWNlcy5sZW5ndGgsICdrZXlJbmRpY2VzJyksIEJ1ZmZlckxheW91dC5ibG9iKGluc3RydWN0aW9uLmRhdGFMZW5ndGgubGVuZ3RoLCAnZGF0YUxlbmd0aCcpLCBCdWZmZXJMYXlvdXQuc2VxKEJ1ZmZlckxheW91dC51OCgndXNlcmRhdHVtJyksIGluc3RydWN0aW9uLmRhdGEubGVuZ3RoLCAnZGF0YScpXSk7XG4gICAgICBjb25zdCBsZW5ndGggPSBpbnN0cnVjdGlvbkxheW91dC5lbmNvZGUoaW5zdHJ1Y3Rpb24sIGluc3RydWN0aW9uQnVmZmVyLCBpbnN0cnVjdGlvbkJ1ZmZlckxlbmd0aCk7XG4gICAgICBpbnN0cnVjdGlvbkJ1ZmZlckxlbmd0aCArPSBsZW5ndGg7XG4gICAgfSk7XG4gICAgaW5zdHJ1Y3Rpb25CdWZmZXIgPSBpbnN0cnVjdGlvbkJ1ZmZlci5zbGljZSgwLCBpbnN0cnVjdGlvbkJ1ZmZlckxlbmd0aCk7XG4gICAgY29uc3Qgc2lnbkRhdGFMYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQuYmxvYigxLCAnbnVtUmVxdWlyZWRTaWduYXR1cmVzJyksIEJ1ZmZlckxheW91dC5ibG9iKDEsICdudW1SZWFkb25seVNpZ25lZEFjY291bnRzJyksIEJ1ZmZlckxheW91dC5ibG9iKDEsICdudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHMnKSwgQnVmZmVyTGF5b3V0LmJsb2Ioa2V5Q291bnQubGVuZ3RoLCAna2V5Q291bnQnKSwgQnVmZmVyTGF5b3V0LnNlcShwdWJsaWNLZXkoJ2tleScpLCBudW1LZXlzLCAna2V5cycpLCBwdWJsaWNLZXkoJ3JlY2VudEJsb2NraGFzaCcpXSk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSB7XG4gICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXM6IEJ1ZmZlci5mcm9tKFt0aGlzLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXNdKSxcbiAgICAgIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHM6IEJ1ZmZlci5mcm9tKFt0aGlzLmhlYWRlci5udW1SZWFkb25seVNpZ25lZEFjY291bnRzXSksXG4gICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM6IEJ1ZmZlci5mcm9tKFt0aGlzLmhlYWRlci5udW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHNdKSxcbiAgICAgIGtleUNvdW50OiBCdWZmZXIuZnJvbShrZXlDb3VudCksXG4gICAgICBrZXlzOiB0aGlzLmFjY291bnRLZXlzLm1hcChrZXkgPT4gdG9CdWZmZXIoa2V5LnRvQnl0ZXMoKSkpLFxuICAgICAgcmVjZW50QmxvY2toYXNoOiBiczU4LmRlY29kZSh0aGlzLnJlY2VudEJsb2NraGFzaClcbiAgICB9O1xuICAgIGxldCBzaWduRGF0YSA9IEJ1ZmZlci5hbGxvYygyMDQ4KTtcbiAgICBjb25zdCBsZW5ndGggPSBzaWduRGF0YUxheW91dC5lbmNvZGUodHJhbnNhY3Rpb24sIHNpZ25EYXRhKTtcbiAgICBpbnN0cnVjdGlvbkJ1ZmZlci5jb3B5KHNpZ25EYXRhLCBsZW5ndGgpO1xuICAgIHJldHVybiBzaWduRGF0YS5zbGljZSgwLCBsZW5ndGggKyBpbnN0cnVjdGlvbkJ1ZmZlci5sZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIGNvbXBpbGVkIG1lc3NhZ2UgaW50byBhIE1lc3NhZ2Ugb2JqZWN0LlxuICAgKi9cbiAgc3RhdGljIGZyb20oYnVmZmVyKSB7XG4gICAgLy8gU2xpY2UgdXAgd2lyZSBkYXRhXG4gICAgbGV0IGJ5dGVBcnJheSA9IFsuLi5idWZmZXJdO1xuICAgIGNvbnN0IG51bVJlcXVpcmVkU2lnbmF0dXJlcyA9IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpO1xuICAgIGlmIChudW1SZXF1aXJlZFNpZ25hdHVyZXMgIT09IChudW1SZXF1aXJlZFNpZ25hdHVyZXMgJiBWRVJTSU9OX1BSRUZJWF9NQVNLKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdWZXJzaW9uZWQgbWVzc2FnZXMgbXVzdCBiZSBkZXNlcmlhbGl6ZWQgd2l0aCBWZXJzaW9uZWRNZXNzYWdlLmRlc2VyaWFsaXplKCknKTtcbiAgICB9XG4gICAgY29uc3QgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cyA9IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpO1xuICAgIGNvbnN0IG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cyA9IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpO1xuICAgIGNvbnN0IGFjY291bnRDb3VudCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgIGxldCBhY2NvdW50S2V5cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWNjb3VudENvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGFjY291bnQgPSBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgUFVCTElDX0tFWV9MRU5HVEgpO1xuICAgICAgYWNjb3VudEtleXMucHVzaChuZXcgUHVibGljS2V5KEJ1ZmZlci5mcm9tKGFjY291bnQpKSk7XG4gICAgfVxuICAgIGNvbnN0IHJlY2VudEJsb2NraGFzaCA9IGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBQVUJMSUNfS0VZX0xFTkdUSCk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25Db3VudCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgIGxldCBpbnN0cnVjdGlvbnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluc3RydWN0aW9uQ291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcHJvZ3JhbUlkSW5kZXggPSBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IGFjY291bnRDb3VudCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgICAgY29uc3QgYWNjb3VudHMgPSBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgYWNjb3VudENvdW50KTtcbiAgICAgIGNvbnN0IGRhdGFMZW5ndGggPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IGRhdGFTbGljZSA9IGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBkYXRhTGVuZ3RoKTtcbiAgICAgIGNvbnN0IGRhdGEgPSBiczU4LmVuY29kZShCdWZmZXIuZnJvbShkYXRhU2xpY2UpKTtcbiAgICAgIGluc3RydWN0aW9ucy5wdXNoKHtcbiAgICAgICAgcHJvZ3JhbUlkSW5kZXgsXG4gICAgICAgIGFjY291bnRzLFxuICAgICAgICBkYXRhXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZUFyZ3MgPSB7XG4gICAgICBoZWFkZXI6IHtcbiAgICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzLFxuICAgICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzLFxuICAgICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHNcbiAgICAgIH0sXG4gICAgICByZWNlbnRCbG9ja2hhc2g6IGJzNTguZW5jb2RlKEJ1ZmZlci5mcm9tKHJlY2VudEJsb2NraGFzaCkpLFxuICAgICAgYWNjb3VudEtleXMsXG4gICAgICBpbnN0cnVjdGlvbnNcbiAgICB9O1xuICAgIHJldHVybiBuZXcgTWVzc2FnZShtZXNzYWdlQXJncyk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZXNzYWdlIGNvbnN0cnVjdG9yIGFyZ3VtZW50c1xuICovXG5cbmNsYXNzIE1lc3NhZ2VWMCB7XG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICB0aGlzLmhlYWRlciA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YXRpY0FjY291bnRLZXlzID0gdm9pZCAwO1xuICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gdm9pZCAwO1xuICAgIHRoaXMuY29tcGlsZWRJbnN0cnVjdGlvbnMgPSB2b2lkIDA7XG4gICAgdGhpcy5hZGRyZXNzVGFibGVMb29rdXBzID0gdm9pZCAwO1xuICAgIHRoaXMuaGVhZGVyID0gYXJncy5oZWFkZXI7XG4gICAgdGhpcy5zdGF0aWNBY2NvdW50S2V5cyA9IGFyZ3Muc3RhdGljQWNjb3VudEtleXM7XG4gICAgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSBhcmdzLnJlY2VudEJsb2NraGFzaDtcbiAgICB0aGlzLmNvbXBpbGVkSW5zdHJ1Y3Rpb25zID0gYXJncy5jb21waWxlZEluc3RydWN0aW9ucztcbiAgICB0aGlzLmFkZHJlc3NUYWJsZUxvb2t1cHMgPSBhcmdzLmFkZHJlc3NUYWJsZUxvb2t1cHM7XG4gIH1cbiAgZ2V0IHZlcnNpb24oKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZ2V0IG51bUFjY291bnRLZXlzRnJvbUxvb2t1cHMoKSB7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBmb3IgKGNvbnN0IGxvb2t1cCBvZiB0aGlzLmFkZHJlc3NUYWJsZUxvb2t1cHMpIHtcbiAgICAgIGNvdW50ICs9IGxvb2t1cC5yZWFkb25seUluZGV4ZXMubGVuZ3RoICsgbG9va3VwLndyaXRhYmxlSW5kZXhlcy5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBjb3VudDtcbiAgfVxuICBnZXRBY2NvdW50S2V5cyhhcmdzKSB7XG4gICAgbGV0IGFjY291bnRLZXlzRnJvbUxvb2t1cHM7XG4gICAgaWYgKGFyZ3MgJiYgJ2FjY291bnRLZXlzRnJvbUxvb2t1cHMnIGluIGFyZ3MgJiYgYXJncy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzKSB7XG4gICAgICBpZiAodGhpcy5udW1BY2NvdW50S2V5c0Zyb21Mb29rdXBzICE9IGFyZ3MuYWNjb3VudEtleXNGcm9tTG9va3Vwcy53cml0YWJsZS5sZW5ndGggKyBhcmdzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMucmVhZG9ubHkubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBhY2NvdW50IGtleXMgYmVjYXVzZSBvZiBhIG1pc21hdGNoIGluIHRoZSBudW1iZXIgb2YgYWNjb3VudCBrZXlzIGZyb20gbG9va3VwcycpO1xuICAgICAgfVxuICAgICAgYWNjb3VudEtleXNGcm9tTG9va3VwcyA9IGFyZ3MuYWNjb3VudEtleXNGcm9tTG9va3VwcztcbiAgICB9IGVsc2UgaWYgKGFyZ3MgJiYgJ2FkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzJyBpbiBhcmdzICYmIGFyZ3MuYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHMpIHtcbiAgICAgIGFjY291bnRLZXlzRnJvbUxvb2t1cHMgPSB0aGlzLnJlc29sdmVBZGRyZXNzVGFibGVMb29rdXBzKGFyZ3MuYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hZGRyZXNzVGFibGVMb29rdXBzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBhY2NvdW50IGtleXMgYmVjYXVzZSBhZGRyZXNzIHRhYmxlIGxvb2t1cHMgd2VyZSBub3QgcmVzb2x2ZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBNZXNzYWdlQWNjb3VudEtleXModGhpcy5zdGF0aWNBY2NvdW50S2V5cywgYWNjb3VudEtleXNGcm9tTG9va3Vwcyk7XG4gIH1cbiAgaXNBY2NvdW50U2lnbmVyKGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4IDwgdGhpcy5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzO1xuICB9XG4gIGlzQWNjb3VudFdyaXRhYmxlKGluZGV4KSB7XG4gICAgY29uc3QgbnVtU2lnbmVkQWNjb3VudHMgPSB0aGlzLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXM7XG4gICAgY29uc3QgbnVtU3RhdGljQWNjb3VudEtleXMgPSB0aGlzLnN0YXRpY0FjY291bnRLZXlzLmxlbmd0aDtcbiAgICBpZiAoaW5kZXggPj0gbnVtU3RhdGljQWNjb3VudEtleXMpIHtcbiAgICAgIGNvbnN0IGxvb2t1cEFjY291bnRLZXlzSW5kZXggPSBpbmRleCAtIG51bVN0YXRpY0FjY291bnRLZXlzO1xuICAgICAgY29uc3QgbnVtV3JpdGFibGVMb29rdXBBY2NvdW50S2V5cyA9IHRoaXMuYWRkcmVzc1RhYmxlTG9va3Vwcy5yZWR1Y2UoKGNvdW50LCBsb29rdXApID0+IGNvdW50ICsgbG9va3VwLndyaXRhYmxlSW5kZXhlcy5sZW5ndGgsIDApO1xuICAgICAgcmV0dXJuIGxvb2t1cEFjY291bnRLZXlzSW5kZXggPCBudW1Xcml0YWJsZUxvb2t1cEFjY291bnRLZXlzO1xuICAgIH0gZWxzZSBpZiAoaW5kZXggPj0gdGhpcy5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzKSB7XG4gICAgICBjb25zdCB1bnNpZ25lZEFjY291bnRJbmRleCA9IGluZGV4IC0gbnVtU2lnbmVkQWNjb3VudHM7XG4gICAgICBjb25zdCBudW1VbnNpZ25lZEFjY291bnRzID0gbnVtU3RhdGljQWNjb3VudEtleXMgLSBudW1TaWduZWRBY2NvdW50cztcbiAgICAgIGNvbnN0IG51bVdyaXRhYmxlVW5zaWduZWRBY2NvdW50cyA9IG51bVVuc2lnbmVkQWNjb3VudHMgLSB0aGlzLmhlYWRlci5udW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM7XG4gICAgICByZXR1cm4gdW5zaWduZWRBY2NvdW50SW5kZXggPCBudW1Xcml0YWJsZVVuc2lnbmVkQWNjb3VudHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG51bVdyaXRhYmxlU2lnbmVkQWNjb3VudHMgPSBudW1TaWduZWRBY2NvdW50cyAtIHRoaXMuaGVhZGVyLm51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHM7XG4gICAgICByZXR1cm4gaW5kZXggPCBudW1Xcml0YWJsZVNpZ25lZEFjY291bnRzO1xuICAgIH1cbiAgfVxuICByZXNvbHZlQWRkcmVzc1RhYmxlTG9va3VwcyhhZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cykge1xuICAgIGNvbnN0IGFjY291bnRLZXlzRnJvbUxvb2t1cHMgPSB7XG4gICAgICB3cml0YWJsZTogW10sXG4gICAgICByZWFkb25seTogW11cbiAgICB9O1xuICAgIGZvciAoY29uc3QgdGFibGVMb29rdXAgb2YgdGhpcy5hZGRyZXNzVGFibGVMb29rdXBzKSB7XG4gICAgICBjb25zdCB0YWJsZUFjY291bnQgPSBhZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cy5maW5kKGFjY291bnQgPT4gYWNjb3VudC5rZXkuZXF1YWxzKHRhYmxlTG9va3VwLmFjY291bnRLZXkpKTtcbiAgICAgIGlmICghdGFibGVBY2NvdW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZpbmQgYWRkcmVzcyBsb29rdXAgdGFibGUgYWNjb3VudCBmb3IgdGFibGUga2V5ICR7dGFibGVMb29rdXAuYWNjb3VudEtleS50b0Jhc2U1OCgpfWApO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBpbmRleCBvZiB0YWJsZUxvb2t1cC53cml0YWJsZUluZGV4ZXMpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgdGFibGVBY2NvdW50LnN0YXRlLmFkZHJlc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgICBhY2NvdW50S2V5c0Zyb21Mb29rdXBzLndyaXRhYmxlLnB1c2godGFibGVBY2NvdW50LnN0YXRlLmFkZHJlc3Nlc1tpbmRleF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZpbmQgYWRkcmVzcyBmb3IgaW5kZXggJHtpbmRleH0gaW4gYWRkcmVzcyBsb29rdXAgdGFibGUgJHt0YWJsZUxvb2t1cC5hY2NvdW50S2V5LnRvQmFzZTU4KCl9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgdGFibGVMb29rdXAucmVhZG9ubHlJbmRleGVzKSB7XG4gICAgICAgIGlmIChpbmRleCA8IHRhYmxlQWNjb3VudC5zdGF0ZS5hZGRyZXNzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgYWNjb3VudEtleXNGcm9tTG9va3Vwcy5yZWFkb25seS5wdXNoKHRhYmxlQWNjb3VudC5zdGF0ZS5hZGRyZXNzZXNbaW5kZXhdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmaW5kIGFkZHJlc3MgZm9yIGluZGV4ICR7aW5kZXh9IGluIGFkZHJlc3MgbG9va3VwIHRhYmxlICR7dGFibGVMb29rdXAuYWNjb3VudEtleS50b0Jhc2U1OCgpfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhY2NvdW50S2V5c0Zyb21Mb29rdXBzO1xuICB9XG4gIHN0YXRpYyBjb21waWxlKGFyZ3MpIHtcbiAgICBjb25zdCBjb21waWxlZEtleXMgPSBDb21waWxlZEtleXMuY29tcGlsZShhcmdzLmluc3RydWN0aW9ucywgYXJncy5wYXllcktleSk7XG4gICAgY29uc3QgYWRkcmVzc1RhYmxlTG9va3VwcyA9IG5ldyBBcnJheSgpO1xuICAgIGNvbnN0IGFjY291bnRLZXlzRnJvbUxvb2t1cHMgPSB7XG4gICAgICB3cml0YWJsZTogbmV3IEFycmF5KCksXG4gICAgICByZWFkb25seTogbmV3IEFycmF5KClcbiAgICB9O1xuICAgIGNvbnN0IGxvb2t1cFRhYmxlQWNjb3VudHMgPSBhcmdzLmFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzIHx8IFtdO1xuICAgIGZvciAoY29uc3QgbG9va3VwVGFibGUgb2YgbG9va3VwVGFibGVBY2NvdW50cykge1xuICAgICAgY29uc3QgZXh0cmFjdFJlc3VsdCA9IGNvbXBpbGVkS2V5cy5leHRyYWN0VGFibGVMb29rdXAobG9va3VwVGFibGUpO1xuICAgICAgaWYgKGV4dHJhY3RSZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBbYWRkcmVzc1RhYmxlTG9va3VwLCB7XG4gICAgICAgICAgd3JpdGFibGUsXG4gICAgICAgICAgcmVhZG9ubHlcbiAgICAgICAgfV0gPSBleHRyYWN0UmVzdWx0O1xuICAgICAgICBhZGRyZXNzVGFibGVMb29rdXBzLnB1c2goYWRkcmVzc1RhYmxlTG9va3VwKTtcbiAgICAgICAgYWNjb3VudEtleXNGcm9tTG9va3Vwcy53cml0YWJsZS5wdXNoKC4uLndyaXRhYmxlKTtcbiAgICAgICAgYWNjb3VudEtleXNGcm9tTG9va3Vwcy5yZWFkb25seS5wdXNoKC4uLnJlYWRvbmx5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgW2hlYWRlciwgc3RhdGljQWNjb3VudEtleXNdID0gY29tcGlsZWRLZXlzLmdldE1lc3NhZ2VDb21wb25lbnRzKCk7XG4gICAgY29uc3QgYWNjb3VudEtleXMgPSBuZXcgTWVzc2FnZUFjY291bnRLZXlzKHN0YXRpY0FjY291bnRLZXlzLCBhY2NvdW50S2V5c0Zyb21Mb29rdXBzKTtcbiAgICBjb25zdCBjb21waWxlZEluc3RydWN0aW9ucyA9IGFjY291bnRLZXlzLmNvbXBpbGVJbnN0cnVjdGlvbnMoYXJncy5pbnN0cnVjdGlvbnMpO1xuICAgIHJldHVybiBuZXcgTWVzc2FnZVYwKHtcbiAgICAgIGhlYWRlcixcbiAgICAgIHN0YXRpY0FjY291bnRLZXlzLFxuICAgICAgcmVjZW50QmxvY2toYXNoOiBhcmdzLnJlY2VudEJsb2NraGFzaCxcbiAgICAgIGNvbXBpbGVkSW5zdHJ1Y3Rpb25zLFxuICAgICAgYWRkcmVzc1RhYmxlTG9va3Vwc1xuICAgIH0pO1xuICB9XG4gIHNlcmlhbGl6ZSgpIHtcbiAgICBjb25zdCBlbmNvZGVkU3RhdGljQWNjb3VudEtleXNMZW5ndGggPSBBcnJheSgpO1xuICAgIGVuY29kZUxlbmd0aChlbmNvZGVkU3RhdGljQWNjb3VudEtleXNMZW5ndGgsIHRoaXMuc3RhdGljQWNjb3VudEtleXMubGVuZ3RoKTtcbiAgICBjb25zdCBzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zID0gdGhpcy5zZXJpYWxpemVJbnN0cnVjdGlvbnMoKTtcbiAgICBjb25zdCBlbmNvZGVkSW5zdHJ1Y3Rpb25zTGVuZ3RoID0gQXJyYXkoKTtcbiAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZEluc3RydWN0aW9uc0xlbmd0aCwgdGhpcy5jb21waWxlZEluc3RydWN0aW9ucy5sZW5ndGgpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzID0gdGhpcy5zZXJpYWxpemVBZGRyZXNzVGFibGVMb29rdXBzKCk7XG4gICAgY29uc3QgZW5jb2RlZEFkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGggPSBBcnJheSgpO1xuICAgIGVuY29kZUxlbmd0aChlbmNvZGVkQWRkcmVzc1RhYmxlTG9va3Vwc0xlbmd0aCwgdGhpcy5hZGRyZXNzVGFibGVMb29rdXBzLmxlbmd0aCk7XG4gICAgY29uc3QgbWVzc2FnZUxheW91dCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgncHJlZml4JyksIEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgnbnVtUmVxdWlyZWRTaWduYXR1cmVzJyksIEJ1ZmZlckxheW91dC51OCgnbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cycpLCBCdWZmZXJMYXlvdXQudTgoJ251bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cycpXSwgJ2hlYWRlcicpLCBCdWZmZXJMYXlvdXQuYmxvYihlbmNvZGVkU3RhdGljQWNjb3VudEtleXNMZW5ndGgubGVuZ3RoLCAnc3RhdGljQWNjb3VudEtleXNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LnNlcShwdWJsaWNLZXkoKSwgdGhpcy5zdGF0aWNBY2NvdW50S2V5cy5sZW5ndGgsICdzdGF0aWNBY2NvdW50S2V5cycpLCBwdWJsaWNLZXkoJ3JlY2VudEJsb2NraGFzaCcpLCBCdWZmZXJMYXlvdXQuYmxvYihlbmNvZGVkSW5zdHJ1Y3Rpb25zTGVuZ3RoLmxlbmd0aCwgJ2luc3RydWN0aW9uc0xlbmd0aCcpLCBCdWZmZXJMYXlvdXQuYmxvYihzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zLmxlbmd0aCwgJ3NlcmlhbGl6ZWRJbnN0cnVjdGlvbnMnKSwgQnVmZmVyTGF5b3V0LmJsb2IoZW5jb2RlZEFkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGgubGVuZ3RoLCAnYWRkcmVzc1RhYmxlTG9va3Vwc0xlbmd0aCcpLCBCdWZmZXJMYXlvdXQuYmxvYihzZXJpYWxpemVkQWRkcmVzc1RhYmxlTG9va3Vwcy5sZW5ndGgsICdzZXJpYWxpemVkQWRkcmVzc1RhYmxlTG9va3VwcycpXSk7XG4gICAgY29uc3Qgc2VyaWFsaXplZE1lc3NhZ2UgPSBuZXcgVWludDhBcnJheShQQUNLRVRfREFUQV9TSVpFKTtcbiAgICBjb25zdCBNRVNTQUdFX1ZFUlNJT05fMF9QUkVGSVggPSAxIDw8IDc7XG4gICAgY29uc3Qgc2VyaWFsaXplZE1lc3NhZ2VMZW5ndGggPSBtZXNzYWdlTGF5b3V0LmVuY29kZSh7XG4gICAgICBwcmVmaXg6IE1FU1NBR0VfVkVSU0lPTl8wX1BSRUZJWCxcbiAgICAgIGhlYWRlcjogdGhpcy5oZWFkZXIsXG4gICAgICBzdGF0aWNBY2NvdW50S2V5c0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZFN0YXRpY0FjY291bnRLZXlzTGVuZ3RoKSxcbiAgICAgIHN0YXRpY0FjY291bnRLZXlzOiB0aGlzLnN0YXRpY0FjY291bnRLZXlzLm1hcChrZXkgPT4ga2V5LnRvQnl0ZXMoKSksXG4gICAgICByZWNlbnRCbG9ja2hhc2g6IGJzNTguZGVjb2RlKHRoaXMucmVjZW50QmxvY2toYXNoKSxcbiAgICAgIGluc3RydWN0aW9uc0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZEluc3RydWN0aW9uc0xlbmd0aCksXG4gICAgICBzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zLFxuICAgICAgYWRkcmVzc1RhYmxlTG9va3Vwc0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZEFkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGgpLFxuICAgICAgc2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHNcbiAgICB9LCBzZXJpYWxpemVkTWVzc2FnZSk7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWRNZXNzYWdlLnNsaWNlKDAsIHNlcmlhbGl6ZWRNZXNzYWdlTGVuZ3RoKTtcbiAgfVxuICBzZXJpYWxpemVJbnN0cnVjdGlvbnMoKSB7XG4gICAgbGV0IHNlcmlhbGl6ZWRMZW5ndGggPSAwO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRJbnN0cnVjdGlvbnMgPSBuZXcgVWludDhBcnJheShQQUNLRVRfREFUQV9TSVpFKTtcbiAgICBmb3IgKGNvbnN0IGluc3RydWN0aW9uIG9mIHRoaXMuY29tcGlsZWRJbnN0cnVjdGlvbnMpIHtcbiAgICAgIGNvbnN0IGVuY29kZWRBY2NvdW50S2V5SW5kZXhlc0xlbmd0aCA9IEFycmF5KCk7XG4gICAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZEFjY291bnRLZXlJbmRleGVzTGVuZ3RoLCBpbnN0cnVjdGlvbi5hY2NvdW50S2V5SW5kZXhlcy5sZW5ndGgpO1xuICAgICAgY29uc3QgZW5jb2RlZERhdGFMZW5ndGggPSBBcnJheSgpO1xuICAgICAgZW5jb2RlTGVuZ3RoKGVuY29kZWREYXRhTGVuZ3RoLCBpbnN0cnVjdGlvbi5kYXRhLmxlbmd0aCk7XG4gICAgICBjb25zdCBpbnN0cnVjdGlvbkxheW91dCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgncHJvZ3JhbUlkSW5kZXgnKSwgQnVmZmVyTGF5b3V0LmJsb2IoZW5jb2RlZEFjY291bnRLZXlJbmRleGVzTGVuZ3RoLmxlbmd0aCwgJ2VuY29kZWRBY2NvdW50S2V5SW5kZXhlc0xlbmd0aCcpLCBCdWZmZXJMYXlvdXQuc2VxKEJ1ZmZlckxheW91dC51OCgpLCBpbnN0cnVjdGlvbi5hY2NvdW50S2V5SW5kZXhlcy5sZW5ndGgsICdhY2NvdW50S2V5SW5kZXhlcycpLCBCdWZmZXJMYXlvdXQuYmxvYihlbmNvZGVkRGF0YUxlbmd0aC5sZW5ndGgsICdlbmNvZGVkRGF0YUxlbmd0aCcpLCBCdWZmZXJMYXlvdXQuYmxvYihpbnN0cnVjdGlvbi5kYXRhLmxlbmd0aCwgJ2RhdGEnKV0pO1xuICAgICAgc2VyaWFsaXplZExlbmd0aCArPSBpbnN0cnVjdGlvbkxheW91dC5lbmNvZGUoe1xuICAgICAgICBwcm9ncmFtSWRJbmRleDogaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkSW5kZXgsXG4gICAgICAgIGVuY29kZWRBY2NvdW50S2V5SW5kZXhlc0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZEFjY291bnRLZXlJbmRleGVzTGVuZ3RoKSxcbiAgICAgICAgYWNjb3VudEtleUluZGV4ZXM6IGluc3RydWN0aW9uLmFjY291bnRLZXlJbmRleGVzLFxuICAgICAgICBlbmNvZGVkRGF0YUxlbmd0aDogbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZERhdGFMZW5ndGgpLFxuICAgICAgICBkYXRhOiBpbnN0cnVjdGlvbi5kYXRhXG4gICAgICB9LCBzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zLCBzZXJpYWxpemVkTGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWRJbnN0cnVjdGlvbnMuc2xpY2UoMCwgc2VyaWFsaXplZExlbmd0aCk7XG4gIH1cbiAgc2VyaWFsaXplQWRkcmVzc1RhYmxlTG9va3VwcygpIHtcbiAgICBsZXQgc2VyaWFsaXplZExlbmd0aCA9IDA7XG4gICAgY29uc3Qgc2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHMgPSBuZXcgVWludDhBcnJheShQQUNLRVRfREFUQV9TSVpFKTtcbiAgICBmb3IgKGNvbnN0IGxvb2t1cCBvZiB0aGlzLmFkZHJlc3NUYWJsZUxvb2t1cHMpIHtcbiAgICAgIGNvbnN0IGVuY29kZWRXcml0YWJsZUluZGV4ZXNMZW5ndGggPSBBcnJheSgpO1xuICAgICAgZW5jb2RlTGVuZ3RoKGVuY29kZWRXcml0YWJsZUluZGV4ZXNMZW5ndGgsIGxvb2t1cC53cml0YWJsZUluZGV4ZXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IGVuY29kZWRSZWFkb25seUluZGV4ZXNMZW5ndGggPSBBcnJheSgpO1xuICAgICAgZW5jb2RlTGVuZ3RoKGVuY29kZWRSZWFkb25seUluZGV4ZXNMZW5ndGgsIGxvb2t1cC5yZWFkb25seUluZGV4ZXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IGFkZHJlc3NUYWJsZUxvb2t1cExheW91dCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW3B1YmxpY0tleSgnYWNjb3VudEtleScpLCBCdWZmZXJMYXlvdXQuYmxvYihlbmNvZGVkV3JpdGFibGVJbmRleGVzTGVuZ3RoLmxlbmd0aCwgJ2VuY29kZWRXcml0YWJsZUluZGV4ZXNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQudTgoKSwgbG9va3VwLndyaXRhYmxlSW5kZXhlcy5sZW5ndGgsICd3cml0YWJsZUluZGV4ZXMnKSwgQnVmZmVyTGF5b3V0LmJsb2IoZW5jb2RlZFJlYWRvbmx5SW5kZXhlc0xlbmd0aC5sZW5ndGgsICdlbmNvZGVkUmVhZG9ubHlJbmRleGVzTGVuZ3RoJyksIEJ1ZmZlckxheW91dC5zZXEoQnVmZmVyTGF5b3V0LnU4KCksIGxvb2t1cC5yZWFkb25seUluZGV4ZXMubGVuZ3RoLCAncmVhZG9ubHlJbmRleGVzJyldKTtcbiAgICAgIHNlcmlhbGl6ZWRMZW5ndGggKz0gYWRkcmVzc1RhYmxlTG9va3VwTGF5b3V0LmVuY29kZSh7XG4gICAgICAgIGFjY291bnRLZXk6IGxvb2t1cC5hY2NvdW50S2V5LnRvQnl0ZXMoKSxcbiAgICAgICAgZW5jb2RlZFdyaXRhYmxlSW5kZXhlc0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZFdyaXRhYmxlSW5kZXhlc0xlbmd0aCksXG4gICAgICAgIHdyaXRhYmxlSW5kZXhlczogbG9va3VwLndyaXRhYmxlSW5kZXhlcyxcbiAgICAgICAgZW5jb2RlZFJlYWRvbmx5SW5kZXhlc0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZFJlYWRvbmx5SW5kZXhlc0xlbmd0aCksXG4gICAgICAgIHJlYWRvbmx5SW5kZXhlczogbG9va3VwLnJlYWRvbmx5SW5kZXhlc1xuICAgICAgfSwgc2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHMsIHNlcmlhbGl6ZWRMZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHMuc2xpY2UoMCwgc2VyaWFsaXplZExlbmd0aCk7XG4gIH1cbiAgc3RhdGljIGRlc2VyaWFsaXplKHNlcmlhbGl6ZWRNZXNzYWdlKSB7XG4gICAgbGV0IGJ5dGVBcnJheSA9IFsuLi5zZXJpYWxpemVkTWVzc2FnZV07XG4gICAgY29uc3QgcHJlZml4ID0gZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSk7XG4gICAgY29uc3QgbWFza2VkUHJlZml4ID0gcHJlZml4ICYgVkVSU0lPTl9QUkVGSVhfTUFTSztcbiAgICBhc3NlcnQocHJlZml4ICE9PSBtYXNrZWRQcmVmaXgsIGBFeHBlY3RlZCB2ZXJzaW9uZWQgbWVzc2FnZSBidXQgcmVjZWl2ZWQgbGVnYWN5IG1lc3NhZ2VgKTtcbiAgICBjb25zdCB2ZXJzaW9uID0gbWFza2VkUHJlZml4O1xuICAgIGFzc2VydCh2ZXJzaW9uID09PSAwLCBgRXhwZWN0ZWQgdmVyc2lvbmVkIG1lc3NhZ2Ugd2l0aCB2ZXJzaW9uIDAgYnV0IGZvdW5kIHZlcnNpb24gJHt2ZXJzaW9ufWApO1xuICAgIGNvbnN0IGhlYWRlciA9IHtcbiAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlczogZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSksXG4gICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzOiBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KSxcbiAgICAgIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50czogZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSlcbiAgICB9O1xuICAgIGNvbnN0IHN0YXRpY0FjY291bnRLZXlzID0gW107XG4gICAgY29uc3Qgc3RhdGljQWNjb3VudEtleXNMZW5ndGggPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRpY0FjY291bnRLZXlzTGVuZ3RoOyBpKyspIHtcbiAgICAgIHN0YXRpY0FjY291bnRLZXlzLnB1c2gobmV3IFB1YmxpY0tleShndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgUFVCTElDX0tFWV9MRU5HVEgpKSk7XG4gICAgfVxuICAgIGNvbnN0IHJlY2VudEJsb2NraGFzaCA9IGJzNTguZW5jb2RlKGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBQVUJMSUNfS0VZX0xFTkdUSCkpO1xuICAgIGNvbnN0IGluc3RydWN0aW9uQ291bnQgPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICBjb25zdCBjb21waWxlZEluc3RydWN0aW9ucyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5zdHJ1Y3Rpb25Db3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBwcm9ncmFtSWRJbmRleCA9IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpO1xuICAgICAgY29uc3QgYWNjb3VudEtleUluZGV4ZXNMZW5ndGggPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IGFjY291bnRLZXlJbmRleGVzID0gZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIGFjY291bnRLZXlJbmRleGVzTGVuZ3RoKTtcbiAgICAgIGNvbnN0IGRhdGFMZW5ndGggPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgZGF0YUxlbmd0aCkpO1xuICAgICAgY29tcGlsZWRJbnN0cnVjdGlvbnMucHVzaCh7XG4gICAgICAgIHByb2dyYW1JZEluZGV4LFxuICAgICAgICBhY2NvdW50S2V5SW5kZXhlcyxcbiAgICAgICAgZGF0YVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGFkZHJlc3NUYWJsZUxvb2t1cHNDb3VudCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgIGNvbnN0IGFkZHJlc3NUYWJsZUxvb2t1cHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFkZHJlc3NUYWJsZUxvb2t1cHNDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBhY2NvdW50S2V5ID0gbmV3IFB1YmxpY0tleShndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgUFVCTElDX0tFWV9MRU5HVEgpKTtcbiAgICAgIGNvbnN0IHdyaXRhYmxlSW5kZXhlc0xlbmd0aCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgICAgY29uc3Qgd3JpdGFibGVJbmRleGVzID0gZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIHdyaXRhYmxlSW5kZXhlc0xlbmd0aCk7XG4gICAgICBjb25zdCByZWFkb25seUluZGV4ZXNMZW5ndGggPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IHJlYWRvbmx5SW5kZXhlcyA9IGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCByZWFkb25seUluZGV4ZXNMZW5ndGgpO1xuICAgICAgYWRkcmVzc1RhYmxlTG9va3Vwcy5wdXNoKHtcbiAgICAgICAgYWNjb3VudEtleSxcbiAgICAgICAgd3JpdGFibGVJbmRleGVzLFxuICAgICAgICByZWFkb25seUluZGV4ZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE1lc3NhZ2VWMCh7XG4gICAgICBoZWFkZXIsXG4gICAgICBzdGF0aWNBY2NvdW50S2V5cyxcbiAgICAgIHJlY2VudEJsb2NraGFzaCxcbiAgICAgIGNvbXBpbGVkSW5zdHJ1Y3Rpb25zLFxuICAgICAgYWRkcmVzc1RhYmxlTG9va3Vwc1xuICAgIH0pO1xuICB9XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbmNvbnN0IFZlcnNpb25lZE1lc3NhZ2UgPSB7XG4gIGRlc2VyaWFsaXplTWVzc2FnZVZlcnNpb24oc2VyaWFsaXplZE1lc3NhZ2UpIHtcbiAgICBjb25zdCBwcmVmaXggPSBzZXJpYWxpemVkTWVzc2FnZVswXTtcbiAgICBjb25zdCBtYXNrZWRQcmVmaXggPSBwcmVmaXggJiBWRVJTSU9OX1BSRUZJWF9NQVNLO1xuXG4gICAgLy8gaWYgdGhlIGhpZ2hlc3QgYml0IG9mIHRoZSBwcmVmaXggaXMgbm90IHNldCwgdGhlIG1lc3NhZ2UgaXMgbm90IHZlcnNpb25lZFxuICAgIGlmIChtYXNrZWRQcmVmaXggPT09IHByZWZpeCkge1xuICAgICAgcmV0dXJuICdsZWdhY3knO1xuICAgIH1cblxuICAgIC8vIHRoZSBsb3dlciA3IGJpdHMgb2YgdGhlIHByZWZpeCBpbmRpY2F0ZSB0aGUgbWVzc2FnZSB2ZXJzaW9uXG4gICAgcmV0dXJuIG1hc2tlZFByZWZpeDtcbiAgfSxcbiAgZGVzZXJpYWxpemU6IHNlcmlhbGl6ZWRNZXNzYWdlID0+IHtcbiAgICBjb25zdCB2ZXJzaW9uID0gVmVyc2lvbmVkTWVzc2FnZS5kZXNlcmlhbGl6ZU1lc3NhZ2VWZXJzaW9uKHNlcmlhbGl6ZWRNZXNzYWdlKTtcbiAgICBpZiAodmVyc2lvbiA9PT0gJ2xlZ2FjeScpIHtcbiAgICAgIHJldHVybiBNZXNzYWdlLmZyb20oc2VyaWFsaXplZE1lc3NhZ2UpO1xuICAgIH1cbiAgICBpZiAodmVyc2lvbiA9PT0gMCkge1xuICAgICAgcmV0dXJuIE1lc3NhZ2VWMC5kZXNlcmlhbGl6ZShzZXJpYWxpemVkTWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gbWVzc2FnZSB2ZXJzaW9uICR7dmVyc2lvbn0gZGVzZXJpYWxpemF0aW9uIGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKiBAaW50ZXJuYWwgKi9cblxuLyoqXG4gKiBUcmFuc2FjdGlvbiBzaWduYXR1cmUgYXMgYmFzZS01OCBlbmNvZGVkIHN0cmluZ1xuICovXG5cbmxldCBUcmFuc2FjdGlvblN0YXR1cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoVHJhbnNhY3Rpb25TdGF0dXMpIHtcbiAgVHJhbnNhY3Rpb25TdGF0dXNbVHJhbnNhY3Rpb25TdGF0dXNbXCJCTE9DS0hFSUdIVF9FWENFRURFRFwiXSA9IDBdID0gXCJCTE9DS0hFSUdIVF9FWENFRURFRFwiO1xuICBUcmFuc2FjdGlvblN0YXR1c1tUcmFuc2FjdGlvblN0YXR1c1tcIlBST0NFU1NFRFwiXSA9IDFdID0gXCJQUk9DRVNTRURcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXNbVHJhbnNhY3Rpb25TdGF0dXNbXCJUSU1FRF9PVVRcIl0gPSAyXSA9IFwiVElNRURfT1VUXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzW1RyYW5zYWN0aW9uU3RhdHVzW1wiTk9OQ0VfSU5WQUxJRFwiXSA9IDNdID0gXCJOT05DRV9JTlZBTElEXCI7XG4gIHJldHVybiBUcmFuc2FjdGlvblN0YXR1cztcbn0oe30pO1xuXG4vKipcbiAqIERlZmF1bHQgKGVtcHR5KSBzaWduYXR1cmVcbiAqL1xuY29uc3QgREVGQVVMVF9TSUdOQVRVUkUgPSBCdWZmZXIuYWxsb2MoU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUykuZmlsbCgwKTtcblxuLyoqXG4gKiBBY2NvdW50IG1ldGFkYXRhIHVzZWQgdG8gZGVmaW5lIGluc3RydWN0aW9uc1xuICovXG5cbi8qKlxuICogTGlzdCBvZiBUcmFuc2FjdGlvbkluc3RydWN0aW9uIG9iamVjdCBmaWVsZHMgdGhhdCBtYXkgYmUgaW5pdGlhbGl6ZWQgYXQgY29uc3RydWN0aW9uXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgVHJhbnNhY3Rpb24uc2VyaWFsaXplKClcbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbi8qKlxuICogVHJhbnNhY3Rpb24gSW5zdHJ1Y3Rpb24gY2xhc3NcbiAqL1xuY2xhc3MgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAvKipcbiAgICAgKiBQdWJsaWMga2V5cyB0byBpbmNsdWRlIGluIHRoaXMgdHJhbnNhY3Rpb25cbiAgICAgKiBCb29sZWFuIHJlcHJlc2VudHMgd2hldGhlciB0aGlzIHB1YmtleSBuZWVkcyB0byBzaWduIHRoZSB0cmFuc2FjdGlvblxuICAgICAqL1xuICAgIHRoaXMua2V5cyA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBQcm9ncmFtIElkIHRvIGV4ZWN1dGVcbiAgICAgKi9cbiAgICB0aGlzLnByb2dyYW1JZCA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBQcm9ncmFtIGlucHV0XG4gICAgICovXG4gICAgdGhpcy5kYXRhID0gQnVmZmVyLmFsbG9jKDApO1xuICAgIHRoaXMucHJvZ3JhbUlkID0gb3B0cy5wcm9ncmFtSWQ7XG4gICAgdGhpcy5rZXlzID0gb3B0cy5rZXlzO1xuICAgIGlmIChvcHRzLmRhdGEpIHtcbiAgICAgIHRoaXMuZGF0YSA9IG9wdHMuZGF0YTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleXM6IHRoaXMua2V5cy5tYXAoKHtcbiAgICAgICAgcHVia2V5LFxuICAgICAgICBpc1NpZ25lcixcbiAgICAgICAgaXNXcml0YWJsZVxuICAgICAgfSkgPT4gKHtcbiAgICAgICAgcHVia2V5OiBwdWJrZXkudG9KU09OKCksXG4gICAgICAgIGlzU2lnbmVyLFxuICAgICAgICBpc1dyaXRhYmxlXG4gICAgICB9KSksXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLnRvSlNPTigpLFxuICAgICAgZGF0YTogWy4uLnRoaXMuZGF0YV1cbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUGFpciBvZiBzaWduYXR1cmUgYW5kIGNvcnJlc3BvbmRpbmcgcHVibGljIGtleVxuICovXG5cbi8qKlxuICogTGlzdCBvZiBUcmFuc2FjdGlvbiBvYmplY3QgZmllbGRzIHRoYXQgbWF5IGJlIGluaXRpYWxpemVkIGF0IGNvbnN0cnVjdGlvblxuICovXG5cbi8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5OyBhbiB1bmZvcnR1bmF0ZSBjb25zZXF1ZW5jZSBvZiBiZWluZ1xuLy8gZm9yY2VkIHRvIG92ZXItZXhwb3J0IHR5cGVzIGJ5IHRoZSBkb2N1bWVudGF0aW9uIGdlbmVyYXRvci5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL3B1bGwvMjU4MjBcblxuLyoqXG4gKiBCbG9ja2hhc2gtYmFzZWQgdHJhbnNhY3Rpb25zIGhhdmUgYSBsaWZldGltZSB0aGF0IGFyZSBkZWZpbmVkIGJ5XG4gKiB0aGUgYmxvY2toYXNoIHRoZXkgaW5jbHVkZS4gQW55IHRyYW5zYWN0aW9uIHdob3NlIGJsb2NraGFzaCBpc1xuICogdG9vIG9sZCB3aWxsIGJlIHJlamVjdGVkLlxuICovXG5cbi8qKlxuICogVXNlIHRoZXNlIG9wdGlvbnMgdG8gY29uc3RydWN0IGEgZHVyYWJsZSBub25jZSB0cmFuc2FjdGlvbi5cbiAqL1xuXG4vKipcbiAqIE5vbmNlIGluZm9ybWF0aW9uIHRvIGJlIHVzZWQgdG8gYnVpbGQgYW4gb2ZmbGluZSBUcmFuc2FjdGlvbi5cbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbi8qKlxuICogVHJhbnNhY3Rpb24gY2xhc3NcbiAqL1xuY2xhc3MgVHJhbnNhY3Rpb24ge1xuICAvKipcbiAgICogVGhlIGZpcnN0IChwYXllcikgVHJhbnNhY3Rpb24gc2lnbmF0dXJlXG4gICAqXG4gICAqIEByZXR1cm5zIHtCdWZmZXIgfCBudWxsfSBCdWZmZXIgb2YgcGF5ZXIncyBzaWduYXR1cmVcbiAgICovXG4gIGdldCBzaWduYXR1cmUoKSB7XG4gICAgaWYgKHRoaXMuc2lnbmF0dXJlcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaWduYXR1cmVzWzBdLnNpZ25hdHVyZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRyYW5zYWN0aW9uIGZlZSBwYXllclxuICAgKi9cblxuICAvLyBDb25zdHJ1Y3QgYSB0cmFuc2FjdGlvbiB3aXRoIGEgYmxvY2toYXNoIGFuZCBsYXN0VmFsaWRCbG9ja0hlaWdodFxuXG4gIC8vIENvbnN0cnVjdCBhIHRyYW5zYWN0aW9uIHVzaW5nIGEgZHVyYWJsZSBub25jZVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBgVHJhbnNhY3Rpb25DdG9yRmllbGRzYCBoYXMgYmVlbiBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi5cbiAgICogUGxlYXNlIHN1cHBseSBhIGBUcmFuc2FjdGlvbkJsb2NraGFzaEN0b3JgIGluc3RlYWQuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYW4gZW1wdHkgVHJhbnNhY3Rpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAvKipcbiAgICAgKiBTaWduYXR1cmVzIGZvciB0aGUgdHJhbnNhY3Rpb24uICBUeXBpY2FsbHkgY3JlYXRlZCBieSBpbnZva2luZyB0aGVcbiAgICAgKiBgc2lnbigpYCBtZXRob2RcbiAgICAgKi9cbiAgICB0aGlzLnNpZ25hdHVyZXMgPSBbXTtcbiAgICB0aGlzLmZlZVBheWVyID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIFRoZSBpbnN0cnVjdGlvbnMgdG8gYXRvbWljYWxseSBleGVjdXRlXG4gICAgICovXG4gICAgdGhpcy5pbnN0cnVjdGlvbnMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBBIHJlY2VudCB0cmFuc2FjdGlvbiBpZC4gTXVzdCBiZSBwb3B1bGF0ZWQgYnkgdGhlIGNhbGxlclxuICAgICAqL1xuICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIHRoZSBsYXN0IGJsb2NrIGNoYWluIGNhbiBhZHZhbmNlIHRvIGJlZm9yZSB0eCBpcyBkZWNsYXJlZCBleHBpcmVkXG4gICAgICogKi9cbiAgICB0aGlzLmxhc3RWYWxpZEJsb2NrSGVpZ2h0ID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIE9wdGlvbmFsIE5vbmNlIGluZm9ybWF0aW9uLiBJZiBwb3B1bGF0ZWQsIHRyYW5zYWN0aW9uIHdpbGwgdXNlIGEgZHVyYWJsZVxuICAgICAqIE5vbmNlIGhhc2ggaW5zdGVhZCBvZiBhIHJlY2VudEJsb2NraGFzaC4gTXVzdCBiZSBwb3B1bGF0ZWQgYnkgdGhlIGNhbGxlclxuICAgICAqL1xuICAgIHRoaXMubm9uY2VJbmZvID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIElmIHRoaXMgaXMgYSBub25jZSB0cmFuc2FjdGlvbiB0aGlzIHJlcHJlc2VudHMgdGhlIG1pbmltdW0gc2xvdCBmcm9tIHdoaWNoXG4gICAgICogdG8gZXZhbHVhdGUgaWYgdGhlIG5vbmNlIGhhcyBhZHZhbmNlZCB3aGVuIGF0dGVtcHRpbmcgdG8gY29uZmlybSB0aGVcbiAgICAgKiB0cmFuc2FjdGlvbi4gVGhpcyBwcm90ZWN0cyBhZ2FpbnN0IGEgY2FzZSB3aGVyZSB0aGUgdHJhbnNhY3Rpb24gY29uZmlybWF0aW9uXG4gICAgICogbG9naWMgbG9hZHMgdGhlIG5vbmNlIGFjY291bnQgZnJvbSBhbiBvbGQgc2xvdCBhbmQgYXNzdW1lcyB0aGUgbWlzbWF0Y2ggaW5cbiAgICAgKiBub25jZSB2YWx1ZSBpbXBsaWVzIHRoYXQgdGhlIG5vbmNlIGhhcyBiZWVuIGFkdmFuY2VkLlxuICAgICAqL1xuICAgIHRoaXMubWluTm9uY2VDb250ZXh0U2xvdCA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLl9tZXNzYWdlID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuX2pzb24gPSB2b2lkIDA7XG4gICAgaWYgKCFvcHRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvcHRzLmZlZVBheWVyKSB7XG4gICAgICB0aGlzLmZlZVBheWVyID0gb3B0cy5mZWVQYXllcjtcbiAgICB9XG4gICAgaWYgKG9wdHMuc2lnbmF0dXJlcykge1xuICAgICAgdGhpcy5zaWduYXR1cmVzID0gb3B0cy5zaWduYXR1cmVzO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdHMsICdub25jZUluZm8nKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBtaW5Db250ZXh0U2xvdCxcbiAgICAgICAgbm9uY2VJbmZvXG4gICAgICB9ID0gb3B0cztcbiAgICAgIHRoaXMubWluTm9uY2VDb250ZXh0U2xvdCA9IG1pbkNvbnRleHRTbG90O1xuICAgICAgdGhpcy5ub25jZUluZm8gPSBub25jZUluZm87XG4gICAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0cywgJ2xhc3RWYWxpZEJsb2NrSGVpZ2h0JykpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYmxvY2toYXNoLFxuICAgICAgICBsYXN0VmFsaWRCbG9ja0hlaWdodFxuICAgICAgfSA9IG9wdHM7XG4gICAgICB0aGlzLnJlY2VudEJsb2NraGFzaCA9IGJsb2NraGFzaDtcbiAgICAgIHRoaXMubGFzdFZhbGlkQmxvY2tIZWlnaHQgPSBsYXN0VmFsaWRCbG9ja0hlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qge1xuICAgICAgICByZWNlbnRCbG9ja2hhc2gsXG4gICAgICAgIG5vbmNlSW5mb1xuICAgICAgfSA9IG9wdHM7XG4gICAgICBpZiAobm9uY2VJbmZvKSB7XG4gICAgICAgIHRoaXMubm9uY2VJbmZvID0gbm9uY2VJbmZvO1xuICAgICAgfVxuICAgICAgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSByZWNlbnRCbG9ja2hhc2g7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICByZWNlbnRCbG9ja2hhc2g6IHRoaXMucmVjZW50QmxvY2toYXNoIHx8IG51bGwsXG4gICAgICBmZWVQYXllcjogdGhpcy5mZWVQYXllciA/IHRoaXMuZmVlUGF5ZXIudG9KU09OKCkgOiBudWxsLFxuICAgICAgbm9uY2VJbmZvOiB0aGlzLm5vbmNlSW5mbyA/IHtcbiAgICAgICAgbm9uY2U6IHRoaXMubm9uY2VJbmZvLm5vbmNlLFxuICAgICAgICBub25jZUluc3RydWN0aW9uOiB0aGlzLm5vbmNlSW5mby5ub25jZUluc3RydWN0aW9uLnRvSlNPTigpXG4gICAgICB9IDogbnVsbCxcbiAgICAgIGluc3RydWN0aW9uczogdGhpcy5pbnN0cnVjdGlvbnMubWFwKGluc3RydWN0aW9uID0+IGluc3RydWN0aW9uLnRvSlNPTigpKSxcbiAgICAgIHNpZ25lcnM6IHRoaXMuc2lnbmF0dXJlcy5tYXAoKHtcbiAgICAgICAgcHVibGljS2V5XG4gICAgICB9KSA9PiB7XG4gICAgICAgIHJldHVybiBwdWJsaWNLZXkudG9KU09OKCk7XG4gICAgICB9KVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQWRkIG9uZSBvciBtb3JlIGluc3RydWN0aW9ucyB0byB0aGlzIFRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8IFRyYW5zYWN0aW9uIHwgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiB8IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb25DdG9yRmllbGRzID59IGl0ZW1zIC0gSW5zdHJ1Y3Rpb25zIHRvIGFkZCB0byB0aGUgVHJhbnNhY3Rpb25cbiAgICovXG4gIGFkZCguLi5pdGVtcykge1xuICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gaW5zdHJ1Y3Rpb25zJyk7XG4gICAgfVxuICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICBpZiAoJ2luc3RydWN0aW9ucycgaW4gaXRlbSkge1xuICAgICAgICB0aGlzLmluc3RydWN0aW9ucyA9IHRoaXMuaW5zdHJ1Y3Rpb25zLmNvbmNhdChpdGVtLmluc3RydWN0aW9ucyk7XG4gICAgICB9IGVsc2UgaWYgKCdkYXRhJyBpbiBpdGVtICYmICdwcm9ncmFtSWQnIGluIGl0ZW0gJiYgJ2tleXMnIGluIGl0ZW0pIHtcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChpdGVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2gobmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oaXRlbSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBpbGUgdHJhbnNhY3Rpb24gZGF0YVxuICAgKi9cbiAgY29tcGlsZU1lc3NhZ2UoKSB7XG4gICAgaWYgKHRoaXMuX21lc3NhZ2UgJiYgSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04oKSkgPT09IEpTT04uc3RyaW5naWZ5KHRoaXMuX2pzb24pKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWVzc2FnZTtcbiAgICB9XG4gICAgbGV0IHJlY2VudEJsb2NraGFzaDtcbiAgICBsZXQgaW5zdHJ1Y3Rpb25zO1xuICAgIGlmICh0aGlzLm5vbmNlSW5mbykge1xuICAgICAgcmVjZW50QmxvY2toYXNoID0gdGhpcy5ub25jZUluZm8ubm9uY2U7XG4gICAgICBpZiAodGhpcy5pbnN0cnVjdGlvbnNbMF0gIT0gdGhpcy5ub25jZUluZm8ubm9uY2VJbnN0cnVjdGlvbikge1xuICAgICAgICBpbnN0cnVjdGlvbnMgPSBbdGhpcy5ub25jZUluZm8ubm9uY2VJbnN0cnVjdGlvbiwgLi4udGhpcy5pbnN0cnVjdGlvbnNdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdHJ1Y3Rpb25zID0gdGhpcy5pbnN0cnVjdGlvbnM7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY2VudEJsb2NraGFzaCA9IHRoaXMucmVjZW50QmxvY2toYXNoO1xuICAgICAgaW5zdHJ1Y3Rpb25zID0gdGhpcy5pbnN0cnVjdGlvbnM7XG4gICAgfVxuICAgIGlmICghcmVjZW50QmxvY2toYXNoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zYWN0aW9uIHJlY2VudEJsb2NraGFzaCByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpZiAoaW5zdHJ1Y3Rpb25zLmxlbmd0aCA8IDEpIHtcbiAgICAgIGNvbnNvbGUud2FybignTm8gaW5zdHJ1Y3Rpb25zIHByb3ZpZGVkJyk7XG4gICAgfVxuICAgIGxldCBmZWVQYXllcjtcbiAgICBpZiAodGhpcy5mZWVQYXllcikge1xuICAgICAgZmVlUGF5ZXIgPSB0aGlzLmZlZVBheWVyO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zaWduYXR1cmVzLmxlbmd0aCA+IDAgJiYgdGhpcy5zaWduYXR1cmVzWzBdLnB1YmxpY0tleSkge1xuICAgICAgLy8gVXNlIGltcGxpY2l0IGZlZSBwYXllclxuICAgICAgZmVlUGF5ZXIgPSB0aGlzLnNpZ25hdHVyZXNbMF0ucHVibGljS2V5O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zYWN0aW9uIGZlZSBwYXllciByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluc3RydWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGluc3RydWN0aW9uc1tpXS5wcm9ncmFtSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyYW5zYWN0aW9uIGluc3RydWN0aW9uIGluZGV4ICR7aX0gaGFzIHVuZGVmaW5lZCBwcm9ncmFtIGlkYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHByb2dyYW1JZHMgPSBbXTtcbiAgICBjb25zdCBhY2NvdW50TWV0YXMgPSBbXTtcbiAgICBpbnN0cnVjdGlvbnMuZm9yRWFjaChpbnN0cnVjdGlvbiA9PiB7XG4gICAgICBpbnN0cnVjdGlvbi5rZXlzLmZvckVhY2goYWNjb3VudE1ldGEgPT4ge1xuICAgICAgICBhY2NvdW50TWV0YXMucHVzaCh7XG4gICAgICAgICAgLi4uYWNjb3VudE1ldGFcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHByb2dyYW1JZCA9IGluc3RydWN0aW9uLnByb2dyYW1JZC50b1N0cmluZygpO1xuICAgICAgaWYgKCFwcm9ncmFtSWRzLmluY2x1ZGVzKHByb2dyYW1JZCkpIHtcbiAgICAgICAgcHJvZ3JhbUlkcy5wdXNoKHByb2dyYW1JZCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBBcHBlbmQgcHJvZ3JhbUlEIGFjY291bnQgbWV0YXNcbiAgICBwcm9ncmFtSWRzLmZvckVhY2gocHJvZ3JhbUlkID0+IHtcbiAgICAgIGFjY291bnRNZXRhcy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiBuZXcgUHVibGljS2V5KHByb2dyYW1JZCksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gQ3VsbCBkdXBsaWNhdGUgYWNjb3VudCBtZXRhc1xuICAgIGNvbnN0IHVuaXF1ZU1ldGFzID0gW107XG4gICAgYWNjb3VudE1ldGFzLmZvckVhY2goYWNjb3VudE1ldGEgPT4ge1xuICAgICAgY29uc3QgcHVia2V5U3RyaW5nID0gYWNjb3VudE1ldGEucHVia2V5LnRvU3RyaW5nKCk7XG4gICAgICBjb25zdCB1bmlxdWVJbmRleCA9IHVuaXF1ZU1ldGFzLmZpbmRJbmRleCh4ID0+IHtcbiAgICAgICAgcmV0dXJuIHgucHVia2V5LnRvU3RyaW5nKCkgPT09IHB1YmtleVN0cmluZztcbiAgICAgIH0pO1xuICAgICAgaWYgKHVuaXF1ZUluZGV4ID4gLTEpIHtcbiAgICAgICAgdW5pcXVlTWV0YXNbdW5pcXVlSW5kZXhdLmlzV3JpdGFibGUgPSB1bmlxdWVNZXRhc1t1bmlxdWVJbmRleF0uaXNXcml0YWJsZSB8fCBhY2NvdW50TWV0YS5pc1dyaXRhYmxlO1xuICAgICAgICB1bmlxdWVNZXRhc1t1bmlxdWVJbmRleF0uaXNTaWduZXIgPSB1bmlxdWVNZXRhc1t1bmlxdWVJbmRleF0uaXNTaWduZXIgfHwgYWNjb3VudE1ldGEuaXNTaWduZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1bmlxdWVNZXRhcy5wdXNoKGFjY291bnRNZXRhKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNvcnQuIFByaW9yaXRpemluZyBmaXJzdCBieSBzaWduZXIsIHRoZW4gYnkgd3JpdGFibGVcbiAgICB1bmlxdWVNZXRhcy5zb3J0KGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICBpZiAoeC5pc1NpZ25lciAhPT0geS5pc1NpZ25lcikge1xuICAgICAgICAvLyBTaWduZXJzIGFsd2F5cyBjb21lIGJlZm9yZSBub24tc2lnbmVyc1xuICAgICAgICByZXR1cm4geC5pc1NpZ25lciA/IC0xIDogMTtcbiAgICAgIH1cbiAgICAgIGlmICh4LmlzV3JpdGFibGUgIT09IHkuaXNXcml0YWJsZSkge1xuICAgICAgICAvLyBXcml0YWJsZSBhY2NvdW50cyBhbHdheXMgY29tZSBiZWZvcmUgcmVhZC1vbmx5IGFjY291bnRzXG4gICAgICAgIHJldHVybiB4LmlzV3JpdGFibGUgPyAtMSA6IDE7XG4gICAgICB9XG4gICAgICAvLyBPdGhlcndpc2UsIHNvcnQgYnkgcHVia2V5LCBzdHJpbmd3aXNlLlxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgbG9jYWxlTWF0Y2hlcjogJ2Jlc3QgZml0JyxcbiAgICAgICAgdXNhZ2U6ICdzb3J0JyxcbiAgICAgICAgc2Vuc2l0aXZpdHk6ICd2YXJpYW50JyxcbiAgICAgICAgaWdub3JlUHVuY3R1YXRpb246IGZhbHNlLFxuICAgICAgICBudW1lcmljOiBmYWxzZSxcbiAgICAgICAgY2FzZUZpcnN0OiAnbG93ZXInXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHgucHVia2V5LnRvQmFzZTU4KCkubG9jYWxlQ29tcGFyZSh5LnB1YmtleS50b0Jhc2U1OCgpLCAnZW4nLCBvcHRpb25zKTtcbiAgICB9KTtcblxuICAgIC8vIE1vdmUgZmVlIHBheWVyIHRvIHRoZSBmcm9udFxuICAgIGNvbnN0IGZlZVBheWVySW5kZXggPSB1bmlxdWVNZXRhcy5maW5kSW5kZXgoeCA9PiB7XG4gICAgICByZXR1cm4geC5wdWJrZXkuZXF1YWxzKGZlZVBheWVyKTtcbiAgICB9KTtcbiAgICBpZiAoZmVlUGF5ZXJJbmRleCA+IC0xKSB7XG4gICAgICBjb25zdCBbcGF5ZXJNZXRhXSA9IHVuaXF1ZU1ldGFzLnNwbGljZShmZWVQYXllckluZGV4LCAxKTtcbiAgICAgIHBheWVyTWV0YS5pc1NpZ25lciA9IHRydWU7XG4gICAgICBwYXllck1ldGEuaXNXcml0YWJsZSA9IHRydWU7XG4gICAgICB1bmlxdWVNZXRhcy51bnNoaWZ0KHBheWVyTWV0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuaXF1ZU1ldGFzLnVuc2hpZnQoe1xuICAgICAgICBwdWJrZXk6IGZlZVBheWVyLFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRGlzYWxsb3cgdW5rbm93biBzaWduZXJzXG4gICAgZm9yIChjb25zdCBzaWduYXR1cmUgb2YgdGhpcy5zaWduYXR1cmVzKSB7XG4gICAgICBjb25zdCB1bmlxdWVJbmRleCA9IHVuaXF1ZU1ldGFzLmZpbmRJbmRleCh4ID0+IHtcbiAgICAgICAgcmV0dXJuIHgucHVia2V5LmVxdWFscyhzaWduYXR1cmUucHVibGljS2V5KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHVuaXF1ZUluZGV4ID4gLTEpIHtcbiAgICAgICAgaWYgKCF1bmlxdWVNZXRhc1t1bmlxdWVJbmRleF0uaXNTaWduZXIpIHtcbiAgICAgICAgICB1bmlxdWVNZXRhc1t1bmlxdWVJbmRleF0uaXNTaWduZXIgPSB0cnVlO1xuICAgICAgICAgIGNvbnNvbGUud2FybignVHJhbnNhY3Rpb24gcmVmZXJlbmNlcyBhIHNpZ25hdHVyZSB0aGF0IGlzIHVubmVjZXNzYXJ5LCAnICsgJ29ubHkgdGhlIGZlZSBwYXllciBhbmQgaW5zdHJ1Y3Rpb24gc2lnbmVyIGFjY291bnRzIHNob3VsZCBzaWduIGEgdHJhbnNhY3Rpb24uICcgKyAnVGhpcyBiZWhhdmlvciBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIHRocm93IGFuIGVycm9yIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gcmVsZWFzZS4nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHNpZ25lcjogJHtzaWduYXR1cmUucHVibGljS2V5LnRvU3RyaW5nKCl9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBudW1SZXF1aXJlZFNpZ25hdHVyZXMgPSAwO1xuICAgIGxldCBudW1SZWFkb25seVNpZ25lZEFjY291bnRzID0gMDtcbiAgICBsZXQgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzID0gMDtcblxuICAgIC8vIFNwbGl0IG91dCBzaWduaW5nIGZyb20gbm9uLXNpZ25pbmcga2V5cyBhbmQgY291bnQgaGVhZGVyIHZhbHVlc1xuICAgIGNvbnN0IHNpZ25lZEtleXMgPSBbXTtcbiAgICBjb25zdCB1bnNpZ25lZEtleXMgPSBbXTtcbiAgICB1bmlxdWVNZXRhcy5mb3JFYWNoKCh7XG4gICAgICBwdWJrZXksXG4gICAgICBpc1NpZ25lcixcbiAgICAgIGlzV3JpdGFibGVcbiAgICB9KSA9PiB7XG4gICAgICBpZiAoaXNTaWduZXIpIHtcbiAgICAgICAgc2lnbmVkS2V5cy5wdXNoKHB1YmtleS50b1N0cmluZygpKTtcbiAgICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzICs9IDE7XG4gICAgICAgIGlmICghaXNXcml0YWJsZSkge1xuICAgICAgICAgIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW5zaWduZWRLZXlzLnB1c2gocHVia2V5LnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAoIWlzV3JpdGFibGUpIHtcbiAgICAgICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHMgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGFjY291bnRLZXlzID0gc2lnbmVkS2V5cy5jb25jYXQodW5zaWduZWRLZXlzKTtcbiAgICBjb25zdCBjb21waWxlZEluc3RydWN0aW9ucyA9IGluc3RydWN0aW9ucy5tYXAoaW5zdHJ1Y3Rpb24gPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhLFxuICAgICAgICBwcm9ncmFtSWRcbiAgICAgIH0gPSBpbnN0cnVjdGlvbjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb2dyYW1JZEluZGV4OiBhY2NvdW50S2V5cy5pbmRleE9mKHByb2dyYW1JZC50b1N0cmluZygpKSxcbiAgICAgICAgYWNjb3VudHM6IGluc3RydWN0aW9uLmtleXMubWFwKG1ldGEgPT4gYWNjb3VudEtleXMuaW5kZXhPZihtZXRhLnB1YmtleS50b1N0cmluZygpKSksXG4gICAgICAgIGRhdGE6IGJzNTguZW5jb2RlKGRhdGEpXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbXBpbGVkSW5zdHJ1Y3Rpb25zLmZvckVhY2goaW5zdHJ1Y3Rpb24gPT4ge1xuICAgICAgYXNzZXJ0KGluc3RydWN0aW9uLnByb2dyYW1JZEluZGV4ID49IDApO1xuICAgICAgaW5zdHJ1Y3Rpb24uYWNjb3VudHMuZm9yRWFjaChrZXlJbmRleCA9PiBhc3NlcnQoa2V5SW5kZXggPj0gMCkpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgTWVzc2FnZSh7XG4gICAgICBoZWFkZXI6IHtcbiAgICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzLFxuICAgICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzLFxuICAgICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHNcbiAgICAgIH0sXG4gICAgICBhY2NvdW50S2V5cyxcbiAgICAgIHJlY2VudEJsb2NraGFzaCxcbiAgICAgIGluc3RydWN0aW9uczogY29tcGlsZWRJbnN0cnVjdGlvbnNcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9jb21waWxlKCkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLmNvbXBpbGVNZXNzYWdlKCk7XG4gICAgY29uc3Qgc2lnbmVkS2V5cyA9IG1lc3NhZ2UuYWNjb3VudEtleXMuc2xpY2UoMCwgbWVzc2FnZS5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzKTtcbiAgICBpZiAodGhpcy5zaWduYXR1cmVzLmxlbmd0aCA9PT0gc2lnbmVkS2V5cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHZhbGlkID0gdGhpcy5zaWduYXR1cmVzLmV2ZXJ5KChwYWlyLCBpbmRleCkgPT4ge1xuICAgICAgICByZXR1cm4gc2lnbmVkS2V5c1tpbmRleF0uZXF1YWxzKHBhaXIucHVibGljS2V5KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHZhbGlkKSByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgdGhpcy5zaWduYXR1cmVzID0gc2lnbmVkS2V5cy5tYXAocHVibGljS2V5ID0+ICh7XG4gICAgICBzaWduYXR1cmU6IG51bGwsXG4gICAgICBwdWJsaWNLZXlcbiAgICB9KSk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgYnVmZmVyIG9mIHRoZSBUcmFuc2FjdGlvbiBkYXRhIHRoYXQgbmVlZCB0byBiZSBjb3ZlcmVkIGJ5IHNpZ25hdHVyZXNcbiAgICovXG4gIHNlcmlhbGl6ZU1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBpbGUoKS5zZXJpYWxpemUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGVzdGltYXRlZCBmZWUgYXNzb2NpYXRlZCB3aXRoIGEgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uZWN0aW9uIENvbm5lY3Rpb24gdG8gUlBDIEVuZHBvaW50LlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXIgfCBudWxsPn0gVGhlIGVzdGltYXRlZCBmZWUgZm9yIHRoZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgYXN5bmMgZ2V0RXN0aW1hdGVkRmVlKGNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm4gKGF3YWl0IGNvbm5lY3Rpb24uZ2V0RmVlRm9yTWVzc2FnZSh0aGlzLmNvbXBpbGVNZXNzYWdlKCkpKS52YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBwdWJsaWMga2V5cyB3aGljaCB3aWxsIGJlIHVzZWQgdG8gc2lnbiB0aGUgVHJhbnNhY3Rpb24uXG4gICAqIFRoZSBmaXJzdCBzaWduZXIgd2lsbCBiZSB1c2VkIGFzIHRoZSB0cmFuc2FjdGlvbiBmZWUgcGF5ZXIgYWNjb3VudC5cbiAgICpcbiAgICogU2lnbmF0dXJlcyBjYW4gYmUgYWRkZWQgd2l0aCBlaXRoZXIgYHBhcnRpYWxTaWduYCBvciBgYWRkU2lnbmF0dXJlYFxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIHYwLjg0LjAuIE9ubHkgdGhlIGZlZSBwYXllciBuZWVkcyB0byBiZVxuICAgKiBzcGVjaWZpZWQgYW5kIGl0IGNhbiBiZSBzZXQgaW4gdGhlIFRyYW5zYWN0aW9uIGNvbnN0cnVjdG9yIG9yIHdpdGggdGhlXG4gICAqIGBmZWVQYXllcmAgcHJvcGVydHkuXG4gICAqL1xuICBzZXRTaWduZXJzKC4uLnNpZ25lcnMpIHtcbiAgICBpZiAoc2lnbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2lnbmVycycpO1xuICAgIH1cbiAgICBjb25zdCBzZWVuID0gbmV3IFNldCgpO1xuICAgIHRoaXMuc2lnbmF0dXJlcyA9IHNpZ25lcnMuZmlsdGVyKHB1YmxpY0tleSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSBwdWJsaWNLZXkudG9TdHJpbmcoKTtcbiAgICAgIGlmIChzZWVuLmhhcyhrZXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlZW4uYWRkKGtleSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pLm1hcChwdWJsaWNLZXkgPT4gKHtcbiAgICAgIHNpZ25hdHVyZTogbnVsbCxcbiAgICAgIHB1YmxpY0tleVxuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWduIHRoZSBUcmFuc2FjdGlvbiB3aXRoIHRoZSBzcGVjaWZpZWQgc2lnbmVycy4gTXVsdGlwbGUgc2lnbmF0dXJlcyBtYXlcbiAgICogYmUgYXBwbGllZCB0byBhIFRyYW5zYWN0aW9uLiBUaGUgZmlyc3Qgc2lnbmF0dXJlIGlzIGNvbnNpZGVyZWQgXCJwcmltYXJ5XCJcbiAgICogYW5kIGlzIHVzZWQgaWRlbnRpZnkgYW5kIGNvbmZpcm0gdHJhbnNhY3Rpb25zLlxuICAgKlxuICAgKiBJZiB0aGUgVHJhbnNhY3Rpb24gYGZlZVBheWVyYCBpcyBub3Qgc2V0LCB0aGUgZmlyc3Qgc2lnbmVyIHdpbGwgYmUgdXNlZFxuICAgKiBhcyB0aGUgdHJhbnNhY3Rpb24gZmVlIHBheWVyIGFjY291bnQuXG4gICAqXG4gICAqIFRyYW5zYWN0aW9uIGZpZWxkcyBzaG91bGQgbm90IGJlIG1vZGlmaWVkIGFmdGVyIHRoZSBmaXJzdCBjYWxsIHRvIGBzaWduYCxcbiAgICogYXMgZG9pbmcgc28gbWF5IGludmFsaWRhdGUgdGhlIHNpZ25hdHVyZSBhbmQgY2F1c2UgdGhlIFRyYW5zYWN0aW9uIHRvIGJlXG4gICAqIHJlamVjdGVkLlxuICAgKlxuICAgKiBUaGUgVHJhbnNhY3Rpb24gbXVzdCBiZSBhc3NpZ25lZCBhIHZhbGlkIGByZWNlbnRCbG9ja2hhc2hgIGJlZm9yZSBpbnZva2luZyB0aGlzIG1ldGhvZFxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PFNpZ25lcj59IHNpZ25lcnMgQXJyYXkgb2Ygc2lnbmVycyB0aGF0IHdpbGwgc2lnbiB0aGUgdHJhbnNhY3Rpb25cbiAgICovXG4gIHNpZ24oLi4uc2lnbmVycykge1xuICAgIGlmIChzaWduZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzaWduZXJzJyk7XG4gICAgfVxuXG4gICAgLy8gRGVkdXBlIHNpZ25lcnNcbiAgICBjb25zdCBzZWVuID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IHVuaXF1ZVNpZ25lcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHNpZ25lciBvZiBzaWduZXJzKSB7XG4gICAgICBjb25zdCBrZXkgPSBzaWduZXIucHVibGljS2V5LnRvU3RyaW5nKCk7XG4gICAgICBpZiAoc2Vlbi5oYXMoa2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlZW4uYWRkKGtleSk7XG4gICAgICAgIHVuaXF1ZVNpZ25lcnMucHVzaChzaWduZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNpZ25hdHVyZXMgPSB1bmlxdWVTaWduZXJzLm1hcChzaWduZXIgPT4gKHtcbiAgICAgIHNpZ25hdHVyZTogbnVsbCxcbiAgICAgIHB1YmxpY0tleTogc2lnbmVyLnB1YmxpY0tleVxuICAgIH0pKTtcbiAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5fY29tcGlsZSgpO1xuICAgIHRoaXMuX3BhcnRpYWxTaWduKG1lc3NhZ2UsIC4uLnVuaXF1ZVNpZ25lcnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnRpYWxseSBzaWduIGEgdHJhbnNhY3Rpb24gd2l0aCB0aGUgc3BlY2lmaWVkIGFjY291bnRzLiBBbGwgYWNjb3VudHMgbXVzdFxuICAgKiBjb3JyZXNwb25kIHRvIGVpdGhlciB0aGUgZmVlIHBheWVyIG9yIGEgc2lnbmVyIGFjY291bnQgaW4gdGhlIHRyYW5zYWN0aW9uXG4gICAqIGluc3RydWN0aW9ucy5cbiAgICpcbiAgICogQWxsIHRoZSBjYXZlYXRzIGZyb20gdGhlIGBzaWduYCBtZXRob2QgYXBwbHkgdG8gYHBhcnRpYWxTaWduYFxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PFNpZ25lcj59IHNpZ25lcnMgQXJyYXkgb2Ygc2lnbmVycyB0aGF0IHdpbGwgc2lnbiB0aGUgdHJhbnNhY3Rpb25cbiAgICovXG4gIHBhcnRpYWxTaWduKC4uLnNpZ25lcnMpIHtcbiAgICBpZiAoc2lnbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2lnbmVycycpO1xuICAgIH1cblxuICAgIC8vIERlZHVwZSBzaWduZXJzXG4gICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCB1bmlxdWVTaWduZXJzID0gW107XG4gICAgZm9yIChjb25zdCBzaWduZXIgb2Ygc2lnbmVycykge1xuICAgICAgY29uc3Qga2V5ID0gc2lnbmVyLnB1YmxpY0tleS50b1N0cmluZygpO1xuICAgICAgaWYgKHNlZW4uaGFzKGtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWVuLmFkZChrZXkpO1xuICAgICAgICB1bmlxdWVTaWduZXJzLnB1c2goc2lnbmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuX2NvbXBpbGUoKTtcbiAgICB0aGlzLl9wYXJ0aWFsU2lnbihtZXNzYWdlLCAuLi51bmlxdWVTaWduZXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9wYXJ0aWFsU2lnbihtZXNzYWdlLCAuLi5zaWduZXJzKSB7XG4gICAgY29uc3Qgc2lnbkRhdGEgPSBtZXNzYWdlLnNlcmlhbGl6ZSgpO1xuICAgIHNpZ25lcnMuZm9yRWFjaChzaWduZXIgPT4ge1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gc2lnbihzaWduRGF0YSwgc2lnbmVyLnNlY3JldEtleSk7XG4gICAgICB0aGlzLl9hZGRTaWduYXR1cmUoc2lnbmVyLnB1YmxpY0tleSwgdG9CdWZmZXIoc2lnbmF0dXJlKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGFuIGV4dGVybmFsbHkgY3JlYXRlZCBzaWduYXR1cmUgdG8gYSB0cmFuc2FjdGlvbi4gVGhlIHB1YmxpYyBrZXlcbiAgICogbXVzdCBjb3JyZXNwb25kIHRvIGVpdGhlciB0aGUgZmVlIHBheWVyIG9yIGEgc2lnbmVyIGFjY291bnQgaW4gdGhlIHRyYW5zYWN0aW9uXG4gICAqIGluc3RydWN0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtQdWJsaWNLZXl9IHB1YmtleSBQdWJsaWMga2V5IHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgdHJhbnNhY3Rpb24uXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBzaWduYXR1cmUgQW4gZXh0ZXJuYWxseSBjcmVhdGVkIHNpZ25hdHVyZSB0byBhZGQgdG8gdGhlIHRyYW5zYWN0aW9uLlxuICAgKi9cbiAgYWRkU2lnbmF0dXJlKHB1YmtleSwgc2lnbmF0dXJlKSB7XG4gICAgdGhpcy5fY29tcGlsZSgpOyAvLyBFbnN1cmUgc2lnbmF0dXJlcyBhcnJheSBpcyBwb3B1bGF0ZWRcbiAgICB0aGlzLl9hZGRTaWduYXR1cmUocHVia2V5LCBzaWduYXR1cmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2FkZFNpZ25hdHVyZShwdWJrZXksIHNpZ25hdHVyZSkge1xuICAgIGFzc2VydChzaWduYXR1cmUubGVuZ3RoID09PSA2NCk7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnNpZ25hdHVyZXMuZmluZEluZGV4KHNpZ3BhaXIgPT4gcHVia2V5LmVxdWFscyhzaWdwYWlyLnB1YmxpY0tleSkpO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biBzaWduZXI6ICR7cHVia2V5LnRvU3RyaW5nKCl9YCk7XG4gICAgfVxuICAgIHRoaXMuc2lnbmF0dXJlc1tpbmRleF0uc2lnbmF0dXJlID0gQnVmZmVyLmZyb20oc2lnbmF0dXJlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZnkgc2lnbmF0dXJlcyBvZiBhIFRyYW5zYWN0aW9uXG4gICAqIE9wdGlvbmFsIHBhcmFtZXRlciBzcGVjaWZpZXMgaWYgd2UncmUgZXhwZWN0aW5nIGEgZnVsbHkgc2lnbmVkIFRyYW5zYWN0aW9uIG9yIGEgcGFydGlhbGx5IHNpZ25lZCBvbmUuXG4gICAqIElmIG5vIGJvb2xlYW4gaXMgcHJvdmlkZWQsIHdlIGV4cGVjdCBhIGZ1bGx5IHNpZ25lZCBUcmFuc2FjdGlvbiBieSBkZWZhdWx0LlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXF1aXJlQWxsU2lnbmF0dXJlcz10cnVlXSBSZXF1aXJlIGEgZnVsbHkgc2lnbmVkIFRyYW5zYWN0aW9uXG4gICAqL1xuICB2ZXJpZnlTaWduYXR1cmVzKHJlcXVpcmVBbGxTaWduYXR1cmVzID0gdHJ1ZSkge1xuICAgIGNvbnN0IHNpZ25hdHVyZUVycm9ycyA9IHRoaXMuX2dldE1lc3NhZ2VTaWduZWRuZXNzRXJyb3JzKHRoaXMuc2VyaWFsaXplTWVzc2FnZSgpLCByZXF1aXJlQWxsU2lnbmF0dXJlcyk7XG4gICAgcmV0dXJuICFzaWduYXR1cmVFcnJvcnM7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfZ2V0TWVzc2FnZVNpZ25lZG5lc3NFcnJvcnMobWVzc2FnZSwgcmVxdWlyZUFsbFNpZ25hdHVyZXMpIHtcbiAgICBjb25zdCBlcnJvcnMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIHNpZ25hdHVyZSxcbiAgICAgIHB1YmxpY0tleVxuICAgIH0gb2YgdGhpcy5zaWduYXR1cmVzKSB7XG4gICAgICBpZiAoc2lnbmF0dXJlID09PSBudWxsKSB7XG4gICAgICAgIGlmIChyZXF1aXJlQWxsU2lnbmF0dXJlcykge1xuICAgICAgICAgIChlcnJvcnMubWlzc2luZyB8fD0gW10pLnB1c2gocHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF2ZXJpZnkoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXkudG9CeXRlcygpKSkge1xuICAgICAgICAgIChlcnJvcnMuaW52YWxpZCB8fD0gW10pLnB1c2gocHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzLmludmFsaWQgfHwgZXJyb3JzLm1pc3NpbmcgPyBlcnJvcnMgOiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplIHRoZSBUcmFuc2FjdGlvbiBpbiB0aGUgd2lyZSBmb3JtYXQuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBbY29uZmlnXSBDb25maWcgb2YgdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIHtCdWZmZXJ9IFNpZ25hdHVyZSBvZiB0cmFuc2FjdGlvbiBpbiB3aXJlIGZvcm1hdC5cbiAgICovXG4gIHNlcmlhbGl6ZShjb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICByZXF1aXJlQWxsU2lnbmF0dXJlcyxcbiAgICAgIHZlcmlmeVNpZ25hdHVyZXNcbiAgICB9ID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICByZXF1aXJlQWxsU2lnbmF0dXJlczogdHJ1ZSxcbiAgICAgIHZlcmlmeVNpZ25hdHVyZXM6IHRydWVcbiAgICB9LCBjb25maWcpO1xuICAgIGNvbnN0IHNpZ25EYXRhID0gdGhpcy5zZXJpYWxpemVNZXNzYWdlKCk7XG4gICAgaWYgKHZlcmlmeVNpZ25hdHVyZXMpIHtcbiAgICAgIGNvbnN0IHNpZ0Vycm9ycyA9IHRoaXMuX2dldE1lc3NhZ2VTaWduZWRuZXNzRXJyb3JzKHNpZ25EYXRhLCByZXF1aXJlQWxsU2lnbmF0dXJlcyk7XG4gICAgICBpZiAoc2lnRXJyb3JzKSB7XG4gICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSAnU2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBmYWlsZWQuJztcbiAgICAgICAgaWYgKHNpZ0Vycm9ycy5pbnZhbGlkKSB7XG4gICAgICAgICAgZXJyb3JNZXNzYWdlICs9IGBcXG5JbnZhbGlkIHNpZ25hdHVyZSBmb3IgcHVibGljIGtleSR7c2lnRXJyb3JzLmludmFsaWQubGVuZ3RoID09PSAxID8gJycgOiAnKHMpJ30gW1xcYCR7c2lnRXJyb3JzLmludmFsaWQubWFwKHAgPT4gcC50b0Jhc2U1OCgpKS5qb2luKCdgLCBgJyl9XFxgXS5gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaWdFcnJvcnMubWlzc2luZykge1xuICAgICAgICAgIGVycm9yTWVzc2FnZSArPSBgXFxuTWlzc2luZyBzaWduYXR1cmUgZm9yIHB1YmxpYyBrZXkke3NpZ0Vycm9ycy5taXNzaW5nLmxlbmd0aCA9PT0gMSA/ICcnIDogJyhzKSd9IFtcXGAke3NpZ0Vycm9ycy5taXNzaW5nLm1hcChwID0+IHAudG9CYXNlNTgoKSkuam9pbignYCwgYCcpfVxcYF0uYDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NlcmlhbGl6ZShzaWduRGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfc2VyaWFsaXplKHNpZ25EYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgc2lnbmF0dXJlc1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNpZ25hdHVyZUNvdW50ID0gW107XG4gICAgZW5jb2RlTGVuZ3RoKHNpZ25hdHVyZUNvdW50LCBzaWduYXR1cmVzLmxlbmd0aCk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25MZW5ndGggPSBzaWduYXR1cmVDb3VudC5sZW5ndGggKyBzaWduYXR1cmVzLmxlbmd0aCAqIDY0ICsgc2lnbkRhdGEubGVuZ3RoO1xuICAgIGNvbnN0IHdpcmVUcmFuc2FjdGlvbiA9IEJ1ZmZlci5hbGxvYyh0cmFuc2FjdGlvbkxlbmd0aCk7XG4gICAgYXNzZXJ0KHNpZ25hdHVyZXMubGVuZ3RoIDwgMjU2KTtcbiAgICBCdWZmZXIuZnJvbShzaWduYXR1cmVDb3VudCkuY29weSh3aXJlVHJhbnNhY3Rpb24sIDApO1xuICAgIHNpZ25hdHVyZXMuZm9yRWFjaCgoe1xuICAgICAgc2lnbmF0dXJlXG4gICAgfSwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChzaWduYXR1cmUgIT09IG51bGwpIHtcbiAgICAgICAgYXNzZXJ0KHNpZ25hdHVyZS5sZW5ndGggPT09IDY0LCBgc2lnbmF0dXJlIGhhcyBpbnZhbGlkIGxlbmd0aGApO1xuICAgICAgICBCdWZmZXIuZnJvbShzaWduYXR1cmUpLmNvcHkod2lyZVRyYW5zYWN0aW9uLCBzaWduYXR1cmVDb3VudC5sZW5ndGggKyBpbmRleCAqIDY0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzaWduRGF0YS5jb3B5KHdpcmVUcmFuc2FjdGlvbiwgc2lnbmF0dXJlQ291bnQubGVuZ3RoICsgc2lnbmF0dXJlcy5sZW5ndGggKiA2NCk7XG4gICAgYXNzZXJ0KHdpcmVUcmFuc2FjdGlvbi5sZW5ndGggPD0gUEFDS0VUX0RBVEFfU0laRSwgYFRyYW5zYWN0aW9uIHRvbyBsYXJnZTogJHt3aXJlVHJhbnNhY3Rpb24ubGVuZ3RofSA+ICR7UEFDS0VUX0RBVEFfU0laRX1gKTtcbiAgICByZXR1cm4gd2lyZVRyYW5zYWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcHJlY2F0ZWQgbWV0aG9kXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0IGtleXMoKSB7XG4gICAgYXNzZXJ0KHRoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aCA9PT0gMSk7XG4gICAgcmV0dXJuIHRoaXMuaW5zdHJ1Y3Rpb25zWzBdLmtleXMubWFwKGtleU9iaiA9PiBrZXlPYmoucHVia2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXByZWNhdGVkIG1ldGhvZFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldCBwcm9ncmFtSWQoKSB7XG4gICAgYXNzZXJ0KHRoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aCA9PT0gMSk7XG4gICAgcmV0dXJuIHRoaXMuaW5zdHJ1Y3Rpb25zWzBdLnByb2dyYW1JZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXByZWNhdGVkIG1ldGhvZFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldCBkYXRhKCkge1xuICAgIGFzc2VydCh0aGlzLmluc3RydWN0aW9ucy5sZW5ndGggPT09IDEpO1xuICAgIHJldHVybiB0aGlzLmluc3RydWN0aW9uc1swXS5kYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgd2lyZSB0cmFuc2FjdGlvbiBpbnRvIGEgVHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlciB8IFVpbnQ4QXJyYXkgfCBBcnJheTxudW1iZXI+fSBidWZmZXIgU2lnbmF0dXJlIG9mIHdpcmUgVHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMge1RyYW5zYWN0aW9ufSBUcmFuc2FjdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIHNpZ25hdHVyZVxuICAgKi9cbiAgc3RhdGljIGZyb20oYnVmZmVyKSB7XG4gICAgLy8gU2xpY2UgdXAgd2lyZSBkYXRhXG4gICAgbGV0IGJ5dGVBcnJheSA9IFsuLi5idWZmZXJdO1xuICAgIGNvbnN0IHNpZ25hdHVyZUNvdW50ID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgbGV0IHNpZ25hdHVyZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ25hdHVyZUNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTKTtcbiAgICAgIHNpZ25hdHVyZXMucHVzaChiczU4LmVuY29kZShCdWZmZXIuZnJvbShzaWduYXR1cmUpKSk7XG4gICAgfVxuICAgIHJldHVybiBUcmFuc2FjdGlvbi5wb3B1bGF0ZShNZXNzYWdlLmZyb20oYnl0ZUFycmF5KSwgc2lnbmF0dXJlcyk7XG4gIH1cblxuICAvKipcbiAgICogUG9wdWxhdGUgVHJhbnNhY3Rpb24gb2JqZWN0IGZyb20gbWVzc2FnZSBhbmQgc2lnbmF0dXJlc1xuICAgKlxuICAgKiBAcGFyYW0ge01lc3NhZ2V9IG1lc3NhZ2UgTWVzc2FnZSBvZiB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHNpZ25hdHVyZXMgTGlzdCBvZiBzaWduYXR1cmVzIHRvIGFzc2lnbiB0byB0aGUgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMge1RyYW5zYWN0aW9ufSBUaGUgcG9wdWxhdGVkIFRyYW5zYWN0aW9uXG4gICAqL1xuICBzdGF0aWMgcG9wdWxhdGUobWVzc2FnZSwgc2lnbmF0dXJlcyA9IFtdKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICB0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBtZXNzYWdlLnJlY2VudEJsb2NraGFzaDtcbiAgICBpZiAobWVzc2FnZS5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzID4gMCkge1xuICAgICAgdHJhbnNhY3Rpb24uZmVlUGF5ZXIgPSBtZXNzYWdlLmFjY291bnRLZXlzWzBdO1xuICAgIH1cbiAgICBzaWduYXR1cmVzLmZvckVhY2goKHNpZ25hdHVyZSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHNpZ1B1YmtleVBhaXIgPSB7XG4gICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlID09IGJzNTguZW5jb2RlKERFRkFVTFRfU0lHTkFUVVJFKSA/IG51bGwgOiBiczU4LmRlY29kZShzaWduYXR1cmUpLFxuICAgICAgICBwdWJsaWNLZXk6IG1lc3NhZ2UuYWNjb3VudEtleXNbaW5kZXhdXG4gICAgICB9O1xuICAgICAgdHJhbnNhY3Rpb24uc2lnbmF0dXJlcy5wdXNoKHNpZ1B1YmtleVBhaXIpO1xuICAgIH0pO1xuICAgIG1lc3NhZ2UuaW5zdHJ1Y3Rpb25zLmZvckVhY2goaW5zdHJ1Y3Rpb24gPT4ge1xuICAgICAgY29uc3Qga2V5cyA9IGluc3RydWN0aW9uLmFjY291bnRzLm1hcChhY2NvdW50ID0+IHtcbiAgICAgICAgY29uc3QgcHVia2V5ID0gbWVzc2FnZS5hY2NvdW50S2V5c1thY2NvdW50XTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwdWJrZXksXG4gICAgICAgICAgaXNTaWduZXI6IHRyYW5zYWN0aW9uLnNpZ25hdHVyZXMuc29tZShrZXlPYmogPT4ga2V5T2JqLnB1YmxpY0tleS50b1N0cmluZygpID09PSBwdWJrZXkudG9TdHJpbmcoKSkgfHwgbWVzc2FnZS5pc0FjY291bnRTaWduZXIoYWNjb3VudCksXG4gICAgICAgICAgaXNXcml0YWJsZTogbWVzc2FnZS5pc0FjY291bnRXcml0YWJsZShhY2NvdW50KVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICB0cmFuc2FjdGlvbi5pbnN0cnVjdGlvbnMucHVzaChuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICAgIGtleXMsXG4gICAgICAgIHByb2dyYW1JZDogbWVzc2FnZS5hY2NvdW50S2V5c1tpbnN0cnVjdGlvbi5wcm9ncmFtSWRJbmRleF0sXG4gICAgICAgIGRhdGE6IGJzNTguZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpXG4gICAgICB9KSk7XG4gICAgfSk7XG4gICAgdHJhbnNhY3Rpb24uX21lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRyYW5zYWN0aW9uLl9qc29uID0gdHJhbnNhY3Rpb24udG9KU09OKCk7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICB9XG59XG5cbmNsYXNzIFRyYW5zYWN0aW9uTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICB0aGlzLnBheWVyS2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gdm9pZCAwO1xuICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gdm9pZCAwO1xuICAgIHRoaXMucGF5ZXJLZXkgPSBhcmdzLnBheWVyS2V5O1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gYXJncy5pbnN0cnVjdGlvbnM7XG4gICAgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSBhcmdzLnJlY2VudEJsb2NraGFzaDtcbiAgfVxuICBzdGF0aWMgZGVjb21waWxlKG1lc3NhZ2UsIGFyZ3MpIHtcbiAgICBjb25zdCB7XG4gICAgICBoZWFkZXIsXG4gICAgICBjb21waWxlZEluc3RydWN0aW9ucyxcbiAgICAgIHJlY2VudEJsb2NraGFzaFxuICAgIH0gPSBtZXNzYWdlO1xuICAgIGNvbnN0IHtcbiAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlcyxcbiAgICAgIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMsXG4gICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHNcbiAgICB9ID0gaGVhZGVyO1xuICAgIGNvbnN0IG51bVdyaXRhYmxlU2lnbmVkQWNjb3VudHMgPSBudW1SZXF1aXJlZFNpZ25hdHVyZXMgLSBudW1SZWFkb25seVNpZ25lZEFjY291bnRzO1xuICAgIGFzc2VydChudW1Xcml0YWJsZVNpZ25lZEFjY291bnRzID4gMCwgJ01lc3NhZ2UgaGVhZGVyIGlzIGludmFsaWQnKTtcbiAgICBjb25zdCBudW1Xcml0YWJsZVVuc2lnbmVkQWNjb3VudHMgPSBtZXNzYWdlLnN0YXRpY0FjY291bnRLZXlzLmxlbmd0aCAtIG51bVJlcXVpcmVkU2lnbmF0dXJlcyAtIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cztcbiAgICBhc3NlcnQobnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzID49IDAsICdNZXNzYWdlIGhlYWRlciBpcyBpbnZhbGlkJyk7XG4gICAgY29uc3QgYWNjb3VudEtleXMgPSBtZXNzYWdlLmdldEFjY291bnRLZXlzKGFyZ3MpO1xuICAgIGNvbnN0IHBheWVyS2V5ID0gYWNjb3VudEtleXMuZ2V0KDApO1xuICAgIGlmIChwYXllcktleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkZWNvbXBpbGUgbWVzc2FnZSBiZWNhdXNlIG5vIGFjY291bnQga2V5cyB3ZXJlIGZvdW5kJyk7XG4gICAgfVxuICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IFtdO1xuICAgIGZvciAoY29uc3QgY29tcGlsZWRJeCBvZiBjb21waWxlZEluc3RydWN0aW9ucykge1xuICAgICAgY29uc3Qga2V5cyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBrZXlJbmRleCBvZiBjb21waWxlZEl4LmFjY291bnRLZXlJbmRleGVzKSB7XG4gICAgICAgIGNvbnN0IHB1YmtleSA9IGFjY291bnRLZXlzLmdldChrZXlJbmRleCk7XG4gICAgICAgIGlmIChwdWJrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZpbmQga2V5IGZvciBhY2NvdW50IGtleSBpbmRleCAke2tleUluZGV4fWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzU2lnbmVyID0ga2V5SW5kZXggPCBudW1SZXF1aXJlZFNpZ25hdHVyZXM7XG4gICAgICAgIGxldCBpc1dyaXRhYmxlO1xuICAgICAgICBpZiAoaXNTaWduZXIpIHtcbiAgICAgICAgICBpc1dyaXRhYmxlID0ga2V5SW5kZXggPCBudW1Xcml0YWJsZVNpZ25lZEFjY291bnRzO1xuICAgICAgICB9IGVsc2UgaWYgKGtleUluZGV4IDwgYWNjb3VudEtleXMuc3RhdGljQWNjb3VudEtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgaXNXcml0YWJsZSA9IGtleUluZGV4IC0gbnVtUmVxdWlyZWRTaWduYXR1cmVzIDwgbnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzV3JpdGFibGUgPSBrZXlJbmRleCAtIGFjY291bnRLZXlzLnN0YXRpY0FjY291bnRLZXlzLmxlbmd0aCA8XG4gICAgICAgICAgLy8gYWNjb3VudEtleXNGcm9tTG9va3VwcyBjYW5ub3QgYmUgdW5kZWZpbmVkIGJlY2F1c2Ugd2UgYWxyZWFkeSBmb3VuZCBhIHB1YmtleSBmb3IgdGhpcyBpbmRleCBhYm92ZVxuICAgICAgICAgIGFjY291bnRLZXlzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMud3JpdGFibGUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGtleXMucHVzaCh7XG4gICAgICAgICAgcHVia2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiBrZXlJbmRleCA8IGhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMsXG4gICAgICAgICAgaXNXcml0YWJsZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByb2dyYW1JZCA9IGFjY291bnRLZXlzLmdldChjb21waWxlZEl4LnByb2dyYW1JZEluZGV4KTtcbiAgICAgIGlmIChwcm9ncmFtSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmaW5kIHByb2dyYW0gaWQgZm9yIHByb2dyYW0gaWQgaW5kZXggJHtjb21waWxlZEl4LnByb2dyYW1JZEluZGV4fWApO1xuICAgICAgfVxuICAgICAgaW5zdHJ1Y3Rpb25zLnB1c2gobmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICBwcm9ncmFtSWQsXG4gICAgICAgIGRhdGE6IHRvQnVmZmVyKGNvbXBpbGVkSXguZGF0YSksXG4gICAgICAgIGtleXNcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbk1lc3NhZ2Uoe1xuICAgICAgcGF5ZXJLZXksXG4gICAgICBpbnN0cnVjdGlvbnMsXG4gICAgICByZWNlbnRCbG9ja2hhc2hcbiAgICB9KTtcbiAgfVxuICBjb21waWxlVG9MZWdhY3lNZXNzYWdlKCkge1xuICAgIHJldHVybiBNZXNzYWdlLmNvbXBpbGUoe1xuICAgICAgcGF5ZXJLZXk6IHRoaXMucGF5ZXJLZXksXG4gICAgICByZWNlbnRCbG9ja2hhc2g6IHRoaXMucmVjZW50QmxvY2toYXNoLFxuICAgICAgaW5zdHJ1Y3Rpb25zOiB0aGlzLmluc3RydWN0aW9uc1xuICAgIH0pO1xuICB9XG4gIGNvbXBpbGVUb1YwTWVzc2FnZShhZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cykge1xuICAgIHJldHVybiBNZXNzYWdlVjAuY29tcGlsZSh7XG4gICAgICBwYXllcktleTogdGhpcy5wYXllcktleSxcbiAgICAgIHJlY2VudEJsb2NraGFzaDogdGhpcy5yZWNlbnRCbG9ja2hhc2gsXG4gICAgICBpbnN0cnVjdGlvbnM6IHRoaXMuaW5zdHJ1Y3Rpb25zLFxuICAgICAgYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHNcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFZlcnNpb25lZCB0cmFuc2FjdGlvbiBjbGFzc1xuICovXG5jbGFzcyBWZXJzaW9uZWRUcmFuc2FjdGlvbiB7XG4gIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2UudmVyc2lvbjtcbiAgfVxuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzaWduYXR1cmVzKSB7XG4gICAgdGhpcy5zaWduYXR1cmVzID0gdm9pZCAwO1xuICAgIHRoaXMubWVzc2FnZSA9IHZvaWQgMDtcbiAgICBpZiAoc2lnbmF0dXJlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhc3NlcnQoc2lnbmF0dXJlcy5sZW5ndGggPT09IG1lc3NhZ2UuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcywgJ0V4cGVjdGVkIHNpZ25hdHVyZXMgbGVuZ3RoIHRvIGJlIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgcmVxdWlyZWQgc2lnbmF0dXJlcycpO1xuICAgICAgdGhpcy5zaWduYXR1cmVzID0gc2lnbmF0dXJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZGVmYXVsdFNpZ25hdHVyZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZS5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzOyBpKyspIHtcbiAgICAgICAgZGVmYXVsdFNpZ25hdHVyZXMucHVzaChuZXcgVWludDhBcnJheShTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTKSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNpZ25hdHVyZXMgPSBkZWZhdWx0U2lnbmF0dXJlcztcbiAgICB9XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgfVxuICBzZXJpYWxpemUoKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZE1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2Uuc2VyaWFsaXplKCk7XG4gICAgY29uc3QgZW5jb2RlZFNpZ25hdHVyZXNMZW5ndGggPSBBcnJheSgpO1xuICAgIGVuY29kZUxlbmd0aChlbmNvZGVkU2lnbmF0dXJlc0xlbmd0aCwgdGhpcy5zaWduYXR1cmVzLmxlbmd0aCk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25MYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQuYmxvYihlbmNvZGVkU2lnbmF0dXJlc0xlbmd0aC5sZW5ndGgsICdlbmNvZGVkU2lnbmF0dXJlc0xlbmd0aCcpLCBCdWZmZXJMYXlvdXQuc2VxKHNpZ25hdHVyZSgpLCB0aGlzLnNpZ25hdHVyZXMubGVuZ3RoLCAnc2lnbmF0dXJlcycpLCBCdWZmZXJMYXlvdXQuYmxvYihzZXJpYWxpemVkTWVzc2FnZS5sZW5ndGgsICdzZXJpYWxpemVkTWVzc2FnZScpXSk7XG4gICAgY29uc3Qgc2VyaWFsaXplZFRyYW5zYWN0aW9uID0gbmV3IFVpbnQ4QXJyYXkoMjA0OCk7XG4gICAgY29uc3Qgc2VyaWFsaXplZFRyYW5zYWN0aW9uTGVuZ3RoID0gdHJhbnNhY3Rpb25MYXlvdXQuZW5jb2RlKHtcbiAgICAgIGVuY29kZWRTaWduYXR1cmVzTGVuZ3RoOiBuZXcgVWludDhBcnJheShlbmNvZGVkU2lnbmF0dXJlc0xlbmd0aCksXG4gICAgICBzaWduYXR1cmVzOiB0aGlzLnNpZ25hdHVyZXMsXG4gICAgICBzZXJpYWxpemVkTWVzc2FnZVxuICAgIH0sIHNlcmlhbGl6ZWRUcmFuc2FjdGlvbik7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWRUcmFuc2FjdGlvbi5zbGljZSgwLCBzZXJpYWxpemVkVHJhbnNhY3Rpb25MZW5ndGgpO1xuICB9XG4gIHN0YXRpYyBkZXNlcmlhbGl6ZShzZXJpYWxpemVkVHJhbnNhY3Rpb24pIHtcbiAgICBsZXQgYnl0ZUFycmF5ID0gWy4uLnNlcmlhbGl6ZWRUcmFuc2FjdGlvbl07XG4gICAgY29uc3Qgc2lnbmF0dXJlcyA9IFtdO1xuICAgIGNvbnN0IHNpZ25hdHVyZXNMZW5ndGggPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ25hdHVyZXNMZW5ndGg7IGkrKykge1xuICAgICAgc2lnbmF0dXJlcy5wdXNoKG5ldyBVaW50OEFycmF5KGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTKSkpO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlID0gVmVyc2lvbmVkTWVzc2FnZS5kZXNlcmlhbGl6ZShuZXcgVWludDhBcnJheShieXRlQXJyYXkpKTtcbiAgICByZXR1cm4gbmV3IFZlcnNpb25lZFRyYW5zYWN0aW9uKG1lc3NhZ2UsIHNpZ25hdHVyZXMpO1xuICB9XG4gIHNpZ24oc2lnbmVycykge1xuICAgIGNvbnN0IG1lc3NhZ2VEYXRhID0gdGhpcy5tZXNzYWdlLnNlcmlhbGl6ZSgpO1xuICAgIGNvbnN0IHNpZ25lclB1YmtleXMgPSB0aGlzLm1lc3NhZ2Uuc3RhdGljQWNjb3VudEtleXMuc2xpY2UoMCwgdGhpcy5tZXNzYWdlLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMpO1xuICAgIGZvciAoY29uc3Qgc2lnbmVyIG9mIHNpZ25lcnMpIHtcbiAgICAgIGNvbnN0IHNpZ25lckluZGV4ID0gc2lnbmVyUHVia2V5cy5maW5kSW5kZXgocHVia2V5ID0+IHB1YmtleS5lcXVhbHMoc2lnbmVyLnB1YmxpY0tleSkpO1xuICAgICAgYXNzZXJ0KHNpZ25lckluZGV4ID49IDAsIGBDYW5ub3Qgc2lnbiB3aXRoIG5vbiBzaWduZXIga2V5ICR7c2lnbmVyLnB1YmxpY0tleS50b0Jhc2U1OCgpfWApO1xuICAgICAgdGhpcy5zaWduYXR1cmVzW3NpZ25lckluZGV4XSA9IHNpZ24obWVzc2FnZURhdGEsIHNpZ25lci5zZWNyZXRLZXkpO1xuICAgIH1cbiAgfVxuICBhZGRTaWduYXR1cmUocHVibGljS2V5LCBzaWduYXR1cmUpIHtcbiAgICBhc3NlcnQoc2lnbmF0dXJlLmJ5dGVMZW5ndGggPT09IDY0LCAnU2lnbmF0dXJlIG11c3QgYmUgNjQgYnl0ZXMgbG9uZycpO1xuICAgIGNvbnN0IHNpZ25lclB1YmtleXMgPSB0aGlzLm1lc3NhZ2Uuc3RhdGljQWNjb3VudEtleXMuc2xpY2UoMCwgdGhpcy5tZXNzYWdlLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMpO1xuICAgIGNvbnN0IHNpZ25lckluZGV4ID0gc2lnbmVyUHVia2V5cy5maW5kSW5kZXgocHVia2V5ID0+IHB1YmtleS5lcXVhbHMocHVibGljS2V5KSk7XG4gICAgYXNzZXJ0KHNpZ25lckluZGV4ID49IDAsIGBDYW4gbm90IGFkZCBzaWduYXR1cmU7IFxcYCR7cHVibGljS2V5LnRvQmFzZTU4KCl9XFxgIGlzIG5vdCByZXF1aXJlZCB0byBzaWduIHRoaXMgdHJhbnNhY3Rpb25gKTtcbiAgICB0aGlzLnNpZ25hdHVyZXNbc2lnbmVySW5kZXhdID0gc2lnbmF0dXJlO1xuICB9XG59XG5cbi8vIFRPRE86IFRoZXNlIGNvbnN0YW50cyBzaG91bGQgYmUgcmVtb3ZlZCBpbiBmYXZvciBvZiByZWFkaW5nIHRoZW0gb3V0IG9mIGFcbi8vIFN5c2NhbGwgYWNjb3VudFxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBOVU1fVElDS1NfUEVSX1NFQ09ORCA9IDE2MDtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgREVGQVVMVF9USUNLU19QRVJfU0xPVCA9IDY0O1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBOVU1fU0xPVFNfUEVSX1NFQ09ORCA9IE5VTV9USUNLU19QRVJfU0VDT05EIC8gREVGQVVMVF9USUNLU19QRVJfU0xPVDtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgTVNfUEVSX1NMT1QgPSAxMDAwIC8gTlVNX1NMT1RTX1BFUl9TRUNPTkQ7XG5cbmNvbnN0IFNZU1ZBUl9DTE9DS19QVUJLRVkgPSBuZXcgUHVibGljS2V5KCdTeXN2YXJDMW9jazExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5jb25zdCBTWVNWQVJfRVBPQ0hfU0NIRURVTEVfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyRXBvY2hTY2hlZHUxZTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuY29uc3QgU1lTVkFSX0lOU1RSVUNUSU9OU19QVUJLRVkgPSBuZXcgUHVibGljS2V5KCdTeXN2YXIxbnN0cnVjdGlvbnMxMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5jb25zdCBTWVNWQVJfUkVDRU5UX0JMT0NLSEFTSEVTX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoJ1N5c3ZhclJlY2VudEIxb2NrSGFzaGVzMTExMTExMTExMTExMTExMTExMTEnKTtcbmNvbnN0IFNZU1ZBUl9SRU5UX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoJ1N5c3ZhclJlbnQxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcbmNvbnN0IFNZU1ZBUl9SRVdBUkRTX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoJ1N5c3ZhclJld2FyZHMxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcbmNvbnN0IFNZU1ZBUl9TTE9UX0hBU0hFU19QVUJLRVkgPSBuZXcgUHVibGljS2V5KCdTeXN2YXJTMW90SGFzaGVzMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5jb25zdCBTWVNWQVJfU0xPVF9ISVNUT1JZX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoJ1N5c3ZhclMxb3RIaXN0b3J5MTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcbmNvbnN0IFNZU1ZBUl9TVEFLRV9ISVNUT1JZX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoJ1N5c3ZhclN0YWtlSGlzdG9yeTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuY2xhc3MgU2VuZFRyYW5zYWN0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBhY3Rpb24sXG4gICAgc2lnbmF0dXJlLFxuICAgIHRyYW5zYWN0aW9uTWVzc2FnZSxcbiAgICBsb2dzXG4gIH0pIHtcbiAgICBjb25zdCBtYXliZUxvZ3NPdXRwdXQgPSBsb2dzID8gYExvZ3M6IFxcbiR7SlNPTi5zdHJpbmdpZnkobG9ncy5zbGljZSgtMTApLCBudWxsLCAyKX0uIGAgOiAnJztcbiAgICBjb25zdCBndWlkZVRleHQgPSAnXFxuQ2F0Y2ggdGhlIGBTZW5kVHJhbnNhY3Rpb25FcnJvcmAgYW5kIGNhbGwgYGdldExvZ3MoKWAgb24gaXQgZm9yIGZ1bGwgZGV0YWlscy4nO1xuICAgIGxldCBtZXNzYWdlO1xuICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICBjYXNlICdzZW5kJzpcbiAgICAgICAgbWVzc2FnZSA9IGBUcmFuc2FjdGlvbiAke3NpZ25hdHVyZX0gcmVzdWx0ZWQgaW4gYW4gZXJyb3IuIFxcbmAgKyBgJHt0cmFuc2FjdGlvbk1lc3NhZ2V9LiBgICsgbWF5YmVMb2dzT3V0cHV0ICsgZ3VpZGVUZXh0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NpbXVsYXRlJzpcbiAgICAgICAgbWVzc2FnZSA9IGBTaW11bGF0aW9uIGZhaWxlZC4gXFxuTWVzc2FnZTogJHt0cmFuc2FjdGlvbk1lc3NhZ2V9LiBcXG5gICsgbWF5YmVMb2dzT3V0cHV0ICsgZ3VpZGVUZXh0O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBtZXNzYWdlID0gYFVua25vd24gYWN0aW9uICckeyhhID0+IGEpKGFjdGlvbil9J2A7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5zaWduYXR1cmUgPSB2b2lkIDA7XG4gICAgdGhpcy50cmFuc2FjdGlvbk1lc3NhZ2UgPSB2b2lkIDA7XG4gICAgdGhpcy50cmFuc2FjdGlvbkxvZ3MgPSB2b2lkIDA7XG4gICAgdGhpcy5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG4gICAgdGhpcy50cmFuc2FjdGlvbk1lc3NhZ2UgPSB0cmFuc2FjdGlvbk1lc3NhZ2U7XG4gICAgdGhpcy50cmFuc2FjdGlvbkxvZ3MgPSBsb2dzID8gbG9ncyA6IHVuZGVmaW5lZDtcbiAgfVxuICBnZXQgdHJhbnNhY3Rpb25FcnJvcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWVzc2FnZTogdGhpcy50cmFuc2FjdGlvbk1lc3NhZ2UsXG4gICAgICBsb2dzOiBBcnJheS5pc0FycmF5KHRoaXMudHJhbnNhY3Rpb25Mb2dzKSA/IHRoaXMudHJhbnNhY3Rpb25Mb2dzIDogdW5kZWZpbmVkXG4gICAgfTtcbiAgfVxuXG4gIC8qIEBkZXByZWNhdGVkIFVzZSBgYXdhaXQgZ2V0TG9ncygpYCBpbnN0ZWFkICovXG4gIGdldCBsb2dzKCkge1xuICAgIGNvbnN0IGNhY2hlZExvZ3MgPSB0aGlzLnRyYW5zYWN0aW9uTG9ncztcbiAgICBpZiAoY2FjaGVkTG9ncyAhPSBudWxsICYmIHR5cGVvZiBjYWNoZWRMb2dzID09PSAnb2JqZWN0JyAmJiAndGhlbicgaW4gY2FjaGVkTG9ncykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZExvZ3M7XG4gIH1cbiAgYXN5bmMgZ2V0TG9ncyhjb25uZWN0aW9uKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMudHJhbnNhY3Rpb25Mb2dzKSkge1xuICAgICAgdGhpcy50cmFuc2FjdGlvbkxvZ3MgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbm5lY3Rpb24uZ2V0VHJhbnNhY3Rpb24odGhpcy5zaWduYXR1cmUpLnRoZW4odHggPT4ge1xuICAgICAgICAgIGlmICh0eCAmJiB0eC5tZXRhICYmIHR4Lm1ldGEubG9nTWVzc2FnZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvZ3MgPSB0eC5tZXRhLmxvZ01lc3NhZ2VzO1xuICAgICAgICAgICAgdGhpcy50cmFuc2FjdGlvbkxvZ3MgPSBsb2dzO1xuICAgICAgICAgICAgcmVzb2x2ZShsb2dzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignTG9nIG1lc3NhZ2VzIG5vdCBmb3VuZCcpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNhY3Rpb25Mb2dzO1xuICB9XG59XG5cbi8vIEtlZXAgaW4gc3luYyB3aXRoIGNsaWVudC9zcmMvcnBjX2N1c3RvbV9lcnJvcnMucnNcbi8vIFR5cGVzY3JpcHQgYGVudW1zYCB0aHdhcnQgdHJlZS1zaGFraW5nLiBTZWUgaHR0cHM6Ly9iYXJnc3Rlbi5vcmcvanN0cy9lbnVtcy9cbmNvbnN0IFNvbGFuYUpTT05SUENFcnJvckNvZGUgPSB7XG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9CTE9DS19DTEVBTkVEX1VQOiAtMzIwMDEsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9TRU5EX1RSQU5TQUNUSU9OX1BSRUZMSUdIVF9GQUlMVVJFOiAtMzIwMDIsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9TSUdOQVRVUkVfVkVSSUZJQ0FUSU9OX0ZBSUxVUkU6IC0zMjAwMyxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX0JMT0NLX05PVF9BVkFJTEFCTEU6IC0zMjAwNCxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX05PREVfVU5IRUFMVEhZOiAtMzIwMDUsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9QUkVDT01QSUxFX1ZFUklGSUNBVElPTl9GQUlMVVJFOiAtMzIwMDYsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9TTE9UX1NLSVBQRUQ6IC0zMjAwNyxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX05PX1NOQVBTSE9UOiAtMzIwMDgsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9MT05HX1RFUk1fU1RPUkFHRV9TTE9UX1NLSVBQRUQ6IC0zMjAwOSxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX0tFWV9FWENMVURFRF9GUk9NX1NFQ09OREFSWV9JTkRFWDogLTMyMDEwLFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fSElTVE9SWV9OT1RfQVZBSUxBQkxFOiAtMzIwMTEsXG4gIEpTT05fUlBDX1NDQU5fRVJST1I6IC0zMjAxMixcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1NJR05BVFVSRV9MRU5fTUlTTUFUQ0g6IC0zMjAxMyxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX0JMT0NLX1NUQVRVU19OT1RfQVZBSUxBQkxFX1lFVDogLTMyMDE0LFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfVU5TVVBQT1JURURfVFJBTlNBQ1RJT05fVkVSU0lPTjogLTMyMDE1LFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfTUlOX0NPTlRFWFRfU0xPVF9OT1RfUkVBQ0hFRDogLTMyMDE2XG59O1xuY2xhc3MgU29sYW5hSlNPTlJQQ0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY29kZSxcbiAgICBtZXNzYWdlLFxuICAgIGRhdGFcbiAgfSwgY3VzdG9tTWVzc2FnZSkge1xuICAgIHN1cGVyKGN1c3RvbU1lc3NhZ2UgIT0gbnVsbCA/IGAke2N1c3RvbU1lc3NhZ2V9OiAke21lc3NhZ2V9YCA6IG1lc3NhZ2UpO1xuICAgIHRoaXMuY29kZSA9IHZvaWQgMDtcbiAgICB0aGlzLmRhdGEgPSB2b2lkIDA7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMubmFtZSA9ICdTb2xhbmFKU09OUlBDRXJyb3InO1xuICB9XG59XG5cbi8qKlxuICogU2lnbiwgc2VuZCBhbmQgY29uZmlybSBhIHRyYW5zYWN0aW9uLlxuICpcbiAqIElmIGBjb21taXRtZW50YCBvcHRpb24gaXMgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gJ21heCcgY29tbWl0bWVudC5cbiAqXG4gKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm5lY3Rpb25cbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5PFNpZ25lcj59IHNpZ25lcnNcbiAqIEBwYXJhbSB7Q29uZmlybU9wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb25TaWduYXR1cmU+fVxuICovXG5hc3luYyBmdW5jdGlvbiBzZW5kQW5kQ29uZmlybVRyYW5zYWN0aW9uKGNvbm5lY3Rpb24sIHRyYW5zYWN0aW9uLCBzaWduZXJzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNlbmRPcHRpb25zID0gb3B0aW9ucyAmJiB7XG4gICAgc2tpcFByZWZsaWdodDogb3B0aW9ucy5za2lwUHJlZmxpZ2h0LFxuICAgIHByZWZsaWdodENvbW1pdG1lbnQ6IG9wdGlvbnMucHJlZmxpZ2h0Q29tbWl0bWVudCB8fCBvcHRpb25zLmNvbW1pdG1lbnQsXG4gICAgbWF4UmV0cmllczogb3B0aW9ucy5tYXhSZXRyaWVzLFxuICAgIG1pbkNvbnRleHRTbG90OiBvcHRpb25zLm1pbkNvbnRleHRTbG90XG4gIH07XG4gIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IGNvbm5lY3Rpb24uc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBzaWduZXJzLCBzZW5kT3B0aW9ucyk7XG4gIGxldCBzdGF0dXM7XG4gIGlmICh0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggIT0gbnVsbCAmJiB0cmFuc2FjdGlvbi5sYXN0VmFsaWRCbG9ja0hlaWdodCAhPSBudWxsKSB7XG4gICAgc3RhdHVzID0gKGF3YWl0IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHtcbiAgICAgIGFib3J0U2lnbmFsOiBvcHRpb25zPy5hYm9ydFNpZ25hbCxcbiAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlLFxuICAgICAgYmxvY2toYXNoOiB0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2gsXG4gICAgICBsYXN0VmFsaWRCbG9ja0hlaWdodDogdHJhbnNhY3Rpb24ubGFzdFZhbGlkQmxvY2tIZWlnaHRcbiAgICB9LCBvcHRpb25zICYmIG9wdGlvbnMuY29tbWl0bWVudCkpLnZhbHVlO1xuICB9IGVsc2UgaWYgKHRyYW5zYWN0aW9uLm1pbk5vbmNlQ29udGV4dFNsb3QgIT0gbnVsbCAmJiB0cmFuc2FjdGlvbi5ub25jZUluZm8gIT0gbnVsbCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG5vbmNlSW5zdHJ1Y3Rpb25cbiAgICB9ID0gdHJhbnNhY3Rpb24ubm9uY2VJbmZvO1xuICAgIGNvbnN0IG5vbmNlQWNjb3VudFB1YmtleSA9IG5vbmNlSW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXk7XG4gICAgc3RhdHVzID0gKGF3YWl0IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHtcbiAgICAgIGFib3J0U2lnbmFsOiBvcHRpb25zPy5hYm9ydFNpZ25hbCxcbiAgICAgIG1pbkNvbnRleHRTbG90OiB0cmFuc2FjdGlvbi5taW5Ob25jZUNvbnRleHRTbG90LFxuICAgICAgbm9uY2VBY2NvdW50UHVia2V5LFxuICAgICAgbm9uY2VWYWx1ZTogdHJhbnNhY3Rpb24ubm9uY2VJbmZvLm5vbmNlLFxuICAgICAgc2lnbmF0dXJlXG4gICAgfSwgb3B0aW9ucyAmJiBvcHRpb25zLmNvbW1pdG1lbnQpKS52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBpZiAob3B0aW9ucz8uYWJvcnRTaWduYWwgIT0gbnVsbCkge1xuICAgICAgY29uc29sZS53YXJuKCdzZW5kQW5kQ29uZmlybVRyYW5zYWN0aW9uKCk6IEEgdHJhbnNhY3Rpb24gd2l0aCBhIGRlcHJlY2F0ZWQgY29uZmlybWF0aW9uIHN0cmF0ZWd5IHdhcyAnICsgJ3N1cHBsaWVkIGFsb25nIHdpdGggYW4gYGFib3J0U2lnbmFsYC4gT25seSB0cmFuc2FjdGlvbnMgaGF2aW5nIGBsYXN0VmFsaWRCbG9ja0hlaWdodGAgJyArICdvciBhIGNvbWJpbmF0aW9uIG9mIGBub25jZUluZm9gIGFuZCBgbWluTm9uY2VDb250ZXh0U2xvdGAgYXJlIGFib3J0YWJsZS4nKTtcbiAgICB9XG4gICAgc3RhdHVzID0gKGF3YWl0IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHNpZ25hdHVyZSwgb3B0aW9ucyAmJiBvcHRpb25zLmNvbW1pdG1lbnQpKS52YWx1ZTtcbiAgfVxuICBpZiAoc3RhdHVzLmVycikge1xuICAgIGlmIChzaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFNlbmRUcmFuc2FjdGlvbkVycm9yKHtcbiAgICAgICAgYWN0aW9uOiAnc2VuZCcsXG4gICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlLFxuICAgICAgICB0cmFuc2FjdGlvbk1lc3NhZ2U6IGBTdGF0dXM6ICgke0pTT04uc3RyaW5naWZ5KHN0YXR1cyl9KWBcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRyYW5zYWN0aW9uICR7c2lnbmF0dXJlfSBmYWlsZWQgKCR7SlNPTi5zdHJpbmdpZnkoc3RhdHVzKX0pYCk7XG4gIH1cbiAgcmV0dXJuIHNpZ25hdHVyZTtcbn1cblxuLy8genp6XG5mdW5jdGlvbiBzbGVlcChtcykge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuLyoqXG4gKiBQb3B1bGF0ZSBhIGJ1ZmZlciBvZiBpbnN0cnVjdGlvbiBkYXRhIHVzaW5nIGFuIEluc3RydWN0aW9uVHlwZVxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGVuY29kZURhdGEodHlwZSwgZmllbGRzKSB7XG4gIGNvbnN0IGFsbG9jTGVuZ3RoID0gdHlwZS5sYXlvdXQuc3BhbiA+PSAwID8gdHlwZS5sYXlvdXQuc3BhbiA6IGdldEFsbG9jKHR5cGUsIGZpZWxkcyk7XG4gIGNvbnN0IGRhdGEgPSBCdWZmZXIuYWxsb2MoYWxsb2NMZW5ndGgpO1xuICBjb25zdCBsYXlvdXRGaWVsZHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBpbnN0cnVjdGlvbjogdHlwZS5pbmRleFxuICB9LCBmaWVsZHMpO1xuICB0eXBlLmxheW91dC5lbmNvZGUobGF5b3V0RmllbGRzLCBkYXRhKTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogRGVjb2RlIGluc3RydWN0aW9uIGRhdGEgYnVmZmVyIHVzaW5nIGFuIEluc3RydWN0aW9uVHlwZVxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGRlY29kZURhdGEkMSh0eXBlLCBidWZmZXIpIHtcbiAgbGV0IGRhdGE7XG4gIHRyeSB7XG4gICAgZGF0YSA9IHR5cGUubGF5b3V0LmRlY29kZShidWZmZXIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5zdHJ1Y3Rpb247ICcgKyBlcnIpO1xuICB9XG4gIGlmIChkYXRhLmluc3RydWN0aW9uICE9PSB0eXBlLmluZGV4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGluc3RydWN0aW9uOyBpbnN0cnVjdGlvbiBpbmRleCBtaXNtYXRjaCAke2RhdGEuaW5zdHJ1Y3Rpb259ICE9ICR7dHlwZS5pbmRleH1gKTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2Jsb2IvOTBiZWRkN2UwNjdiNWI4ZjNkZGJiNDVkYTAwYTRlOWNhYmIyMmM2Mi9zZGsvc3JjL2ZlZV9jYWxjdWxhdG9yLnJzI0w3LUwxMVxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBGZWVDYWxjdWxhdG9yTGF5b3V0ID0gQnVmZmVyTGF5b3V0Lm51NjQoJ2xhbXBvcnRzUGVyU2lnbmF0dXJlJyk7XG5cbi8qKlxuICogQ2FsY3VsYXRvciBmb3IgdHJhbnNhY3Rpb24gZmVlcy5cbiAqXG4gKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS44LjAuXG4gKi9cblxuLyoqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9ibG9iLzBlYTI4NDNlYzljZGM1MTc1NzJiOGU2MmM5NTlmNDFiNTVjZjQ0NTMvc2RrL3NyYy9ub25jZV9zdGF0ZS5ycyNMMjktTDMyXG4gKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IE5vbmNlQWNjb3VudExheW91dCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ3ZlcnNpb24nKSwgQnVmZmVyTGF5b3V0LnUzMignc3RhdGUnKSwgcHVibGljS2V5KCdhdXRob3JpemVkUHVia2V5JyksIHB1YmxpY0tleSgnbm9uY2UnKSwgQnVmZmVyTGF5b3V0LnN0cnVjdChbRmVlQ2FsY3VsYXRvckxheW91dF0sICdmZWVDYWxjdWxhdG9yJyldKTtcbmNvbnN0IE5PTkNFX0FDQ09VTlRfTEVOR1RIID0gTm9uY2VBY2NvdW50TGF5b3V0LnNwYW47XG5cbi8qKlxuICogQSBkdXJhYmxlIG5vbmNlIGlzIGEgMzIgYnl0ZSB2YWx1ZSBlbmNvZGVkIGFzIGEgYmFzZTU4IHN0cmluZy5cbiAqL1xuXG4vKipcbiAqIE5vbmNlQWNjb3VudCBjbGFzc1xuICovXG5jbGFzcyBOb25jZUFjY291bnQge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgdGhpcy5hdXRob3JpemVkUHVia2V5ID0gdm9pZCAwO1xuICAgIHRoaXMubm9uY2UgPSB2b2lkIDA7XG4gICAgdGhpcy5mZWVDYWxjdWxhdG9yID0gdm9pZCAwO1xuICAgIHRoaXMuYXV0aG9yaXplZFB1YmtleSA9IGFyZ3MuYXV0aG9yaXplZFB1YmtleTtcbiAgICB0aGlzLm5vbmNlID0gYXJncy5ub25jZTtcbiAgICB0aGlzLmZlZUNhbGN1bGF0b3IgPSBhcmdzLmZlZUNhbGN1bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemUgTm9uY2VBY2NvdW50IGZyb20gdGhlIGFjY291bnQgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIGJ1ZmZlciBhY2NvdW50IGRhdGFcbiAgICogQHJldHVybiBOb25jZUFjY291bnRcbiAgICovXG4gIHN0YXRpYyBmcm9tQWNjb3VudERhdGEoYnVmZmVyKSB7XG4gICAgY29uc3Qgbm9uY2VBY2NvdW50ID0gTm9uY2VBY2NvdW50TGF5b3V0LmRlY29kZSh0b0J1ZmZlcihidWZmZXIpLCAwKTtcbiAgICByZXR1cm4gbmV3IE5vbmNlQWNjb3VudCh7XG4gICAgICBhdXRob3JpemVkUHVia2V5OiBuZXcgUHVibGljS2V5KG5vbmNlQWNjb3VudC5hdXRob3JpemVkUHVia2V5KSxcbiAgICAgIG5vbmNlOiBuZXcgUHVibGljS2V5KG5vbmNlQWNjb3VudC5ub25jZSkudG9TdHJpbmcoKSxcbiAgICAgIGZlZUNhbGN1bGF0b3I6IG5vbmNlQWNjb3VudC5mZWVDYWxjdWxhdG9yXG4gICAgfSk7XG4gIH1cbn1cblxuY29uc3QgZW5jb2RlRGVjb2RlID0gbGF5b3V0ID0+IHtcbiAgY29uc3QgZGVjb2RlID0gbGF5b3V0LmRlY29kZS5iaW5kKGxheW91dCk7XG4gIGNvbnN0IGVuY29kZSA9IGxheW91dC5lbmNvZGUuYmluZChsYXlvdXQpO1xuICByZXR1cm4ge1xuICAgIGRlY29kZSxcbiAgICBlbmNvZGVcbiAgfTtcbn07XG5jb25zdCBiaWdJbnQgPSBsZW5ndGggPT4gcHJvcGVydHkgPT4ge1xuICBjb25zdCBsYXlvdXQgPSBibG9iKGxlbmd0aCwgcHJvcGVydHkpO1xuICBjb25zdCB7XG4gICAgZW5jb2RlLFxuICAgIGRlY29kZVxuICB9ID0gZW5jb2RlRGVjb2RlKGxheW91dCk7XG4gIGNvbnN0IGJpZ0ludExheW91dCA9IGxheW91dDtcbiAgYmlnSW50TGF5b3V0LmRlY29kZSA9IChidWZmZXIsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IHNyYyA9IGRlY29kZShidWZmZXIsIG9mZnNldCk7XG4gICAgcmV0dXJuIHRvQmlnSW50TEUoQnVmZmVyLmZyb20oc3JjKSk7XG4gIH07XG4gIGJpZ0ludExheW91dC5lbmNvZGUgPSAoYmlnSW50LCBidWZmZXIsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IHNyYyA9IHRvQnVmZmVyTEUoYmlnSW50LCBsZW5ndGgpO1xuICAgIHJldHVybiBlbmNvZGUoc3JjLCBidWZmZXIsIG9mZnNldCk7XG4gIH07XG4gIHJldHVybiBiaWdJbnRMYXlvdXQ7XG59O1xuY29uc3QgdTY0ID0gYmlnSW50KDgpO1xuXG4vKipcbiAqIENyZWF0ZSBhY2NvdW50IHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIFRyYW5zZmVyIHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEFzc2lnbiBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgYWNjb3VudCB3aXRoIHNlZWQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQ3JlYXRlIG5vbmNlIGFjY291bnQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQ3JlYXRlIG5vbmNlIGFjY291bnQgd2l0aCBzZWVkIHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEluaXRpYWxpemUgbm9uY2UgYWNjb3VudCBzeXN0ZW0gaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBZHZhbmNlIG5vbmNlIGFjY291bnQgc3lzdGVtIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogV2l0aGRyYXcgbm9uY2UgYWNjb3VudCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBdXRob3JpemUgbm9uY2UgYWNjb3VudCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBbGxvY2F0ZSBhY2NvdW50IHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEFsbG9jYXRlIGFjY291bnQgd2l0aCBzZWVkIHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEFzc2lnbiBhY2NvdW50IHdpdGggc2VlZCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBUcmFuc2ZlciB3aXRoIHNlZWQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKiBEZWNvZGVkIHRyYW5zZmVyIHN5c3RlbSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiAqL1xuXG4vKiogRGVjb2RlZCB0cmFuc2ZlcldpdGhTZWVkIHN5c3RlbSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiAqL1xuXG4vKipcbiAqIFN5c3RlbSBJbnN0cnVjdGlvbiBjbGFzc1xuICovXG5jbGFzcyBTeXN0ZW1JbnN0cnVjdGlvbiB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogRGVjb2RlIGEgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gdHlwZS5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVJbnN0cnVjdGlvblR5cGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKTtcbiAgICBjb25zdCB0eXBlSW5kZXggPSBpbnN0cnVjdGlvblR5cGVMYXlvdXQuZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpO1xuICAgIGxldCB0eXBlO1xuICAgIGZvciAoY29uc3QgW2l4VHlwZSwgbGF5b3V0XSBvZiBPYmplY3QuZW50cmllcyhTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUykpIHtcbiAgICAgIGlmIChsYXlvdXQuaW5kZXggPT0gdHlwZUluZGV4KSB7XG4gICAgICAgIHR5cGUgPSBpeFR5cGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5zdHJ1Y3Rpb24gdHlwZSBpbmNvcnJlY3Q7IG5vdCBhIFN5c3RlbUluc3RydWN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIGNyZWF0ZSBhY2NvdW50IHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVDcmVhdGVBY2NvdW50KGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG4gICAgY29uc3Qge1xuICAgICAgbGFtcG9ydHMsXG4gICAgICBzcGFjZSxcbiAgICAgIHByb2dyYW1JZFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQ3JlYXRlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgZnJvbVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBuZXdBY2NvdW50UHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIGxhbXBvcnRzLFxuICAgICAgc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IG5ldyBQdWJsaWNLZXkocHJvZ3JhbUlkKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgdHJhbnNmZXIgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVRyYW5zZmVyKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG4gICAgY29uc3Qge1xuICAgICAgbGFtcG9ydHNcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLlRyYW5zZmVyLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgZnJvbVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICB0b1B1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBsYW1wb3J0c1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgdHJhbnNmZXIgd2l0aCBzZWVkIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVUcmFuc2ZlcldpdGhTZWVkKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgY29uc3Qge1xuICAgICAgbGFtcG9ydHMsXG4gICAgICBzZWVkLFxuICAgICAgcHJvZ3JhbUlkXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5UcmFuc2ZlcldpdGhTZWVkLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgZnJvbVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBiYXNlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIHRvUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleSxcbiAgICAgIGxhbXBvcnRzLFxuICAgICAgc2VlZCxcbiAgICAgIHByb2dyYW1JZDogbmV3IFB1YmxpY0tleShwcm9ncmFtSWQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYW4gYWxsb2NhdGUgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUFsbG9jYXRlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMSk7XG4gICAgY29uc3Qge1xuICAgICAgc3BhY2VcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFsbG9jYXRlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgYWNjb3VudFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBzcGFjZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGFsbG9jYXRlIHdpdGggc2VlZCBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQWxsb2NhdGVXaXRoU2VlZChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDEpO1xuICAgIGNvbnN0IHtcbiAgICAgIGJhc2UsXG4gICAgICBzZWVkLFxuICAgICAgc3BhY2UsXG4gICAgICBwcm9ncmFtSWRcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFsbG9jYXRlV2l0aFNlZWQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBhY2NvdW50UHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGJhc2VQdWJrZXk6IG5ldyBQdWJsaWNLZXkoYmFzZSksXG4gICAgICBzZWVkLFxuICAgICAgc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IG5ldyBQdWJsaWNLZXkocHJvZ3JhbUlkKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGFzc2lnbiBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQXNzaWduKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMSk7XG4gICAgY29uc3Qge1xuICAgICAgcHJvZ3JhbUlkXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5Bc3NpZ24sIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBhY2NvdW50UHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIHByb2dyYW1JZDogbmV3IFB1YmxpY0tleShwcm9ncmFtSWQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYW4gYXNzaWduIHdpdGggc2VlZCBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQXNzaWduV2l0aFNlZWQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAxKTtcbiAgICBjb25zdCB7XG4gICAgICBiYXNlLFxuICAgICAgc2VlZCxcbiAgICAgIHByb2dyYW1JZFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXNzaWduV2l0aFNlZWQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBhY2NvdW50UHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGJhc2VQdWJrZXk6IG5ldyBQdWJsaWNLZXkoYmFzZSksXG4gICAgICBzZWVkLFxuICAgICAgcHJvZ3JhbUlkOiBuZXcgUHVibGljS2V5KHByb2dyYW1JZClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIGNyZWF0ZSBhY2NvdW50IHdpdGggc2VlZCBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQ3JlYXRlV2l0aFNlZWQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAyKTtcbiAgICBjb25zdCB7XG4gICAgICBiYXNlLFxuICAgICAgc2VlZCxcbiAgICAgIGxhbXBvcnRzLFxuICAgICAgc3BhY2UsXG4gICAgICBwcm9ncmFtSWRcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkNyZWF0ZVdpdGhTZWVkLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgZnJvbVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBuZXdBY2NvdW50UHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIGJhc2VQdWJrZXk6IG5ldyBQdWJsaWNLZXkoYmFzZSksXG4gICAgICBzZWVkLFxuICAgICAgbGFtcG9ydHMsXG4gICAgICBzcGFjZSxcbiAgICAgIHByb2dyYW1JZDogbmV3IFB1YmxpY0tleShwcm9ncmFtSWQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBub25jZSBpbml0aWFsaXplIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVOb25jZUluaXRpYWxpemUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBjb25zdCB7XG4gICAgICBhdXRob3JpemVkXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5Jbml0aWFsaXplTm9uY2VBY2NvdW50LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgbm9uY2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShhdXRob3JpemVkKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgbm9uY2UgYWR2YW5jZSBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlTm9uY2VBZHZhbmNlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFkdmFuY2VOb25jZUFjY291bnQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBub25jZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgbm9uY2Ugd2l0aGRyYXcgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZU5vbmNlV2l0aGRyYXcoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCA1KTtcbiAgICBjb25zdCB7XG4gICAgICBsYW1wb3J0c1xuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuV2l0aGRyYXdOb25jZUFjY291bnQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBub25jZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICB0b1B1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzRdLnB1YmtleSxcbiAgICAgIGxhbXBvcnRzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBub25jZSBhdXRob3JpemUgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZU5vbmNlQXV0aG9yaXplKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG4gICAgY29uc3Qge1xuICAgICAgYXV0aG9yaXplZFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplTm9uY2VBY2NvdW50LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgbm9uY2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5OiBuZXcgUHVibGljS2V5KGF1dGhvcml6ZWQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBjaGVja1Byb2dyYW1JZChwcm9ncmFtSWQpIHtcbiAgICBpZiAoIXByb2dyYW1JZC5lcXVhbHMoU3lzdGVtUHJvZ3JhbS5wcm9ncmFtSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5zdHJ1Y3Rpb247IHByb2dyYW1JZCBpcyBub3QgU3lzdGVtUHJvZ3JhbScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBjaGVja0tleUxlbmd0aChrZXlzLCBleHBlY3RlZExlbmd0aCkge1xuICAgIGlmIChrZXlzLmxlbmd0aCA8IGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5zdHJ1Y3Rpb247IGZvdW5kICR7a2V5cy5sZW5ndGh9IGtleXMsIGV4cGVjdGVkIGF0IGxlYXN0ICR7ZXhwZWN0ZWRMZW5ndGh9YCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgU3lzdGVtSW5zdHJ1Y3Rpb25UeXBlJ3NcbiAqL1xuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIHN5c3RlbSBJbnN0cnVjdGlvblR5cGUnc1xuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTID0gT2JqZWN0LmZyZWV6ZSh7XG4gIENyZWF0ZToge1xuICAgIGluZGV4OiAwLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ2xhbXBvcnRzJyksIEJ1ZmZlckxheW91dC5uczY0KCdzcGFjZScpLCBwdWJsaWNLZXkoJ3Byb2dyYW1JZCcpXSlcbiAgfSxcbiAgQXNzaWduOiB7XG4gICAgaW5kZXg6IDEsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ3Byb2dyYW1JZCcpXSlcbiAgfSxcbiAgVHJhbnNmZXI6IHtcbiAgICBpbmRleDogMixcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHU2NCgnbGFtcG9ydHMnKV0pXG4gIH0sXG4gIENyZWF0ZVdpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDMsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ2Jhc2UnKSwgcnVzdFN0cmluZygnc2VlZCcpLCBCdWZmZXJMYXlvdXQubnM2NCgnbGFtcG9ydHMnKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ3NwYWNlJyksIHB1YmxpY0tleSgncHJvZ3JhbUlkJyldKVxuICB9LFxuICBBZHZhbmNlTm9uY2VBY2NvdW50OiB7XG4gICAgaW5kZXg6IDQsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpXSlcbiAgfSxcbiAgV2l0aGRyYXdOb25jZUFjY291bnQ6IHtcbiAgICBpbmRleDogNSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dC5uczY0KCdsYW1wb3J0cycpXSlcbiAgfSxcbiAgSW5pdGlhbGl6ZU5vbmNlQWNjb3VudDoge1xuICAgIGluZGV4OiA2LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgcHVibGljS2V5KCdhdXRob3JpemVkJyldKVxuICB9LFxuICBBdXRob3JpemVOb25jZUFjY291bnQ6IHtcbiAgICBpbmRleDogNyxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgnYXV0aG9yaXplZCcpXSlcbiAgfSxcbiAgQWxsb2NhdGU6IHtcbiAgICBpbmRleDogOCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dC5uczY0KCdzcGFjZScpXSlcbiAgfSxcbiAgQWxsb2NhdGVXaXRoU2VlZDoge1xuICAgIGluZGV4OiA5LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgcHVibGljS2V5KCdiYXNlJyksIHJ1c3RTdHJpbmcoJ3NlZWQnKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ3NwYWNlJyksIHB1YmxpY0tleSgncHJvZ3JhbUlkJyldKVxuICB9LFxuICBBc3NpZ25XaXRoU2VlZDoge1xuICAgIGluZGV4OiAxMCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgnYmFzZScpLCBydXN0U3RyaW5nKCdzZWVkJyksIHB1YmxpY0tleSgncHJvZ3JhbUlkJyldKVxuICB9LFxuICBUcmFuc2ZlcldpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDExLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgdTY0KCdsYW1wb3J0cycpLCBydXN0U3RyaW5nKCdzZWVkJyksIHB1YmxpY0tleSgncHJvZ3JhbUlkJyldKVxuICB9LFxuICBVcGdyYWRlTm9uY2VBY2NvdW50OiB7XG4gICAgaW5kZXg6IDEyLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH1cbn0pO1xuXG4vKipcbiAqIEZhY3RvcnkgY2xhc3MgZm9yIHRyYW5zYWN0aW9ucyB0byBpbnRlcmFjdCB3aXRoIHRoZSBTeXN0ZW0gcHJvZ3JhbVxuICovXG5jbGFzcyBTeXN0ZW1Qcm9ncmFtIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBQdWJsaWMga2V5IHRoYXQgaWRlbnRpZmllcyB0aGUgU3lzdGVtIHByb2dyYW1cbiAgICovXG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IGFjY291bnRcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVBY2NvdW50KHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5DcmVhdGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbGFtcG9ydHM6IHBhcmFtcy5sYW1wb3J0cyxcbiAgICAgIHNwYWNlOiBwYXJhbXMuc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IHRvQnVmZmVyKHBhcmFtcy5wcm9ncmFtSWQudG9CdWZmZXIoKSlcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMubmV3QWNjb3VudFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uIHRoYXQgdHJhbnNmZXJzIGxhbXBvcnRzIGZyb20gb25lIGFjY291bnQgdG8gYW5vdGhlclxuICAgKi9cbiAgc3RhdGljIHRyYW5zZmVyKHBhcmFtcykge1xuICAgIGxldCBkYXRhO1xuICAgIGxldCBrZXlzO1xuICAgIGlmICgnYmFzZVB1YmtleScgaW4gcGFyYW1zKSB7XG4gICAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuVHJhbnNmZXJXaXRoU2VlZDtcbiAgICAgIGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgICAgbGFtcG9ydHM6IEJpZ0ludChwYXJhbXMubGFtcG9ydHMpLFxuICAgICAgICBzZWVkOiBwYXJhbXMuc2VlZCxcbiAgICAgICAgcHJvZ3JhbUlkOiB0b0J1ZmZlcihwYXJhbXMucHJvZ3JhbUlkLnRvQnVmZmVyKCkpXG4gICAgICB9KTtcbiAgICAgIGtleXMgPSBbe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5mcm9tUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYmFzZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLnRvUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH1dO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuVHJhbnNmZXI7XG4gICAgICBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICAgIGxhbXBvcnRzOiBCaWdJbnQocGFyYW1zLmxhbXBvcnRzKVxuICAgICAgfSk7XG4gICAgICBrZXlzID0gW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMudG9QdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfV07XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uIHRoYXQgYXNzaWducyBhbiBhY2NvdW50IHRvIGEgcHJvZ3JhbVxuICAgKi9cbiAgc3RhdGljIGFzc2lnbihwYXJhbXMpIHtcbiAgICBsZXQgZGF0YTtcbiAgICBsZXQga2V5cztcbiAgICBpZiAoJ2Jhc2VQdWJrZXknIGluIHBhcmFtcykge1xuICAgICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFzc2lnbldpdGhTZWVkO1xuICAgICAgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgICBiYXNlOiB0b0J1ZmZlcihwYXJhbXMuYmFzZVB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgICAgc2VlZDogcGFyYW1zLnNlZWQsXG4gICAgICAgIHByb2dyYW1JZDogdG9CdWZmZXIocGFyYW1zLnByb2dyYW1JZC50b0J1ZmZlcigpKVxuICAgICAgfSk7XG4gICAgICBrZXlzID0gW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYWNjb3VudFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmJhc2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5Bc3NpZ247XG4gICAgICBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICAgIHByb2dyYW1JZDogdG9CdWZmZXIocGFyYW1zLnByb2dyYW1JZC50b0J1ZmZlcigpKVxuICAgICAgfSk7XG4gICAgICBrZXlzID0gW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYWNjb3VudFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH1dO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgYWNjb3VudCBhdFxuICAgKiAgIGFuIGFkZHJlc3MgZ2VuZXJhdGVkIHdpdGggYGZyb21gLCBhIHNlZWQsIGFuZCBwcm9ncmFtSWRcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVBY2NvdW50V2l0aFNlZWQocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkNyZWF0ZVdpdGhTZWVkO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGJhc2U6IHRvQnVmZmVyKHBhcmFtcy5iYXNlUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgc2VlZDogcGFyYW1zLnNlZWQsXG4gICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgc3BhY2U6IHBhcmFtcy5zcGFjZSxcbiAgICAgIHByb2dyYW1JZDogdG9CdWZmZXIocGFyYW1zLnByb2dyYW1JZC50b0J1ZmZlcigpKVxuICAgIH0pO1xuICAgIGxldCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5uZXdBY2NvdW50UHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH1dO1xuICAgIGlmICghcGFyYW1zLmJhc2VQdWJrZXkuZXF1YWxzKHBhcmFtcy5mcm9tUHVia2V5KSkge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYmFzZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IE5vbmNlIGFjY291bnRcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVOb25jZUFjY291bnQocGFyYW1zKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICBpZiAoJ2Jhc2VQdWJrZXknIGluIHBhcmFtcyAmJiAnc2VlZCcgaW4gcGFyYW1zKSB7XG4gICAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50V2l0aFNlZWQoe1xuICAgICAgICBmcm9tUHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgICAgbmV3QWNjb3VudFB1YmtleTogcGFyYW1zLm5vbmNlUHVia2V5LFxuICAgICAgICBiYXNlUHVia2V5OiBwYXJhbXMuYmFzZVB1YmtleSxcbiAgICAgICAgc2VlZDogcGFyYW1zLnNlZWQsXG4gICAgICAgIGxhbXBvcnRzOiBwYXJhbXMubGFtcG9ydHMsXG4gICAgICAgIHNwYWNlOiBOT05DRV9BQ0NPVU5UX0xFTkdUSCxcbiAgICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZFxuICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50KHtcbiAgICAgICAgZnJvbVB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICAgIG5ld0FjY291bnRQdWJrZXk6IHBhcmFtcy5ub25jZVB1YmtleSxcbiAgICAgICAgbGFtcG9ydHM6IHBhcmFtcy5sYW1wb3J0cyxcbiAgICAgICAgc3BhY2U6IE5PTkNFX0FDQ09VTlRfTEVOR1RILFxuICAgICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGNvbnN0IGluaXRQYXJhbXMgPSB7XG4gICAgICBub25jZVB1YmtleTogcGFyYW1zLm5vbmNlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogcGFyYW1zLmF1dGhvcml6ZWRQdWJrZXlcbiAgICB9O1xuICAgIHRyYW5zYWN0aW9uLmFkZCh0aGlzLm5vbmNlSW5pdGlhbGl6ZShpbml0UGFyYW1zKSk7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGFuIGluc3RydWN0aW9uIHRvIGluaXRpYWxpemUgYSBOb25jZSBhY2NvdW50XG4gICAqL1xuICBzdGF0aWMgbm9uY2VJbml0aWFsaXplKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5Jbml0aWFsaXplTm9uY2VBY2NvdW50O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGF1dGhvcml6ZWQ6IHRvQnVmZmVyKHBhcmFtcy5hdXRob3JpemVkUHVia2V5LnRvQnVmZmVyKCkpXG4gICAgfSk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0ge1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMubm9uY2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9SRUNFTlRfQkxPQ0tIQVNIRVNfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1JFTlRfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb25EYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhbiBpbnN0cnVjdGlvbiB0byBhZHZhbmNlIHRoZSBub25jZSBpbiBhIE5vbmNlIGFjY291bnRcbiAgICovXG4gIHN0YXRpYyBub25jZUFkdmFuY2UocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFkdmFuY2VOb25jZUFjY291bnQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0ge1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMubm9uY2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9SRUNFTlRfQkxPQ0tIQVNIRVNfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKGluc3RydWN0aW9uRGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiB0aGF0IHdpdGhkcmF3cyBsYW1wb3J0cyBmcm9tIGEgTm9uY2UgYWNjb3VudFxuICAgKi9cbiAgc3RhdGljIG5vbmNlV2l0aGRyYXcocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLldpdGhkcmF3Tm9uY2VBY2NvdW50O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGxhbXBvcnRzOiBwYXJhbXMubGFtcG9ydHNcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMubm9uY2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy50b1B1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1JFQ0VOVF9CTE9DS0hBU0hFU19QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfUkVOVF9QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiB0aGF0IGF1dGhvcml6ZXMgYSBuZXcgUHVibGljS2V5IGFzIHRoZSBhdXRob3JpdHlcbiAgICogb24gYSBOb25jZSBhY2NvdW50LlxuICAgKi9cbiAgc3RhdGljIG5vbmNlQXV0aG9yaXplKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemVOb25jZUFjY291bnQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgYXV0aG9yaXplZDogdG9CdWZmZXIocGFyYW1zLm5ld0F1dGhvcml6ZWRQdWJrZXkudG9CdWZmZXIoKSlcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMubm9uY2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5hdXRob3JpemVkUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uIHRoYXQgYWxsb2NhdGVzIHNwYWNlIGluIGFuIGFjY291bnQgd2l0aG91dCBmdW5kaW5nXG4gICAqL1xuICBzdGF0aWMgYWxsb2NhdGUocGFyYW1zKSB7XG4gICAgbGV0IGRhdGE7XG4gICAgbGV0IGtleXM7XG4gICAgaWYgKCdiYXNlUHVia2V5JyBpbiBwYXJhbXMpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5BbGxvY2F0ZVdpdGhTZWVkO1xuICAgICAgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgICBiYXNlOiB0b0J1ZmZlcihwYXJhbXMuYmFzZVB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgICAgc2VlZDogcGFyYW1zLnNlZWQsXG4gICAgICAgIHNwYWNlOiBwYXJhbXMuc3BhY2UsXG4gICAgICAgIHByb2dyYW1JZDogdG9CdWZmZXIocGFyYW1zLnByb2dyYW1JZC50b0J1ZmZlcigpKVxuICAgICAgfSk7XG4gICAgICBrZXlzID0gW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYWNjb3VudFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmJhc2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5BbGxvY2F0ZTtcbiAgICAgIGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgICAgc3BhY2U6IHBhcmFtcy5zcGFjZVxuICAgICAgfSk7XG4gICAgICBrZXlzID0gW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYWNjb3VudFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH1dO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cbn1cblN5c3RlbVByb2dyYW0ucHJvZ3JhbUlkID0gbmV3IFB1YmxpY0tleSgnMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuLy8gS2VlcCBwcm9ncmFtIGNodW5rcyB1bmRlciBQQUNLRVRfREFUQV9TSVpFLCBsZWF2aW5nIGVub3VnaCByb29tIGZvciB0aGVcbi8vIHJlc3Qgb2YgdGhlIFRyYW5zYWN0aW9uIGZpZWxkc1xuLy9cbi8vIFRPRE86IHJlcGxhY2UgMzAwIHdpdGggYSBwcm9wZXIgY29uc3RhbnQgZm9yIHRoZSBzaXplIG9mIHRoZSBvdGhlclxuLy8gVHJhbnNhY3Rpb24gZmllbGRzXG5jb25zdCBDSFVOS19TSVpFID0gUEFDS0VUX0RBVEFfU0laRSAtIDMwMDtcblxuLyoqXG4gKiBQcm9ncmFtIGxvYWRlciBpbnRlcmZhY2VcbiAqL1xuY2xhc3MgTG9hZGVyIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBBbW91bnQgb2YgcHJvZ3JhbSBkYXRhIHBsYWNlZCBpbiBlYWNoIGxvYWQgVHJhbnNhY3Rpb25cbiAgICovXG5cbiAgLyoqXG4gICAqIE1pbmltdW0gbnVtYmVyIG9mIHNpZ25hdHVyZXMgcmVxdWlyZWQgdG8gbG9hZCBhIHByb2dyYW0gbm90IGluY2x1ZGluZ1xuICAgKiByZXRyaWVzXG4gICAqXG4gICAqIENhbiBiZSB1c2VkIHRvIGNhbGN1bGF0ZSB0cmFuc2FjdGlvbiBmZWVzXG4gICAqL1xuICBzdGF0aWMgZ2V0TWluTnVtU2lnbmF0dXJlcyhkYXRhTGVuZ3RoKSB7XG4gICAgcmV0dXJuIDIgKiAoXG4gICAgLy8gRXZlcnkgdHJhbnNhY3Rpb24gcmVxdWlyZXMgdHdvIHNpZ25hdHVyZXMgKHBheWVyICsgcHJvZ3JhbSlcbiAgICBNYXRoLmNlaWwoZGF0YUxlbmd0aCAvIExvYWRlci5jaHVua1NpemUpICsgMSArXG4gICAgLy8gQWRkIG9uZSBmb3IgQ3JlYXRlIHRyYW5zYWN0aW9uXG4gICAgMSkgLy8gQWRkIG9uZSBmb3IgRmluYWxpemUgdHJhbnNhY3Rpb25cbiAgICA7XG4gIH1cblxuICAvKipcbiAgICogTG9hZHMgYSBnZW5lcmljIHByb2dyYW1cbiAgICpcbiAgICogQHBhcmFtIGNvbm5lY3Rpb24gVGhlIGNvbm5lY3Rpb24gdG8gdXNlXG4gICAqIEBwYXJhbSBwYXllciBTeXN0ZW0gYWNjb3VudCB0aGF0IHBheXMgdG8gbG9hZCB0aGUgcHJvZ3JhbVxuICAgKiBAcGFyYW0gcHJvZ3JhbSBBY2NvdW50IHRvIGxvYWQgdGhlIHByb2dyYW0gaW50b1xuICAgKiBAcGFyYW0gcHJvZ3JhbUlkIFB1YmxpYyBrZXkgdGhhdCBpZGVudGlmaWVzIHRoZSBsb2FkZXJcbiAgICogQHBhcmFtIGRhdGEgUHJvZ3JhbSBvY3RldHNcbiAgICogQHJldHVybiB0cnVlIGlmIHByb2dyYW0gd2FzIGxvYWRlZCBzdWNjZXNzZnVsbHksIGZhbHNlIGlmIHByb2dyYW0gd2FzIGFscmVhZHkgbG9hZGVkXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgbG9hZChjb25uZWN0aW9uLCBwYXllciwgcHJvZ3JhbSwgcHJvZ3JhbUlkLCBkYXRhKSB7XG4gICAge1xuICAgICAgY29uc3QgYmFsYW5jZU5lZWRlZCA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0aW9uKGRhdGEubGVuZ3RoKTtcblxuICAgICAgLy8gRmV0Y2ggcHJvZ3JhbSBhY2NvdW50IGluZm8gdG8gY2hlY2sgaWYgaXQgaGFzIGFscmVhZHkgYmVlbiBjcmVhdGVkXG4gICAgICBjb25zdCBwcm9ncmFtSW5mbyA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0QWNjb3VudEluZm8ocHJvZ3JhbS5wdWJsaWNLZXksICdjb25maXJtZWQnKTtcbiAgICAgIGxldCB0cmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICBpZiAocHJvZ3JhbUluZm8gIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHByb2dyYW1JbmZvLmV4ZWN1dGFibGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdQcm9ncmFtIGxvYWQgZmFpbGVkLCBhY2NvdW50IGlzIGFscmVhZHkgZXhlY3V0YWJsZScpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvZ3JhbUluZm8uZGF0YS5sZW5ndGggIT09IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbiB8fCBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5hbGxvY2F0ZSh7XG4gICAgICAgICAgICBhY2NvdW50UHVia2V5OiBwcm9ncmFtLnB1YmxpY0tleSxcbiAgICAgICAgICAgIHNwYWNlOiBkYXRhLmxlbmd0aFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXByb2dyYW1JbmZvLm93bmVyLmVxdWFscyhwcm9ncmFtSWQpKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbiB8fCBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5hc3NpZ24oe1xuICAgICAgICAgICAgYWNjb3VudFB1YmtleTogcHJvZ3JhbS5wdWJsaWNLZXksXG4gICAgICAgICAgICBwcm9ncmFtSWRcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2dyYW1JbmZvLmxhbXBvcnRzIDwgYmFsYW5jZU5lZWRlZCkge1xuICAgICAgICAgIHRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb24gfHwgbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0udHJhbnNmZXIoe1xuICAgICAgICAgICAgZnJvbVB1YmtleTogcGF5ZXIucHVibGljS2V5LFxuICAgICAgICAgICAgdG9QdWJrZXk6IHByb2dyYW0ucHVibGljS2V5LFxuICAgICAgICAgICAgbGFtcG9ydHM6IGJhbGFuY2VOZWVkZWQgLSBwcm9ncmFtSW5mby5sYW1wb3J0c1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50KHtcbiAgICAgICAgICBmcm9tUHVia2V5OiBwYXllci5wdWJsaWNLZXksXG4gICAgICAgICAgbmV3QWNjb3VudFB1YmtleTogcHJvZ3JhbS5wdWJsaWNLZXksXG4gICAgICAgICAgbGFtcG9ydHM6IGJhbGFuY2VOZWVkZWQgPiAwID8gYmFsYW5jZU5lZWRlZCA6IDEsXG4gICAgICAgICAgc3BhY2U6IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIHByb2dyYW1JZFxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBhY2NvdW50IGlzIGFscmVhZHkgY3JlYXRlZCBjb3JyZWN0bHksIHNraXAgdGhpcyBzdGVwXG4gICAgICAvLyBhbmQgcHJvY2VlZCBkaXJlY3RseSB0byBsb2FkaW5nIGluc3RydWN0aW9uc1xuICAgICAgaWYgKHRyYW5zYWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgIGF3YWl0IHNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24oY29ubmVjdGlvbiwgdHJhbnNhY3Rpb24sIFtwYXllciwgcHJvZ3JhbV0sIHtcbiAgICAgICAgICBjb21taXRtZW50OiAnY29uZmlybWVkJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGF0YUxheW91dCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dC51MzIoJ29mZnNldCcpLCBCdWZmZXJMYXlvdXQudTMyKCdieXRlc0xlbmd0aCcpLCBCdWZmZXJMYXlvdXQudTMyKCdieXRlc0xlbmd0aFBhZGRpbmcnKSwgQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQudTgoJ2J5dGUnKSwgQnVmZmVyTGF5b3V0Lm9mZnNldChCdWZmZXJMYXlvdXQudTMyKCksIC04KSwgJ2J5dGVzJyldKTtcbiAgICBjb25zdCBjaHVua1NpemUgPSBMb2FkZXIuY2h1bmtTaXplO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGxldCBhcnJheSA9IGRhdGE7XG4gICAgbGV0IHRyYW5zYWN0aW9ucyA9IFtdO1xuICAgIHdoaWxlIChhcnJheS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBieXRlcyA9IGFycmF5LnNsaWNlKDAsIGNodW5rU2l6ZSk7XG4gICAgICBjb25zdCBkYXRhID0gQnVmZmVyLmFsbG9jKGNodW5rU2l6ZSArIDE2KTtcbiAgICAgIGRhdGFMYXlvdXQuZW5jb2RlKHtcbiAgICAgICAgaW5zdHJ1Y3Rpb246IDAsXG4gICAgICAgIC8vIExvYWQgaW5zdHJ1Y3Rpb25cbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBieXRlczogYnl0ZXMsXG4gICAgICAgIGJ5dGVzTGVuZ3RoOiAwLFxuICAgICAgICBieXRlc0xlbmd0aFBhZGRpbmc6IDBcbiAgICAgIH0sIGRhdGEpO1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAgICBrZXlzOiBbe1xuICAgICAgICAgIHB1YmtleTogcHJvZ3JhbS5wdWJsaWNLZXksXG4gICAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgICB9XSxcbiAgICAgICAgcHJvZ3JhbUlkLFxuICAgICAgICBkYXRhXG4gICAgICB9KTtcbiAgICAgIHRyYW5zYWN0aW9ucy5wdXNoKHNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24oY29ubmVjdGlvbiwgdHJhbnNhY3Rpb24sIFtwYXllciwgcHJvZ3JhbV0sIHtcbiAgICAgICAgY29tbWl0bWVudDogJ2NvbmZpcm1lZCdcbiAgICAgIH0pKTtcblxuICAgICAgLy8gRGVsYXkgYmV0d2VlbiBzZW5kcyBpbiBhbiBhdHRlbXB0IHRvIHJlZHVjZSByYXRlIGxpbWl0IGVycm9yc1xuICAgICAgaWYgKGNvbm5lY3Rpb24uX3JwY0VuZHBvaW50LmluY2x1ZGVzKCdzb2xhbmEuY29tJykpIHtcbiAgICAgICAgY29uc3QgUkVRVUVTVFNfUEVSX1NFQ09ORCA9IDQ7XG4gICAgICAgIGF3YWl0IHNsZWVwKDEwMDAgLyBSRVFVRVNUU19QRVJfU0VDT05EKTtcbiAgICAgIH1cbiAgICAgIG9mZnNldCArPSBjaHVua1NpemU7XG4gICAgICBhcnJheSA9IGFycmF5LnNsaWNlKGNodW5rU2l6ZSk7XG4gICAgfVxuICAgIGF3YWl0IFByb21pc2UuYWxsKHRyYW5zYWN0aW9ucyk7XG5cbiAgICAvLyBGaW5hbGl6ZSB0aGUgYWNjb3VudCBsb2FkZWQgd2l0aCBwcm9ncmFtIGRhdGEgZm9yIGV4ZWN1dGlvblxuICAgIHtcbiAgICAgIGNvbnN0IGRhdGFMYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpXSk7XG4gICAgICBjb25zdCBkYXRhID0gQnVmZmVyLmFsbG9jKGRhdGFMYXlvdXQuc3Bhbik7XG4gICAgICBkYXRhTGF5b3V0LmVuY29kZSh7XG4gICAgICAgIGluc3RydWN0aW9uOiAxIC8vIEZpbmFsaXplIGluc3RydWN0aW9uXG4gICAgICB9LCBkYXRhKTtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgICAga2V5czogW3tcbiAgICAgICAgICBwdWJrZXk6IHByb2dyYW0ucHVibGljS2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgICAgfSwge1xuICAgICAgICAgIHB1YmtleTogU1lTVkFSX1JFTlRfUFVCS0VZLFxuICAgICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgICB9XSxcbiAgICAgICAgcHJvZ3JhbUlkLFxuICAgICAgICBkYXRhXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGRlcGxveUNvbW1pdG1lbnQgPSAncHJvY2Vzc2VkJztcbiAgICAgIGNvbnN0IGZpbmFsaXplU2lnbmF0dXJlID0gYXdhaXQgY29ubmVjdGlvbi5zZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIFtwYXllciwgcHJvZ3JhbV0sIHtcbiAgICAgICAgcHJlZmxpZ2h0Q29tbWl0bWVudDogZGVwbG95Q29tbWl0bWVudFxuICAgICAgfSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIHZhbHVlXG4gICAgICB9ID0gYXdhaXQgY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oe1xuICAgICAgICBzaWduYXR1cmU6IGZpbmFsaXplU2lnbmF0dXJlLFxuICAgICAgICBsYXN0VmFsaWRCbG9ja0hlaWdodDogdHJhbnNhY3Rpb24ubGFzdFZhbGlkQmxvY2tIZWlnaHQsXG4gICAgICAgIGJsb2NraGFzaDogdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoXG4gICAgICB9LCBkZXBsb3lDb21taXRtZW50KTtcbiAgICAgIGlmICh2YWx1ZS5lcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmFuc2FjdGlvbiAke2ZpbmFsaXplU2lnbmF0dXJlfSBmYWlsZWQgKCR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfSlgKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIHByZXZlbnQgcHJvZ3JhbXMgZnJvbSBiZWluZyB1c2FibGUgdW50aWwgdGhlIHNsb3QgYWZ0ZXIgdGhlaXIgZGVwbG95bWVudC5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL3B1bGwvMjk2NTRcbiAgICAgIHdoaWxlICh0cnVlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50U2xvdCA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0U2xvdCh7XG4gICAgICAgICAgICBjb21taXRtZW50OiBkZXBsb3lDb21taXRtZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGN1cnJlbnRTbG90ID4gY29udGV4dC5zbG90KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIC8qIGVtcHR5ICovXG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIE1hdGgucm91bmQoTVNfUEVSX1NMT1QgLyAyKSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHN1Y2Nlc3NcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuTG9hZGVyLmNodW5rU2l6ZSA9IENIVU5LX1NJWkU7XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuMTcuMjAuXG4gKi9cbmNvbnN0IEJQRl9MT0FERVJfUFJPR1JBTV9JRCA9IG5ldyBQdWJsaWNLZXkoJ0JQRkxvYWRlcjIxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuLyoqXG4gKiBGYWN0b3J5IGNsYXNzIGZvciB0cmFuc2FjdGlvbnMgdG8gaW50ZXJhY3Qgd2l0aCBhIHByb2dyYW0gbG9hZGVyXG4gKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuMTcuMjAuXG4gKi9cbmNsYXNzIEJwZkxvYWRlciB7XG4gIC8qKlxuICAgKiBNaW5pbXVtIG51bWJlciBvZiBzaWduYXR1cmVzIHJlcXVpcmVkIHRvIGxvYWQgYSBwcm9ncmFtIG5vdCBpbmNsdWRpbmdcbiAgICogcmV0cmllc1xuICAgKlxuICAgKiBDYW4gYmUgdXNlZCB0byBjYWxjdWxhdGUgdHJhbnNhY3Rpb24gZmVlc1xuICAgKi9cbiAgc3RhdGljIGdldE1pbk51bVNpZ25hdHVyZXMoZGF0YUxlbmd0aCkge1xuICAgIHJldHVybiBMb2FkZXIuZ2V0TWluTnVtU2lnbmF0dXJlcyhkYXRhTGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIGEgU0JGIHByb2dyYW1cbiAgICpcbiAgICogQHBhcmFtIGNvbm5lY3Rpb24gVGhlIGNvbm5lY3Rpb24gdG8gdXNlXG4gICAqIEBwYXJhbSBwYXllciBBY2NvdW50IHRoYXQgd2lsbCBwYXkgcHJvZ3JhbSBsb2FkaW5nIGZlZXNcbiAgICogQHBhcmFtIHByb2dyYW0gQWNjb3VudCB0byBsb2FkIHRoZSBwcm9ncmFtIGludG9cbiAgICogQHBhcmFtIGVsZiBUaGUgZW50aXJlIEVMRiBjb250YWluaW5nIHRoZSBTQkYgcHJvZ3JhbVxuICAgKiBAcGFyYW0gbG9hZGVyUHJvZ3JhbUlkIFRoZSBwcm9ncmFtIGlkIG9mIHRoZSBCUEYgbG9hZGVyIHRvIHVzZVxuICAgKiBAcmV0dXJuIHRydWUgaWYgcHJvZ3JhbSB3YXMgbG9hZGVkIHN1Y2Nlc3NmdWxseSwgZmFsc2UgaWYgcHJvZ3JhbSB3YXMgYWxyZWFkeSBsb2FkZWRcbiAgICovXG4gIHN0YXRpYyBsb2FkKGNvbm5lY3Rpb24sIHBheWVyLCBwcm9ncmFtLCBlbGYsIGxvYWRlclByb2dyYW1JZCkge1xuICAgIHJldHVybiBMb2FkZXIubG9hZChjb25uZWN0aW9uLCBwYXllciwgcHJvZ3JhbSwgbG9hZGVyUHJvZ3JhbUlkLCBlbGYpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzICh4KSB7XG5cdHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ2RlZmF1bHQnKSA/IHhbJ2RlZmF1bHQnXSA6IHg7XG59XG5cbnZhciBhZ2VudGtlZXBhbGl2ZSA9IHtleHBvcnRzOiB7fX07XG5cbi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgbXM7XG52YXIgaGFzUmVxdWlyZWRNcztcblxuZnVuY3Rpb24gcmVxdWlyZU1zICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkTXMpIHJldHVybiBtcztcblx0aGFzUmVxdWlyZWRNcyA9IDE7XG5cdHZhciBzID0gMTAwMDtcblx0dmFyIG0gPSBzICogNjA7XG5cdHZhciBoID0gbSAqIDYwO1xuXHR2YXIgZCA9IGggKiAyNDtcblx0dmFyIHcgPSBkICogNztcblx0dmFyIHkgPSBkICogMzY1LjI1O1xuXG5cdC8qKlxuXHQgKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuXHQgKlxuXHQgKiBPcHRpb25zOlxuXHQgKlxuXHQgKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuXHQgKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcblx0ICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0bXMgPSBmdW5jdGlvbiAodmFsLCBvcHRpb25zKSB7XG5cdCAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdCAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuXHQgIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuXHQgICAgcmV0dXJuIHBhcnNlKHZhbCk7XG5cdCAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWwpKSB7XG5cdCAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcblx0ICB9XG5cdCAgdGhyb3cgbmV3IEVycm9yKFxuXHQgICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG5cdCAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcblx0ICApO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG5cdCAgc3RyID0gU3RyaW5nKHN0cik7XG5cdCAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cdCAgdmFyIG1hdGNoID0gL14oLT8oPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHdlZWtzP3x3fHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuXHQgICAgc3RyXG5cdCAgKTtcblx0ICBpZiAoIW1hdGNoKSB7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXHQgIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG5cdCAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcblx0ICBzd2l0Y2ggKHR5cGUpIHtcblx0ICAgIGNhc2UgJ3llYXJzJzpcblx0ICAgIGNhc2UgJ3llYXInOlxuXHQgICAgY2FzZSAneXJzJzpcblx0ICAgIGNhc2UgJ3lyJzpcblx0ICAgIGNhc2UgJ3knOlxuXHQgICAgICByZXR1cm4gbiAqIHk7XG5cdCAgICBjYXNlICd3ZWVrcyc6XG5cdCAgICBjYXNlICd3ZWVrJzpcblx0ICAgIGNhc2UgJ3cnOlxuXHQgICAgICByZXR1cm4gbiAqIHc7XG5cdCAgICBjYXNlICdkYXlzJzpcblx0ICAgIGNhc2UgJ2RheSc6XG5cdCAgICBjYXNlICdkJzpcblx0ICAgICAgcmV0dXJuIG4gKiBkO1xuXHQgICAgY2FzZSAnaG91cnMnOlxuXHQgICAgY2FzZSAnaG91cic6XG5cdCAgICBjYXNlICdocnMnOlxuXHQgICAgY2FzZSAnaHInOlxuXHQgICAgY2FzZSAnaCc6XG5cdCAgICAgIHJldHVybiBuICogaDtcblx0ICAgIGNhc2UgJ21pbnV0ZXMnOlxuXHQgICAgY2FzZSAnbWludXRlJzpcblx0ICAgIGNhc2UgJ21pbnMnOlxuXHQgICAgY2FzZSAnbWluJzpcblx0ICAgIGNhc2UgJ20nOlxuXHQgICAgICByZXR1cm4gbiAqIG07XG5cdCAgICBjYXNlICdzZWNvbmRzJzpcblx0ICAgIGNhc2UgJ3NlY29uZCc6XG5cdCAgICBjYXNlICdzZWNzJzpcblx0ICAgIGNhc2UgJ3NlYyc6XG5cdCAgICBjYXNlICdzJzpcblx0ICAgICAgcmV0dXJuIG4gKiBzO1xuXHQgICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcblx0ICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcblx0ICAgIGNhc2UgJ21zZWNzJzpcblx0ICAgIGNhc2UgJ21zZWMnOlxuXHQgICAgY2FzZSAnbXMnOlxuXHQgICAgICByZXR1cm4gbjtcblx0ICAgIGRlZmF1bHQ6XG5cdCAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdCAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cblx0ICpcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG1zXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG5cdCAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuXHQgIGlmIChtc0FicyA+PSBkKSB7XG5cdCAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuXHQgIH1cblx0ICBpZiAobXNBYnMgPj0gaCkge1xuXHQgICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcblx0ICB9XG5cdCAgaWYgKG1zQWJzID49IG0pIHtcblx0ICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG5cdCAgfVxuXHQgIGlmIChtc0FicyA+PSBzKSB7XG5cdCAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuXHQgIH1cblx0ICByZXR1cm4gbXMgKyAnbXMnO1xuXHR9XG5cblx0LyoqXG5cdCAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuXHQgKlxuXHQgKiBAcGFyYW0ge051bWJlcn0gbXNcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gZm10TG9uZyhtcykge1xuXHQgIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcblx0ICBpZiAobXNBYnMgPj0gZCkge1xuXHQgICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGQsICdkYXknKTtcblx0ICB9XG5cdCAgaWYgKG1zQWJzID49IGgpIHtcblx0ICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBoLCAnaG91cicpO1xuXHQgIH1cblx0ICBpZiAobXNBYnMgPj0gbSkge1xuXHQgICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIG0sICdtaW51dGUnKTtcblx0ICB9XG5cdCAgaWYgKG1zQWJzID49IHMpIHtcblx0ICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBzLCAnc2Vjb25kJyk7XG5cdCAgfVxuXHQgIHJldHVybiBtcyArICcgbXMnO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuXHQgKi9cblxuXHRmdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XG5cdCAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcblx0ICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG4pICsgJyAnICsgbmFtZSArIChpc1BsdXJhbCA/ICdzJyA6ICcnKTtcblx0fVxuXHRyZXR1cm4gbXM7XG59XG5cbi8qIVxuICogaHVtYW5pemUtbXMgLSBpbmRleC5qc1xuICogQ29weXJpZ2h0KGMpIDIwMTQgZGVhZF9ob3JzZSA8ZGVhZF9ob3JzZUBxcS5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG52YXIgaHVtYW5pemVNcztcbnZhciBoYXNSZXF1aXJlZEh1bWFuaXplTXM7XG5cbmZ1bmN0aW9uIHJlcXVpcmVIdW1hbml6ZU1zICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkSHVtYW5pemVNcykgcmV0dXJuIGh1bWFuaXplTXM7XG5cdGhhc1JlcXVpcmVkSHVtYW5pemVNcyA9IDE7XG5cblx0LyoqXG5cdCAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG5cdCAqL1xuXG5cdHZhciB1dGlsID0gcmVxdWlyZSQkMDtcblx0dmFyIG1zID0gLypAX19QVVJFX18qLyByZXF1aXJlTXMoKTtcblxuXHRodW1hbml6ZU1zID0gZnVuY3Rpb24gKHQpIHtcblx0ICBpZiAodHlwZW9mIHQgPT09ICdudW1iZXInKSByZXR1cm4gdDtcblx0ICB2YXIgciA9IG1zKHQpO1xuXHQgIGlmIChyID09PSB1bmRlZmluZWQpIHtcblx0ICAgIHZhciBlcnIgPSBuZXcgRXJyb3IodXRpbC5mb3JtYXQoJ2h1bWFuaXplLW1zKCVqKSByZXN1bHQgdW5kZWZpbmVkJywgdCkpO1xuXHQgICAgY29uc29sZS53YXJuKGVyci5zdGFjayk7XG5cdCAgfVxuXHQgIHJldHVybiByO1xuXHR9O1xuXHRyZXR1cm4gaHVtYW5pemVNcztcbn1cblxudmFyIGNvbnN0YW50cztcbnZhciBoYXNSZXF1aXJlZENvbnN0YW50cztcblxuZnVuY3Rpb24gcmVxdWlyZUNvbnN0YW50cyAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZENvbnN0YW50cykgcmV0dXJuIGNvbnN0YW50cztcblx0aGFzUmVxdWlyZWRDb25zdGFudHMgPSAxO1xuXG5cdGNvbnN0YW50cyA9IHtcblx0ICAvLyBhZ2VudFxuXHQgIENVUlJFTlRfSUQ6IFN5bWJvbCgnYWdlbnRrZWVwYWxpdmUjY3VycmVudElkJyksXG5cdCAgQ1JFQVRFX0lEOiBTeW1ib2woJ2FnZW50a2VlcGFsaXZlI2NyZWF0ZUlkJyksXG5cdCAgSU5JVF9TT0NLRVQ6IFN5bWJvbCgnYWdlbnRrZWVwYWxpdmUjaW5pdFNvY2tldCcpLFxuXHQgIENSRUFURV9IVFRQU19DT05ORUNUSU9OOiBTeW1ib2woJ2FnZW50a2VlcGFsaXZlI2NyZWF0ZUh0dHBzQ29ubmVjdGlvbicpLFxuXHQgIC8vIHNvY2tldFxuXHQgIFNPQ0tFVF9DUkVBVEVEX1RJTUU6IFN5bWJvbCgnYWdlbnRrZWVwYWxpdmUjc29ja2V0Q3JlYXRlZFRpbWUnKSxcblx0ICBTT0NLRVRfTkFNRTogU3ltYm9sKCdhZ2VudGtlZXBhbGl2ZSNzb2NrZXROYW1lJyksXG5cdCAgU09DS0VUX1JFUVVFU1RfQ09VTlQ6IFN5bWJvbCgnYWdlbnRrZWVwYWxpdmUjc29ja2V0UmVxdWVzdENvdW50JyksXG5cdCAgU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlQ6IFN5bWJvbCgnYWdlbnRrZWVwYWxpdmUjc29ja2V0UmVxdWVzdEZpbmlzaGVkQ291bnQnKSxcblx0fTtcblx0cmV0dXJuIGNvbnN0YW50cztcbn1cblxudmFyIGFnZW50O1xudmFyIGhhc1JlcXVpcmVkQWdlbnQ7XG5cbmZ1bmN0aW9uIHJlcXVpcmVBZ2VudCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEFnZW50KSByZXR1cm4gYWdlbnQ7XG5cdGhhc1JlcXVpcmVkQWdlbnQgPSAxO1xuXG5cdGNvbnN0IE9yaWdpbmFsQWdlbnQgPSByZXF1aXJlJCQwJDEuQWdlbnQ7XG5cdGNvbnN0IG1zID0gLypAX19QVVJFX18qLyByZXF1aXJlSHVtYW5pemVNcygpO1xuXHRjb25zdCBkZWJ1ZyA9IHJlcXVpcmUkJDAuZGVidWdsb2coJ2FnZW50a2VlcGFsaXZlJyk7XG5cdGNvbnN0IHtcblx0ICBJTklUX1NPQ0tFVCxcblx0ICBDVVJSRU5UX0lELFxuXHQgIENSRUFURV9JRCxcblx0ICBTT0NLRVRfQ1JFQVRFRF9USU1FLFxuXHQgIFNPQ0tFVF9OQU1FLFxuXHQgIFNPQ0tFVF9SRVFVRVNUX0NPVU5ULFxuXHQgIFNPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5ULFxuXHR9ID0gLypAX19QVVJFX18qLyByZXF1aXJlQ29uc3RhbnRzKCk7XG5cblx0Ly8gT3JpZ2luYWxBZ2VudCBjb21lIGZyb21cblx0Ly8gLSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi92OC4xMi4wL2xpYi9faHR0cF9hZ2VudC5qc1xuXHQvLyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL3YxMC4xMi4wL2xpYi9faHR0cF9hZ2VudC5qc1xuXG5cdC8vIG5vZGUgPD0gMTBcblx0bGV0IGRlZmF1bHRUaW1lb3V0TGlzdGVuZXJDb3VudCA9IDE7XG5cdGNvbnN0IG1ham9yVmVyc2lvbiA9IHBhcnNlSW50KHByb2Nlc3MudmVyc2lvbi5zcGxpdCgnLicsIDEpWzBdLnN1YnN0cmluZygxKSk7XG5cdGlmIChtYWpvclZlcnNpb24gPj0gMTEgJiYgbWFqb3JWZXJzaW9uIDw9IDEyKSB7XG5cdCAgZGVmYXVsdFRpbWVvdXRMaXN0ZW5lckNvdW50ID0gMjtcblx0fSBlbHNlIGlmIChtYWpvclZlcnNpb24gPj0gMTMpIHtcblx0ICBkZWZhdWx0VGltZW91dExpc3RlbmVyQ291bnQgPSAzO1xuXHR9XG5cblx0ZnVuY3Rpb24gZGVwcmVjYXRlKG1lc3NhZ2UpIHtcblx0ICBjb25zb2xlLmxvZygnW2FnZW50a2VlcGFsaXZlOmRlcHJlY2F0ZWRdICVzJywgbWVzc2FnZSk7XG5cdH1cblxuXHRjbGFzcyBBZ2VudCBleHRlbmRzIE9yaWdpbmFsQWdlbnQge1xuXHQgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0ICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHQgICAgb3B0aW9ucy5rZWVwQWxpdmUgPSBvcHRpb25zLmtlZXBBbGl2ZSAhPT0gZmFsc2U7XG5cdCAgICAvLyBkZWZhdWx0IGlzIGtlZXAtYWxpdmUgYW5kIDRzIGZyZWUgc29ja2V0IHRpbWVvdXRcblx0ICAgIC8vIHNlZSBodHRwczovL21lZGl1bS5jb20vc3NlbnNlLXRlY2gvcmVkdWNlLW5ldHdvcmtpbmctZXJyb3JzLWluLW5vZGVqcy0yM2I0ZWI5ZjJkODNcblx0ICAgIGlmIChvcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0ID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgb3B0aW9ucy5mcmVlU29ja2V0VGltZW91dCA9IDQwMDA7XG5cdCAgICB9XG5cdCAgICAvLyBMZWdhY3kgQVBJOiBrZWVwQWxpdmVUaW1lb3V0IHNob3VsZCBiZSByZW5hbWUgdG8gYGZyZWVTb2NrZXRUaW1lb3V0YFxuXHQgICAgaWYgKG9wdGlvbnMua2VlcEFsaXZlVGltZW91dCkge1xuXHQgICAgICBkZXByZWNhdGUoJ29wdGlvbnMua2VlcEFsaXZlVGltZW91dCBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIG9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQgaW5zdGVhZCcpO1xuXHQgICAgICBvcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0ID0gb3B0aW9ucy5rZWVwQWxpdmVUaW1lb3V0O1xuXHQgICAgICBkZWxldGUgb3B0aW9ucy5rZWVwQWxpdmVUaW1lb3V0O1xuXHQgICAgfVxuXHQgICAgLy8gTGVnYWN5IEFQSTogZnJlZVNvY2tldEtlZXBBbGl2ZVRpbWVvdXQgc2hvdWxkIGJlIHJlbmFtZSB0byBgZnJlZVNvY2tldFRpbWVvdXRgXG5cdCAgICBpZiAob3B0aW9ucy5mcmVlU29ja2V0S2VlcEFsaXZlVGltZW91dCkge1xuXHQgICAgICBkZXByZWNhdGUoJ29wdGlvbnMuZnJlZVNvY2tldEtlZXBBbGl2ZVRpbWVvdXQgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBvcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0IGluc3RlYWQnKTtcblx0ICAgICAgb3B0aW9ucy5mcmVlU29ja2V0VGltZW91dCA9IG9wdGlvbnMuZnJlZVNvY2tldEtlZXBBbGl2ZVRpbWVvdXQ7XG5cdCAgICAgIGRlbGV0ZSBvcHRpb25zLmZyZWVTb2NrZXRLZWVwQWxpdmVUaW1lb3V0O1xuXHQgICAgfVxuXG5cdCAgICAvLyBTZXRzIHRoZSBzb2NrZXQgdG8gdGltZW91dCBhZnRlciB0aW1lb3V0IG1pbGxpc2Vjb25kcyBvZiBpbmFjdGl2aXR5IG9uIHRoZSBzb2NrZXQuXG5cdCAgICAvLyBCeSBkZWZhdWx0IGlzIGRvdWJsZSBmcmVlIHNvY2tldCB0aW1lb3V0LlxuXHQgICAgaWYgKG9wdGlvbnMudGltZW91dCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIC8vIG1ha2Ugc3VyZSBzb2NrZXQgZGVmYXVsdCBpbmFjdGl2aXR5IHRpbWVvdXQgPj0gOHNcblx0ICAgICAgb3B0aW9ucy50aW1lb3V0ID0gTWF0aC5tYXgob3B0aW9ucy5mcmVlU29ja2V0VGltZW91dCAqIDIsIDgwMDApO1xuXHQgICAgfVxuXG5cdCAgICAvLyBzdXBwb3J0IGh1bWFuaXplIGZvcm1hdFxuXHQgICAgb3B0aW9ucy50aW1lb3V0ID0gbXMob3B0aW9ucy50aW1lb3V0KTtcblx0ICAgIG9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQgPSBtcyhvcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0KTtcblx0ICAgIG9wdGlvbnMuc29ja2V0QWN0aXZlVFRMID0gb3B0aW9ucy5zb2NrZXRBY3RpdmVUVEwgPyBtcyhvcHRpb25zLnNvY2tldEFjdGl2ZVRUTCkgOiAwO1xuXG5cdCAgICBzdXBlcihvcHRpb25zKTtcblxuXHQgICAgdGhpc1tDVVJSRU5UX0lEXSA9IDA7XG5cblx0ICAgIC8vIGNyZWF0ZSBzb2NrZXQgc3VjY2VzcyBjb3VudGVyXG5cdCAgICB0aGlzLmNyZWF0ZVNvY2tldENvdW50ID0gMDtcblx0ICAgIHRoaXMuY3JlYXRlU29ja2V0Q291bnRMYXN0Q2hlY2sgPSAwO1xuXG5cdCAgICB0aGlzLmNyZWF0ZVNvY2tldEVycm9yQ291bnQgPSAwO1xuXHQgICAgdGhpcy5jcmVhdGVTb2NrZXRFcnJvckNvdW50TGFzdENoZWNrID0gMDtcblxuXHQgICAgdGhpcy5jbG9zZVNvY2tldENvdW50ID0gMDtcblx0ICAgIHRoaXMuY2xvc2VTb2NrZXRDb3VudExhc3RDaGVjayA9IDA7XG5cblx0ICAgIC8vIHNvY2tldCBlcnJvciBldmVudCBjb3VudFxuXHQgICAgdGhpcy5lcnJvclNvY2tldENvdW50ID0gMDtcblx0ICAgIHRoaXMuZXJyb3JTb2NrZXRDb3VudExhc3RDaGVjayA9IDA7XG5cblx0ICAgIC8vIHJlcXVlc3QgZmluaXNoZWQgY291bnRlclxuXHQgICAgdGhpcy5yZXF1ZXN0Q291bnQgPSAwO1xuXHQgICAgdGhpcy5yZXF1ZXN0Q291bnRMYXN0Q2hlY2sgPSAwO1xuXG5cdCAgICAvLyBpbmNsdWRpbmcgZnJlZSBzb2NrZXQgdGltZW91dCBjb3VudGVyXG5cdCAgICB0aGlzLnRpbWVvdXRTb2NrZXRDb3VudCA9IDA7XG5cdCAgICB0aGlzLnRpbWVvdXRTb2NrZXRDb3VudExhc3RDaGVjayA9IDA7XG5cblx0ICAgIHRoaXMub24oJ2ZyZWUnLCBzb2NrZXQgPT4ge1xuXHQgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC8zMjAwMFxuXHQgICAgICAvLyBOb2RlLmpzIG5hdGl2ZSBhZ2VudCB3aWxsIGNoZWNrIHNvY2tldCB0aW1lb3V0IGVxcyBhZ2VudC5vcHRpb25zLnRpbWVvdXQuXG5cdCAgICAgIC8vIFVzZSB0aGUgdHRsIG9yIGZyZWVTb2NrZXRUaW1lb3V0IHRvIG92ZXJ3cml0ZS5cblx0ICAgICAgY29uc3QgdGltZW91dCA9IHRoaXMuY2FsY1NvY2tldFRpbWVvdXQoc29ja2V0KTtcblx0ICAgICAgaWYgKHRpbWVvdXQgPiAwICYmIHNvY2tldC50aW1lb3V0ICE9PSB0aW1lb3V0KSB7XG5cdCAgICAgICAgc29ja2V0LnNldFRpbWVvdXQodGltZW91dCk7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgIH1cblxuXHQgIGdldCBmcmVlU29ja2V0S2VlcEFsaXZlVGltZW91dCgpIHtcblx0ICAgIGRlcHJlY2F0ZSgnYWdlbnQuZnJlZVNvY2tldEtlZXBBbGl2ZVRpbWVvdXQgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBhZ2VudC5vcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0IGluc3RlYWQnKTtcblx0ICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQ7XG5cdCAgfVxuXG5cdCAgZ2V0IHRpbWVvdXQoKSB7XG5cdCAgICBkZXByZWNhdGUoJ2FnZW50LnRpbWVvdXQgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBhZ2VudC5vcHRpb25zLnRpbWVvdXQgaW5zdGVhZCcpO1xuXHQgICAgcmV0dXJuIHRoaXMub3B0aW9ucy50aW1lb3V0O1xuXHQgIH1cblxuXHQgIGdldCBzb2NrZXRBY3RpdmVUVEwoKSB7XG5cdCAgICBkZXByZWNhdGUoJ2FnZW50LnNvY2tldEFjdGl2ZVRUTCBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIGFnZW50Lm9wdGlvbnMuc29ja2V0QWN0aXZlVFRMIGluc3RlYWQnKTtcblx0ICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc29ja2V0QWN0aXZlVFRMO1xuXHQgIH1cblxuXHQgIGNhbGNTb2NrZXRUaW1lb3V0KHNvY2tldCkge1xuXHQgICAgLyoqXG5cdCAgICAgKiByZXR1cm4gPD0gMDogc2hvdWxkIGZyZWUgc29ja2V0XG5cdCAgICAgKiByZXR1cm4gPiAwOiBzaG91bGQgdXBkYXRlIHNvY2tldCB0aW1lb3V0XG5cdCAgICAgKiByZXR1cm4gdW5kZWZpbmVkOiBub3QgZmluZCBjdXN0b20gdGltZW91dFxuXHQgICAgICovXG5cdCAgICBsZXQgZnJlZVNvY2tldFRpbWVvdXQgPSB0aGlzLm9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQ7XG5cdCAgICBjb25zdCBzb2NrZXRBY3RpdmVUVEwgPSB0aGlzLm9wdGlvbnMuc29ja2V0QWN0aXZlVFRMO1xuXHQgICAgaWYgKHNvY2tldEFjdGl2ZVRUTCkge1xuXHQgICAgICAvLyBjaGVjayBzb2NrZXRBY3RpdmVUVExcblx0ICAgICAgY29uc3QgYWxpdmVUaW1lID0gRGF0ZS5ub3coKSAtIHNvY2tldFtTT0NLRVRfQ1JFQVRFRF9USU1FXTtcblx0ICAgICAgY29uc3QgZGlmZiA9IHNvY2tldEFjdGl2ZVRUTCAtIGFsaXZlVGltZTtcblx0ICAgICAgaWYgKGRpZmYgPD0gMCkge1xuXHQgICAgICAgIHJldHVybiBkaWZmO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChmcmVlU29ja2V0VGltZW91dCAmJiBkaWZmIDwgZnJlZVNvY2tldFRpbWVvdXQpIHtcblx0ICAgICAgICBmcmVlU29ja2V0VGltZW91dCA9IGRpZmY7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIC8vIHNldCBmcmVlU29ja2V0VGltZW91dFxuXHQgICAgaWYgKGZyZWVTb2NrZXRUaW1lb3V0KSB7XG5cdCAgICAgIC8vIHNldCBmcmVlIGtlZXBhbGl2ZSB0aW1lclxuXHQgICAgICAvLyB0cnkgdG8gdXNlIHNvY2tldCBjdXN0b20gZnJlZVNvY2tldFRpbWVvdXQgZmlyc3QsIHN1cHBvcnQgaGVhZGVyc1sna2VlcC1hbGl2ZSddXG5cdCAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLW1vZHVsZXMvdXJsbGliL2Jsb2IvYjc2MDUzMDIwOTIzZjRkOTlhMWM5M2NmMmUxNmUwYzViYTEwYmFjZi9saWIvdXJsbGliLmpzI0w0OThcblx0ICAgICAgY29uc3QgY3VzdG9tRnJlZVNvY2tldFRpbWVvdXQgPSBzb2NrZXQuZnJlZVNvY2tldFRpbWVvdXQgfHwgc29ja2V0LmZyZWVTb2NrZXRLZWVwQWxpdmVUaW1lb3V0O1xuXHQgICAgICByZXR1cm4gY3VzdG9tRnJlZVNvY2tldFRpbWVvdXQgfHwgZnJlZVNvY2tldFRpbWVvdXQ7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAga2VlcFNvY2tldEFsaXZlKHNvY2tldCkge1xuXHQgICAgY29uc3QgcmVzdWx0ID0gc3VwZXIua2VlcFNvY2tldEFsaXZlKHNvY2tldCk7XG5cdCAgICAvLyBzaG91bGQgbm90IGtlZXBBbGl2ZSwgZG8gbm90aGluZ1xuXHQgICAgaWYgKCFyZXN1bHQpIHJldHVybiByZXN1bHQ7XG5cblx0ICAgIGNvbnN0IGN1c3RvbVRpbWVvdXQgPSB0aGlzLmNhbGNTb2NrZXRUaW1lb3V0KHNvY2tldCk7XG5cdCAgICBpZiAodHlwZW9mIGN1c3RvbVRpbWVvdXQgPT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHQgICAgaWYgKGN1c3RvbVRpbWVvdXQgPD0gMCkge1xuXHQgICAgICBkZWJ1ZygnJXMocmVxdWVzdHM6ICVzLCBmaW5pc2hlZDogJXMpIGZyZWUgYnV0IG5lZWQgdG8gZGVzdHJveSBieSBUVEwsIHJlcXVlc3QgY291bnQgJXMsIGRpZmYgaXMgJXMnLFxuXHQgICAgICAgIHNvY2tldFtTT0NLRVRfTkFNRV0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVF0sIGN1c3RvbVRpbWVvdXQpO1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgICBpZiAoc29ja2V0LnRpbWVvdXQgIT09IGN1c3RvbVRpbWVvdXQpIHtcblx0ICAgICAgc29ja2V0LnNldFRpbWVvdXQoY3VzdG9tVGltZW91dCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9XG5cblx0ICAvLyBvbmx5IGNhbGwgb24gYWRkUmVxdWVzdFxuXHQgIHJldXNlU29ja2V0KC4uLmFyZ3MpIHtcblx0ICAgIC8vIHJldXNlU29ja2V0KHNvY2tldCwgcmVxKVxuXHQgICAgc3VwZXIucmV1c2VTb2NrZXQoLi4uYXJncyk7XG5cdCAgICBjb25zdCBzb2NrZXQgPSBhcmdzWzBdO1xuXHQgICAgY29uc3QgcmVxID0gYXJnc1sxXTtcblx0ICAgIHJlcS5yZXVzZWRTb2NrZXQgPSB0cnVlO1xuXHQgICAgY29uc3QgYWdlbnRUaW1lb3V0ID0gdGhpcy5vcHRpb25zLnRpbWVvdXQ7XG5cdCAgICBpZiAoZ2V0U29ja2V0VGltZW91dChzb2NrZXQpICE9PSBhZ2VudFRpbWVvdXQpIHtcblx0ICAgICAgLy8gcmVzZXQgdGltZW91dCBiZWZvcmUgdXNlXG5cdCAgICAgIHNvY2tldC5zZXRUaW1lb3V0KGFnZW50VGltZW91dCk7XG5cdCAgICAgIGRlYnVnKCclcyByZXNldCB0aW1lb3V0IHRvICVzbXMnLCBzb2NrZXRbU09DS0VUX05BTUVdLCBhZ2VudFRpbWVvdXQpO1xuXHQgICAgfVxuXHQgICAgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSsrO1xuXHQgICAgZGVidWcoJyVzKHJlcXVlc3RzOiAlcywgZmluaXNoZWQ6ICVzKSByZXVzZSBvbiBhZGRSZXF1ZXN0LCB0aW1lb3V0ICVzbXMnLFxuXHQgICAgICBzb2NrZXRbU09DS0VUX05BTUVdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdLFxuXHQgICAgICBnZXRTb2NrZXRUaW1lb3V0KHNvY2tldCkpO1xuXHQgIH1cblxuXHQgIFtDUkVBVEVfSURdKCkge1xuXHQgICAgY29uc3QgaWQgPSB0aGlzW0NVUlJFTlRfSURdKys7XG5cdCAgICBpZiAodGhpc1tDVVJSRU5UX0lEXSA9PT0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHRoaXNbQ1VSUkVOVF9JRF0gPSAwO1xuXHQgICAgcmV0dXJuIGlkO1xuXHQgIH1cblxuXHQgIFtJTklUX1NPQ0tFVF0oc29ja2V0LCBvcHRpb25zKSB7XG5cdCAgICAvLyBidWdmaXggaGVyZS5cblx0ICAgIC8vIGh0dHBzIG9uIG5vZGUgOCwgMTAgd29uJ3Qgc2V0IGFnZW50Lm9wdGlvbnMudGltZW91dCBieSBkZWZhdWx0XG5cdCAgICAvLyBUT0RPOiBuZWVkIHRvIGZpeCBvbiBub2RlIGl0c2VsZlxuXHQgICAgaWYgKG9wdGlvbnMudGltZW91dCkge1xuXHQgICAgICBjb25zdCB0aW1lb3V0ID0gZ2V0U29ja2V0VGltZW91dChzb2NrZXQpO1xuXHQgICAgICBpZiAoIXRpbWVvdXQpIHtcblx0ICAgICAgICBzb2NrZXQuc2V0VGltZW91dChvcHRpb25zLnRpbWVvdXQpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLm9wdGlvbnMua2VlcEFsaXZlKSB7XG5cdCAgICAgIC8vIERpc2FibGUgTmFnbGUncyBhbGdvcml0aG06IGh0dHA6Ly9ibG9nLmNhdXN0aWsuY29tLzIwMTIvMDQvMDgvc2NhbGluZy1ub2RlLWpzLXRvLTEwMGstY29uY3VycmVudC1jb25uZWN0aW9ucy9cblx0ICAgICAgLy8gaHR0cHM6Ly9mZW5nbWsyLmNvbS9iZW5jaG1hcmsvbmFnbGUtYWxnb3JpdGhtLWRlbGF5ZWQtYWNrLW1vY2suaHRtbFxuXHQgICAgICBzb2NrZXQuc2V0Tm9EZWxheSh0cnVlKTtcblx0ICAgIH1cblx0ICAgIHRoaXMuY3JlYXRlU29ja2V0Q291bnQrKztcblx0ICAgIGlmICh0aGlzLm9wdGlvbnMuc29ja2V0QWN0aXZlVFRMKSB7XG5cdCAgICAgIHNvY2tldFtTT0NLRVRfQ1JFQVRFRF9USU1FXSA9IERhdGUubm93KCk7XG5cdCAgICB9XG5cdCAgICAvLyBkb24ndCBzaG93IHRoZSBob2xlICctLS0tLUJFR0lOIENFUlRJRklDQVRFLS0tLScga2V5IHN0cmluZ1xuXHQgICAgc29ja2V0W1NPQ0tFVF9OQU1FXSA9IGBzb2NrWyR7dGhpc1tDUkVBVEVfSURdKCl9IyR7b3B0aW9ucy5fYWdlbnRLZXl9XWAuc3BsaXQoJy0tLS0tQkVHSU4nLCAxKVswXTtcblx0ICAgIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0gPSAxO1xuXHQgICAgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UXSA9IDA7XG5cdCAgICBpbnN0YWxsTGlzdGVuZXJzKHRoaXMsIHNvY2tldCwgb3B0aW9ucyk7XG5cdCAgfVxuXG5cdCAgY3JlYXRlQ29ubmVjdGlvbihvcHRpb25zLCBvbmNyZWF0ZSkge1xuXHQgICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuXHQgICAgY29uc3Qgb25OZXdDcmVhdGUgPSAoZXJyLCBzb2NrZXQpID0+IHtcblx0ICAgICAgaWYgKGNhbGxlZCkgcmV0dXJuO1xuXHQgICAgICBjYWxsZWQgPSB0cnVlO1xuXG5cdCAgICAgIGlmIChlcnIpIHtcblx0ICAgICAgICB0aGlzLmNyZWF0ZVNvY2tldEVycm9yQ291bnQrKztcblx0ICAgICAgICByZXR1cm4gb25jcmVhdGUoZXJyKTtcblx0ICAgICAgfVxuXHQgICAgICB0aGlzW0lOSVRfU09DS0VUXShzb2NrZXQsIG9wdGlvbnMpO1xuXHQgICAgICBvbmNyZWF0ZShlcnIsIHNvY2tldCk7XG5cdCAgICB9O1xuXG5cdCAgICBjb25zdCBuZXdTb2NrZXQgPSBzdXBlci5jcmVhdGVDb25uZWN0aW9uKG9wdGlvbnMsIG9uTmV3Q3JlYXRlKTtcblx0ICAgIGlmIChuZXdTb2NrZXQpIG9uTmV3Q3JlYXRlKG51bGwsIG5ld1NvY2tldCk7XG5cdCAgICByZXR1cm4gbmV3U29ja2V0O1xuXHQgIH1cblxuXHQgIGdldCBzdGF0dXNDaGFuZ2VkKCkge1xuXHQgICAgY29uc3QgY2hhbmdlZCA9IHRoaXMuY3JlYXRlU29ja2V0Q291bnQgIT09IHRoaXMuY3JlYXRlU29ja2V0Q291bnRMYXN0Q2hlY2sgfHxcblx0ICAgICAgdGhpcy5jcmVhdGVTb2NrZXRFcnJvckNvdW50ICE9PSB0aGlzLmNyZWF0ZVNvY2tldEVycm9yQ291bnRMYXN0Q2hlY2sgfHxcblx0ICAgICAgdGhpcy5jbG9zZVNvY2tldENvdW50ICE9PSB0aGlzLmNsb3NlU29ja2V0Q291bnRMYXN0Q2hlY2sgfHxcblx0ICAgICAgdGhpcy5lcnJvclNvY2tldENvdW50ICE9PSB0aGlzLmVycm9yU29ja2V0Q291bnRMYXN0Q2hlY2sgfHxcblx0ICAgICAgdGhpcy50aW1lb3V0U29ja2V0Q291bnQgIT09IHRoaXMudGltZW91dFNvY2tldENvdW50TGFzdENoZWNrIHx8XG5cdCAgICAgIHRoaXMucmVxdWVzdENvdW50ICE9PSB0aGlzLnJlcXVlc3RDb3VudExhc3RDaGVjaztcblx0ICAgIGlmIChjaGFuZ2VkKSB7XG5cdCAgICAgIHRoaXMuY3JlYXRlU29ja2V0Q291bnRMYXN0Q2hlY2sgPSB0aGlzLmNyZWF0ZVNvY2tldENvdW50O1xuXHQgICAgICB0aGlzLmNyZWF0ZVNvY2tldEVycm9yQ291bnRMYXN0Q2hlY2sgPSB0aGlzLmNyZWF0ZVNvY2tldEVycm9yQ291bnQ7XG5cdCAgICAgIHRoaXMuY2xvc2VTb2NrZXRDb3VudExhc3RDaGVjayA9IHRoaXMuY2xvc2VTb2NrZXRDb3VudDtcblx0ICAgICAgdGhpcy5lcnJvclNvY2tldENvdW50TGFzdENoZWNrID0gdGhpcy5lcnJvclNvY2tldENvdW50O1xuXHQgICAgICB0aGlzLnRpbWVvdXRTb2NrZXRDb3VudExhc3RDaGVjayA9IHRoaXMudGltZW91dFNvY2tldENvdW50O1xuXHQgICAgICB0aGlzLnJlcXVlc3RDb3VudExhc3RDaGVjayA9IHRoaXMucmVxdWVzdENvdW50O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGNoYW5nZWQ7XG5cdCAgfVxuXG5cdCAgZ2V0Q3VycmVudFN0YXR1cygpIHtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgIGNyZWF0ZVNvY2tldENvdW50OiB0aGlzLmNyZWF0ZVNvY2tldENvdW50LFxuXHQgICAgICBjcmVhdGVTb2NrZXRFcnJvckNvdW50OiB0aGlzLmNyZWF0ZVNvY2tldEVycm9yQ291bnQsXG5cdCAgICAgIGNsb3NlU29ja2V0Q291bnQ6IHRoaXMuY2xvc2VTb2NrZXRDb3VudCxcblx0ICAgICAgZXJyb3JTb2NrZXRDb3VudDogdGhpcy5lcnJvclNvY2tldENvdW50LFxuXHQgICAgICB0aW1lb3V0U29ja2V0Q291bnQ6IHRoaXMudGltZW91dFNvY2tldENvdW50LFxuXHQgICAgICByZXF1ZXN0Q291bnQ6IHRoaXMucmVxdWVzdENvdW50LFxuXHQgICAgICBmcmVlU29ja2V0czogaW5zcGVjdCh0aGlzLmZyZWVTb2NrZXRzKSxcblx0ICAgICAgc29ja2V0czogaW5zcGVjdCh0aGlzLnNvY2tldHMpLFxuXHQgICAgICByZXF1ZXN0czogaW5zcGVjdCh0aGlzLnJlcXVlc3RzKSxcblx0ICAgIH07XG5cdCAgfVxuXHR9XG5cblx0Ly8gbm9kZSA4IGRvbid0IGhhcyB0aW1lb3V0IGF0dHJpYnV0ZSBvbiBzb2NrZXRcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvMjEyMDQvZmlsZXMjZGlmZi1lNmVmMDI0YzM3NzVkNzg3YzM4NDg3YTYzMDllNDkxZFI0MDhcblx0ZnVuY3Rpb24gZ2V0U29ja2V0VGltZW91dChzb2NrZXQpIHtcblx0ICByZXR1cm4gc29ja2V0LnRpbWVvdXQgfHwgc29ja2V0Ll9pZGxlVGltZW91dDtcblx0fVxuXG5cdGZ1bmN0aW9uIGluc3RhbGxMaXN0ZW5lcnMoYWdlbnQsIHNvY2tldCwgb3B0aW9ucykge1xuXHQgIGRlYnVnKCclcyBjcmVhdGUsIHRpbWVvdXQgJXNtcycsIHNvY2tldFtTT0NLRVRfTkFNRV0sIGdldFNvY2tldFRpbWVvdXQoc29ja2V0KSk7XG5cblx0ICAvLyBsaXN0ZW5lciBzb2NrZXQgZXZlbnRzOiBjbG9zZSwgdGltZW91dCwgZXJyb3IsIGZyZWVcblx0ICBmdW5jdGlvbiBvbkZyZWUoKSB7XG5cdCAgICAvLyBjcmVhdGUgYW5kIHNvY2tldC5lbWl0KCdmcmVlJykgbG9naWNcblx0ICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL21hc3Rlci9saWIvX2h0dHBfYWdlbnQuanMjTDMxMVxuXHQgICAgLy8gbm8gcmVxIG9uIHRoZSBzb2NrZXQsIGl0IHNob3VsZCBiZSB0aGUgbmV3IHNvY2tldFxuXHQgICAgaWYgKCFzb2NrZXQuX2h0dHBNZXNzYWdlICYmIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0gPT09IDEpIHJldHVybjtcblxuXHQgICAgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UXSsrO1xuXHQgICAgYWdlbnQucmVxdWVzdENvdW50Kys7XG5cdCAgICBkZWJ1ZygnJXMocmVxdWVzdHM6ICVzLCBmaW5pc2hlZDogJXMpIGZyZWUnLFxuXHQgICAgICBzb2NrZXRbU09DS0VUX05BTUVdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdKTtcblxuXHQgICAgLy8gc2hvdWxkIHJldXNlIG9uIHBlZGRpbmcgcmVxdWVzdHM/XG5cdCAgICBjb25zdCBuYW1lID0gYWdlbnQuZ2V0TmFtZShvcHRpb25zKTtcblx0ICAgIGlmIChzb2NrZXQud3JpdGFibGUgJiYgYWdlbnQucmVxdWVzdHNbbmFtZV0gJiYgYWdlbnQucmVxdWVzdHNbbmFtZV0ubGVuZ3RoKSB7XG5cdCAgICAgIC8vIHdpbGwgYmUgcmV1c2Ugb24gYWdlbnQgZnJlZSBsaXN0ZW5lclxuXHQgICAgICBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdKys7XG5cdCAgICAgIGRlYnVnKCclcyhyZXF1ZXN0czogJXMsIGZpbmlzaGVkOiAlcykgd2lsbCBiZSByZXVzZSBvbiBhZ2VudCBmcmVlIGV2ZW50Jyxcblx0ICAgICAgICBzb2NrZXRbU09DS0VUX05BTUVdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdKTtcblx0ICAgIH1cblx0ICB9XG5cdCAgc29ja2V0Lm9uKCdmcmVlJywgb25GcmVlKTtcblxuXHQgIGZ1bmN0aW9uIG9uQ2xvc2UoaXNFcnJvcikge1xuXHQgICAgZGVidWcoJyVzKHJlcXVlc3RzOiAlcywgZmluaXNoZWQ6ICVzKSBjbG9zZSwgaXNFcnJvcjogJXMnLFxuXHQgICAgICBzb2NrZXRbU09DS0VUX05BTUVdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdLCBpc0Vycm9yKTtcblx0ICAgIGFnZW50LmNsb3NlU29ja2V0Q291bnQrKztcblx0ICB9XG5cdCAgc29ja2V0Lm9uKCdjbG9zZScsIG9uQ2xvc2UpO1xuXG5cdCAgLy8gc3RhcnQgc29ja2V0IHRpbWVvdXQgaGFuZGxlclxuXHQgIGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcblx0ICAgIC8vIG9uVGltZW91dCBhbmQgZW1pdFJlcXVlc3RUaW1lb3V0KF9odHRwX2NsaWVudC5qcylcblx0ICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL3YxMi54L2xpYi9faHR0cF9jbGllbnQuanMjTDcxMVxuXHQgICAgY29uc3QgbGlzdGVuZXJDb3VudCA9IHNvY2tldC5saXN0ZW5lcnMoJ3RpbWVvdXQnKS5sZW5ndGg7XG5cdCAgICAvLyBub2RlIDw9IDEwLCBkZWZhdWx0IGxpc3RlbmVyQ291bnQgaXMgMSwgb25UaW1lb3V0XG5cdCAgICAvLyAxMSA8IG5vZGUgPD0gMTIsIGRlZmF1bHQgbGlzdGVuZXJDb3VudCBpcyAyLCBvblRpbWVvdXQgYW5kIGVtaXRSZXF1ZXN0VGltZW91dFxuXHQgICAgLy8gbm9kZSA+PSAxMywgZGVmYXVsdCBsaXN0ZW5lckNvdW50IGlzIDMsIG9uVGltZW91dCxcblx0ICAgIC8vICAgb25UaW1lb3V0KGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzMyMDAwL2ZpbGVzI2RpZmYtNWY3ZmIwODUwNDEyYzZiZTE4OWZhZWRkZWE2YzUzNTlSMzMzKVxuXHQgICAgLy8gICBhbmQgZW1pdFJlcXVlc3RUaW1lb3V0XG5cdCAgICBjb25zdCB0aW1lb3V0ID0gZ2V0U29ja2V0VGltZW91dChzb2NrZXQpO1xuXHQgICAgY29uc3QgcmVxID0gc29ja2V0Ll9odHRwTWVzc2FnZTtcblx0ICAgIGNvbnN0IHJlcVRpbWVvdXRMaXN0ZW5lckNvdW50ID0gcmVxICYmIHJlcS5saXN0ZW5lcnMoJ3RpbWVvdXQnKS5sZW5ndGggfHwgMDtcblx0ICAgIGRlYnVnKCclcyhyZXF1ZXN0czogJXMsIGZpbmlzaGVkOiAlcykgdGltZW91dCBhZnRlciAlc21zLCBsaXN0ZW5lcnMgJXMsIGRlZmF1bHRUaW1lb3V0TGlzdGVuZXJDb3VudCAlcywgaGFzSHR0cFJlcXVlc3QgJXMsIEh0dHBSZXF1ZXN0IHRpbWVvdXRMaXN0ZW5lckNvdW50ICVzJyxcblx0ICAgICAgc29ja2V0W1NPQ0tFVF9OQU1FXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UXSxcblx0ICAgICAgdGltZW91dCwgbGlzdGVuZXJDb3VudCwgZGVmYXVsdFRpbWVvdXRMaXN0ZW5lckNvdW50LCAhIXJlcSwgcmVxVGltZW91dExpc3RlbmVyQ291bnQpO1xuXHQgICAgaWYgKGRlYnVnLmVuYWJsZWQpIHtcblx0ICAgICAgZGVidWcoJ3RpbWVvdXQgbGlzdGVuZXJzOiAlcycsIHNvY2tldC5saXN0ZW5lcnMoJ3RpbWVvdXQnKS5tYXAoZiA9PiBmLm5hbWUpLmpvaW4oJywgJykpO1xuXHQgICAgfVxuXHQgICAgYWdlbnQudGltZW91dFNvY2tldENvdW50Kys7XG5cdCAgICBjb25zdCBuYW1lID0gYWdlbnQuZ2V0TmFtZShvcHRpb25zKTtcblx0ICAgIGlmIChhZ2VudC5mcmVlU29ja2V0c1tuYW1lXSAmJiBhZ2VudC5mcmVlU29ja2V0c1tuYW1lXS5pbmRleE9mKHNvY2tldCkgIT09IC0xKSB7XG5cdCAgICAgIC8vIGZyZWUgc29ja2V0IHRpbWVvdXQsIGRlc3Ryb3kgcXVpZXRseVxuXHQgICAgICBzb2NrZXQuZGVzdHJveSgpO1xuXHQgICAgICAvLyBSZW1vdmUgaXQgZnJvbSBmcmVlU29ja2V0cyBsaXN0IGltbWVkaWF0ZWx5IHRvIHByZXZlbnQgbmV3IHJlcXVlc3RzXG5cdCAgICAgIC8vIGZyb20gYmVpbmcgc2VudCB0aHJvdWdoIHRoaXMgc29ja2V0LlxuXHQgICAgICBhZ2VudC5yZW1vdmVTb2NrZXQoc29ja2V0LCBvcHRpb25zKTtcblx0ICAgICAgZGVidWcoJyVzIGlzIGZyZWUsIGRlc3Ryb3kgcXVpZXRseScsIHNvY2tldFtTT0NLRVRfTkFNRV0pO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gYW55IHJlcXVlc3Qgc29ja2V0IHRpbWVvdXQgaGFuZGxlcixcblx0ICAgICAgLy8gYWdlbnQgbmVlZCB0byBoYW5kbGUgc29ja2V0IHRpbWVvdXQgaXRzZWxmLlxuXHQgICAgICAvL1xuXHQgICAgICAvLyBjdXN0b20gcmVxdWVzdCBzb2NrZXQgdGltZW91dCBoYW5kbGUgbG9naWMgbXVzdCBmb2xsb3cgdGhlc2UgcnVsZXM6XG5cdCAgICAgIC8vICAxLiBEZXN0cm95IHNvY2tldCBmaXJzdFxuXHQgICAgICAvLyAgMi4gTXVzdCBlbWl0IHNvY2tldCAnYWdlbnRSZW1vdmUnIGV2ZW50IHRlbGwgYWdlbnQgcmVtb3ZlIHNvY2tldFxuXHQgICAgICAvLyAgICAgZnJvbSBmcmVlU29ja2V0cyBsaXN0IGltbWVkaWF0ZWx5LlxuXHQgICAgICAvLyAgICAgT3RoZXJpc2UgeW91IG1heSBiZSBnZXQgJ3NvY2tldCBoYW5nIHVwJyBlcnJvciB3aGVuIHJldXNlXG5cdCAgICAgIC8vICAgICBmcmVlIHNvY2tldCBhbmQgdGltZW91dCBoYXBwZW4gaW4gdGhlIHNhbWUgdGltZS5cblx0ICAgICAgaWYgKHJlcVRpbWVvdXRMaXN0ZW5lckNvdW50ID09PSAwKSB7XG5cdCAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ1NvY2tldCB0aW1lb3V0Jyk7XG5cdCAgICAgICAgZXJyb3IuY29kZSA9ICdFUlJfU09DS0VUX1RJTUVPVVQnO1xuXHQgICAgICAgIGVycm9yLnRpbWVvdXQgPSB0aW1lb3V0O1xuXHQgICAgICAgIC8vIG11c3QgbWFudWFsbHkgY2FsbCBzb2NrZXQuZW5kKCkgb3Igc29ja2V0LmRlc3Ryb3koKSB0byBlbmQgdGhlIGNvbm5lY3Rpb24uXG5cdCAgICAgICAgLy8gaHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0LXYxMC54L2RvY3MvYXBpL25ldC5odG1sI25ldF9zb2NrZXRfc2V0dGltZW91dF90aW1lb3V0X2NhbGxiYWNrXG5cdCAgICAgICAgc29ja2V0LmRlc3Ryb3koZXJyb3IpO1xuXHQgICAgICAgIGFnZW50LnJlbW92ZVNvY2tldChzb2NrZXQsIG9wdGlvbnMpO1xuXHQgICAgICAgIGRlYnVnKCclcyBkZXN0cm95IHdpdGggdGltZW91dCBlcnJvcicsIHNvY2tldFtTT0NLRVRfTkFNRV0pO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHQgIHNvY2tldC5vbigndGltZW91dCcsIG9uVGltZW91dCk7XG5cblx0ICBmdW5jdGlvbiBvbkVycm9yKGVycikge1xuXHQgICAgY29uc3QgbGlzdGVuZXJDb3VudCA9IHNvY2tldC5saXN0ZW5lcnMoJ2Vycm9yJykubGVuZ3RoO1xuXHQgICAgZGVidWcoJyVzKHJlcXVlc3RzOiAlcywgZmluaXNoZWQ6ICVzKSBlcnJvcjogJXMsIGxpc3RlbmVyQ291bnQ6ICVzJyxcblx0ICAgICAgc29ja2V0W1NPQ0tFVF9OQU1FXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UXSxcblx0ICAgICAgZXJyLCBsaXN0ZW5lckNvdW50KTtcblx0ICAgIGFnZW50LmVycm9yU29ja2V0Q291bnQrKztcblx0ICAgIGlmIChsaXN0ZW5lckNvdW50ID09PSAxKSB7XG5cdCAgICAgIC8vIGlmIHNvY2tldCBkb24ndCBjb250YWluIGVycm9yIGV2ZW50IGhhbmRsZXIsIGRvbid0IGNhdGNoIGl0LCBlbWl0IGl0IGFnYWluXG5cdCAgICAgIGRlYnVnKCclcyBlbWl0IHVuY2F1Z2h0IGVycm9yIGV2ZW50Jywgc29ja2V0W1NPQ0tFVF9OQU1FXSk7XG5cdCAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcblx0ICAgICAgc29ja2V0LmVtaXQoJ2Vycm9yJywgZXJyKTtcblx0ICAgIH1cblx0ICB9XG5cdCAgc29ja2V0Lm9uKCdlcnJvcicsIG9uRXJyb3IpO1xuXG5cdCAgZnVuY3Rpb24gb25SZW1vdmUoKSB7XG5cdCAgICBkZWJ1ZygnJXMocmVxdWVzdHM6ICVzLCBmaW5pc2hlZDogJXMpIGFnZW50UmVtb3ZlJyxcblx0ICAgICAgc29ja2V0W1NPQ0tFVF9OQU1FXSxcblx0ICAgICAgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UXSk7XG5cdCAgICAvLyBXZSBuZWVkIHRoaXMgZnVuY3Rpb24gZm9yIGNhc2VzIGxpa2UgSFRUUCAndXBncmFkZSdcblx0ICAgIC8vIChkZWZpbmVkIGJ5IFdlYlNvY2tldHMpIHdoZXJlIHdlIG5lZWQgdG8gcmVtb3ZlIGEgc29ja2V0IGZyb20gdGhlXG5cdCAgICAvLyBwb29sIGJlY2F1c2UgaXQnbGwgYmUgbG9ja2VkIHVwIGluZGVmaW5pdGVseVxuXHQgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uQ2xvc2UpO1xuXHQgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuXHQgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdmcmVlJywgb25GcmVlKTtcblx0ICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcigndGltZW91dCcsIG9uVGltZW91dCk7XG5cdCAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2FnZW50UmVtb3ZlJywgb25SZW1vdmUpO1xuXHQgIH1cblx0ICBzb2NrZXQub24oJ2FnZW50UmVtb3ZlJywgb25SZW1vdmUpO1xuXHR9XG5cblx0YWdlbnQgPSBBZ2VudDtcblxuXHRmdW5jdGlvbiBpbnNwZWN0KG9iaikge1xuXHQgIGNvbnN0IHJlcyA9IHt9O1xuXHQgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuXHQgICAgcmVzW2tleV0gPSBvYmpba2V5XS5sZW5ndGg7XG5cdCAgfVxuXHQgIHJldHVybiByZXM7XG5cdH1cblx0cmV0dXJuIGFnZW50O1xufVxuXG52YXIgaHR0cHNfYWdlbnQ7XG52YXIgaGFzUmVxdWlyZWRIdHRwc19hZ2VudDtcblxuZnVuY3Rpb24gcmVxdWlyZUh0dHBzX2FnZW50ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkSHR0cHNfYWdlbnQpIHJldHVybiBodHRwc19hZ2VudDtcblx0aGFzUmVxdWlyZWRIdHRwc19hZ2VudCA9IDE7XG5cblx0Y29uc3QgT3JpZ2luYWxIdHRwc0FnZW50ID0gcmVxdWlyZSQkMCQyLkFnZW50O1xuXHRjb25zdCBIdHRwQWdlbnQgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVBZ2VudCgpO1xuXHRjb25zdCB7XG5cdCAgSU5JVF9TT0NLRVQsXG5cdCAgQ1JFQVRFX0hUVFBTX0NPTk5FQ1RJT04sXG5cdH0gPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVDb25zdGFudHMoKTtcblxuXHRjbGFzcyBIdHRwc0FnZW50IGV4dGVuZHMgSHR0cEFnZW50IHtcblx0ICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdCAgICBzdXBlcihvcHRpb25zKTtcblxuXHQgICAgdGhpcy5kZWZhdWx0UG9ydCA9IDQ0Mztcblx0ICAgIHRoaXMucHJvdG9jb2wgPSAnaHR0cHM6Jztcblx0ICAgIHRoaXMubWF4Q2FjaGVkU2Vzc2lvbnMgPSB0aGlzLm9wdGlvbnMubWF4Q2FjaGVkU2Vzc2lvbnM7XG5cdCAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHQgICAgaWYgKHRoaXMubWF4Q2FjaGVkU2Vzc2lvbnMgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICB0aGlzLm1heENhY2hlZFNlc3Npb25zID0gMTAwO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLl9zZXNzaW9uQ2FjaGUgPSB7XG5cdCAgICAgIG1hcDoge30sXG5cdCAgICAgIGxpc3Q6IFtdLFxuXHQgICAgfTtcblx0ICB9XG5cblx0ICBjcmVhdGVDb25uZWN0aW9uKG9wdGlvbnMsIG9uY3JlYXRlKSB7XG5cdCAgICBjb25zdCBzb2NrZXQgPSB0aGlzW0NSRUFURV9IVFRQU19DT05ORUNUSU9OXShvcHRpb25zLCBvbmNyZWF0ZSk7XG5cdCAgICB0aGlzW0lOSVRfU09DS0VUXShzb2NrZXQsIG9wdGlvbnMpO1xuXHQgICAgcmV0dXJuIHNvY2tldDtcblx0ICB9XG5cdH1cblxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi9tYXN0ZXIvbGliL2h0dHBzLmpzI0w4OVxuXHRIdHRwc0FnZW50LnByb3RvdHlwZVtDUkVBVEVfSFRUUFNfQ09OTkVDVElPTl0gPSBPcmlnaW5hbEh0dHBzQWdlbnQucHJvdG90eXBlLmNyZWF0ZUNvbm5lY3Rpb247XG5cblx0W1xuXHQgICdnZXROYW1lJyxcblx0ICAnX2dldFNlc3Npb24nLFxuXHQgICdfY2FjaGVTZXNzaW9uJyxcblx0ICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC80OTgyXG5cdCAgJ19ldmljdFNlc3Npb24nLFxuXHRdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG5cdCAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0ICBpZiAodHlwZW9mIE9yaWdpbmFsSHR0cHNBZ2VudC5wcm90b3R5cGVbbWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgSHR0cHNBZ2VudC5wcm90b3R5cGVbbWV0aG9kXSA9IE9yaWdpbmFsSHR0cHNBZ2VudC5wcm90b3R5cGVbbWV0aG9kXTtcblx0ICB9XG5cdH0pO1xuXG5cdGh0dHBzX2FnZW50ID0gSHR0cHNBZ2VudDtcblx0cmV0dXJuIGh0dHBzX2FnZW50O1xufVxuXG52YXIgaGFzUmVxdWlyZWRBZ2VudGtlZXBhbGl2ZTtcblxuZnVuY3Rpb24gcmVxdWlyZUFnZW50a2VlcGFsaXZlICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkQWdlbnRrZWVwYWxpdmUpIHJldHVybiBhZ2VudGtlZXBhbGl2ZS5leHBvcnRzO1xuXHRoYXNSZXF1aXJlZEFnZW50a2VlcGFsaXZlID0gMTtcblxuXHRhZ2VudGtlZXBhbGl2ZS5leHBvcnRzID0gLypAX19QVVJFX18qLyByZXF1aXJlQWdlbnQoKTtcblx0YWdlbnRrZWVwYWxpdmUuZXhwb3J0cy5IdHRwc0FnZW50ID0gLypAX19QVVJFX18qLyByZXF1aXJlSHR0cHNfYWdlbnQoKTtcblx0YWdlbnRrZWVwYWxpdmUuZXhwb3J0cy5jb25zdGFudHMgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVDb25zdGFudHMoKTtcblx0cmV0dXJuIGFnZW50a2VlcGFsaXZlLmV4cG9ydHM7XG59XG5cbnZhciBhZ2VudGtlZXBhbGl2ZUV4cG9ydHMgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVBZ2VudGtlZXBhbGl2ZSgpO1xudmFyIEh0dHBLZWVwQWxpdmVBZ2VudCA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhhZ2VudGtlZXBhbGl2ZUV4cG9ydHMpO1xuXG52YXIgZmFzdFN0YWJsZVN0cmluZ2lmeSQxO1xudmFyIGhhc1JlcXVpcmVkRmFzdFN0YWJsZVN0cmluZ2lmeTtcblxuZnVuY3Rpb24gcmVxdWlyZUZhc3RTdGFibGVTdHJpbmdpZnkgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRGYXN0U3RhYmxlU3RyaW5naWZ5KSByZXR1cm4gZmFzdFN0YWJsZVN0cmluZ2lmeSQxO1xuXHRoYXNSZXF1aXJlZEZhc3RTdGFibGVTdHJpbmdpZnkgPSAxO1xuXHR2YXIgb2JqVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXHR2YXIgb2JqS2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uKG9iaikge1xuXHRcdFx0dmFyIGtleXMgPSBbXTtcblx0XHRcdGZvciAodmFyIG5hbWUgaW4gb2JqKSB7XG5cdFx0XHRcdGtleXMucHVzaChuYW1lKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBrZXlzO1xuXHRcdH07XG5cblx0ZnVuY3Rpb24gc3RyaW5naWZ5KHZhbCwgaXNBcnJheVByb3ApIHtcblx0XHR2YXIgaSwgbWF4LCBzdHIsIGtleXMsIGtleSwgcHJvcFZhbCwgdG9TdHI7XG5cdFx0aWYgKHZhbCA9PT0gdHJ1ZSkge1xuXHRcdFx0cmV0dXJuIFwidHJ1ZVwiO1xuXHRcdH1cblx0XHRpZiAodmFsID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuIFwiZmFsc2VcIjtcblx0XHR9XG5cdFx0c3dpdGNoICh0eXBlb2YgdmFsKSB7XG5cdFx0XHRjYXNlIFwib2JqZWN0XCI6XG5cdFx0XHRcdGlmICh2YWwgPT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fSBlbHNlIGlmICh2YWwudG9KU09OICYmIHR5cGVvZiB2YWwudG9KU09OID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5KHZhbC50b0pTT04oKSwgaXNBcnJheVByb3ApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRvU3RyID0gb2JqVG9TdHJpbmcuY2FsbCh2YWwpO1xuXHRcdFx0XHRcdGlmICh0b1N0ciA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG5cdFx0XHRcdFx0XHRzdHIgPSAnWyc7XG5cdFx0XHRcdFx0XHRtYXggPSB2YWwubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRcdGZvcihpID0gMDsgaSA8IG1heDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdHN0ciArPSBzdHJpbmdpZnkodmFsW2ldLCB0cnVlKSArICcsJztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChtYXggPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRzdHIgKz0gc3RyaW5naWZ5KHZhbFtpXSwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gc3RyICsgJ10nO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodG9TdHIgPT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcblx0XHRcdFx0XHRcdC8vIG9ubHkgb2JqZWN0IGlzIGxlZnRcblx0XHRcdFx0XHRcdGtleXMgPSBvYmpLZXlzKHZhbCkuc29ydCgpO1xuXHRcdFx0XHRcdFx0bWF4ID0ga2V5cy5sZW5ndGg7XG5cdFx0XHRcdFx0XHRzdHIgPSBcIlwiO1xuXHRcdFx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdFx0XHR3aGlsZSAoaSA8IG1heCkge1xuXHRcdFx0XHRcdFx0XHRrZXkgPSBrZXlzW2ldO1xuXHRcdFx0XHRcdFx0XHRwcm9wVmFsID0gc3RyaW5naWZ5KHZhbFtrZXldLCBmYWxzZSk7XG5cdFx0XHRcdFx0XHRcdGlmIChwcm9wVmFsICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoc3RyKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdHIgKz0gJywnO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRzdHIgKz0gSlNPTi5zdHJpbmdpZnkoa2V5KSArICc6JyArIHByb3BWYWw7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuICd7JyArIHN0ciArICd9Jztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRjYXNlIFwiZnVuY3Rpb25cIjpcblx0XHRcdGNhc2UgXCJ1bmRlZmluZWRcIjpcblx0XHRcdFx0cmV0dXJuIGlzQXJyYXlQcm9wID8gbnVsbCA6IHVuZGVmaW5lZDtcblx0XHRcdGNhc2UgXCJzdHJpbmdcIjpcblx0XHRcdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbCk7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gaXNGaW5pdGUodmFsKSA/IHZhbCA6IG51bGw7XG5cdFx0fVxuXHR9XG5cblx0ZmFzdFN0YWJsZVN0cmluZ2lmeSQxID0gZnVuY3Rpb24odmFsKSB7XG5cdFx0dmFyIHJldHVyblZhbCA9IHN0cmluZ2lmeSh2YWwsIGZhbHNlKTtcblx0XHRpZiAocmV0dXJuVmFsICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiAnJysgcmV0dXJuVmFsO1xuXHRcdH1cblx0fTtcblx0cmV0dXJuIGZhc3RTdGFibGVTdHJpbmdpZnkkMTtcbn1cblxudmFyIGZhc3RTdGFibGVTdHJpbmdpZnlFeHBvcnRzID0gLypAX19QVVJFX18qLyByZXF1aXJlRmFzdFN0YWJsZVN0cmluZ2lmeSgpO1xudmFyIGZhc3RTdGFibGVTdHJpbmdpZnkgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoZmFzdFN0YWJsZVN0cmluZ2lmeUV4cG9ydHMpO1xuXG5jb25zdCBNSU5JTVVNX1NMT1RfUEVSX0VQT0NIID0gMzI7XG5cbi8vIFJldHVybnMgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBpbiB0aGUgYmluYXJ5IHJlcHJlc2VudGF0aW9uIG9mIHNlbGYuXG5mdW5jdGlvbiB0cmFpbGluZ1plcm9zKG4pIHtcbiAgbGV0IHRyYWlsaW5nWmVyb3MgPSAwO1xuICB3aGlsZSAobiA+IDEpIHtcbiAgICBuIC89IDI7XG4gICAgdHJhaWxpbmdaZXJvcysrO1xuICB9XG4gIHJldHVybiB0cmFpbGluZ1plcm9zO1xufVxuXG4vLyBSZXR1cm5zIHRoZSBzbWFsbGVzdCBwb3dlciBvZiB0d28gZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIG5cbmZ1bmN0aW9uIG5leHRQb3dlck9mVHdvKG4pIHtcbiAgaWYgKG4gPT09IDApIHJldHVybiAxO1xuICBuLS07XG4gIG4gfD0gbiA+PiAxO1xuICBuIHw9IG4gPj4gMjtcbiAgbiB8PSBuID4+IDQ7XG4gIG4gfD0gbiA+PiA4O1xuICBuIHw9IG4gPj4gMTY7XG4gIG4gfD0gbiA+PiAzMjtcbiAgcmV0dXJuIG4gKyAxO1xufVxuXG4vKipcbiAqIEVwb2NoIHNjaGVkdWxlXG4gKiAoc2VlIGh0dHBzOi8vZG9jcy5zb2xhbmEuY29tL3Rlcm1pbm9sb2d5I2Vwb2NoKVxuICogQ2FuIGJlIHJldHJpZXZlZCB3aXRoIHRoZSB7QGxpbmsgQ29ubmVjdGlvbi5nZXRFcG9jaFNjaGVkdWxlfSBtZXRob2RcbiAqL1xuY2xhc3MgRXBvY2hTY2hlZHVsZSB7XG4gIGNvbnN0cnVjdG9yKHNsb3RzUGVyRXBvY2gsIGxlYWRlclNjaGVkdWxlU2xvdE9mZnNldCwgd2FybXVwLCBmaXJzdE5vcm1hbEVwb2NoLCBmaXJzdE5vcm1hbFNsb3QpIHtcbiAgICAvKiogVGhlIG1heGltdW0gbnVtYmVyIG9mIHNsb3RzIGluIGVhY2ggZXBvY2ggKi9cbiAgICB0aGlzLnNsb3RzUGVyRXBvY2ggPSB2b2lkIDA7XG4gICAgLyoqIFRoZSBudW1iZXIgb2Ygc2xvdHMgYmVmb3JlIGJlZ2lubmluZyBvZiBhbiBlcG9jaCB0byBjYWxjdWxhdGUgYSBsZWFkZXIgc2NoZWR1bGUgZm9yIHRoYXQgZXBvY2ggKi9cbiAgICB0aGlzLmxlYWRlclNjaGVkdWxlU2xvdE9mZnNldCA9IHZvaWQgMDtcbiAgICAvKiogSW5kaWNhdGVzIHdoZXRoZXIgZXBvY2hzIHN0YXJ0IHNob3J0IGFuZCBncm93ICovXG4gICAgdGhpcy53YXJtdXAgPSB2b2lkIDA7XG4gICAgLyoqIFRoZSBmaXJzdCBlcG9jaCB3aXRoIGBzbG90c1BlckVwb2NoYCBzbG90cyAqL1xuICAgIHRoaXMuZmlyc3ROb3JtYWxFcG9jaCA9IHZvaWQgMDtcbiAgICAvKiogVGhlIGZpcnN0IHNsb3Qgb2YgYGZpcnN0Tm9ybWFsRXBvY2hgICovXG4gICAgdGhpcy5maXJzdE5vcm1hbFNsb3QgPSB2b2lkIDA7XG4gICAgdGhpcy5zbG90c1BlckVwb2NoID0gc2xvdHNQZXJFcG9jaDtcbiAgICB0aGlzLmxlYWRlclNjaGVkdWxlU2xvdE9mZnNldCA9IGxlYWRlclNjaGVkdWxlU2xvdE9mZnNldDtcbiAgICB0aGlzLndhcm11cCA9IHdhcm11cDtcbiAgICB0aGlzLmZpcnN0Tm9ybWFsRXBvY2ggPSBmaXJzdE5vcm1hbEVwb2NoO1xuICAgIHRoaXMuZmlyc3ROb3JtYWxTbG90ID0gZmlyc3ROb3JtYWxTbG90O1xuICB9XG4gIGdldEVwb2NoKHNsb3QpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRFcG9jaEFuZFNsb3RJbmRleChzbG90KVswXTtcbiAgfVxuICBnZXRFcG9jaEFuZFNsb3RJbmRleChzbG90KSB7XG4gICAgaWYgKHNsb3QgPCB0aGlzLmZpcnN0Tm9ybWFsU2xvdCkge1xuICAgICAgY29uc3QgZXBvY2ggPSB0cmFpbGluZ1plcm9zKG5leHRQb3dlck9mVHdvKHNsb3QgKyBNSU5JTVVNX1NMT1RfUEVSX0VQT0NIICsgMSkpIC0gdHJhaWxpbmdaZXJvcyhNSU5JTVVNX1NMT1RfUEVSX0VQT0NIKSAtIDE7XG4gICAgICBjb25zdCBlcG9jaExlbiA9IHRoaXMuZ2V0U2xvdHNJbkVwb2NoKGVwb2NoKTtcbiAgICAgIGNvbnN0IHNsb3RJbmRleCA9IHNsb3QgLSAoZXBvY2hMZW4gLSBNSU5JTVVNX1NMT1RfUEVSX0VQT0NIKTtcbiAgICAgIHJldHVybiBbZXBvY2gsIHNsb3RJbmRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5vcm1hbFNsb3RJbmRleCA9IHNsb3QgLSB0aGlzLmZpcnN0Tm9ybWFsU2xvdDtcbiAgICAgIGNvbnN0IG5vcm1hbEVwb2NoSW5kZXggPSBNYXRoLmZsb29yKG5vcm1hbFNsb3RJbmRleCAvIHRoaXMuc2xvdHNQZXJFcG9jaCk7XG4gICAgICBjb25zdCBlcG9jaCA9IHRoaXMuZmlyc3ROb3JtYWxFcG9jaCArIG5vcm1hbEVwb2NoSW5kZXg7XG4gICAgICBjb25zdCBzbG90SW5kZXggPSBub3JtYWxTbG90SW5kZXggJSB0aGlzLnNsb3RzUGVyRXBvY2g7XG4gICAgICByZXR1cm4gW2Vwb2NoLCBzbG90SW5kZXhdO1xuICAgIH1cbiAgfVxuICBnZXRGaXJzdFNsb3RJbkVwb2NoKGVwb2NoKSB7XG4gICAgaWYgKGVwb2NoIDw9IHRoaXMuZmlyc3ROb3JtYWxFcG9jaCkge1xuICAgICAgcmV0dXJuIChNYXRoLnBvdygyLCBlcG9jaCkgLSAxKSAqIE1JTklNVU1fU0xPVF9QRVJfRVBPQ0g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoZXBvY2ggLSB0aGlzLmZpcnN0Tm9ybWFsRXBvY2gpICogdGhpcy5zbG90c1BlckVwb2NoICsgdGhpcy5maXJzdE5vcm1hbFNsb3Q7XG4gICAgfVxuICB9XG4gIGdldExhc3RTbG90SW5FcG9jaChlcG9jaCkge1xuICAgIHJldHVybiB0aGlzLmdldEZpcnN0U2xvdEluRXBvY2goZXBvY2gpICsgdGhpcy5nZXRTbG90c0luRXBvY2goZXBvY2gpIC0gMTtcbiAgfVxuICBnZXRTbG90c0luRXBvY2goZXBvY2gpIHtcbiAgICBpZiAoZXBvY2ggPCB0aGlzLmZpcnN0Tm9ybWFsRXBvY2gpIHtcbiAgICAgIHJldHVybiBNYXRoLnBvdygyLCBlcG9jaCArIHRyYWlsaW5nWmVyb3MoTUlOSU1VTV9TTE9UX1BFUl9FUE9DSCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5zbG90c1BlckVwb2NoO1xuICAgIH1cbiAgfVxufVxuXG52YXIgZmV0Y2hJbXBsID0gdHlwZW9mIGdsb2JhbFRoaXMuZmV0Y2ggPT09ICdmdW5jdGlvbicgP1xuLy8gVGhlIEZldGNoIEFQSSBpcyBzdXBwb3J0ZWQgZXhwZXJpbWVudGFsbHkgaW4gTm9kZSAxNy41KyBhbmQgbmF0aXZlbHkgaW4gTm9kZSAxOCsuXG5nbG9iYWxUaGlzLmZldGNoIDpcbi8vIE90aGVyd2lzZSB1c2UgdGhlIHBvbHlmaWxsLlxuYXN5bmMgZnVuY3Rpb24gKGlucHV0LCBpbml0KSB7XG4gIGNvbnN0IHByb2Nlc3NlZElucHV0ID0gdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyAmJiBpbnB1dC5zbGljZSgwLCAyKSA9PT0gJy8vJyA/ICdodHRwczonICsgaW5wdXQgOiBpbnB1dDtcbiAgcmV0dXJuIGF3YWl0IG5vZGVGZXRjaC5kZWZhdWx0KHByb2Nlc3NlZElucHV0LCBpbml0KTtcbn07XG5cbmNsYXNzIFJwY1dlYlNvY2tldENsaWVudCBleHRlbmRzIENvbW1vbkNsaWVudCB7XG4gIGNvbnN0cnVjdG9yKGFkZHJlc3MsIG9wdGlvbnMsIGdlbmVyYXRlX3JlcXVlc3RfaWQpIHtcbiAgICBjb25zdCB3ZWJTb2NrZXRGYWN0b3J5ID0gdXJsID0+IHtcbiAgICAgIGNvbnN0IHJwYyA9IFdlYlNvY2tldCh1cmwsIHtcbiAgICAgICAgYXV0b2Nvbm5lY3Q6IHRydWUsXG4gICAgICAgIG1heF9yZWNvbm5lY3RzOiA1LFxuICAgICAgICByZWNvbm5lY3Q6IHRydWUsXG4gICAgICAgIHJlY29ubmVjdF9pbnRlcnZhbDogMTAwMCxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSk7XG4gICAgICBpZiAoJ3NvY2tldCcgaW4gcnBjKSB7XG4gICAgICAgIHRoaXMudW5kZXJseWluZ1NvY2tldCA9IHJwYy5zb2NrZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnVuZGVybHlpbmdTb2NrZXQgPSBycGM7XG4gICAgICB9XG4gICAgICByZXR1cm4gcnBjO1xuICAgIH07XG4gICAgc3VwZXIod2ViU29ja2V0RmFjdG9yeSwgYWRkcmVzcywgb3B0aW9ucywgZ2VuZXJhdGVfcmVxdWVzdF9pZCk7XG4gICAgdGhpcy51bmRlcmx5aW5nU29ja2V0ID0gdm9pZCAwO1xuICB9XG4gIGNhbGwoLi4uYXJncykge1xuICAgIGNvbnN0IHJlYWR5U3RhdGUgPSB0aGlzLnVuZGVybHlpbmdTb2NrZXQ/LnJlYWR5U3RhdGU7XG4gICAgaWYgKHJlYWR5U3RhdGUgPT09IDEgLyogV2ViU29ja2V0Lk9QRU4gKi8pIHtcbiAgICAgIHJldHVybiBzdXBlci5jYWxsKC4uLmFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdUcmllZCB0byBjYWxsIGEgSlNPTi1SUEMgbWV0aG9kIGAnICsgYXJnc1swXSArICdgIGJ1dCB0aGUgc29ja2V0IHdhcyBub3QgYENPTk5FQ1RJTkdgIG9yIGBPUEVOYCAoYHJlYWR5U3RhdGVgIHdhcyAnICsgcmVhZHlTdGF0ZSArICcpJykpO1xuICB9XG4gIG5vdGlmeSguLi5hcmdzKSB7XG4gICAgY29uc3QgcmVhZHlTdGF0ZSA9IHRoaXMudW5kZXJseWluZ1NvY2tldD8ucmVhZHlTdGF0ZTtcbiAgICBpZiAocmVhZHlTdGF0ZSA9PT0gMSAvKiBXZWJTb2NrZXQuT1BFTiAqLykge1xuICAgICAgcmV0dXJuIHN1cGVyLm5vdGlmeSguLi5hcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignVHJpZWQgdG8gc2VuZCBhIEpTT04tUlBDIG5vdGlmaWNhdGlvbiBgJyArIGFyZ3NbMF0gKyAnYCBidXQgdGhlIHNvY2tldCB3YXMgbm90IGBDT05ORUNUSU5HYCBvciBgT1BFTmAgKGByZWFkeVN0YXRlYCB3YXMgJyArIHJlYWR5U3RhdGUgKyAnKScpKTtcbiAgfVxufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbi8qKlxuICogRGVjb2RlIGFjY291bnQgZGF0YSBidWZmZXIgdXNpbmcgYW4gQWNjb3VudFR5cGVcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBkZWNvZGVEYXRhKHR5cGUsIGRhdGEpIHtcbiAgbGV0IGRlY29kZWQ7XG4gIHRyeSB7XG4gICAgZGVjb2RlZCA9IHR5cGUubGF5b3V0LmRlY29kZShkYXRhKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluc3RydWN0aW9uOyAnICsgZXJyKTtcbiAgfVxuICBpZiAoZGVjb2RlZC50eXBlSW5kZXggIT09IHR5cGUuaW5kZXgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgYWNjb3VudCBkYXRhOyBhY2NvdW50IHR5cGUgbWlzbWF0Y2ggJHtkZWNvZGVkLnR5cGVJbmRleH0gIT0gJHt0eXBlLmluZGV4fWApO1xuICB9XG4gIHJldHVybiBkZWNvZGVkO1xufVxuXG4vLy8gVGhlIHNlcmlhbGl6ZWQgc2l6ZSBvZiBsb29rdXAgdGFibGUgbWV0YWRhdGFcbmNvbnN0IExPT0tVUF9UQUJMRV9NRVRBX1NJWkUgPSA1NjtcbmNsYXNzIEFkZHJlc3NMb29rdXBUYWJsZUFjY291bnQge1xuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgdGhpcy5rZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGF0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmtleSA9IGFyZ3Mua2V5O1xuICAgIHRoaXMuc3RhdGUgPSBhcmdzLnN0YXRlO1xuICB9XG4gIGlzQWN0aXZlKCkge1xuICAgIGNvbnN0IFU2NF9NQVggPSBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZicpO1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmRlYWN0aXZhdGlvblNsb3QgPT09IFU2NF9NQVg7XG4gIH1cbiAgc3RhdGljIGRlc2VyaWFsaXplKGFjY291bnREYXRhKSB7XG4gICAgY29uc3QgbWV0YSA9IGRlY29kZURhdGEoTG9va3VwVGFibGVNZXRhTGF5b3V0LCBhY2NvdW50RGF0YSk7XG4gICAgY29uc3Qgc2VyaWFsaXplZEFkZHJlc3Nlc0xlbiA9IGFjY291bnREYXRhLmxlbmd0aCAtIExPT0tVUF9UQUJMRV9NRVRBX1NJWkU7XG4gICAgYXNzZXJ0KHNlcmlhbGl6ZWRBZGRyZXNzZXNMZW4gPj0gMCwgJ2xvb2t1cCB0YWJsZSBpcyBpbnZhbGlkJyk7XG4gICAgYXNzZXJ0KHNlcmlhbGl6ZWRBZGRyZXNzZXNMZW4gJSAzMiA9PT0gMCwgJ2xvb2t1cCB0YWJsZSBpcyBpbnZhbGlkJyk7XG4gICAgY29uc3QgbnVtU2VyaWFsaXplZEFkZHJlc3NlcyA9IHNlcmlhbGl6ZWRBZGRyZXNzZXNMZW4gLyAzMjtcbiAgICBjb25zdCB7XG4gICAgICBhZGRyZXNzZXNcbiAgICB9ID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnNlcShwdWJsaWNLZXkoKSwgbnVtU2VyaWFsaXplZEFkZHJlc3NlcywgJ2FkZHJlc3NlcycpXSkuZGVjb2RlKGFjY291bnREYXRhLnNsaWNlKExPT0tVUF9UQUJMRV9NRVRBX1NJWkUpKTtcbiAgICByZXR1cm4ge1xuICAgICAgZGVhY3RpdmF0aW9uU2xvdDogbWV0YS5kZWFjdGl2YXRpb25TbG90LFxuICAgICAgbGFzdEV4dGVuZGVkU2xvdDogbWV0YS5sYXN0RXh0ZW5kZWRTbG90LFxuICAgICAgbGFzdEV4dGVuZGVkU2xvdFN0YXJ0SW5kZXg6IG1ldGEubGFzdEV4dGVuZGVkU3RhcnRJbmRleCxcbiAgICAgIGF1dGhvcml0eTogbWV0YS5hdXRob3JpdHkubGVuZ3RoICE9PSAwID8gbmV3IFB1YmxpY0tleShtZXRhLmF1dGhvcml0eVswXSkgOiB1bmRlZmluZWQsXG4gICAgICBhZGRyZXNzZXM6IGFkZHJlc3Nlcy5tYXAoYWRkcmVzcyA9PiBuZXcgUHVibGljS2V5KGFkZHJlc3MpKVxuICAgIH07XG4gIH1cbn1cbmNvbnN0IExvb2t1cFRhYmxlTWV0YUxheW91dCA9IHtcbiAgaW5kZXg6IDEsXG4gIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMigndHlwZUluZGV4JyksIHU2NCgnZGVhY3RpdmF0aW9uU2xvdCcpLCBCdWZmZXJMYXlvdXQubnU2NCgnbGFzdEV4dGVuZGVkU2xvdCcpLCBCdWZmZXJMYXlvdXQudTgoJ2xhc3RFeHRlbmRlZFN0YXJ0SW5kZXgnKSwgQnVmZmVyTGF5b3V0LnU4KCksXG4gIC8vIG9wdGlvblxuICBCdWZmZXJMYXlvdXQuc2VxKHB1YmxpY0tleSgpLCBCdWZmZXJMYXlvdXQub2Zmc2V0KEJ1ZmZlckxheW91dC51OCgpLCAtMSksICdhdXRob3JpdHknKV0pXG59O1xuXG5jb25zdCBVUkxfUkUgPSAvXlteOl0rOlxcL1xcLyhbXjpbXSt8XFxbW15cXF1dK1xcXSkoOlxcZCspPyguKikvaTtcbmZ1bmN0aW9uIG1ha2VXZWJzb2NrZXRVcmwoZW5kcG9pbnQpIHtcbiAgY29uc3QgbWF0Y2hlcyA9IGVuZHBvaW50Lm1hdGNoKFVSTF9SRSk7XG4gIGlmIChtYXRjaGVzID09IG51bGwpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoYEZhaWxlZCB0byB2YWxpZGF0ZSBlbmRwb2ludCBVUkwgXFxgJHtlbmRwb2ludH1cXGBgKTtcbiAgfVxuICBjb25zdCBbXyxcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgaG9zdGlzaCwgcG9ydFdpdGhDb2xvbiwgcmVzdF0gPSBtYXRjaGVzO1xuICBjb25zdCBwcm90b2NvbCA9IGVuZHBvaW50LnN0YXJ0c1dpdGgoJ2h0dHBzOicpID8gJ3dzczonIDogJ3dzOic7XG4gIGNvbnN0IHN0YXJ0UG9ydCA9IHBvcnRXaXRoQ29sb24gPT0gbnVsbCA/IG51bGwgOiBwYXJzZUludChwb3J0V2l0aENvbG9uLnNsaWNlKDEpLCAxMCk7XG4gIGNvbnN0IHdlYnNvY2tldFBvcnQgPVxuICAvLyBPbmx5IHNoaWZ0IHRoZSBwb3J0IGJ5ICsxIGFzIGEgY29udmVudGlvbiBmb3Igd3Mocykgb25seSBpZiBnaXZlbiBlbmRwb2ludFxuICAvLyBpcyBleHBsaWNpdGx5IHNwZWNpZnlpbmcgdGhlIGVuZHBvaW50IHBvcnQgKEhUVFAtYmFzZWQgUlBDKSwgYXNzdW1pbmdcbiAgLy8gd2UncmUgZGlyZWN0bHkgdHJ5aW5nIHRvIGNvbm5lY3QgdG8gYWdhdmUtdmFsaWRhdG9yJ3Mgd3MgbGlzdGVuaW5nIHBvcnQuXG4gIC8vIFdoZW4gdGhlIGVuZHBvaW50IG9taXRzIHRoZSBwb3J0LCB3ZSdyZSBjb25uZWN0aW5nIHRvIHRoZSBwcm90b2NvbFxuICAvLyBkZWZhdWx0IHBvcnRzOiBodHRwKDgwKSBvciBodHRwcyg0NDMpIGFuZCBpdCdzIGFzc3VtZWQgd2UncmUgYmVoaW5kIGEgcmV2ZXJzZVxuICAvLyBwcm94eSB3aGljaCBtYW5hZ2VzIFdlYlNvY2tldCB1cGdyYWRlIGFuZCBiYWNrZW5kIHBvcnQgcmVkaXJlY3Rpb24uXG4gIHN0YXJ0UG9ydCA9PSBudWxsID8gJycgOiBgOiR7c3RhcnRQb3J0ICsgMX1gO1xuICByZXR1cm4gYCR7cHJvdG9jb2x9Ly8ke2hvc3Rpc2h9JHt3ZWJzb2NrZXRQb3J0fSR7cmVzdH1gO1xufVxuXG5jb25zdCBQdWJsaWNLZXlGcm9tU3RyaW5nID0gY29lcmNlKGluc3RhbmNlKFB1YmxpY0tleSksIHN0cmluZygpLCB2YWx1ZSA9PiBuZXcgUHVibGljS2V5KHZhbHVlKSk7XG5jb25zdCBSYXdBY2NvdW50RGF0YVJlc3VsdCA9IHR1cGxlKFtzdHJpbmcoKSwgbGl0ZXJhbCgnYmFzZTY0JyldKTtcbmNvbnN0IEJ1ZmZlckZyb21SYXdBY2NvdW50RGF0YSA9IGNvZXJjZShpbnN0YW5jZShCdWZmZXIpLCBSYXdBY2NvdW50RGF0YVJlc3VsdCwgdmFsdWUgPT4gQnVmZmVyLmZyb20odmFsdWVbMF0sICdiYXNlNjQnKSk7XG5cbi8qKlxuICogQXR0ZW1wdCB0byB1c2UgYSByZWNlbnQgYmxvY2toYXNoIGZvciB1cCB0byAzMCBzZWNvbmRzXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgQkxPQ0tIQVNIX0NBQ0hFX1RJTUVPVVRfTVMgPSAzMCAqIDEwMDA7XG5cbi8qKlxuICogSEFDSy5cbiAqIENvcGllZCBmcm9tIHJwYy13ZWJzb2NrZXRzL2Rpc3QvbGliL2NsaWVudC5cbiAqIE90aGVyd2lzZSwgYHlhcm4gYnVpbGRgIGZhaWxzIHdpdGg6XG4gKiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9zdGV2ZWx1c2NoZXIvYzA1N2VjYTgxZDQ3OWVmNzA1Y2RiNTMxNjJmOTk3MWRcbiAqL1xuXG4vKiogQGludGVybmFsICovXG4vKiogQGludGVybmFsICovXG4vKiogQGludGVybmFsICovXG4vKiogQGludGVybmFsICovXG5cbi8qKiBAaW50ZXJuYWwgKi9cbi8qKlxuICogQGludGVybmFsXG4gKiBFdmVyeSBzdWJzY3JpcHRpb24gY29udGFpbnMgdGhlIGFyZ3MgdXNlZCB0byBvcGVuIHRoZSBzdWJzY3JpcHRpb24gd2l0aFxuICogdGhlIHNlcnZlciwgYW5kIGEgbGlzdCBvZiBjYWxsZXJzIGludGVyZXN0ZWQgaW4gbm90aWZpY2F0aW9ucy5cbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogQSBzdWJzY3JpcHRpb24gbWF5IGJlIGluIHZhcmlvdXMgc3RhdGVzIG9mIGNvbm5lY3RlZG5lc3MuIE9ubHkgd2hlbiBpdCBpc1xuICogZnVsbHkgY29ubmVjdGVkIHdpbGwgaXQgaGF2ZSBhIHNlcnZlciBzdWJzY3JpcHRpb24gaWQgYXNzb2NpYXRlZCB3aXRoIGl0LlxuICogVGhpcyBpZCBjYW4gYmUgcmV0dXJuZWQgdG8gdGhlIHNlcnZlciB0byB1bnN1YnNjcmliZSB0aGUgY2xpZW50IGVudGlyZWx5LlxuICovXG5cbi8qKlxuICogQSB0eXBlIHRoYXQgZW5jYXBzdWxhdGVzIGEgc3Vic2NyaXB0aW9uJ3MgUlBDIG1ldGhvZFxuICogbmFtZXMgYW5kIG5vdGlmaWNhdGlvbiAoY2FsbGJhY2spIHNpZ25hdHVyZS5cbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogVXRpbGl0eSB0eXBlIHRoYXQga2VlcHMgdGFnZ2VkIHVuaW9ucyBpbnRhY3Qgd2hpbGUgb21pdHRpbmcgcHJvcGVydGllcy5cbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogVGhpcyB0eXBlIHJlcHJlc2VudHMgYSBzaW5nbGUgc3Vic2NyaWJhYmxlICd0b3BpYy4nIEl0J3MgbWFkZSB1cCBvZjpcbiAqXG4gKiAtIFRoZSBhcmdzIHVzZWQgdG8gb3BlbiB0aGUgc3Vic2NyaXB0aW9uIHdpdGggdGhlIHNlcnZlcixcbiAqIC0gVGhlIHN0YXRlIG9mIHRoZSBzdWJzY3JpcHRpb24sIGluIHRlcm1zIG9mIGl0cyBjb25uZWN0ZWRuZXNzLCBhbmRcbiAqIC0gVGhlIHNldCBvZiBjYWxsYmFja3MgdG8gY2FsbCB3aGVuIHRoZSBzZXJ2ZXIgcHVibGlzaGVzIG5vdGlmaWNhdGlvbnNcbiAqXG4gKiBUaGlzIHJlY29yZCBnZXRzIGluZGV4ZWQgYnkgYFN1YnNjcmlwdGlvbkNvbmZpZ0hhc2hgIGFuZCBpcyB1c2VkIHRvXG4gKiBzZXQgdXAgc3Vic2NyaXB0aW9ucywgZmFuIG91dCBub3RpZmljYXRpb25zLCBhbmQgdHJhY2sgc3Vic2NyaXB0aW9uIHN0YXRlLlxuICovXG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuLyoqXG4gKiBFeHRyYSBjb250ZXh0dWFsIGluZm9ybWF0aW9uIGZvciBSUEMgcmVzcG9uc2VzXG4gKi9cblxuLyoqXG4gKiBPcHRpb25zIGZvciBzZW5kaW5nIHRyYW5zYWN0aW9uc1xuICovXG5cbi8qKlxuICogT3B0aW9ucyBmb3IgY29uZmlybWluZyB0cmFuc2FjdGlvbnNcbiAqL1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMlxuICovXG5cbi8qKlxuICogT3B0aW9ucyBmb3IgZ2V0U2lnbmF0dXJlc0ZvckFkZHJlc3NcbiAqL1xuXG4vKipcbiAqIFJQQyBSZXNwb25zZSB3aXRoIGV4dHJhIGNvbnRleHR1YWwgaW5mb3JtYXRpb25cbiAqL1xuXG4vKipcbiAqIEEgc3RyYXRlZ3kgZm9yIGNvbmZpcm1pbmcgdHJhbnNhY3Rpb25zIHRoYXQgdXNlcyB0aGUgbGFzdCB2YWxpZFxuICogYmxvY2sgaGVpZ2h0IGZvciBhIGdpdmVuIGJsb2NraGFzaCB0byBjaGVjayBmb3IgdHJhbnNhY3Rpb24gZXhwaXJhdGlvbi5cbiAqL1xuXG4vKipcbiAqIEEgc3RyYXRlZ3kgZm9yIGNvbmZpcm1pbmcgZHVyYWJsZSBub25jZSB0cmFuc2FjdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIHNoYXJlZCBieSBhbGwgdHJhbnNhY3Rpb24gY29uZmlybWF0aW9uIHN0cmF0ZWdpZXNcbiAqL1xuXG4vKipcbiAqIFRoaXMgdHlwZSByZXByZXNlbnRzIGFsbCB0cmFuc2FjdGlvbiBjb25maXJtYXRpb24gc3RyYXRlZ2llc1xuICovXG5cbi8qIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gYXNzZXJ0RW5kcG9pbnRVcmwocHV0YXRpdmVVcmwpIHtcbiAgaWYgKC9eaHR0cHM/Oi8udGVzdChwdXRhdGl2ZVVybCkgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRW5kcG9pbnQgVVJMIG11c3Qgc3RhcnQgd2l0aCBgaHR0cDpgIG9yIGBodHRwczpgLicpO1xuICB9XG4gIHJldHVybiBwdXRhdGl2ZVVybDtcbn1cblxuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZykge1xuICBsZXQgY29tbWl0bWVudDtcbiAgbGV0IGNvbmZpZztcbiAgaWYgKHR5cGVvZiBjb21taXRtZW50T3JDb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgY29tbWl0bWVudCA9IGNvbW1pdG1lbnRPckNvbmZpZztcbiAgfSBlbHNlIGlmIChjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50OiBzcGVjaWZpZWRDb21taXRtZW50LFxuICAgICAgLi4uc3BlY2lmaWVkQ29uZmlnXG4gICAgfSA9IGNvbW1pdG1lbnRPckNvbmZpZztcbiAgICBjb21taXRtZW50ID0gc3BlY2lmaWVkQ29tbWl0bWVudDtcbiAgICBjb25maWcgPSBzcGVjaWZpZWRDb25maWc7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb21taXRtZW50LFxuICAgIGNvbmZpZ1xuICB9O1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBhcHBseURlZmF1bHRNZW1jbXBFbmNvZGluZ1RvRmlsdGVycyhmaWx0ZXJzKSB7XG4gIHJldHVybiBmaWx0ZXJzLm1hcChmaWx0ZXIgPT4gJ21lbWNtcCcgaW4gZmlsdGVyID8ge1xuICAgIC4uLmZpbHRlcixcbiAgICBtZW1jbXA6IHtcbiAgICAgIC4uLmZpbHRlci5tZW1jbXAsXG4gICAgICBlbmNvZGluZzogZmlsdGVyLm1lbWNtcC5lbmNvZGluZyA/PyAnYmFzZTU4J1xuICAgIH1cbiAgfSA6IGZpbHRlcik7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJwY1Jlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIHVuaW9uKFt0eXBlKHtcbiAgICBqc29ucnBjOiBsaXRlcmFsKCcyLjAnKSxcbiAgICBpZDogc3RyaW5nKCksXG4gICAgcmVzdWx0XG4gIH0pLCB0eXBlKHtcbiAgICBqc29ucnBjOiBsaXRlcmFsKCcyLjAnKSxcbiAgICBpZDogc3RyaW5nKCksXG4gICAgZXJyb3I6IHR5cGUoe1xuICAgICAgY29kZTogdW5rbm93bigpLFxuICAgICAgbWVzc2FnZTogc3RyaW5nKCksXG4gICAgICBkYXRhOiBvcHRpb25hbChhbnkoKSlcbiAgICB9KVxuICB9KV0pO1xufVxuY29uc3QgVW5rbm93blJwY1Jlc3VsdCA9IGNyZWF0ZVJwY1Jlc3VsdCh1bmtub3duKCkpO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBqc29uUnBjUmVzdWx0KHNjaGVtYSkge1xuICByZXR1cm4gY29lcmNlKGNyZWF0ZVJwY1Jlc3VsdChzY2hlbWEpLCBVbmtub3duUnBjUmVzdWx0LCB2YWx1ZSA9PiB7XG4gICAgaWYgKCdlcnJvcicgaW4gdmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4udmFsdWUsXG4gICAgICAgIHJlc3VsdDogY3JlYXRlKHZhbHVlLnJlc3VsdCwgc2NoZW1hKVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBqc29uUnBjUmVzdWx0QW5kQ29udGV4dCh2YWx1ZSkge1xuICByZXR1cm4ganNvblJwY1Jlc3VsdCh0eXBlKHtcbiAgICBjb250ZXh0OiB0eXBlKHtcbiAgICAgIHNsb3Q6IG51bWJlcigpXG4gICAgfSksXG4gICAgdmFsdWVcbiAgfSkpO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBub3RpZmljYXRpb25SZXN1bHRBbmRDb250ZXh0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlKHtcbiAgICBjb250ZXh0OiB0eXBlKHtcbiAgICAgIHNsb3Q6IG51bWJlcigpXG4gICAgfSksXG4gICAgdmFsdWVcbiAgfSk7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHZlcnNpb25lZE1lc3NhZ2VGcm9tUmVzcG9uc2UodmVyc2lvbiwgcmVzcG9uc2UpIHtcbiAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2VWMCh7XG4gICAgICBoZWFkZXI6IHJlc3BvbnNlLmhlYWRlcixcbiAgICAgIHN0YXRpY0FjY291bnRLZXlzOiByZXNwb25zZS5hY2NvdW50S2V5cy5tYXAoYWNjb3VudEtleSA9PiBuZXcgUHVibGljS2V5KGFjY291bnRLZXkpKSxcbiAgICAgIHJlY2VudEJsb2NraGFzaDogcmVzcG9uc2UucmVjZW50QmxvY2toYXNoLFxuICAgICAgY29tcGlsZWRJbnN0cnVjdGlvbnM6IHJlc3BvbnNlLmluc3RydWN0aW9ucy5tYXAoaXggPT4gKHtcbiAgICAgICAgcHJvZ3JhbUlkSW5kZXg6IGl4LnByb2dyYW1JZEluZGV4LFxuICAgICAgICBhY2NvdW50S2V5SW5kZXhlczogaXguYWNjb3VudHMsXG4gICAgICAgIGRhdGE6IGJzNTguZGVjb2RlKGl4LmRhdGEpXG4gICAgICB9KSksXG4gICAgICBhZGRyZXNzVGFibGVMb29rdXBzOiByZXNwb25zZS5hZGRyZXNzVGFibGVMb29rdXBzXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBNZXNzYWdlKHJlc3BvbnNlKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsZXZlbCBvZiBjb21taXRtZW50IGRlc2lyZWQgd2hlbiBxdWVyeWluZyBzdGF0ZVxuICogPHByZT5cbiAqICAgJ3Byb2Nlc3NlZCc6IFF1ZXJ5IHRoZSBtb3N0IHJlY2VudCBibG9jayB3aGljaCBoYXMgcmVhY2hlZCAxIGNvbmZpcm1hdGlvbiBieSB0aGUgY29ubmVjdGVkIG5vZGVcbiAqICAgJ2NvbmZpcm1lZCc6IFF1ZXJ5IHRoZSBtb3N0IHJlY2VudCBibG9jayB3aGljaCBoYXMgcmVhY2hlZCAxIGNvbmZpcm1hdGlvbiBieSB0aGUgY2x1c3RlclxuICogICAnZmluYWxpemVkJzogUXVlcnkgdGhlIG1vc3QgcmVjZW50IGJsb2NrIHdoaWNoIGhhcyBiZWVuIGZpbmFsaXplZCBieSB0aGUgY2x1c3RlclxuICogPC9wcmU+XG4gKi9cblxuLy8gRGVwcmVjYXRlZCBhcyBvZiB2MS41LjVcblxuLyoqXG4gKiBBIHN1YnNldCBvZiBDb21taXRtZW50IGxldmVscywgd2hpY2ggYXJlIGF0IGxlYXN0IG9wdGltaXN0aWNhbGx5IGNvbmZpcm1lZFxuICogPHByZT5cbiAqICAgJ2NvbmZpcm1lZCc6IFF1ZXJ5IHRoZSBtb3N0IHJlY2VudCBibG9jayB3aGljaCBoYXMgcmVhY2hlZCAxIGNvbmZpcm1hdGlvbiBieSB0aGUgY2x1c3RlclxuICogICAnZmluYWxpemVkJzogUXVlcnkgdGhlIG1vc3QgcmVjZW50IGJsb2NrIHdoaWNoIGhhcyBiZWVuIGZpbmFsaXplZCBieSB0aGUgY2x1c3RlclxuICogPC9wcmU+XG4gKi9cblxuLyoqXG4gKiBGaWx0ZXIgZm9yIGxhcmdlc3QgYWNjb3VudHMgcXVlcnlcbiAqIDxwcmU+XG4gKiAgICdjaXJjdWxhdGluZyc6ICAgIFJldHVybiB0aGUgbGFyZ2VzdCBhY2NvdW50cyB0aGF0IGFyZSBwYXJ0IG9mIHRoZSBjaXJjdWxhdGluZyBzdXBwbHlcbiAqICAgJ25vbkNpcmN1bGF0aW5nJzogUmV0dXJuIHRoZSBsYXJnZXN0IGFjY291bnRzIHRoYXQgYXJlIG5vdCBwYXJ0IG9mIHRoZSBjaXJjdWxhdGluZyBzdXBwbHlcbiAqIDwvcHJlPlxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRBY2NvdW50SW5mb2AgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0QmFsYW5jZWAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0QmxvY2tgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldEJsb2NrYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRTdGFrZU1pbmltdW1EZWxlZ2F0aW9uYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRCbG9ja0hlaWdodGAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0RXBvY2hJbmZvYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRJbmZsYXRpb25SZXdhcmRgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldExhdGVzdEJsb2NraGFzaGAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgaXNCbG9ja2hhc2hWYWxpZGAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0U2xvdGAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0U2xvdExlYWRlcmAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0VHJhbnNhY3Rpb25gIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldFRyYW5zYWN0aW9uYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRMYXJnZXN0QWNjb3VudHNgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldFN1cHBseWAgcmVxdWVzdCBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBkZXNjcmliaW5nIGEgY2x1c3RlciBub2RlXG4gKi9cblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBkZXNjcmliaW5nIGEgdm90ZSBhY2NvdW50XG4gKi9cblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgY2x1c3RlciB2b3RlIGFjY291bnRzXG4gKi9cblxuLyoqXG4gKiBOZXR3b3JrIEluZmxhdGlvblxuICogKHNlZSBodHRwczovL2RvY3Muc29sYW5hLmNvbS9pbXBsZW1lbnRlZC1wcm9wb3NhbHMvZWRfb3ZlcnZpZXcpXG4gKi9cblxuY29uc3QgR2V0SW5mbGF0aW9uR292ZXJub3JSZXN1bHQgPSB0eXBlKHtcbiAgZm91bmRhdGlvbjogbnVtYmVyKCksXG4gIGZvdW5kYXRpb25UZXJtOiBudW1iZXIoKSxcbiAgaW5pdGlhbDogbnVtYmVyKCksXG4gIHRhcGVyOiBudW1iZXIoKSxcbiAgdGVybWluYWw6IG51bWJlcigpXG59KTtcblxuLyoqXG4gKiBUaGUgaW5mbGF0aW9uIHJld2FyZCBmb3IgYW4gZXBvY2hcbiAqL1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRJbmZsYXRpb25SZXdhcmRcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEluZmxhdGlvblJld2FyZFJlc3VsdCA9IGpzb25ScGNSZXN1bHQoYXJyYXkobnVsbGFibGUodHlwZSh7XG4gIGVwb2NoOiBudW1iZXIoKSxcbiAgZWZmZWN0aXZlU2xvdDogbnVtYmVyKCksXG4gIGFtb3VudDogbnVtYmVyKCksXG4gIHBvc3RCYWxhbmNlOiBudW1iZXIoKSxcbiAgY29tbWlzc2lvbjogb3B0aW9uYWwobnVsbGFibGUobnVtYmVyKCkpKVxufSkpKSk7XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNSZXN1bHQgPSBhcnJheSh0eXBlKHtcbiAgc2xvdDogbnVtYmVyKCksXG4gIHByaW9yaXRpemF0aW9uRmVlOiBudW1iZXIoKVxufSkpO1xuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0SW5mbGF0aW9uUmF0ZVwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0SW5mbGF0aW9uUmF0ZVJlc3VsdCA9IHR5cGUoe1xuICB0b3RhbDogbnVtYmVyKCksXG4gIHZhbGlkYXRvcjogbnVtYmVyKCksXG4gIGZvdW5kYXRpb246IG51bWJlcigpLFxuICBlcG9jaDogbnVtYmVyKClcbn0pO1xuXG4vKipcbiAqIEluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IGVwb2NoXG4gKi9cblxuY29uc3QgR2V0RXBvY2hJbmZvUmVzdWx0ID0gdHlwZSh7XG4gIGVwb2NoOiBudW1iZXIoKSxcbiAgc2xvdEluZGV4OiBudW1iZXIoKSxcbiAgc2xvdHNJbkVwb2NoOiBudW1iZXIoKSxcbiAgYWJzb2x1dGVTbG90OiBudW1iZXIoKSxcbiAgYmxvY2tIZWlnaHQ6IG9wdGlvbmFsKG51bWJlcigpKSxcbiAgdHJhbnNhY3Rpb25Db3VudDogb3B0aW9uYWwobnVtYmVyKCkpXG59KTtcbmNvbnN0IEdldEVwb2NoU2NoZWR1bGVSZXN1bHQgPSB0eXBlKHtcbiAgc2xvdHNQZXJFcG9jaDogbnVtYmVyKCksXG4gIGxlYWRlclNjaGVkdWxlU2xvdE9mZnNldDogbnVtYmVyKCksXG4gIHdhcm11cDogYm9vbGVhbigpLFxuICBmaXJzdE5vcm1hbEVwb2NoOiBudW1iZXIoKSxcbiAgZmlyc3ROb3JtYWxTbG90OiBudW1iZXIoKVxufSk7XG5cbi8qKlxuICogTGVhZGVyIHNjaGVkdWxlXG4gKiAoc2VlIGh0dHBzOi8vZG9jcy5zb2xhbmEuY29tL3Rlcm1pbm9sb2d5I2xlYWRlci1zY2hlZHVsZSlcbiAqL1xuXG5jb25zdCBHZXRMZWFkZXJTY2hlZHVsZVJlc3VsdCA9IHJlY29yZChzdHJpbmcoKSwgYXJyYXkobnVtYmVyKCkpKTtcblxuLyoqXG4gKiBUcmFuc2FjdGlvbiBlcnJvciBvciBudWxsXG4gKi9cbmNvbnN0IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHQgPSBudWxsYWJsZSh1bmlvbihbdHlwZSh7fSksIHN0cmluZygpXSkpO1xuXG4vKipcbiAqIFNpZ25hdHVyZSBzdGF0dXMgZm9yIGEgdHJhbnNhY3Rpb25cbiAqL1xuY29uc3QgU2lnbmF0dXJlU3RhdHVzUmVzdWx0ID0gdHlwZSh7XG4gIGVycjogVHJhbnNhY3Rpb25FcnJvclJlc3VsdFxufSk7XG5cbi8qKlxuICogVHJhbnNhY3Rpb24gc2lnbmF0dXJlIHJlY2VpdmVkIG5vdGlmaWNhdGlvblxuICovXG5jb25zdCBTaWduYXR1cmVSZWNlaXZlZFJlc3VsdCA9IGxpdGVyYWwoJ3JlY2VpdmVkU2lnbmF0dXJlJyk7XG5cbi8qKlxuICogVmVyc2lvbiBpbmZvIGZvciBhIG5vZGVcbiAqL1xuXG5jb25zdCBWZXJzaW9uUmVzdWx0ID0gdHlwZSh7XG4gICdzb2xhbmEtY29yZSc6IHN0cmluZygpLFxuICAnZmVhdHVyZS1zZXQnOiBvcHRpb25hbChudW1iZXIoKSlcbn0pO1xuY29uc3QgUGFyc2VkSW5zdHJ1Y3Rpb25TdHJ1Y3QgPSB0eXBlKHtcbiAgcHJvZ3JhbTogc3RyaW5nKCksXG4gIHByb2dyYW1JZDogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgcGFyc2VkOiB1bmtub3duKClcbn0pO1xuY29uc3QgUGFydGlhbGx5RGVjb2RlZEluc3RydWN0aW9uU3RydWN0ID0gdHlwZSh7XG4gIHByb2dyYW1JZDogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgYWNjb3VudHM6IGFycmF5KFB1YmxpY0tleUZyb21TdHJpbmcpLFxuICBkYXRhOiBzdHJpbmcoKVxufSk7XG5jb25zdCBTaW11bGF0ZWRUcmFuc2FjdGlvblJlc3BvbnNlU3RydWN0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQodHlwZSh7XG4gIGVycjogbnVsbGFibGUodW5pb24oW3R5cGUoe30pLCBzdHJpbmcoKV0pKSxcbiAgbG9nczogbnVsbGFibGUoYXJyYXkoc3RyaW5nKCkpKSxcbiAgYWNjb3VudHM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KG51bGxhYmxlKHR5cGUoe1xuICAgIGV4ZWN1dGFibGU6IGJvb2xlYW4oKSxcbiAgICBvd25lcjogc3RyaW5nKCksXG4gICAgbGFtcG9ydHM6IG51bWJlcigpLFxuICAgIGRhdGE6IGFycmF5KHN0cmluZygpKSxcbiAgICByZW50RXBvY2g6IG9wdGlvbmFsKG51bWJlcigpKVxuICB9KSkpKSksXG4gIHVuaXRzQ29uc3VtZWQ6IG9wdGlvbmFsKG51bWJlcigpKSxcbiAgcmV0dXJuRGF0YTogb3B0aW9uYWwobnVsbGFibGUodHlwZSh7XG4gICAgcHJvZ3JhbUlkOiBzdHJpbmcoKSxcbiAgICBkYXRhOiB0dXBsZShbc3RyaW5nKCksIGxpdGVyYWwoJ2Jhc2U2NCcpXSlcbiAgfSkpKSxcbiAgaW5uZXJJbnN0cnVjdGlvbnM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KHR5cGUoe1xuICAgIGluZGV4OiBudW1iZXIoKSxcbiAgICBpbnN0cnVjdGlvbnM6IGFycmF5KHVuaW9uKFtQYXJzZWRJbnN0cnVjdGlvblN0cnVjdCwgUGFydGlhbGx5RGVjb2RlZEluc3RydWN0aW9uU3RydWN0XSkpXG4gIH0pKSkpXG59KSk7XG5cbi8qKlxuICogTWV0YWRhdGEgZm9yIGEgcGFyc2VkIGNvbmZpcm1lZCB0cmFuc2FjdGlvbiBvbiB0aGUgbGVkZ2VyXG4gKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuOC4wLiBQbGVhc2UgdXNlIHtAbGluayBQYXJzZWRUcmFuc2FjdGlvbk1ldGF9IGluc3RlYWQuXG4gKi9cblxuLyoqXG4gKiBDb2xsZWN0aW9uIG9mIGFkZHJlc3NlcyBsb2FkZWQgYnkgYSB0cmFuc2FjdGlvbiB1c2luZyBhZGRyZXNzIHRhYmxlIGxvb2t1cHNcbiAqL1xuXG4vKipcbiAqIE1ldGFkYXRhIGZvciBhIHBhcnNlZCB0cmFuc2FjdGlvbiBvbiB0aGUgbGVkZ2VyXG4gKi9cblxuLyoqXG4gKiBNZXRhZGF0YSBmb3IgYSBjb25maXJtZWQgdHJhbnNhY3Rpb24gb24gdGhlIGxlZGdlclxuICovXG5cbi8qKlxuICogQSBwcm9jZXNzZWQgdHJhbnNhY3Rpb24gZnJvbSB0aGUgUlBDIEFQSVxuICovXG5cbi8qKlxuICogQSBwcm9jZXNzZWQgdHJhbnNhY3Rpb24gZnJvbSB0aGUgUlBDIEFQSVxuICovXG5cbi8qKlxuICogQSBwcm9jZXNzZWQgdHJhbnNhY3Rpb24gbWVzc2FnZSBmcm9tIHRoZSBSUEMgQVBJXG4gKi9cblxuLyoqXG4gKiBBIGNvbmZpcm1lZCB0cmFuc2FjdGlvbiBvbiB0aGUgbGVkZ2VyXG4gKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuOC4wLlxuICovXG5cbi8qKlxuICogQSBwYXJ0aWFsbHkgZGVjb2RlZCB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvblxuICovXG5cbi8qKlxuICogQSBwYXJzZWQgdHJhbnNhY3Rpb24gbWVzc2FnZSBhY2NvdW50XG4gKi9cblxuLyoqXG4gKiBBIHBhcnNlZCB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvblxuICovXG5cbi8qKlxuICogQSBwYXJzZWQgYWRkcmVzcyB0YWJsZSBsb29rdXBcbiAqL1xuXG4vKipcbiAqIEEgcGFyc2VkIHRyYW5zYWN0aW9uIG1lc3NhZ2VcbiAqL1xuXG4vKipcbiAqIEEgcGFyc2VkIHRyYW5zYWN0aW9uXG4gKi9cblxuLyoqXG4gKiBBIHBhcnNlZCBhbmQgY29uZmlybWVkIHRyYW5zYWN0aW9uIG9uIHRoZSBsZWRnZXJcbiAqXG4gKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS44LjAuIFBsZWFzZSB1c2Uge0BsaW5rIFBhcnNlZFRyYW5zYWN0aW9uV2l0aE1ldGF9IGluc3RlYWQuXG4gKi9cblxuLyoqXG4gKiBBIHBhcnNlZCB0cmFuc2FjdGlvbiBvbiB0aGUgbGVkZ2VyIHdpdGggbWV0YVxuICovXG5cbi8qKlxuICogQSBwcm9jZXNzZWQgYmxvY2sgZmV0Y2hlZCBmcm9tIHRoZSBSUEMgQVBJXG4gKi9cblxuLyoqXG4gKiBBIHByb2Nlc3NlZCBibG9jayBmZXRjaGVkIGZyb20gdGhlIFJQQyBBUEkgd2hlcmUgdGhlIGB0cmFuc2FjdGlvbkRldGFpbHNgIG1vZGUgaXMgYGFjY291bnRzYFxuICovXG5cbi8qKlxuICogQSBwcm9jZXNzZWQgYmxvY2sgZmV0Y2hlZCBmcm9tIHRoZSBSUEMgQVBJIHdoZXJlIHRoZSBgdHJhbnNhY3Rpb25EZXRhaWxzYCBtb2RlIGlzIGBub25lYFxuICovXG5cbi8qKlxuICogQSBibG9jayB3aXRoIHBhcnNlZCB0cmFuc2FjdGlvbnNcbiAqL1xuXG4vKipcbiAqIEEgYmxvY2sgd2l0aCBwYXJzZWQgdHJhbnNhY3Rpb25zIHdoZXJlIHRoZSBgdHJhbnNhY3Rpb25EZXRhaWxzYCBtb2RlIGlzIGBhY2NvdW50c2BcbiAqL1xuXG4vKipcbiAqIEEgYmxvY2sgd2l0aCBwYXJzZWQgdHJhbnNhY3Rpb25zIHdoZXJlIHRoZSBgdHJhbnNhY3Rpb25EZXRhaWxzYCBtb2RlIGlzIGBub25lYFxuICovXG5cbi8qKlxuICogQSBwcm9jZXNzZWQgYmxvY2sgZmV0Y2hlZCBmcm9tIHRoZSBSUEMgQVBJXG4gKi9cblxuLyoqXG4gKiBBIHByb2Nlc3NlZCBibG9jayBmZXRjaGVkIGZyb20gdGhlIFJQQyBBUEkgd2hlcmUgdGhlIGB0cmFuc2FjdGlvbkRldGFpbHNgIG1vZGUgaXMgYGFjY291bnRzYFxuICovXG5cbi8qKlxuICogQSBwcm9jZXNzZWQgYmxvY2sgZmV0Y2hlZCBmcm9tIHRoZSBSUEMgQVBJIHdoZXJlIHRoZSBgdHJhbnNhY3Rpb25EZXRhaWxzYCBtb2RlIGlzIGBub25lYFxuICovXG5cbi8qKlxuICogQSBjb25maXJtZWQgYmxvY2sgb24gdGhlIGxlZGdlclxuICpcbiAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjguMC5cbiAqL1xuXG4vKipcbiAqIEEgQmxvY2sgb24gdGhlIGxlZGdlciB3aXRoIHNpZ25hdHVyZXMgb25seVxuICovXG5cbi8qKlxuICogcmVjZW50IGJsb2NrIHByb2R1Y3Rpb24gaW5mb3JtYXRpb25cbiAqL1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRCbG9ja1Byb2R1Y3Rpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEJsb2NrUHJvZHVjdGlvblJlc3BvbnNlU3RydWN0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQodHlwZSh7XG4gIGJ5SWRlbnRpdHk6IHJlY29yZChzdHJpbmcoKSwgYXJyYXkobnVtYmVyKCkpKSxcbiAgcmFuZ2U6IHR5cGUoe1xuICAgIGZpcnN0U2xvdDogbnVtYmVyKCksXG4gICAgbGFzdFNsb3Q6IG51bWJlcigpXG4gIH0pXG59KSk7XG5cbi8qKlxuICogQSBwZXJmb3JtYW5jZSBzYW1wbGVcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVScGNDbGllbnQodXJsLCBodHRwSGVhZGVycywgY3VzdG9tRmV0Y2gsIGZldGNoTWlkZGxld2FyZSwgZGlzYWJsZVJldHJ5T25SYXRlTGltaXQsIGh0dHBBZ2VudCkge1xuICBjb25zdCBmZXRjaCA9IGN1c3RvbUZldGNoID8gY3VzdG9tRmV0Y2ggOiBmZXRjaEltcGw7XG4gIGxldCBhZ2VudDtcbiAge1xuICAgIGlmIChodHRwQWdlbnQgPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICBjb25zdCBhZ2VudE9wdGlvbnMgPSB7XG4gICAgICAgICAgLy8gT25lIHNlY29uZCBmZXdlciB0aGFuIHRoZSBTb2xhbmEgUlBDJ3Mga2VlcGFsaXZlIHRpbWVvdXQuXG4gICAgICAgICAgLy8gUmVhZCBtb3JlOiBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2lzc3Vlcy8yNzg1OSNpc3N1ZWNvbW1lbnQtMTM0MDA5Nzg4OVxuICAgICAgICAgIGZyZWVTb2NrZXRUaW1lb3V0OiAxOTAwMCxcbiAgICAgICAgICBrZWVwQWxpdmU6IHRydWUsXG4gICAgICAgICAgbWF4U29ja2V0czogMjVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHVybC5zdGFydHNXaXRoKCdodHRwczonKSkge1xuICAgICAgICAgIGFnZW50ID0gbmV3IGFnZW50a2VlcGFsaXZlRXhwb3J0cy5IdHRwc0FnZW50KGFnZW50T3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWdlbnQgPSBuZXcgSHR0cEtlZXBBbGl2ZUFnZW50KGFnZW50T3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGh0dHBBZ2VudCAhPT0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgaXNIdHRwcyA9IHVybC5zdGFydHNXaXRoKCdodHRwczonKTtcbiAgICAgICAgaWYgKGlzSHR0cHMgJiYgIShodHRwQWdlbnQgaW5zdGFuY2VvZiBBZ2VudCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBlbmRwb2ludCBgJyArIHVybCArICdgIGNhbiBvbmx5IGJlIHBhaXJlZCB3aXRoIGFuIGBodHRwcy5BZ2VudGAuIFlvdSBoYXZlLCBpbnN0ZWFkLCBzdXBwbGllZCBhbiAnICsgJ2BodHRwLkFnZW50YCB0aHJvdWdoIGBodHRwQWdlbnRgLicpO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc0h0dHBzICYmIGh0dHBBZ2VudCBpbnN0YW5jZW9mIEFnZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZW5kcG9pbnQgYCcgKyB1cmwgKyAnYCBjYW4gb25seSBiZSBwYWlyZWQgd2l0aCBhbiBgaHR0cC5BZ2VudGAuIFlvdSBoYXZlLCBpbnN0ZWFkLCBzdXBwbGllZCBhbiAnICsgJ2BodHRwcy5BZ2VudGAgdGhyb3VnaCBgaHR0cEFnZW50YC4nKTtcbiAgICAgICAgfVxuICAgICAgICBhZ2VudCA9IGh0dHBBZ2VudDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IGZldGNoV2l0aE1pZGRsZXdhcmU7XG4gIGlmIChmZXRjaE1pZGRsZXdhcmUpIHtcbiAgICBmZXRjaFdpdGhNaWRkbGV3YXJlID0gYXN5bmMgKGluZm8sIGluaXQpID0+IHtcbiAgICAgIGNvbnN0IG1vZGlmaWVkRmV0Y2hBcmdzID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZldGNoTWlkZGxld2FyZShpbmZvLCBpbml0LCAobW9kaWZpZWRJbmZvLCBtb2RpZmllZEluaXQpID0+IHJlc29sdmUoW21vZGlmaWVkSW5mbywgbW9kaWZpZWRJbml0XSkpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGF3YWl0IGZldGNoKC4uLm1vZGlmaWVkRmV0Y2hBcmdzKTtcbiAgICB9O1xuICB9XG4gIGNvbnN0IGNsaWVudEJyb3dzZXIgPSBuZXcgUnBjQ2xpZW50KGFzeW5jIChyZXF1ZXN0LCBjYWxsYmFjaykgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGJvZHk6IHJlcXVlc3QsXG4gICAgICBhZ2VudCxcbiAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICB9LCBodHRwSGVhZGVycyB8fCB7fSwgQ09NTU9OX0hUVFBfSEVBREVSUylcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICBsZXQgdG9vX21hbnlfcmVxdWVzdHNfcmV0cmllcyA9IDU7XG4gICAgICBsZXQgcmVzO1xuICAgICAgbGV0IHdhaXRUaW1lID0gNTAwO1xuICAgICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoZmV0Y2hXaXRoTWlkZGxld2FyZSkge1xuICAgICAgICAgIHJlcyA9IGF3YWl0IGZldGNoV2l0aE1pZGRsZXdhcmUodXJsLCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXMuc3RhdHVzICE9PSA0MjkgLyogVG9vIG1hbnkgcmVxdWVzdHMgKi8pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlzYWJsZVJldHJ5T25SYXRlTGltaXQgPT09IHRydWUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0b29fbWFueV9yZXF1ZXN0c19yZXRyaWVzIC09IDE7XG4gICAgICAgIGlmICh0b29fbWFueV9yZXF1ZXN0c19yZXRyaWVzID09PSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5lcnJvcihgU2VydmVyIHJlc3BvbmRlZCB3aXRoICR7cmVzLnN0YXR1c30gJHtyZXMuc3RhdHVzVGV4dH0uICBSZXRyeWluZyBhZnRlciAke3dhaXRUaW1lfW1zIGRlbGF5Li4uYCk7XG4gICAgICAgIGF3YWl0IHNsZWVwKHdhaXRUaW1lKTtcbiAgICAgICAgd2FpdFRpbWUgKj0gMjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgaWYgKHJlcy5vaykge1xuICAgICAgICBjYWxsYmFjayhudWxsLCB0ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihgJHtyZXMuc3RhdHVzfSAke3Jlcy5zdGF0dXNUZXh0fTogJHt0ZXh0fWApKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikgY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gIH0sIHt9KTtcbiAgcmV0dXJuIGNsaWVudEJyb3dzZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVScGNSZXF1ZXN0KGNsaWVudCkge1xuICByZXR1cm4gKG1ldGhvZCwgYXJncykgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjbGllbnQucmVxdWVzdChtZXRob2QsIGFyZ3MsIChlcnIsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJwY0JhdGNoUmVxdWVzdChjbGllbnQpIHtcbiAgcmV0dXJuIHJlcXVlc3RzID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgLy8gRG8gbm90aGluZyBpZiByZXF1ZXN0cyBpcyBlbXB0eVxuICAgICAgaWYgKHJlcXVlc3RzLmxlbmd0aCA9PT0gMCkgcmVzb2x2ZShbXSk7XG4gICAgICBjb25zdCBiYXRjaCA9IHJlcXVlc3RzLm1hcChwYXJhbXMgPT4ge1xuICAgICAgICByZXR1cm4gY2xpZW50LnJlcXVlc3QocGFyYW1zLm1ldGhvZE5hbWUsIHBhcmFtcy5hcmdzKTtcbiAgICAgIH0pO1xuICAgICAgY2xpZW50LnJlcXVlc3QoYmF0Y2gsIChlcnIsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn1cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0SW5mbGF0aW9uR292ZXJub3JcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEluZmxhdGlvbkdvdmVybm9yUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChHZXRJbmZsYXRpb25Hb3Zlcm5vclJlc3VsdCk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEluZmxhdGlvblJhdGVcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEluZmxhdGlvblJhdGVScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KEdldEluZmxhdGlvblJhdGVSZXN1bHQpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoR2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzUmVzdWx0KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0RXBvY2hJbmZvXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRFcG9jaEluZm9ScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KEdldEVwb2NoSW5mb1Jlc3VsdCk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEVwb2NoU2NoZWR1bGVcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEVwb2NoU2NoZWR1bGVScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KEdldEVwb2NoU2NoZWR1bGVSZXN1bHQpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRMZWFkZXJTY2hlZHVsZVwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0TGVhZGVyU2NoZWR1bGVScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KEdldExlYWRlclNjaGVkdWxlUmVzdWx0KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwibWluaW11bUxlZGdlclNsb3RcIiBhbmQgXCJnZXRGaXJzdEF2YWlsYWJsZUJsb2NrXCIgbWVzc2FnZXNcbiAqL1xuY29uc3QgU2xvdFJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVtYmVyKCkpO1xuXG4vKipcbiAqIFN1cHBseVxuICovXG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFN1cHBseVwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0U3VwcGx5UnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQodHlwZSh7XG4gIHRvdGFsOiBudW1iZXIoKSxcbiAgY2lyY3VsYXRpbmc6IG51bWJlcigpLFxuICBub25DaXJjdWxhdGluZzogbnVtYmVyKCksXG4gIG5vbkNpcmN1bGF0aW5nQWNjb3VudHM6IGFycmF5KFB1YmxpY0tleUZyb21TdHJpbmcpXG59KSk7XG5cbi8qKlxuICogVG9rZW4gYW1vdW50IG9iamVjdCB3aGljaCByZXR1cm5zIGEgdG9rZW4gYW1vdW50IGluIGRpZmZlcmVudCBmb3JtYXRzXG4gKiBmb3IgdmFyaW91cyBjbGllbnQgdXNlIGNhc2VzLlxuICovXG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgc3RydWN0dXJlIGZvciB0b2tlbiBhbW91bnRzXG4gKi9cbmNvbnN0IFRva2VuQW1vdW50UmVzdWx0ID0gdHlwZSh7XG4gIGFtb3VudDogc3RyaW5nKCksXG4gIHVpQW1vdW50OiBudWxsYWJsZShudW1iZXIoKSksXG4gIGRlY2ltYWxzOiBudW1iZXIoKSxcbiAgdWlBbW91bnRTdHJpbmc6IG9wdGlvbmFsKHN0cmluZygpKVxufSk7XG5cbi8qKlxuICogVG9rZW4gYWRkcmVzcyBhbmQgYmFsYW5jZS5cbiAqL1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRUb2tlbkxhcmdlc3RBY2NvdW50c1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0VG9rZW5MYXJnZXN0QWNjb3VudHNSZXN1bHQgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChhcnJheSh0eXBlKHtcbiAgYWRkcmVzczogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgYW1vdW50OiBzdHJpbmcoKSxcbiAgdWlBbW91bnQ6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgZGVjaW1hbHM6IG51bWJlcigpLFxuICB1aUFtb3VudFN0cmluZzogb3B0aW9uYWwoc3RyaW5nKCkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRUb2tlbkFjY291bnRzQnlPd25lclwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0VG9rZW5BY2NvdW50c0J5T3duZXIgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChhcnJheSh0eXBlKHtcbiAgcHVia2V5OiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBhY2NvdW50OiB0eXBlKHtcbiAgICBleGVjdXRhYmxlOiBib29sZWFuKCksXG4gICAgb3duZXI6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gICAgbGFtcG9ydHM6IG51bWJlcigpLFxuICAgIGRhdGE6IEJ1ZmZlckZyb21SYXdBY2NvdW50RGF0YSxcbiAgICByZW50RXBvY2g6IG51bWJlcigpXG4gIH0pXG59KSkpO1xuY29uc3QgUGFyc2VkQWNjb3VudERhdGFSZXN1bHQgPSB0eXBlKHtcbiAgcHJvZ3JhbTogc3RyaW5nKCksXG4gIHBhcnNlZDogdW5rbm93bigpLFxuICBzcGFjZTogbnVtYmVyKClcbn0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRUb2tlbkFjY291bnRzQnlPd25lclwiIG1lc3NhZ2Ugd2l0aCBwYXJzZWQgZGF0YVxuICovXG5jb25zdCBHZXRQYXJzZWRUb2tlbkFjY291bnRzQnlPd25lciA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KGFycmF5KHR5cGUoe1xuICBwdWJrZXk6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGFjY291bnQ6IHR5cGUoe1xuICAgIGV4ZWN1dGFibGU6IGJvb2xlYW4oKSxcbiAgICBvd25lcjogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgICBsYW1wb3J0czogbnVtYmVyKCksXG4gICAgZGF0YTogUGFyc2VkQWNjb3VudERhdGFSZXN1bHQsXG4gICAgcmVudEVwb2NoOiBudW1iZXIoKVxuICB9KVxufSkpKTtcblxuLyoqXG4gKiBQYWlyIG9mIGFuIGFjY291bnQgYWRkcmVzcyBhbmQgaXRzIGJhbGFuY2VcbiAqL1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRMYXJnZXN0QWNjb3VudHNcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldExhcmdlc3RBY2NvdW50c1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KGFycmF5KHR5cGUoe1xuICBsYW1wb3J0czogbnVtYmVyKCksXG4gIGFkZHJlc3M6IFB1YmxpY0tleUZyb21TdHJpbmdcbn0pKSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IEFjY291bnRJbmZvUmVzdWx0ID0gdHlwZSh7XG4gIGV4ZWN1dGFibGU6IGJvb2xlYW4oKSxcbiAgb3duZXI6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGxhbXBvcnRzOiBudW1iZXIoKSxcbiAgZGF0YTogQnVmZmVyRnJvbVJhd0FjY291bnREYXRhLFxuICByZW50RXBvY2g6IG51bWJlcigpXG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgS2V5ZWRBY2NvdW50SW5mb1Jlc3VsdCA9IHR5cGUoe1xuICBwdWJrZXk6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGFjY291bnQ6IEFjY291bnRJbmZvUmVzdWx0XG59KTtcbmNvbnN0IFBhcnNlZE9yUmF3QWNjb3VudERhdGEgPSBjb2VyY2UodW5pb24oW2luc3RhbmNlKEJ1ZmZlciksIFBhcnNlZEFjY291bnREYXRhUmVzdWx0XSksIHVuaW9uKFtSYXdBY2NvdW50RGF0YVJlc3VsdCwgUGFyc2VkQWNjb3VudERhdGFSZXN1bHRdKSwgdmFsdWUgPT4ge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gY3JlYXRlKHZhbHVlLCBCdWZmZXJGcm9tUmF3QWNjb3VudERhdGEpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFBhcnNlZEFjY291bnRJbmZvUmVzdWx0ID0gdHlwZSh7XG4gIGV4ZWN1dGFibGU6IGJvb2xlYW4oKSxcbiAgb3duZXI6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGxhbXBvcnRzOiBudW1iZXIoKSxcbiAgZGF0YTogUGFyc2VkT3JSYXdBY2NvdW50RGF0YSxcbiAgcmVudEVwb2NoOiBudW1iZXIoKVxufSk7XG5jb25zdCBLZXllZFBhcnNlZEFjY291bnRJbmZvUmVzdWx0ID0gdHlwZSh7XG4gIHB1YmtleTogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgYWNjb3VudDogUGFyc2VkQWNjb3VudEluZm9SZXN1bHRcbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBTdGFrZUFjdGl2YXRpb25SZXN1bHQgPSB0eXBlKHtcbiAgc3RhdGU6IHVuaW9uKFtsaXRlcmFsKCdhY3RpdmUnKSwgbGl0ZXJhbCgnaW5hY3RpdmUnKSwgbGl0ZXJhbCgnYWN0aXZhdGluZycpLCBsaXRlcmFsKCdkZWFjdGl2YXRpbmcnKV0pLFxuICBhY3RpdmU6IG51bWJlcigpLFxuICBpbmFjdGl2ZTogbnVtYmVyKClcbn0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczJcIiBtZXNzYWdlXG4gKi9cblxuY29uc3QgR2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChhcnJheSh0eXBlKHtcbiAgc2lnbmF0dXJlOiBzdHJpbmcoKSxcbiAgc2xvdDogbnVtYmVyKCksXG4gIGVycjogVHJhbnNhY3Rpb25FcnJvclJlc3VsdCxcbiAgbWVtbzogbnVsbGFibGUoc3RyaW5nKCkpLFxuICBibG9ja1RpbWU6IG9wdGlvbmFsKG51bGxhYmxlKG51bWJlcigpKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFNpZ25hdHVyZXNGb3JBZGRyZXNzXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRTaWduYXR1cmVzRm9yQWRkcmVzc1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoYXJyYXkodHlwZSh7XG4gIHNpZ25hdHVyZTogc3RyaW5nKCksXG4gIHNsb3Q6IG51bWJlcigpLFxuICBlcnI6IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHQsXG4gIG1lbW86IG51bGxhYmxlKHN0cmluZygpKSxcbiAgYmxvY2tUaW1lOiBvcHRpb25hbChudWxsYWJsZShudW1iZXIoKSkpXG59KSkpO1xuXG4vKioqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiYWNjb3VudE5vdGlmaWNhdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgQWNjb3VudE5vdGlmaWNhdGlvblJlc3VsdCA9IHR5cGUoe1xuICBzdWJzY3JpcHRpb246IG51bWJlcigpLFxuICByZXN1bHQ6IG5vdGlmaWNhdGlvblJlc3VsdEFuZENvbnRleHQoQWNjb3VudEluZm9SZXN1bHQpXG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgUHJvZ3JhbUFjY291bnRJbmZvUmVzdWx0ID0gdHlwZSh7XG4gIHB1YmtleTogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgYWNjb3VudDogQWNjb3VudEluZm9SZXN1bHRcbn0pO1xuXG4vKioqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwicHJvZ3JhbU5vdGlmaWNhdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgUHJvZ3JhbUFjY291bnROb3RpZmljYXRpb25SZXN1bHQgPSB0eXBlKHtcbiAgc3Vic2NyaXB0aW9uOiBudW1iZXIoKSxcbiAgcmVzdWx0OiBub3RpZmljYXRpb25SZXN1bHRBbmRDb250ZXh0KFByb2dyYW1BY2NvdW50SW5mb1Jlc3VsdClcbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBTbG90SW5mb1Jlc3VsdCA9IHR5cGUoe1xuICBwYXJlbnQ6IG51bWJlcigpLFxuICBzbG90OiBudW1iZXIoKSxcbiAgcm9vdDogbnVtYmVyKClcbn0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJzbG90Tm90aWZpY2F0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBTbG90Tm90aWZpY2F0aW9uUmVzdWx0ID0gdHlwZSh7XG4gIHN1YnNjcmlwdGlvbjogbnVtYmVyKCksXG4gIHJlc3VsdDogU2xvdEluZm9SZXN1bHRcbn0pO1xuXG4vKipcbiAqIFNsb3QgdXBkYXRlcyB3aGljaCBjYW4gYmUgdXNlZCBmb3IgdHJhY2tpbmcgdGhlIGxpdmUgcHJvZ3Jlc3Mgb2YgYSBjbHVzdGVyLlxuICogLSBgXCJmaXJzdFNocmVkUmVjZWl2ZWRcImA6IGNvbm5lY3RlZCBub2RlIHJlY2VpdmVkIHRoZSBmaXJzdCBzaHJlZCBvZiBhIGJsb2NrLlxuICogSW5kaWNhdGVzIHRoYXQgYSBuZXcgYmxvY2sgdGhhdCBpcyBiZWluZyBwcm9kdWNlZC5cbiAqIC0gYFwiY29tcGxldGVkXCJgOiBjb25uZWN0ZWQgbm9kZSBoYXMgcmVjZWl2ZWQgYWxsIHNocmVkcyBvZiBhIGJsb2NrLiBJbmRpY2F0ZXNcbiAqIGEgYmxvY2sgd2FzIHJlY2VudGx5IHByb2R1Y2VkLlxuICogLSBgXCJvcHRpbWlzdGljQ29uZmlybWF0aW9uXCJgOiBibG9jayB3YXMgb3B0aW1pc3RpY2FsbHkgY29uZmlybWVkIGJ5IHRoZVxuICogY2x1c3Rlci4gSXQgaXMgbm90IGd1YXJhbnRlZWQgdGhhdCBhbiBvcHRpbWlzdGljIGNvbmZpcm1hdGlvbiBub3RpZmljYXRpb25cbiAqIHdpbGwgYmUgc2VudCBmb3IgZXZlcnkgZmluYWxpemVkIGJsb2Nrcy5cbiAqIC0gYFwicm9vdFwiYDogdGhlIGNvbm5lY3RlZCBub2RlIHJvb3RlZCB0aGlzIGJsb2NrLlxuICogLSBgXCJjcmVhdGVkQmFua1wiYDogdGhlIGNvbm5lY3RlZCBub2RlIGhhcyBzdGFydGVkIHZhbGlkYXRpbmcgdGhpcyBibG9jay5cbiAqIC0gYFwiZnJvemVuXCJgOiB0aGUgY29ubmVjdGVkIG5vZGUgaGFzIHZhbGlkYXRlZCB0aGlzIGJsb2NrLlxuICogLSBgXCJkZWFkXCJgOiB0aGUgY29ubmVjdGVkIG5vZGUgZmFpbGVkIHRvIHZhbGlkYXRlIHRoaXMgYmxvY2suXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgU2xvdFVwZGF0ZVJlc3VsdCA9IHVuaW9uKFt0eXBlKHtcbiAgdHlwZTogdW5pb24oW2xpdGVyYWwoJ2ZpcnN0U2hyZWRSZWNlaXZlZCcpLCBsaXRlcmFsKCdjb21wbGV0ZWQnKSwgbGl0ZXJhbCgnb3B0aW1pc3RpY0NvbmZpcm1hdGlvbicpLCBsaXRlcmFsKCdyb290JyldKSxcbiAgc2xvdDogbnVtYmVyKCksXG4gIHRpbWVzdGFtcDogbnVtYmVyKClcbn0pLCB0eXBlKHtcbiAgdHlwZTogbGl0ZXJhbCgnY3JlYXRlZEJhbmsnKSxcbiAgcGFyZW50OiBudW1iZXIoKSxcbiAgc2xvdDogbnVtYmVyKCksXG4gIHRpbWVzdGFtcDogbnVtYmVyKClcbn0pLCB0eXBlKHtcbiAgdHlwZTogbGl0ZXJhbCgnZnJvemVuJyksXG4gIHNsb3Q6IG51bWJlcigpLFxuICB0aW1lc3RhbXA6IG51bWJlcigpLFxuICBzdGF0czogdHlwZSh7XG4gICAgbnVtVHJhbnNhY3Rpb25FbnRyaWVzOiBudW1iZXIoKSxcbiAgICBudW1TdWNjZXNzZnVsVHJhbnNhY3Rpb25zOiBudW1iZXIoKSxcbiAgICBudW1GYWlsZWRUcmFuc2FjdGlvbnM6IG51bWJlcigpLFxuICAgIG1heFRyYW5zYWN0aW9uc1BlckVudHJ5OiBudW1iZXIoKVxuICB9KVxufSksIHR5cGUoe1xuICB0eXBlOiBsaXRlcmFsKCdkZWFkJyksXG4gIHNsb3Q6IG51bWJlcigpLFxuICB0aW1lc3RhbXA6IG51bWJlcigpLFxuICBlcnI6IHN0cmluZygpXG59KV0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJzbG90c1VwZGF0ZXNOb3RpZmljYXRpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IFNsb3RVcGRhdGVOb3RpZmljYXRpb25SZXN1bHQgPSB0eXBlKHtcbiAgc3Vic2NyaXB0aW9uOiBudW1iZXIoKSxcbiAgcmVzdWx0OiBTbG90VXBkYXRlUmVzdWx0XG59KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwic2lnbmF0dXJlTm90aWZpY2F0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBTaWduYXR1cmVOb3RpZmljYXRpb25SZXN1bHQgPSB0eXBlKHtcbiAgc3Vic2NyaXB0aW9uOiBudW1iZXIoKSxcbiAgcmVzdWx0OiBub3RpZmljYXRpb25SZXN1bHRBbmRDb250ZXh0KHVuaW9uKFtTaWduYXR1cmVTdGF0dXNSZXN1bHQsIFNpZ25hdHVyZVJlY2VpdmVkUmVzdWx0XSkpXG59KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwicm9vdE5vdGlmaWNhdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgUm9vdE5vdGlmaWNhdGlvblJlc3VsdCA9IHR5cGUoe1xuICBzdWJzY3JpcHRpb246IG51bWJlcigpLFxuICByZXN1bHQ6IG51bWJlcigpXG59KTtcbmNvbnN0IENvbnRhY3RJbmZvUmVzdWx0ID0gdHlwZSh7XG4gIHB1YmtleTogc3RyaW5nKCksXG4gIGdvc3NpcDogbnVsbGFibGUoc3RyaW5nKCkpLFxuICB0cHU6IG51bGxhYmxlKHN0cmluZygpKSxcbiAgcnBjOiBudWxsYWJsZShzdHJpbmcoKSksXG4gIHZlcnNpb246IG51bGxhYmxlKHN0cmluZygpKVxufSk7XG5jb25zdCBWb3RlQWNjb3VudEluZm9SZXN1bHQgPSB0eXBlKHtcbiAgdm90ZVB1YmtleTogc3RyaW5nKCksXG4gIG5vZGVQdWJrZXk6IHN0cmluZygpLFxuICBhY3RpdmF0ZWRTdGFrZTogbnVtYmVyKCksXG4gIGVwb2NoVm90ZUFjY291bnQ6IGJvb2xlYW4oKSxcbiAgZXBvY2hDcmVkaXRzOiBhcnJheSh0dXBsZShbbnVtYmVyKCksIG51bWJlcigpLCBudW1iZXIoKV0pKSxcbiAgY29tbWlzc2lvbjogbnVtYmVyKCksXG4gIGxhc3RWb3RlOiBudW1iZXIoKSxcbiAgcm9vdFNsb3Q6IG51bGxhYmxlKG51bWJlcigpKVxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFZvdGVBY2NvdW50c1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0Vm90ZUFjY291bnRzID0ganNvblJwY1Jlc3VsdCh0eXBlKHtcbiAgY3VycmVudDogYXJyYXkoVm90ZUFjY291bnRJbmZvUmVzdWx0KSxcbiAgZGVsaW5xdWVudDogYXJyYXkoVm90ZUFjY291bnRJbmZvUmVzdWx0KVxufSkpO1xuY29uc3QgQ29uZmlybWF0aW9uU3RhdHVzID0gdW5pb24oW2xpdGVyYWwoJ3Byb2Nlc3NlZCcpLCBsaXRlcmFsKCdjb25maXJtZWQnKSwgbGl0ZXJhbCgnZmluYWxpemVkJyldKTtcbmNvbnN0IFNpZ25hdHVyZVN0YXR1c1Jlc3BvbnNlID0gdHlwZSh7XG4gIHNsb3Q6IG51bWJlcigpLFxuICBjb25maXJtYXRpb25zOiBudWxsYWJsZShudW1iZXIoKSksXG4gIGVycjogVHJhbnNhY3Rpb25FcnJvclJlc3VsdCxcbiAgY29uZmlybWF0aW9uU3RhdHVzOiBvcHRpb25hbChDb25maXJtYXRpb25TdGF0dXMpXG59KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0U2lnbmF0dXJlU3RhdHVzZXNcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFNpZ25hdHVyZVN0YXR1c2VzUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQoYXJyYXkobnVsbGFibGUoU2lnbmF0dXJlU3RhdHVzUmVzcG9uc2UpKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0aW9uUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudW1iZXIoKSk7XG5jb25zdCBBZGRyZXNzVGFibGVMb29rdXBTdHJ1Y3QgPSB0eXBlKHtcbiAgYWNjb3VudEtleTogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgd3JpdGFibGVJbmRleGVzOiBhcnJheShudW1iZXIoKSksXG4gIHJlYWRvbmx5SW5kZXhlczogYXJyYXkobnVtYmVyKCkpXG59KTtcbmNvbnN0IENvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0ID0gdHlwZSh7XG4gIHNpZ25hdHVyZXM6IGFycmF5KHN0cmluZygpKSxcbiAgbWVzc2FnZTogdHlwZSh7XG4gICAgYWNjb3VudEtleXM6IGFycmF5KHN0cmluZygpKSxcbiAgICBoZWFkZXI6IHR5cGUoe1xuICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzOiBudW1iZXIoKSxcbiAgICAgIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHM6IG51bWJlcigpLFxuICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzOiBudW1iZXIoKVxuICAgIH0pLFxuICAgIGluc3RydWN0aW9uczogYXJyYXkodHlwZSh7XG4gICAgICBhY2NvdW50czogYXJyYXkobnVtYmVyKCkpLFxuICAgICAgZGF0YTogc3RyaW5nKCksXG4gICAgICBwcm9ncmFtSWRJbmRleDogbnVtYmVyKClcbiAgICB9KSksXG4gICAgcmVjZW50QmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgICBhZGRyZXNzVGFibGVMb29rdXBzOiBvcHRpb25hbChhcnJheShBZGRyZXNzVGFibGVMb29rdXBTdHJ1Y3QpKVxuICB9KVxufSk7XG5jb25zdCBBbm5vdGF0ZWRBY2NvdW50S2V5ID0gdHlwZSh7XG4gIHB1YmtleTogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgc2lnbmVyOiBib29sZWFuKCksXG4gIHdyaXRhYmxlOiBib29sZWFuKCksXG4gIHNvdXJjZTogb3B0aW9uYWwodW5pb24oW2xpdGVyYWwoJ3RyYW5zYWN0aW9uJyksIGxpdGVyYWwoJ2xvb2t1cFRhYmxlJyldKSlcbn0pO1xuY29uc3QgQ29uZmlybWVkVHJhbnNhY3Rpb25BY2NvdW50c01vZGVSZXN1bHQgPSB0eXBlKHtcbiAgYWNjb3VudEtleXM6IGFycmF5KEFubm90YXRlZEFjY291bnRLZXkpLFxuICBzaWduYXR1cmVzOiBhcnJheShzdHJpbmcoKSlcbn0pO1xuY29uc3QgUGFyc2VkSW5zdHJ1Y3Rpb25SZXN1bHQgPSB0eXBlKHtcbiAgcGFyc2VkOiB1bmtub3duKCksXG4gIHByb2dyYW06IHN0cmluZygpLFxuICBwcm9ncmFtSWQ6IFB1YmxpY0tleUZyb21TdHJpbmdcbn0pO1xuY29uc3QgUmF3SW5zdHJ1Y3Rpb25SZXN1bHQgPSB0eXBlKHtcbiAgYWNjb3VudHM6IGFycmF5KFB1YmxpY0tleUZyb21TdHJpbmcpLFxuICBkYXRhOiBzdHJpbmcoKSxcbiAgcHJvZ3JhbUlkOiBQdWJsaWNLZXlGcm9tU3RyaW5nXG59KTtcbmNvbnN0IEluc3RydWN0aW9uUmVzdWx0ID0gdW5pb24oW1Jhd0luc3RydWN0aW9uUmVzdWx0LCBQYXJzZWRJbnN0cnVjdGlvblJlc3VsdF0pO1xuY29uc3QgVW5rbm93bkluc3RydWN0aW9uUmVzdWx0ID0gdW5pb24oW3R5cGUoe1xuICBwYXJzZWQ6IHVua25vd24oKSxcbiAgcHJvZ3JhbTogc3RyaW5nKCksXG4gIHByb2dyYW1JZDogc3RyaW5nKClcbn0pLCB0eXBlKHtcbiAgYWNjb3VudHM6IGFycmF5KHN0cmluZygpKSxcbiAgZGF0YTogc3RyaW5nKCksXG4gIHByb2dyYW1JZDogc3RyaW5nKClcbn0pXSk7XG5jb25zdCBQYXJzZWRPclJhd0luc3RydWN0aW9uID0gY29lcmNlKEluc3RydWN0aW9uUmVzdWx0LCBVbmtub3duSW5zdHJ1Y3Rpb25SZXN1bHQsIHZhbHVlID0+IHtcbiAgaWYgKCdhY2NvdW50cycgaW4gdmFsdWUpIHtcbiAgICByZXR1cm4gY3JlYXRlKHZhbHVlLCBSYXdJbnN0cnVjdGlvblJlc3VsdCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZSh2YWx1ZSwgUGFyc2VkSW5zdHJ1Y3Rpb25SZXN1bHQpO1xuICB9XG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25SZXN1bHQgPSB0eXBlKHtcbiAgc2lnbmF0dXJlczogYXJyYXkoc3RyaW5nKCkpLFxuICBtZXNzYWdlOiB0eXBlKHtcbiAgICBhY2NvdW50S2V5czogYXJyYXkoQW5ub3RhdGVkQWNjb3VudEtleSksXG4gICAgaW5zdHJ1Y3Rpb25zOiBhcnJheShQYXJzZWRPclJhd0luc3RydWN0aW9uKSxcbiAgICByZWNlbnRCbG9ja2hhc2g6IHN0cmluZygpLFxuICAgIGFkZHJlc3NUYWJsZUxvb2t1cHM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KEFkZHJlc3NUYWJsZUxvb2t1cFN0cnVjdCkpKVxuICB9KVxufSk7XG5jb25zdCBUb2tlbkJhbGFuY2VSZXN1bHQgPSB0eXBlKHtcbiAgYWNjb3VudEluZGV4OiBudW1iZXIoKSxcbiAgbWludDogc3RyaW5nKCksXG4gIG93bmVyOiBvcHRpb25hbChzdHJpbmcoKSksXG4gIHByb2dyYW1JZDogb3B0aW9uYWwoc3RyaW5nKCkpLFxuICB1aVRva2VuQW1vdW50OiBUb2tlbkFtb3VudFJlc3VsdFxufSk7XG5jb25zdCBMb2FkZWRBZGRyZXNzZXNSZXN1bHQgPSB0eXBlKHtcbiAgd3JpdGFibGU6IGFycmF5KFB1YmxpY0tleUZyb21TdHJpbmcpLFxuICByZWFkb25seTogYXJyYXkoUHVibGljS2V5RnJvbVN0cmluZylcbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQgPSB0eXBlKHtcbiAgZXJyOiBUcmFuc2FjdGlvbkVycm9yUmVzdWx0LFxuICBmZWU6IG51bWJlcigpLFxuICBpbm5lckluc3RydWN0aW9uczogb3B0aW9uYWwobnVsbGFibGUoYXJyYXkodHlwZSh7XG4gICAgaW5kZXg6IG51bWJlcigpLFxuICAgIGluc3RydWN0aW9uczogYXJyYXkodHlwZSh7XG4gICAgICBhY2NvdW50czogYXJyYXkobnVtYmVyKCkpLFxuICAgICAgZGF0YTogc3RyaW5nKCksXG4gICAgICBwcm9ncmFtSWRJbmRleDogbnVtYmVyKClcbiAgICB9KSlcbiAgfSkpKSksXG4gIHByZUJhbGFuY2VzOiBhcnJheShudW1iZXIoKSksXG4gIHBvc3RCYWxhbmNlczogYXJyYXkobnVtYmVyKCkpLFxuICBsb2dNZXNzYWdlczogb3B0aW9uYWwobnVsbGFibGUoYXJyYXkoc3RyaW5nKCkpKSksXG4gIHByZVRva2VuQmFsYW5jZXM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KFRva2VuQmFsYW5jZVJlc3VsdCkpKSxcbiAgcG9zdFRva2VuQmFsYW5jZXM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KFRva2VuQmFsYW5jZVJlc3VsdCkpKSxcbiAgbG9hZGVkQWRkcmVzc2VzOiBvcHRpb25hbChMb2FkZWRBZGRyZXNzZXNSZXN1bHQpLFxuICBjb21wdXRlVW5pdHNDb25zdW1lZDogb3B0aW9uYWwobnVtYmVyKCkpXG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0ID0gdHlwZSh7XG4gIGVycjogVHJhbnNhY3Rpb25FcnJvclJlc3VsdCxcbiAgZmVlOiBudW1iZXIoKSxcbiAgaW5uZXJJbnN0cnVjdGlvbnM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KHR5cGUoe1xuICAgIGluZGV4OiBudW1iZXIoKSxcbiAgICBpbnN0cnVjdGlvbnM6IGFycmF5KFBhcnNlZE9yUmF3SW5zdHJ1Y3Rpb24pXG4gIH0pKSkpLFxuICBwcmVCYWxhbmNlczogYXJyYXkobnVtYmVyKCkpLFxuICBwb3N0QmFsYW5jZXM6IGFycmF5KG51bWJlcigpKSxcbiAgbG9nTWVzc2FnZXM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KHN0cmluZygpKSkpLFxuICBwcmVUb2tlbkJhbGFuY2VzOiBvcHRpb25hbChudWxsYWJsZShhcnJheShUb2tlbkJhbGFuY2VSZXN1bHQpKSksXG4gIHBvc3RUb2tlbkJhbGFuY2VzOiBvcHRpb25hbChudWxsYWJsZShhcnJheShUb2tlbkJhbGFuY2VSZXN1bHQpKSksXG4gIGxvYWRlZEFkZHJlc3Nlczogb3B0aW9uYWwoTG9hZGVkQWRkcmVzc2VzUmVzdWx0KSxcbiAgY29tcHV0ZVVuaXRzQ29uc3VtZWQ6IG9wdGlvbmFsKG51bWJlcigpKVxufSk7XG5jb25zdCBUcmFuc2FjdGlvblZlcnNpb25TdHJ1Y3QgPSB1bmlvbihbbGl0ZXJhbCgwKSwgbGl0ZXJhbCgnbGVnYWN5JyldKTtcblxuLyoqIEBpbnRlcm5hbCAqL1xuY29uc3QgUmV3YXJkc1Jlc3VsdCA9IHR5cGUoe1xuICBwdWJrZXk6IHN0cmluZygpLFxuICBsYW1wb3J0czogbnVtYmVyKCksXG4gIHBvc3RCYWxhbmNlOiBudWxsYWJsZShudW1iZXIoKSksXG4gIHJld2FyZFR5cGU6IG51bGxhYmxlKHN0cmluZygpKSxcbiAgY29tbWlzc2lvbjogb3B0aW9uYWwobnVsbGFibGUobnVtYmVyKCkpKVxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRCbG9ja1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVsbGFibGUodHlwZSh7XG4gIGJsb2NraGFzaDogc3RyaW5nKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcGFyZW50U2xvdDogbnVtYmVyKCksXG4gIHRyYW5zYWN0aW9uczogYXJyYXkodHlwZSh7XG4gICAgdHJhbnNhY3Rpb246IENvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0LFxuICAgIG1ldGE6IG51bGxhYmxlKENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCksXG4gICAgdmVyc2lvbjogb3B0aW9uYWwoVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0KVxuICB9KSksXG4gIHJld2FyZHM6IG9wdGlvbmFsKGFycmF5KFJld2FyZHNSZXN1bHQpKSxcbiAgYmxvY2tUaW1lOiBudWxsYWJsZShudW1iZXIoKSksXG4gIGJsb2NrSGVpZ2h0OiBudWxsYWJsZShudW1iZXIoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrXCIgbWVzc2FnZSB3aGVuIGB0cmFuc2FjdGlvbkRldGFpbHNgIGlzIGBub25lYFxuICovXG5jb25zdCBHZXROb25lTW9kZUJsb2NrUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudWxsYWJsZSh0eXBlKHtcbiAgYmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcHJldmlvdXNCbG9ja2hhc2g6IHN0cmluZygpLFxuICBwYXJlbnRTbG90OiBudW1iZXIoKSxcbiAgcmV3YXJkczogb3B0aW9uYWwoYXJyYXkoUmV3YXJkc1Jlc3VsdCkpLFxuICBibG9ja1RpbWU6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgYmxvY2tIZWlnaHQ6IG51bGxhYmxlKG51bWJlcigpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tcIiBtZXNzYWdlIHdoZW4gYHRyYW5zYWN0aW9uRGV0YWlsc2AgaXMgYGFjY291bnRzYFxuICovXG5jb25zdCBHZXRBY2NvdW50c01vZGVCbG9ja1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVsbGFibGUodHlwZSh7XG4gIGJsb2NraGFzaDogc3RyaW5nKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcGFyZW50U2xvdDogbnVtYmVyKCksXG4gIHRyYW5zYWN0aW9uczogYXJyYXkodHlwZSh7XG4gICAgdHJhbnNhY3Rpb246IENvbmZpcm1lZFRyYW5zYWN0aW9uQWNjb3VudHNNb2RlUmVzdWx0LFxuICAgIG1ldGE6IG51bGxhYmxlKENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCksXG4gICAgdmVyc2lvbjogb3B0aW9uYWwoVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0KVxuICB9KSksXG4gIHJld2FyZHM6IG9wdGlvbmFsKGFycmF5KFJld2FyZHNSZXN1bHQpKSxcbiAgYmxvY2tUaW1lOiBudWxsYWJsZShudW1iZXIoKSksXG4gIGJsb2NrSGVpZ2h0OiBudWxsYWJsZShudW1iZXIoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgcGFyc2VkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRCbG9ja1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0UGFyc2VkQmxvY2tScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bGxhYmxlKHR5cGUoe1xuICBibG9ja2hhc2g6IHN0cmluZygpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogc3RyaW5nKCksXG4gIHBhcmVudFNsb3Q6IG51bWJlcigpLFxuICB0cmFuc2FjdGlvbnM6IGFycmF5KHR5cGUoe1xuICAgIHRyYW5zYWN0aW9uOiBQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCxcbiAgICBtZXRhOiBudWxsYWJsZShQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpLFxuICAgIHZlcnNpb246IG9wdGlvbmFsKFRyYW5zYWN0aW9uVmVyc2lvblN0cnVjdClcbiAgfSkpLFxuICByZXdhcmRzOiBvcHRpb25hbChhcnJheShSZXdhcmRzUmVzdWx0KSksXG4gIGJsb2NrVGltZTogbnVsbGFibGUobnVtYmVyKCkpLFxuICBibG9ja0hlaWdodDogbnVsbGFibGUobnVtYmVyKCkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIHBhcnNlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tcIiBtZXNzYWdlICB3aGVuIGB0cmFuc2FjdGlvbkRldGFpbHNgIGlzIGBhY2NvdW50c2BcbiAqL1xuY29uc3QgR2V0UGFyc2VkQWNjb3VudHNNb2RlQmxvY2tScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bGxhYmxlKHR5cGUoe1xuICBibG9ja2hhc2g6IHN0cmluZygpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogc3RyaW5nKCksXG4gIHBhcmVudFNsb3Q6IG51bWJlcigpLFxuICB0cmFuc2FjdGlvbnM6IGFycmF5KHR5cGUoe1xuICAgIHRyYW5zYWN0aW9uOiBDb25maXJtZWRUcmFuc2FjdGlvbkFjY291bnRzTW9kZVJlc3VsdCxcbiAgICBtZXRhOiBudWxsYWJsZShQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpLFxuICAgIHZlcnNpb246IG9wdGlvbmFsKFRyYW5zYWN0aW9uVmVyc2lvblN0cnVjdClcbiAgfSkpLFxuICByZXdhcmRzOiBvcHRpb25hbChhcnJheShSZXdhcmRzUmVzdWx0KSksXG4gIGJsb2NrVGltZTogbnVsbGFibGUobnVtYmVyKCkpLFxuICBibG9ja0hlaWdodDogbnVsbGFibGUobnVtYmVyKCkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIHBhcnNlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tcIiBtZXNzYWdlICB3aGVuIGB0cmFuc2FjdGlvbkRldGFpbHNgIGlzIGBub25lYFxuICovXG5jb25zdCBHZXRQYXJzZWROb25lTW9kZUJsb2NrUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudWxsYWJsZSh0eXBlKHtcbiAgYmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcHJldmlvdXNCbG9ja2hhc2g6IHN0cmluZygpLFxuICBwYXJlbnRTbG90OiBudW1iZXIoKSxcbiAgcmV3YXJkczogb3B0aW9uYWwoYXJyYXkoUmV3YXJkc1Jlc3VsdCkpLFxuICBibG9ja1RpbWU6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgYmxvY2tIZWlnaHQ6IG51bGxhYmxlKG51bWJlcigpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0Q29uZmlybWVkQmxvY2tcIiBtZXNzYWdlXG4gKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuOC4wLiBQbGVhc2UgdXNlIHtAbGluayBHZXRCbG9ja1JwY1Jlc3VsdH0gaW5zdGVhZC5cbiAqL1xuY29uc3QgR2V0Q29uZmlybWVkQmxvY2tScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bGxhYmxlKHR5cGUoe1xuICBibG9ja2hhc2g6IHN0cmluZygpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogc3RyaW5nKCksXG4gIHBhcmVudFNsb3Q6IG51bWJlcigpLFxuICB0cmFuc2FjdGlvbnM6IGFycmF5KHR5cGUoe1xuICAgIHRyYW5zYWN0aW9uOiBDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCxcbiAgICBtZXRhOiBudWxsYWJsZShDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpXG4gIH0pKSxcbiAgcmV3YXJkczogb3B0aW9uYWwoYXJyYXkoUmV3YXJkc1Jlc3VsdCkpLFxuICBibG9ja1RpbWU6IG51bGxhYmxlKG51bWJlcigpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEJsb2NrU2lnbmF0dXJlc1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVsbGFibGUodHlwZSh7XG4gIGJsb2NraGFzaDogc3RyaW5nKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcGFyZW50U2xvdDogbnVtYmVyKCksXG4gIHNpZ25hdHVyZXM6IGFycmF5KHN0cmluZygpKSxcbiAgYmxvY2tUaW1lOiBudWxsYWJsZShudW1iZXIoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFRyYW5zYWN0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRUcmFuc2FjdGlvblJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVsbGFibGUodHlwZSh7XG4gIHNsb3Q6IG51bWJlcigpLFxuICBtZXRhOiBudWxsYWJsZShDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpLFxuICBibG9ja1RpbWU6IG9wdGlvbmFsKG51bGxhYmxlKG51bWJlcigpKSksXG4gIHRyYW5zYWN0aW9uOiBDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCxcbiAgdmVyc2lvbjogb3B0aW9uYWwoVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0KVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBwYXJzZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFRyYW5zYWN0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRQYXJzZWRUcmFuc2FjdGlvblJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVsbGFibGUodHlwZSh7XG4gIHNsb3Q6IG51bWJlcigpLFxuICB0cmFuc2FjdGlvbjogUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25SZXN1bHQsXG4gIG1ldGE6IG51bGxhYmxlKFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCksXG4gIGJsb2NrVGltZTogb3B0aW9uYWwobnVsbGFibGUobnVtYmVyKCkpKSxcbiAgdmVyc2lvbjogb3B0aW9uYWwoVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0KVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0TGF0ZXN0QmxvY2toYXNoXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRMYXRlc3RCbG9ja2hhc2hScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dCh0eXBlKHtcbiAgYmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgbGFzdFZhbGlkQmxvY2tIZWlnaHQ6IG51bWJlcigpXG59KSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImlzQmxvY2toYXNoVmFsaWRcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IElzQmxvY2toYXNoVmFsaWRScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChib29sZWFuKCkpO1xuY29uc3QgUGVyZlNhbXBsZVJlc3VsdCA9IHR5cGUoe1xuICBzbG90OiBudW1iZXIoKSxcbiAgbnVtVHJhbnNhY3Rpb25zOiBudW1iZXIoKSxcbiAgbnVtU2xvdHM6IG51bWJlcigpLFxuICBzYW1wbGVQZXJpb2RTZWNzOiBudW1iZXIoKVxufSk7XG5cbi8qXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgXCJnZXRSZWNlbnRQZXJmb3JtYW5jZVNhbXBsZXNcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFJlY2VudFBlcmZvcm1hbmNlU2FtcGxlc1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoYXJyYXkoUGVyZlNhbXBsZVJlc3VsdCkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRGZWVDYWxjdWxhdG9yRm9yQmxvY2toYXNoXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRGZWVDYWxjdWxhdG9yUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQobnVsbGFibGUodHlwZSh7XG4gIGZlZUNhbGN1bGF0b3I6IHR5cGUoe1xuICAgIGxhbXBvcnRzUGVyU2lnbmF0dXJlOiBudW1iZXIoKVxuICB9KVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwicmVxdWVzdEFpcmRyb3BcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IFJlcXVlc3RBaXJkcm9wUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChzdHJpbmcoKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcInNlbmRUcmFuc2FjdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgU2VuZFRyYW5zYWN0aW9uUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChzdHJpbmcoKSk7XG5cbi8qKlxuICogSW5mb3JtYXRpb24gYWJvdXQgdGhlIGxhdGVzdCBzbG90IGJlaW5nIHByb2Nlc3NlZCBieSBhIG5vZGVcbiAqL1xuXG4vKipcbiAqIFBhcnNlZCBhY2NvdW50IGRhdGFcbiAqL1xuXG4vKipcbiAqIFN0YWtlIEFjdGl2YXRpb24gZGF0YVxuICovXG5cbi8qKlxuICogRGF0YSBzbGljZSBhcmd1bWVudCBmb3IgZ2V0UHJvZ3JhbUFjY291bnRzXG4gKi9cblxuLyoqXG4gKiBNZW1vcnkgY29tcGFyaXNvbiBmaWx0ZXIgZm9yIGdldFByb2dyYW1BY2NvdW50c1xuICovXG5cbi8qKlxuICogRGF0YSBzaXplIGNvbXBhcmlzb24gZmlsdGVyIGZvciBnZXRQcm9ncmFtQWNjb3VudHNcbiAqL1xuXG4vKipcbiAqIEEgZmlsdGVyIG9iamVjdCBmb3IgZ2V0UHJvZ3JhbUFjY291bnRzXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgZ2V0UHJvZ3JhbUFjY291bnRzIHJlcXVlc3RzXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgZ2V0UGFyc2VkUHJvZ3JhbUFjY291bnRzXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgZ2V0TXVsdGlwbGVBY2NvdW50c1xuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGBnZXRTdGFrZUFjdGl2YXRpb25gXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgYGdldFN0YWtlQWN0aXZhdGlvbmBcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBgZ2V0U3Rha2VBY3RpdmF0aW9uYFxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGBnZXROb25jZWBcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBgZ2V0Tm9uY2VBbmRDb250ZXh0YFxuICovXG5cbi8qKlxuICogSW5mb3JtYXRpb24gZGVzY3JpYmluZyBhbiBhY2NvdW50XG4gKi9cblxuLyoqXG4gKiBBY2NvdW50IGluZm9ybWF0aW9uIGlkZW50aWZpZWQgYnkgcHVia2V5XG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3IgYWNjb3VudCBjaGFuZ2Ugbm90aWZpY2F0aW9uc1xuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHByb2dyYW0gYWNjb3VudCBjaGFuZ2Ugbm90aWZpY2F0aW9uc1xuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHNsb3QgY2hhbmdlIG5vdGlmaWNhdGlvbnNcbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciBzbG90IHVwZGF0ZSBub3RpZmljYXRpb25zXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3Igc2lnbmF0dXJlIHN0YXR1cyBub3RpZmljYXRpb25zXG4gKi9cblxuLyoqXG4gKiBTaWduYXR1cmUgc3RhdHVzIG5vdGlmaWNhdGlvbiB3aXRoIHRyYW5zYWN0aW9uIHJlc3VsdFxuICovXG5cbi8qKlxuICogU2lnbmF0dXJlIHJlY2VpdmVkIG5vdGlmaWNhdGlvblxuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHNpZ25hdHVyZSBub3RpZmljYXRpb25zXG4gKi9cblxuLyoqXG4gKiBTaWduYXR1cmUgc3Vic2NyaXB0aW9uIG9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciByb290IGNoYW5nZSBub3RpZmljYXRpb25zXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgTG9nc1Jlc3VsdCA9IHR5cGUoe1xuICBlcnI6IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHQsXG4gIGxvZ3M6IGFycmF5KHN0cmluZygpKSxcbiAgc2lnbmF0dXJlOiBzdHJpbmcoKVxufSk7XG5cbi8qKlxuICogTG9ncyByZXN1bHQuXG4gKi9cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwibG9nc05vdGlmaWNhdGlvblwiIG1lc3NhZ2UuXG4gKi9cbmNvbnN0IExvZ3NOb3RpZmljYXRpb25SZXN1bHQgPSB0eXBlKHtcbiAgcmVzdWx0OiBub3RpZmljYXRpb25SZXN1bHRBbmRDb250ZXh0KExvZ3NSZXN1bHQpLFxuICBzdWJzY3JpcHRpb246IG51bWJlcigpXG59KTtcblxuLyoqXG4gKiBGaWx0ZXIgZm9yIGxvZyBzdWJzY3JpcHRpb25zLlxuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIGxvZyBub3RpZmljYXRpb25zLlxuICovXG5cbi8qKlxuICogU2lnbmF0dXJlIHJlc3VsdFxuICovXG5cbi8qKlxuICogVHJhbnNhY3Rpb24gZXJyb3JcbiAqL1xuXG4vKipcbiAqIFRyYW5zYWN0aW9uIGNvbmZpcm1hdGlvbiBzdGF0dXNcbiAqIDxwcmU+XG4gKiAgICdwcm9jZXNzZWQnOiBUcmFuc2FjdGlvbiBsYW5kZWQgaW4gYSBibG9jayB3aGljaCBoYXMgcmVhY2hlZCAxIGNvbmZpcm1hdGlvbiBieSB0aGUgY29ubmVjdGVkIG5vZGVcbiAqICAgJ2NvbmZpcm1lZCc6IFRyYW5zYWN0aW9uIGxhbmRlZCBpbiBhIGJsb2NrIHdoaWNoIGhhcyByZWFjaGVkIDEgY29uZmlybWF0aW9uIGJ5IHRoZSBjbHVzdGVyXG4gKiAgICdmaW5hbGl6ZWQnOiBUcmFuc2FjdGlvbiBsYW5kZWQgaW4gYSBibG9jayB3aGljaCBoYXMgYmVlbiBmaW5hbGl6ZWQgYnkgdGhlIGNsdXN0ZXJcbiAqIDwvcHJlPlxuICovXG5cbi8qKlxuICogU2lnbmF0dXJlIHN0YXR1c1xuICovXG5cbi8qKlxuICogQSBjb25maXJtZWQgc2lnbmF0dXJlIHdpdGggaXRzIHN0YXR1c1xuICovXG5cbi8qKlxuICogQW4gb2JqZWN0IGRlZmluaW5nIGhlYWRlcnMgdG8gYmUgcGFzc2VkIHRvIHRoZSBSUEMgc2VydmVyXG4gKi9cblxuLyoqXG4gKiBUaGUgdHlwZSBvZiB0aGUgSmF2YVNjcmlwdCBgZmV0Y2goKWAgQVBJXG4gKi9cblxuLyoqXG4gKiBBIGNhbGxiYWNrIHVzZWQgdG8gYXVnbWVudCB0aGUgb3V0Z29pbmcgSFRUUCByZXF1ZXN0XG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIGZvciBpbnN0YW50aWF0aW5nIGEgQ29ubmVjdGlvblxuICovXG5cbi8qKiBAaW50ZXJuYWwgKi9cbmNvbnN0IENPTU1PTl9IVFRQX0hFQURFUlMgPSB7XG4gICdzb2xhbmEtY2xpZW50JzogYGpzLyR7XCIxLjAuMC1tYWludGVuYW5jZVwifWBcbn07XG5cbi8qKlxuICogQSBjb25uZWN0aW9uIHRvIGEgZnVsbG5vZGUgSlNPTiBSUEMgZW5kcG9pbnRcbiAqL1xuY2xhc3MgQ29ubmVjdGlvbiB7XG4gIC8qKlxuICAgKiBFc3RhYmxpc2ggYSBKU09OIFJQQyBjb25uZWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBlbmRwb2ludCBVUkwgdG8gdGhlIGZ1bGxub2RlIEpTT04gUlBDIGVuZHBvaW50XG4gICAqIEBwYXJhbSBjb21taXRtZW50T3JDb25maWcgb3B0aW9uYWwgZGVmYXVsdCBjb21taXRtZW50IGxldmVsIG9yIG9wdGlvbmFsIENvbm5lY3Rpb25Db25maWcgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICovXG4gIGNvbnN0cnVjdG9yKGVuZHBvaW50LCBfY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX2NvbW1pdG1lbnQgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX2NvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ycGNFbmRwb2ludCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcnBjV3NFbmRwb2ludCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcnBjQ2xpZW50ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ycGNSZXF1ZXN0ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ycGNCYXRjaFJlcXVlc3QgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkID0gZmFsc2U7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldEhlYXJ0YmVhdCA9IG51bGw7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0ID0gbnVsbDtcbiAgICAvKiogQGludGVybmFsXG4gICAgICogQSBudW1iZXIgdGhhdCB3ZSBpbmNyZW1lbnQgZXZlcnkgdGltZSBhbiBhY3RpdmUgY29ubmVjdGlvbiBjbG9zZXMuXG4gICAgICogVXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgc2FtZSBzb2NrZXQgY29ubmVjdGlvbiB0aGF0IHdhcyBvcGVuXG4gICAgICogd2hlbiBhbiBhc3luYyBvcGVyYXRpb24gc3RhcnRlZCBpcyB0aGUgc2FtZSBvbmUgdGhhdCdzIGFjdGl2ZSB3aGVuXG4gICAgICogaXRzIGNvbnRpbnVhdGlvbiBmaXJlcy5cbiAgICAgKlxuICAgICAqL1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldEdlbmVyYXRpb24gPSAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9kaXNhYmxlQmxvY2toYXNoQ2FjaGluZyA9IGZhbHNlO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9wb2xsaW5nQmxvY2toYXNoID0gZmFsc2U7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX2Jsb2NraGFzaEluZm8gPSB7XG4gICAgICBsYXRlc3RCbG9ja2hhc2g6IG51bGwsXG4gICAgICBsYXN0RmV0Y2g6IDAsXG4gICAgICB0cmFuc2FjdGlvblNpZ25hdHVyZXM6IFtdLFxuICAgICAgc2ltdWxhdGVkU2lnbmF0dXJlczogW11cbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9uZXh0Q2xpZW50U3Vic2NyaXB0aW9uSWQgPSAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25EaXNwb3NlRnVuY3Rpb25zQnlDbGllbnRTdWJzY3JpcHRpb25JZCA9IHt9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25IYXNoQnlDbGllbnRTdWJzY3JpcHRpb25JZCA9IHt9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25TdGF0ZUNoYW5nZUNhbGxiYWNrc0J5SGFzaCA9IHt9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25DYWxsYmFja3NCeVNlcnZlclN1YnNjcmlwdGlvbklkID0ge307XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2ggPSB7fTtcbiAgICAvKipcbiAgICAgKiBTcGVjaWFsIGNhc2UuXG4gICAgICogQWZ0ZXIgYSBzaWduYXR1cmUgaXMgcHJvY2Vzc2VkLCBSUENzIGF1dG9tYXRpY2FsbHkgZGlzcG9zZSBvZiB0aGVcbiAgICAgKiBzdWJzY3JpcHRpb24gb24gdGhlIHNlcnZlciBzaWRlLiBXZSBuZWVkIHRvIHRyYWNrIHdoaWNoIG9mIHRoZXNlXG4gICAgICogc3Vic2NyaXB0aW9ucyBoYXZlIGJlZW4gZGlzcG9zZWQgaW4gc3VjaCBhIHdheSwgc28gdGhhdCB3ZSBrbm93XG4gICAgICogd2hldGhlciB0aGUgY2xpZW50IGlzIGRlYWxpbmcgd2l0aCBhIG5vdC15ZXQtcHJvY2Vzc2VkIHNpZ25hdHVyZVxuICAgICAqIChpbiB3aGljaCBjYXNlIHdlIG11c3QgdGVhciBkb3duIHRoZSBzZXJ2ZXIgc3Vic2NyaXB0aW9uKSBvciBhblxuICAgICAqIGFscmVhZHktcHJvY2Vzc2VkIHNpZ25hdHVyZSAoaW4gd2hpY2ggY2FzZSB0aGUgY2xpZW50IGNhbiBzaW1wbHlcbiAgICAgKiBjbGVhciBvdXQgdGhlIHN1YnNjcmlwdGlvbiBsb2NhbGx5IHdpdGhvdXQgdGVsbGluZyB0aGUgc2VydmVyKS5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoZXJlIGlzIGEgcHJvcG9zYWwgdG8gZWxpbWluYXRlIHRoaXMgc3BlY2lhbCBjYXNlLCBoZXJlOlxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvaXNzdWVzLzE4ODkyXG4gICAgICovXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNBdXRvRGlzcG9zZWRCeVJwYyA9IG5ldyBTZXQoKTtcbiAgICAvKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgYmxvY2sgaGVpZ2h0IG9mIHRoZSBub2RlXG4gICAgICovXG4gICAgdGhpcy5nZXRCbG9ja0hlaWdodCA9ICgoKSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0UHJvbWlzZXMgPSB7fTtcbiAgICAgIHJldHVybiBhc3luYyBjb21taXRtZW50T3JDb25maWcgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY29tbWl0bWVudCxcbiAgICAgICAgICBjb25maWdcbiAgICAgICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RIYXNoID0gZmFzdFN0YWJsZVN0cmluZ2lmeShhcmdzKTtcbiAgICAgICAgcmVxdWVzdFByb21pc2VzW3JlcXVlc3RIYXNoXSA9IHJlcXVlc3RQcm9taXNlc1tyZXF1ZXN0SGFzaF0gPz8gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2tIZWlnaHQnLCBhcmdzKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQobnVtYmVyKCkpKTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgYmxvY2sgaGVpZ2h0IGluZm9ybWF0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgZGVsZXRlIHJlcXVlc3RQcm9taXNlc1tyZXF1ZXN0SGFzaF07XG4gICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVxdWVzdFByb21pc2VzW3JlcXVlc3RIYXNoXTtcbiAgICAgIH07XG4gICAgfSkoKTtcbiAgICBsZXQgd3NFbmRwb2ludDtcbiAgICBsZXQgaHR0cEhlYWRlcnM7XG4gICAgbGV0IGZldGNoO1xuICAgIGxldCBmZXRjaE1pZGRsZXdhcmU7XG4gICAgbGV0IGRpc2FibGVSZXRyeU9uUmF0ZUxpbWl0O1xuICAgIGxldCBodHRwQWdlbnQ7XG4gICAgaWYgKF9jb21taXRtZW50T3JDb25maWcgJiYgdHlwZW9mIF9jb21taXRtZW50T3JDb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9jb21taXRtZW50ID0gX2NvbW1pdG1lbnRPckNvbmZpZztcbiAgICB9IGVsc2UgaWYgKF9jb21taXRtZW50T3JDb25maWcpIHtcbiAgICAgIHRoaXMuX2NvbW1pdG1lbnQgPSBfY29tbWl0bWVudE9yQ29uZmlnLmNvbW1pdG1lbnQ7XG4gICAgICB0aGlzLl9jb25maXJtVHJhbnNhY3Rpb25Jbml0aWFsVGltZW91dCA9IF9jb21taXRtZW50T3JDb25maWcuY29uZmlybVRyYW5zYWN0aW9uSW5pdGlhbFRpbWVvdXQ7XG4gICAgICB3c0VuZHBvaW50ID0gX2NvbW1pdG1lbnRPckNvbmZpZy53c0VuZHBvaW50O1xuICAgICAgaHR0cEhlYWRlcnMgPSBfY29tbWl0bWVudE9yQ29uZmlnLmh0dHBIZWFkZXJzO1xuICAgICAgZmV0Y2ggPSBfY29tbWl0bWVudE9yQ29uZmlnLmZldGNoO1xuICAgICAgZmV0Y2hNaWRkbGV3YXJlID0gX2NvbW1pdG1lbnRPckNvbmZpZy5mZXRjaE1pZGRsZXdhcmU7XG4gICAgICBkaXNhYmxlUmV0cnlPblJhdGVMaW1pdCA9IF9jb21taXRtZW50T3JDb25maWcuZGlzYWJsZVJldHJ5T25SYXRlTGltaXQ7XG4gICAgICBodHRwQWdlbnQgPSBfY29tbWl0bWVudE9yQ29uZmlnLmh0dHBBZ2VudDtcbiAgICB9XG4gICAgdGhpcy5fcnBjRW5kcG9pbnQgPSBhc3NlcnRFbmRwb2ludFVybChlbmRwb2ludCk7XG4gICAgdGhpcy5fcnBjV3NFbmRwb2ludCA9IHdzRW5kcG9pbnQgfHwgbWFrZVdlYnNvY2tldFVybChlbmRwb2ludCk7XG4gICAgdGhpcy5fcnBjQ2xpZW50ID0gY3JlYXRlUnBjQ2xpZW50KGVuZHBvaW50LCBodHRwSGVhZGVycywgZmV0Y2gsIGZldGNoTWlkZGxld2FyZSwgZGlzYWJsZVJldHJ5T25SYXRlTGltaXQsIGh0dHBBZ2VudCk7XG4gICAgdGhpcy5fcnBjUmVxdWVzdCA9IGNyZWF0ZVJwY1JlcXVlc3QodGhpcy5fcnBjQ2xpZW50KTtcbiAgICB0aGlzLl9ycGNCYXRjaFJlcXVlc3QgPSBjcmVhdGVScGNCYXRjaFJlcXVlc3QodGhpcy5fcnBjQ2xpZW50KTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQgPSBuZXcgUnBjV2ViU29ja2V0Q2xpZW50KHRoaXMuX3JwY1dzRW5kcG9pbnQsIHtcbiAgICAgIGF1dG9jb25uZWN0OiBmYWxzZSxcbiAgICAgIG1heF9yZWNvbm5lY3RzOiBJbmZpbml0eVxuICAgIH0pO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbignb3BlbicsIHRoaXMuX3dzT25PcGVuLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbignZXJyb3InLCB0aGlzLl93c09uRXJyb3IuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdjbG9zZScsIHRoaXMuX3dzT25DbG9zZS5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ2FjY291bnROb3RpZmljYXRpb24nLCB0aGlzLl93c09uQWNjb3VudE5vdGlmaWNhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ3Byb2dyYW1Ob3RpZmljYXRpb24nLCB0aGlzLl93c09uUHJvZ3JhbUFjY291bnROb3RpZmljYXRpb24uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdzbG90Tm90aWZpY2F0aW9uJywgdGhpcy5fd3NPblNsb3ROb3RpZmljYXRpb24uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdzbG90c1VwZGF0ZXNOb3RpZmljYXRpb24nLCB0aGlzLl93c09uU2xvdFVwZGF0ZXNOb3RpZmljYXRpb24uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdzaWduYXR1cmVOb3RpZmljYXRpb24nLCB0aGlzLl93c09uU2lnbmF0dXJlTm90aWZpY2F0aW9uLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbigncm9vdE5vdGlmaWNhdGlvbicsIHRoaXMuX3dzT25Sb290Tm90aWZpY2F0aW9uLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbignbG9nc05vdGlmaWNhdGlvbicsIHRoaXMuX3dzT25Mb2dzTm90aWZpY2F0aW9uLmJpbmQodGhpcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IGNvbW1pdG1lbnQgdXNlZCBmb3IgcmVxdWVzdHNcbiAgICovXG4gIGdldCBjb21taXRtZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9jb21taXRtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBSUEMgZW5kcG9pbnRcbiAgICovXG4gIGdldCBycGNFbmRwb2ludCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcnBjRW5kcG9pbnQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGJhbGFuY2UgZm9yIHRoZSBzcGVjaWZpZWQgcHVibGljIGtleSwgcmV0dXJuIHdpdGggY29udGV4dFxuICAgKi9cbiAgYXN5bmMgZ2V0QmFsYW5jZUFuZENvbnRleHQocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtwdWJsaWNLZXkudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCYWxhbmNlJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQobnVtYmVyKCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBiYWxhbmNlIGZvciAke3B1YmxpY0tleS50b0Jhc2U1OCgpfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgYmFsYW5jZSBmb3IgdGhlIHNwZWNpZmllZCBwdWJsaWMga2V5XG4gICAqL1xuICBhc3luYyBnZXRCYWxhbmNlKHB1YmxpY0tleSwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0QmFsYW5jZUFuZENvbnRleHQocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcpLnRoZW4oeCA9PiB4LnZhbHVlKS5jYXRjaChlID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIGdldCBiYWxhbmNlIG9mIGFjY291bnQgJyArIHB1YmxpY0tleS50b0Jhc2U1OCgpICsgJzogJyArIGUpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBlc3RpbWF0ZWQgcHJvZHVjdGlvbiB0aW1lIG9mIGEgYmxvY2tcbiAgICovXG4gIGFzeW5jIGdldEJsb2NrVGltZShzbG90KSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2tUaW1lJywgW3Nsb3RdKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KG51bGxhYmxlKG51bWJlcigpKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IGJsb2NrIHRpbWUgZm9yIHNsb3QgJHtzbG90fWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgbG93ZXN0IHNsb3QgdGhhdCB0aGUgbm9kZSBoYXMgaW5mb3JtYXRpb24gYWJvdXQgaW4gaXRzIGxlZGdlci5cbiAgICogVGhpcyB2YWx1ZSBtYXkgaW5jcmVhc2Ugb3ZlciB0aW1lIGlmIHRoZSBub2RlIGlzIGNvbmZpZ3VyZWQgdG8gcHVyZ2Ugb2xkZXIgbGVkZ2VyIGRhdGFcbiAgICovXG4gIGFzeW5jIGdldE1pbmltdW1MZWRnZXJTbG90KCkge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ21pbmltdW1MZWRnZXJTbG90JywgW10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQobnVtYmVyKCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBtaW5pbXVtIGxlZGdlciBzbG90Jyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBzbG90IG9mIHRoZSBsb3dlc3QgY29uZmlybWVkIGJsb2NrIHRoYXQgaGFzIG5vdCBiZWVuIHB1cmdlZCBmcm9tIHRoZSBsZWRnZXJcbiAgICovXG4gIGFzeW5jIGdldEZpcnN0QXZhaWxhYmxlQmxvY2soKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0Rmlyc3RBdmFpbGFibGVCbG9jaycsIFtdKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBTbG90UnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBmaXJzdCBhdmFpbGFibGUgYmxvY2snKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgc3VwcGx5XG4gICAqL1xuICBhc3luYyBnZXRTdXBwbHkoY29uZmlnKSB7XG4gICAgbGV0IGNvbmZpZ0FyZyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgY29uZmlnQXJnID0ge1xuICAgICAgICBjb21taXRtZW50OiBjb25maWdcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChjb25maWcpIHtcbiAgICAgIGNvbmZpZ0FyZyA9IHtcbiAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICBjb21taXRtZW50OiBjb25maWcgJiYgY29uZmlnLmNvbW1pdG1lbnQgfHwgdGhpcy5jb21taXRtZW50XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25maWdBcmcgPSB7XG4gICAgICAgIGNvbW1pdG1lbnQ6IHRoaXMuY29tbWl0bWVudFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0U3VwcGx5JywgW2NvbmZpZ0FyZ10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFN1cHBseVJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgc3VwcGx5Jyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IHN1cHBseSBvZiBhIHRva2VuIG1pbnRcbiAgICovXG4gIGFzeW5jIGdldFRva2VuU3VwcGx5KHRva2VuTWludEFkZHJlc3MsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFt0b2tlbk1pbnRBZGRyZXNzLnRvQmFzZTU4KCldLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUb2tlblN1cHBseScsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KFRva2VuQW1vdW50UmVzdWx0KSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdG9rZW4gc3VwcGx5Jyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IGJhbGFuY2Ugb2YgYSB0b2tlbiBhY2NvdW50XG4gICAqL1xuICBhc3luYyBnZXRUb2tlbkFjY291bnRCYWxhbmNlKHRva2VuQWRkcmVzcywgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3Rva2VuQWRkcmVzcy50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VG9rZW5BY2NvdW50QmFsYW5jZScsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KFRva2VuQW1vdW50UmVzdWx0KSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdG9rZW4gYWNjb3VudCBiYWxhbmNlJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFsbCB0aGUgdG9rZW4gYWNjb3VudHMgb3duZWQgYnkgdGhlIHNwZWNpZmllZCBhY2NvdW50XG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8UnBjUmVzcG9uc2VBbmRDb250ZXh0PEdldFByb2dyYW1BY2NvdW50c1Jlc3BvbnNlPn1cbiAgICovXG4gIGFzeW5jIGdldFRva2VuQWNjb3VudHNCeU93bmVyKG93bmVyQWRkcmVzcywgZmlsdGVyLCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGxldCBfYXJncyA9IFtvd25lckFkZHJlc3MudG9CYXNlNTgoKV07XG4gICAgaWYgKCdtaW50JyBpbiBmaWx0ZXIpIHtcbiAgICAgIF9hcmdzLnB1c2goe1xuICAgICAgICBtaW50OiBmaWx0ZXIubWludC50b0Jhc2U1OCgpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2FyZ3MucHVzaCh7XG4gICAgICAgIHByb2dyYW1JZDogZmlsdGVyLnByb2dyYW1JZC50b0Jhc2U1OCgpXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhfYXJncywgY29tbWl0bWVudCwgJ2Jhc2U2NCcsIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VG9rZW5BY2NvdW50c0J5T3duZXInLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRUb2tlbkFjY291bnRzQnlPd25lcik7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgdG9rZW4gYWNjb3VudHMgb3duZWQgYnkgYWNjb3VudCAke293bmVyQWRkcmVzcy50b0Jhc2U1OCgpfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBwYXJzZWQgdG9rZW4gYWNjb3VudHMgb3duZWQgYnkgdGhlIHNwZWNpZmllZCBhY2NvdW50XG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8UnBjUmVzcG9uc2VBbmRDb250ZXh0PEFycmF5PHtwdWJrZXk6IFB1YmxpY0tleSwgYWNjb3VudDogQWNjb3VudEluZm88UGFyc2VkQWNjb3VudERhdGE+fT4+Pn1cbiAgICovXG4gIGFzeW5jIGdldFBhcnNlZFRva2VuQWNjb3VudHNCeU93bmVyKG93bmVyQWRkcmVzcywgZmlsdGVyLCBjb21taXRtZW50KSB7XG4gICAgbGV0IF9hcmdzID0gW293bmVyQWRkcmVzcy50b0Jhc2U1OCgpXTtcbiAgICBpZiAoJ21pbnQnIGluIGZpbHRlcikge1xuICAgICAgX2FyZ3MucHVzaCh7XG4gICAgICAgIG1pbnQ6IGZpbHRlci5taW50LnRvQmFzZTU4KClcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBfYXJncy5wdXNoKHtcbiAgICAgICAgcHJvZ3JhbUlkOiBmaWx0ZXIucHJvZ3JhbUlkLnRvQmFzZTU4KClcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKF9hcmdzLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRva2VuQWNjb3VudHNCeU93bmVyJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UGFyc2VkVG9rZW5BY2NvdW50c0J5T3duZXIpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IHRva2VuIGFjY291bnRzIG93bmVkIGJ5IGFjY291bnQgJHtvd25lckFkZHJlc3MudG9CYXNlNTgoKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIDIwIGxhcmdlc3QgYWNjb3VudHMgd2l0aCB0aGVpciBjdXJyZW50IGJhbGFuY2VzXG4gICAqL1xuICBhc3luYyBnZXRMYXJnZXN0QWNjb3VudHMoY29uZmlnKSB7XG4gICAgY29uc3QgYXJnID0ge1xuICAgICAgLi4uY29uZmlnLFxuICAgICAgY29tbWl0bWVudDogY29uZmlnICYmIGNvbmZpZy5jb21taXRtZW50IHx8IHRoaXMuY29tbWl0bWVudFxuICAgIH07XG4gICAgY29uc3QgYXJncyA9IGFyZy5maWx0ZXIgfHwgYXJnLmNvbW1pdG1lbnQgPyBbYXJnXSA6IFtdO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldExhcmdlc3RBY2NvdW50cycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldExhcmdlc3RBY2NvdW50c1JwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgbGFyZ2VzdCBhY2NvdW50cycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgMjAgbGFyZ2VzdCB0b2tlbiBhY2NvdW50cyB3aXRoIHRoZWlyIGN1cnJlbnQgYmFsYW5jZXNcbiAgICogZm9yIGEgZ2l2ZW4gbWludC5cbiAgICovXG4gIGFzeW5jIGdldFRva2VuTGFyZ2VzdEFjY291bnRzKG1pbnRBZGRyZXNzLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbbWludEFkZHJlc3MudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRva2VuTGFyZ2VzdEFjY291bnRzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0VG9rZW5MYXJnZXN0QWNjb3VudHNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHRva2VuIGxhcmdlc3QgYWNjb3VudHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYWxsIHRoZSBhY2NvdW50IGluZm8gZm9yIHRoZSBzcGVjaWZpZWQgcHVibGljIGtleSwgcmV0dXJuIHdpdGggY29udGV4dFxuICAgKi9cbiAgYXN5bmMgZ2V0QWNjb3VudEluZm9BbmRDb250ZXh0KHB1YmxpY0tleSwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtwdWJsaWNLZXkudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQsICdiYXNlNjQnLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEFjY291bnRJbmZvJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQobnVsbGFibGUoQWNjb3VudEluZm9SZXN1bHQpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgaW5mbyBhYm91dCBhY2NvdW50ICR7cHVibGljS2V5LnRvQmFzZTU4KCl9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHBhcnNlZCBhY2NvdW50IGluZm8gZm9yIHRoZSBzcGVjaWZpZWQgcHVibGljIGtleVxuICAgKi9cbiAgYXN5bmMgZ2V0UGFyc2VkQWNjb3VudEluZm8ocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3B1YmxpY0tleS50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgJ2pzb25QYXJzZWQnLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEFjY291bnRJbmZvJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQobnVsbGFibGUoUGFyc2VkQWNjb3VudEluZm9SZXN1bHQpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgaW5mbyBhYm91dCBhY2NvdW50ICR7cHVibGljS2V5LnRvQmFzZTU4KCl9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFsbCB0aGUgYWNjb3VudCBpbmZvIGZvciB0aGUgc3BlY2lmaWVkIHB1YmxpYyBrZXlcbiAgICovXG4gIGFzeW5jIGdldEFjY291bnRJbmZvKHB1YmxpY0tleSwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudEluZm9BbmRDb250ZXh0KHB1YmxpY0tleSwgY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICAgIHJldHVybiByZXMudmFsdWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gZ2V0IGluZm8gYWJvdXQgYWNjb3VudCAnICsgcHVibGljS2V5LnRvQmFzZTU4KCkgKyAnOiAnICsgZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFsbCB0aGUgYWNjb3VudCBpbmZvIGZvciBtdWx0aXBsZSBhY2NvdW50cyBzcGVjaWZpZWQgYnkgYW4gYXJyYXkgb2YgcHVibGljIGtleXMsIHJldHVybiB3aXRoIGNvbnRleHRcbiAgICovXG4gIGFzeW5jIGdldE11bHRpcGxlUGFyc2VkQWNjb3VudHMocHVibGljS2V5cywgcmF3Q29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcocmF3Q29uZmlnKTtcbiAgICBjb25zdCBrZXlzID0gcHVibGljS2V5cy5tYXAoa2V5ID0+IGtleS50b0Jhc2U1OCgpKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtrZXlzXSwgY29tbWl0bWVudCwgJ2pzb25QYXJzZWQnLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldE11bHRpcGxlQWNjb3VudHMnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChhcnJheShudWxsYWJsZShQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdCkpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgaW5mbyBmb3IgYWNjb3VudHMgJHtrZXlzfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhbGwgdGhlIGFjY291bnQgaW5mbyBmb3IgbXVsdGlwbGUgYWNjb3VudHMgc3BlY2lmaWVkIGJ5IGFuIGFycmF5IG9mIHB1YmxpYyBrZXlzLCByZXR1cm4gd2l0aCBjb250ZXh0XG4gICAqL1xuICBhc3luYyBnZXRNdWx0aXBsZUFjY291bnRzSW5mb0FuZENvbnRleHQocHVibGljS2V5cywgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBrZXlzID0gcHVibGljS2V5cy5tYXAoa2V5ID0+IGtleS50b0Jhc2U1OCgpKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtrZXlzXSwgY29tbWl0bWVudCwgJ2Jhc2U2NCcsIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0TXVsdGlwbGVBY2NvdW50cycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KGFycmF5KG51bGxhYmxlKEFjY291bnRJbmZvUmVzdWx0KSkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBpbmZvIGZvciBhY2NvdW50cyAke2tleXN9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFsbCB0aGUgYWNjb3VudCBpbmZvIGZvciBtdWx0aXBsZSBhY2NvdW50cyBzcGVjaWZpZWQgYnkgYW4gYXJyYXkgb2YgcHVibGljIGtleXNcbiAgICovXG4gIGFzeW5jIGdldE11bHRpcGxlQWNjb3VudHNJbmZvKHB1YmxpY0tleXMsIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZ2V0TXVsdGlwbGVBY2NvdW50c0luZm9BbmRDb250ZXh0KHB1YmxpY0tleXMsIGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgcmV0dXJuIHJlcy52YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGVwb2NoIGFjdGl2YXRpb24gaW5mb3JtYXRpb24gZm9yIGEgc3Rha2UgYWNjb3VudCB0aGF0IGhhcyBiZWVuIGRlbGVnYXRlZFxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS4xODsgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uXG4gICAqL1xuICBhc3luYyBnZXRTdGFrZUFjdGl2YXRpb24ocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcsIGVwb2NoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtwdWJsaWNLZXkudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywge1xuICAgICAgLi4uY29uZmlnLFxuICAgICAgZXBvY2g6IGVwb2NoICE9IG51bGwgPyBlcG9jaCA6IGNvbmZpZz8uZXBvY2hcbiAgICB9KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTdGFrZUFjdGl2YXRpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KFN0YWtlQWN0aXZhdGlvblJlc3VsdCkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IFN0YWtlIEFjdGl2YXRpb24gJHtwdWJsaWNLZXkudG9CYXNlNTgoKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYWxsIHRoZSBhY2NvdW50cyBvd25lZCBieSB0aGUgc3BlY2lmaWVkIHByb2dyYW0gaWRcbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTx7cHVia2V5OiBQdWJsaWNLZXksIGFjY291bnQ6IEFjY291bnRJbmZvPEJ1ZmZlcj59Pj59XG4gICAqL1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIGdldFByb2dyYW1BY2NvdW50cyhwcm9ncmFtSWQsIGNvbmZpZ09yQ29tbWl0bWVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbmZpZ09yQ29tbWl0bWVudCk7XG4gICAgY29uc3Qge1xuICAgICAgZW5jb2RpbmcsXG4gICAgICAuLi5jb25maWdXaXRob3V0RW5jb2RpbmdcbiAgICB9ID0gY29uZmlnIHx8IHt9O1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3Byb2dyYW1JZC50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgZW5jb2RpbmcgfHwgJ2Jhc2U2NCcsIHtcbiAgICAgIC4uLmNvbmZpZ1dpdGhvdXRFbmNvZGluZyxcbiAgICAgIC4uLihjb25maWdXaXRob3V0RW5jb2RpbmcuZmlsdGVycyA/IHtcbiAgICAgICAgZmlsdGVyczogYXBwbHlEZWZhdWx0TWVtY21wRW5jb2RpbmdUb0ZpbHRlcnMoY29uZmlnV2l0aG91dEVuY29kaW5nLmZpbHRlcnMpXG4gICAgICB9IDogbnVsbClcbiAgICB9KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRQcm9ncmFtQWNjb3VudHMnLCBhcmdzKTtcbiAgICBjb25zdCBiYXNlU2NoZW1hID0gYXJyYXkoS2V5ZWRBY2NvdW50SW5mb1Jlc3VsdCk7XG4gICAgY29uc3QgcmVzID0gY29uZmlnV2l0aG91dEVuY29kaW5nLndpdGhDb250ZXh0ID09PSB0cnVlID8gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQoYmFzZVNjaGVtYSkpIDogY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChiYXNlU2NoZW1hKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgYWNjb3VudHMgb3duZWQgYnkgcHJvZ3JhbSAke3Byb2dyYW1JZC50b0Jhc2U1OCgpfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhbmQgcGFyc2UgYWxsIHRoZSBhY2NvdW50cyBvd25lZCBieSB0aGUgc3BlY2lmaWVkIHByb2dyYW0gaWRcbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTx7cHVia2V5OiBQdWJsaWNLZXksIGFjY291bnQ6IEFjY291bnRJbmZvPEJ1ZmZlciB8IFBhcnNlZEFjY291bnREYXRhPn0+Pn1cbiAgICovXG4gIGFzeW5jIGdldFBhcnNlZFByb2dyYW1BY2NvdW50cyhwcm9ncmFtSWQsIGNvbmZpZ09yQ29tbWl0bWVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbmZpZ09yQ29tbWl0bWVudCk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbcHJvZ3JhbUlkLnRvQmFzZTU4KCldLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcsIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0UHJvZ3JhbUFjY291bnRzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChhcnJheShLZXllZFBhcnNlZEFjY291bnRJbmZvUmVzdWx0KSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IGFjY291bnRzIG93bmVkIGJ5IHByb2dyYW0gJHtwcm9ncmFtSWQudG9CYXNlNTgoKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKiogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCBgY29uZmlybVRyYW5zYWN0aW9uYCBhbmQgcGFzcyBpbiB7QGxpbmsgVHJhbnNhY3Rpb25Db25maXJtYXRpb25TdHJhdGVneX0gKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgYXN5bmMgY29uZmlybVRyYW5zYWN0aW9uKHN0cmF0ZWd5LCBjb21taXRtZW50KSB7XG4gICAgbGV0IHJhd1NpZ25hdHVyZTtcbiAgICBpZiAodHlwZW9mIHN0cmF0ZWd5ID09ICdzdHJpbmcnKSB7XG4gICAgICByYXdTaWduYXR1cmUgPSBzdHJhdGVneTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29uZmlnID0gc3RyYXRlZ3k7XG4gICAgICBpZiAoY29uZmlnLmFib3J0U2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjb25maWcuYWJvcnRTaWduYWwucmVhc29uKTtcbiAgICAgIH1cbiAgICAgIHJhd1NpZ25hdHVyZSA9IGNvbmZpZy5zaWduYXR1cmU7XG4gICAgfVxuICAgIGxldCBkZWNvZGVkU2lnbmF0dXJlO1xuICAgIHRyeSB7XG4gICAgICBkZWNvZGVkU2lnbmF0dXJlID0gYnM1OC5kZWNvZGUocmF3U2lnbmF0dXJlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbmF0dXJlIG11c3QgYmUgYmFzZTU4IGVuY29kZWQ6ICcgKyByYXdTaWduYXR1cmUpO1xuICAgIH1cbiAgICBhc3NlcnQoZGVjb2RlZFNpZ25hdHVyZS5sZW5ndGggPT09IDY0LCAnc2lnbmF0dXJlIGhhcyBpbnZhbGlkIGxlbmd0aCcpO1xuICAgIGlmICh0eXBlb2Ygc3RyYXRlZ3kgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5jb25maXJtVHJhbnNhY3Rpb25Vc2luZ0xlZ2FjeVRpbWVvdXRTdHJhdGVneSh7XG4gICAgICAgIGNvbW1pdG1lbnQ6IGNvbW1pdG1lbnQgfHwgdGhpcy5jb21taXRtZW50LFxuICAgICAgICBzaWduYXR1cmU6IHJhd1NpZ25hdHVyZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICgnbGFzdFZhbGlkQmxvY2tIZWlnaHQnIGluIHN0cmF0ZWd5KSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5jb25maXJtVHJhbnNhY3Rpb25Vc2luZ0Jsb2NrSGVpZ2h0RXhjZWVkYW5jZVN0cmF0ZWd5KHtcbiAgICAgICAgY29tbWl0bWVudDogY29tbWl0bWVudCB8fCB0aGlzLmNvbW1pdG1lbnQsXG4gICAgICAgIHN0cmF0ZWd5XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY29uZmlybVRyYW5zYWN0aW9uVXNpbmdEdXJhYmxlTm9uY2VTdHJhdGVneSh7XG4gICAgICAgIGNvbW1pdG1lbnQ6IGNvbW1pdG1lbnQgfHwgdGhpcy5jb21taXRtZW50LFxuICAgICAgICBzdHJhdGVneVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldENhbmNlbGxhdGlvblByb21pc2Uoc2lnbmFsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgIGlmIChzaWduYWwgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgcmVqZWN0KHNpZ25hbC5yZWFzb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4ge1xuICAgICAgICAgIHJlamVjdChzaWduYWwucmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0VHJhbnNhY3Rpb25Db25maXJtYXRpb25Qcm9taXNlKHtcbiAgICBjb21taXRtZW50LFxuICAgIHNpZ25hdHVyZVxuICB9KSB7XG4gICAgbGV0IHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkO1xuICAgIGxldCBkaXNwb3NlU2lnbmF0dXJlU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VPYnNlcnZlcjtcbiAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgIGNvbnN0IGNvbmZpcm1hdGlvblByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzaWduYXR1cmVTdWJzY3JpcHRpb25JZCA9IHRoaXMub25TaWduYXR1cmUoc2lnbmF0dXJlLCAocmVzdWx0LCBjb250ZXh0KSA9PiB7XG4gICAgICAgICAgc2lnbmF0dXJlU3Vic2NyaXB0aW9uSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgdmFsdWU6IHJlc3VsdFxuICAgICAgICAgIH07XG4gICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICBfX3R5cGU6IFRyYW5zYWN0aW9uU3RhdHVzLlBST0NFU1NFRCxcbiAgICAgICAgICAgIHJlc3BvbnNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGNvbW1pdG1lbnQpO1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25TZXR1cFByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlU3Vic2NyaXB0aW9uU2V0dXAgPT4ge1xuICAgICAgICAgIGlmIChzaWduYXR1cmVTdWJzY3JpcHRpb25JZCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXNvbHZlU3Vic2NyaXB0aW9uU2V0dXAoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlzcG9zZVNpZ25hdHVyZVN1YnNjcmlwdGlvblN0YXRlQ2hhbmdlT2JzZXJ2ZXIgPSB0aGlzLl9vblN1YnNjcmlwdGlvblN0YXRlQ2hhbmdlKHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkLCBuZXh0U3RhdGUgPT4ge1xuICAgICAgICAgICAgICBpZiAobmV4dFN0YXRlID09PSAnc3Vic2NyaWJlZCcpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlU3Vic2NyaXB0aW9uU2V0dXAoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICBhd2FpdCBzdWJzY3JpcHRpb25TZXR1cFByb21pc2U7XG4gICAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0U2lnbmF0dXJlU3RhdHVzKHNpZ25hdHVyZSk7XG4gICAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgICBpZiAocmVzcG9uc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9ID0gcmVzcG9uc2U7XG4gICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlPy5lcnIpIHtcbiAgICAgICAgICAgIHJlamVjdCh2YWx1ZS5lcnIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNvbW1pdG1lbnQpIHtcbiAgICAgICAgICAgICAgY2FzZSAnY29uZmlybWVkJzpcbiAgICAgICAgICAgICAgY2FzZSAnc2luZ2xlJzpcbiAgICAgICAgICAgICAgY2FzZSAnc2luZ2xlR29zc2lwJzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUuY29uZmlybWF0aW9uU3RhdHVzID09PSAncHJvY2Vzc2VkJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgJ2ZpbmFsaXplZCc6XG4gICAgICAgICAgICAgIGNhc2UgJ21heCc6XG4gICAgICAgICAgICAgIGNhc2UgJ3Jvb3QnOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5jb25maXJtYXRpb25TdGF0dXMgPT09ICdwcm9jZXNzZWQnIHx8IHZhbHVlLmNvbmZpcm1hdGlvblN0YXR1cyA9PT0gJ2NvbmZpcm1lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBleGhhdXN0IGVudW1zIHRvIGVuc3VyZSBmdWxsIGNvdmVyYWdlXG4gICAgICAgICAgICAgIGNhc2UgJ3Byb2Nlc3NlZCc6XG4gICAgICAgICAgICAgIGNhc2UgJ3JlY2VudCc6XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICBfX3R5cGU6IFRyYW5zYWN0aW9uU3RhdHVzLlBST0NFU1NFRCxcbiAgICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBhYm9ydENvbmZpcm1hdGlvbiA9ICgpID0+IHtcbiAgICAgIGlmIChkaXNwb3NlU2lnbmF0dXJlU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VPYnNlcnZlcikge1xuICAgICAgICBkaXNwb3NlU2lnbmF0dXJlU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VPYnNlcnZlcigpO1xuICAgICAgICBkaXNwb3NlU2lnbmF0dXJlU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VPYnNlcnZlciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChzaWduYXR1cmVTdWJzY3JpcHRpb25JZCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlU2lnbmF0dXJlTGlzdGVuZXIoc2lnbmF0dXJlU3Vic2NyaXB0aW9uSWQpO1xuICAgICAgICBzaWduYXR1cmVTdWJzY3JpcHRpb25JZCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBhYm9ydENvbmZpcm1hdGlvbixcbiAgICAgIGNvbmZpcm1hdGlvblByb21pc2VcbiAgICB9O1xuICB9XG4gIGFzeW5jIGNvbmZpcm1UcmFuc2FjdGlvblVzaW5nQmxvY2tIZWlnaHRFeGNlZWRhbmNlU3RyYXRlZ3koe1xuICAgIGNvbW1pdG1lbnQsXG4gICAgc3RyYXRlZ3k6IHtcbiAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgbGFzdFZhbGlkQmxvY2tIZWlnaHQsXG4gICAgICBzaWduYXR1cmVcbiAgICB9XG4gIH0pIHtcbiAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgIGNvbnN0IGV4cGlyeVByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGNvbnN0IGNoZWNrQmxvY2tIZWlnaHQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgYmxvY2tIZWlnaHQgPSBhd2FpdCB0aGlzLmdldEJsb2NrSGVpZ2h0KGNvbW1pdG1lbnQpO1xuICAgICAgICAgIHJldHVybiBibG9ja0hlaWdodDtcbiAgICAgICAgfSBjYXRjaCAoX2UpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICBsZXQgY3VycmVudEJsb2NrSGVpZ2h0ID0gYXdhaXQgY2hlY2tCbG9ja0hlaWdodCgpO1xuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICB3aGlsZSAoY3VycmVudEJsb2NrSGVpZ2h0IDw9IGxhc3RWYWxpZEJsb2NrSGVpZ2h0KSB7XG4gICAgICAgICAgYXdhaXQgc2xlZXAoMTAwMCk7XG4gICAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgICBjdXJyZW50QmxvY2tIZWlnaHQgPSBhd2FpdCBjaGVja0Jsb2NrSGVpZ2h0KCk7XG4gICAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICBfX3R5cGU6IFRyYW5zYWN0aW9uU3RhdHVzLkJMT0NLSEVJR0hUX0VYQ0VFREVEXG4gICAgICAgIH0pO1xuICAgICAgfSkoKTtcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBhYm9ydENvbmZpcm1hdGlvbixcbiAgICAgIGNvbmZpcm1hdGlvblByb21pc2VcbiAgICB9ID0gdGhpcy5nZXRUcmFuc2FjdGlvbkNvbmZpcm1hdGlvblByb21pc2Uoe1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIHNpZ25hdHVyZVxuICAgIH0pO1xuICAgIGNvbnN0IGNhbmNlbGxhdGlvblByb21pc2UgPSB0aGlzLmdldENhbmNlbGxhdGlvblByb21pc2UoYWJvcnRTaWduYWwpO1xuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG91dGNvbWUgPSBhd2FpdCBQcm9taXNlLnJhY2UoW2NhbmNlbGxhdGlvblByb21pc2UsIGNvbmZpcm1hdGlvblByb21pc2UsIGV4cGlyeVByb21pc2VdKTtcbiAgICAgIGlmIChvdXRjb21lLl9fdHlwZSA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuUFJPQ0VTU0VEKSB7XG4gICAgICAgIHJlc3VsdCA9IG91dGNvbWUucmVzcG9uc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FeHBpcmVkQmxvY2toZWlnaHRFeGNlZWRlZEVycm9yKHNpZ25hdHVyZSk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgYWJvcnRDb25maXJtYXRpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBhc3luYyBjb25maXJtVHJhbnNhY3Rpb25Vc2luZ0R1cmFibGVOb25jZVN0cmF0ZWd5KHtcbiAgICBjb21taXRtZW50LFxuICAgIHN0cmF0ZWd5OiB7XG4gICAgICBhYm9ydFNpZ25hbCxcbiAgICAgIG1pbkNvbnRleHRTbG90LFxuICAgICAgbm9uY2VBY2NvdW50UHVia2V5LFxuICAgICAgbm9uY2VWYWx1ZSxcbiAgICAgIHNpZ25hdHVyZVxuICAgIH1cbiAgfSkge1xuICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgY29uc3QgZXhwaXJ5UHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgbGV0IGN1cnJlbnROb25jZVZhbHVlID0gbm9uY2VWYWx1ZTtcbiAgICAgIGxldCBsYXN0Q2hlY2tlZFNsb3QgPSBudWxsO1xuICAgICAgY29uc3QgZ2V0Q3VycmVudE5vbmNlVmFsdWUgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIHZhbHVlOiBub25jZUFjY291bnRcbiAgICAgICAgICB9ID0gYXdhaXQgdGhpcy5nZXROb25jZUFuZENvbnRleHQobm9uY2VBY2NvdW50UHVia2V5LCB7XG4gICAgICAgICAgICBjb21taXRtZW50LFxuICAgICAgICAgICAgbWluQ29udGV4dFNsb3RcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsYXN0Q2hlY2tlZFNsb3QgPSBjb250ZXh0LnNsb3Q7XG4gICAgICAgICAgcmV0dXJuIG5vbmNlQWNjb3VudD8ubm9uY2U7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBJZiBmb3Igd2hhdGV2ZXIgcmVhc29uIHdlIGNhbid0IHJlYWNoL3JlYWQgdGhlIG5vbmNlXG4gICAgICAgICAgLy8gYWNjb3VudCwganVzdCBrZWVwIHVzaW5nIHRoZSBsYXN0LWtub3duIHZhbHVlLlxuICAgICAgICAgIHJldHVybiBjdXJyZW50Tm9uY2VWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgIGN1cnJlbnROb25jZVZhbHVlID0gYXdhaXQgZ2V0Q3VycmVudE5vbmNlVmFsdWUoKTtcbiAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgd2hpbGUgKHRydWUgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKG5vbmNlVmFsdWUgIT09IGN1cnJlbnROb25jZVZhbHVlKSB7XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgX190eXBlOiBUcmFuc2FjdGlvblN0YXR1cy5OT05DRV9JTlZBTElELFxuICAgICAgICAgICAgICBzbG90SW5XaGljaE5vbmNlRGlkQWR2YW5jZTogbGFzdENoZWNrZWRTbG90XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgc2xlZXAoMjAwMCk7XG4gICAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgICBjdXJyZW50Tm9uY2VWYWx1ZSA9IGF3YWl0IGdldEN1cnJlbnROb25jZVZhbHVlKCk7XG4gICAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSkoKTtcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBhYm9ydENvbmZpcm1hdGlvbixcbiAgICAgIGNvbmZpcm1hdGlvblByb21pc2VcbiAgICB9ID0gdGhpcy5nZXRUcmFuc2FjdGlvbkNvbmZpcm1hdGlvblByb21pc2Uoe1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIHNpZ25hdHVyZVxuICAgIH0pO1xuICAgIGNvbnN0IGNhbmNlbGxhdGlvblByb21pc2UgPSB0aGlzLmdldENhbmNlbGxhdGlvblByb21pc2UoYWJvcnRTaWduYWwpO1xuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG91dGNvbWUgPSBhd2FpdCBQcm9taXNlLnJhY2UoW2NhbmNlbGxhdGlvblByb21pc2UsIGNvbmZpcm1hdGlvblByb21pc2UsIGV4cGlyeVByb21pc2VdKTtcbiAgICAgIGlmIChvdXRjb21lLl9fdHlwZSA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuUFJPQ0VTU0VEKSB7XG4gICAgICAgIHJlc3VsdCA9IG91dGNvbWUucmVzcG9uc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBEb3VibGUgY2hlY2sgdGhhdCB0aGUgdHJhbnNhY3Rpb24gaXMgaW5kZWVkIHVuY29uZmlybWVkLlxuICAgICAgICBsZXQgc2lnbmF0dXJlU3RhdHVzO1xuICAgICAgICB3aGlsZSAodHJ1ZSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBzdGF0dXMgPSBhd2FpdCB0aGlzLmdldFNpZ25hdHVyZVN0YXR1cyhzaWduYXR1cmUpO1xuICAgICAgICAgIGlmIChzdGF0dXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0dXMuY29udGV4dC5zbG90IDwgKG91dGNvbWUuc2xvdEluV2hpY2hOb25jZURpZEFkdmFuY2UgPz8gbWluQ29udGV4dFNsb3QpKSB7XG4gICAgICAgICAgICBhd2FpdCBzbGVlcCg0MDApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNpZ25hdHVyZVN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2lnbmF0dXJlU3RhdHVzPy52YWx1ZSkge1xuICAgICAgICAgIGNvbnN0IGNvbW1pdG1lbnRGb3JTdGF0dXMgPSBjb21taXRtZW50IHx8ICdmaW5hbGl6ZWQnO1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGNvbmZpcm1hdGlvblN0YXR1c1xuICAgICAgICAgIH0gPSBzaWduYXR1cmVTdGF0dXMudmFsdWU7XG4gICAgICAgICAgc3dpdGNoIChjb21taXRtZW50Rm9yU3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlICdwcm9jZXNzZWQnOlxuICAgICAgICAgICAgY2FzZSAncmVjZW50JzpcbiAgICAgICAgICAgICAgaWYgKGNvbmZpcm1hdGlvblN0YXR1cyAhPT0gJ3Byb2Nlc3NlZCcgJiYgY29uZmlybWF0aW9uU3RhdHVzICE9PSAnY29uZmlybWVkJyAmJiBjb25maXJtYXRpb25TdGF0dXMgIT09ICdmaW5hbGl6ZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRXhwaXJlZE5vbmNlSW52YWxpZEVycm9yKHNpZ25hdHVyZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb25maXJtZWQnOlxuICAgICAgICAgICAgY2FzZSAnc2luZ2xlJzpcbiAgICAgICAgICAgIGNhc2UgJ3NpbmdsZUdvc3NpcCc6XG4gICAgICAgICAgICAgIGlmIChjb25maXJtYXRpb25TdGF0dXMgIT09ICdjb25maXJtZWQnICYmIGNvbmZpcm1hdGlvblN0YXR1cyAhPT0gJ2ZpbmFsaXplZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3Ioc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2ZpbmFsaXplZCc6XG4gICAgICAgICAgICBjYXNlICdtYXgnOlxuICAgICAgICAgICAgY2FzZSAncm9vdCc6XG4gICAgICAgICAgICAgIGlmIChjb25maXJtYXRpb25TdGF0dXMgIT09ICdmaW5hbGl6ZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRXhwaXJlZE5vbmNlSW52YWxpZEVycm9yKHNpZ25hdHVyZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBFeGhhdXN0aXZlIHN3aXRjaC5cbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICAgICAgICAoXyA9PiB7fSkoY29tbWl0bWVudEZvclN0YXR1cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgIGNvbnRleHQ6IHNpZ25hdHVyZVN0YXR1cy5jb250ZXh0LFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgZXJyOiBzaWduYXR1cmVTdGF0dXMudmFsdWUuZXJyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3Ioc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIGFib3J0Q29uZmlybWF0aW9uKCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYXN5bmMgY29uZmlybVRyYW5zYWN0aW9uVXNpbmdMZWdhY3lUaW1lb3V0U3RyYXRlZ3koe1xuICAgIGNvbW1pdG1lbnQsXG4gICAgc2lnbmF0dXJlXG4gIH0pIHtcbiAgICBsZXQgdGltZW91dElkO1xuICAgIGNvbnN0IGV4cGlyeVByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGxldCB0aW1lb3V0TXMgPSB0aGlzLl9jb25maXJtVHJhbnNhY3Rpb25Jbml0aWFsVGltZW91dCB8fCA2MCAqIDEwMDA7XG4gICAgICBzd2l0Y2ggKGNvbW1pdG1lbnQpIHtcbiAgICAgICAgY2FzZSAncHJvY2Vzc2VkJzpcbiAgICAgICAgY2FzZSAncmVjZW50JzpcbiAgICAgICAgY2FzZSAnc2luZ2xlJzpcbiAgICAgICAgY2FzZSAnY29uZmlybWVkJzpcbiAgICAgICAgY2FzZSAnc2luZ2xlR29zc2lwJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aW1lb3V0TXMgPSB0aGlzLl9jb25maXJtVHJhbnNhY3Rpb25Jbml0aWFsVGltZW91dCB8fCAzMCAqIDEwMDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHJlc29sdmUoe1xuICAgICAgICBfX3R5cGU6IFRyYW5zYWN0aW9uU3RhdHVzLlRJTUVEX09VVCxcbiAgICAgICAgdGltZW91dE1zXG4gICAgICB9KSwgdGltZW91dE1zKTtcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBhYm9ydENvbmZpcm1hdGlvbixcbiAgICAgIGNvbmZpcm1hdGlvblByb21pc2VcbiAgICB9ID0gdGhpcy5nZXRUcmFuc2FjdGlvbkNvbmZpcm1hdGlvblByb21pc2Uoe1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIHNpZ25hdHVyZVxuICAgIH0pO1xuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG91dGNvbWUgPSBhd2FpdCBQcm9taXNlLnJhY2UoW2NvbmZpcm1hdGlvblByb21pc2UsIGV4cGlyeVByb21pc2VdKTtcbiAgICAgIGlmIChvdXRjb21lLl9fdHlwZSA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuUFJPQ0VTU0VEKSB7XG4gICAgICAgIHJlc3VsdCA9IG91dGNvbWUucmVzcG9uc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FeHBpcmVkVGltZW91dEVycm9yKHNpZ25hdHVyZSwgb3V0Y29tZS50aW1lb3V0TXMgLyAxMDAwKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICBhYm9ydENvbmZpcm1hdGlvbigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbGlzdCBvZiBub2RlcyB0aGF0IGFyZSBjdXJyZW50bHkgcGFydGljaXBhdGluZyBpbiB0aGUgY2x1c3RlclxuICAgKi9cbiAgYXN5bmMgZ2V0Q2x1c3Rlck5vZGVzKCkge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldENsdXN0ZXJOb2RlcycsIFtdKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KGFycmF5KENvbnRhY3RJbmZvUmVzdWx0KSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGNsdXN0ZXIgbm9kZXMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBsaXN0IG9mIG5vZGVzIHRoYXQgYXJlIGN1cnJlbnRseSBwYXJ0aWNpcGF0aW5nIGluIHRoZSBjbHVzdGVyXG4gICAqL1xuICBhc3luYyBnZXRWb3RlQWNjb3VudHMoY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFZvdGVBY2NvdW50cycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFZvdGVBY2NvdW50cyk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdm90ZSBhY2NvdW50cycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgY3VycmVudCBzbG90IHRoYXQgdGhlIG5vZGUgaXMgcHJvY2Vzc2luZ1xuICAgKi9cbiAgYXN5bmMgZ2V0U2xvdChjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTbG90JywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChudW1iZXIoKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHNsb3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGN1cnJlbnQgc2xvdCBsZWFkZXIgb2YgdGhlIGNsdXN0ZXJcbiAgICovXG4gIGFzeW5jIGdldFNsb3RMZWFkZXIoY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0U2xvdExlYWRlcicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoc3RyaW5nKCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBzbG90IGxlYWRlcicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBgbGltaXRgIG51bWJlciBvZiBzbG90IGxlYWRlcnMgc3RhcnRpbmcgZnJvbSBgc3RhcnRTbG90YFxuICAgKlxuICAgKiBAcGFyYW0gc3RhcnRTbG90IGZldGNoIHNsb3QgbGVhZGVycyBzdGFydGluZyBmcm9tIHRoaXMgc2xvdFxuICAgKiBAcGFyYW0gbGltaXQgbnVtYmVyIG9mIHNsb3QgbGVhZGVycyB0byByZXR1cm5cbiAgICovXG4gIGFzeW5jIGdldFNsb3RMZWFkZXJzKHN0YXJ0U2xvdCwgbGltaXQpIHtcbiAgICBjb25zdCBhcmdzID0gW3N0YXJ0U2xvdCwgbGltaXRdO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFNsb3RMZWFkZXJzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChhcnJheShQdWJsaWNLZXlGcm9tU3RyaW5nKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHNsb3QgbGVhZGVycycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgY3VycmVudCBzdGF0dXMgb2YgYSBzaWduYXR1cmVcbiAgICovXG4gIGFzeW5jIGdldFNpZ25hdHVyZVN0YXR1cyhzaWduYXR1cmUsIGNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB2YWx1ZTogdmFsdWVzXG4gICAgfSA9IGF3YWl0IHRoaXMuZ2V0U2lnbmF0dXJlU3RhdHVzZXMoW3NpZ25hdHVyZV0sIGNvbmZpZyk7XG4gICAgYXNzZXJ0KHZhbHVlcy5sZW5ndGggPT09IDEpO1xuICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICBjb250ZXh0LFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IHN0YXR1c2VzIG9mIGEgYmF0Y2ggb2Ygc2lnbmF0dXJlc1xuICAgKi9cbiAgYXN5bmMgZ2V0U2lnbmF0dXJlU3RhdHVzZXMoc2lnbmF0dXJlcywgY29uZmlnKSB7XG4gICAgY29uc3QgcGFyYW1zID0gW3NpZ25hdHVyZXNdO1xuICAgIGlmIChjb25maWcpIHtcbiAgICAgIHBhcmFtcy5wdXNoKGNvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFNpZ25hdHVyZVN0YXR1c2VzJywgcGFyYW1zKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRTaWduYXR1cmVTdGF0dXNlc1JwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgc2lnbmF0dXJlIHN0YXR1cycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgY3VycmVudCB0cmFuc2FjdGlvbiBjb3VudCBvZiB0aGUgY2x1c3RlclxuICAgKi9cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25Db3VudChjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUcmFuc2FjdGlvbkNvdW50JywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChudW1iZXIoKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHRyYW5zYWN0aW9uIGNvdW50Jyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IHRvdGFsIGN1cnJlbmN5IHN1cHBseSBvZiB0aGUgY2x1c3RlciBpbiBsYW1wb3J0c1xuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS4yLjguIFBsZWFzZSB1c2Uge0BsaW5rIGdldFN1cHBseX0gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldFRvdGFsU3VwcGx5KGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmdldFN1cHBseSh7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgZXhjbHVkZU5vbkNpcmN1bGF0aW5nQWNjb3VudHNMaXN0OiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdC52YWx1ZS50b3RhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgY2x1c3RlciBJbmZsYXRpb25Hb3Zlcm5vciBwYXJhbWV0ZXJzXG4gICAqL1xuICBhc3luYyBnZXRJbmZsYXRpb25Hb3Zlcm5vcihjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0SW5mbGF0aW9uR292ZXJub3InLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRJbmZsYXRpb25Hb3Zlcm5vclJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgaW5mbGF0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBpbmZsYXRpb24gcmV3YXJkIGZvciBhIGxpc3Qgb2YgYWRkcmVzc2VzIGZvciBhbiBlcG9jaFxuICAgKi9cbiAgYXN5bmMgZ2V0SW5mbGF0aW9uUmV3YXJkKGFkZHJlc3NlcywgZXBvY2gsIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbYWRkcmVzc2VzLm1hcChwdWJrZXkgPT4gcHVia2V5LnRvQmFzZTU4KCkpXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCB7XG4gICAgICAuLi5jb25maWcsXG4gICAgICBlcG9jaDogZXBvY2ggIT0gbnVsbCA/IGVwb2NoIDogY29uZmlnPy5lcG9jaFxuICAgIH0pO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEluZmxhdGlvblJld2FyZCcsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEluZmxhdGlvblJld2FyZFJlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgaW5mbGF0aW9uIHJld2FyZCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgc3BlY2lmaWMgaW5mbGF0aW9uIHZhbHVlcyBmb3IgdGhlIGN1cnJlbnQgZXBvY2hcbiAgICovXG4gIGFzeW5jIGdldEluZmxhdGlvblJhdGUoKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0SW5mbGF0aW9uUmF0ZScsIFtdKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRJbmZsYXRpb25SYXRlUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBpbmZsYXRpb24gcmF0ZScpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgRXBvY2ggSW5mbyBwYXJhbWV0ZXJzXG4gICAqL1xuICBhc3luYyBnZXRFcG9jaEluZm8oY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0RXBvY2hJbmZvJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0RXBvY2hJbmZvUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBlcG9jaCBpbmZvJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBFcG9jaCBTY2hlZHVsZSBwYXJhbWV0ZXJzXG4gICAqL1xuICBhc3luYyBnZXRFcG9jaFNjaGVkdWxlKCkge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEVwb2NoU2NoZWR1bGUnLCBbXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0RXBvY2hTY2hlZHVsZVJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgZXBvY2ggc2NoZWR1bGUnKTtcbiAgICB9XG4gICAgY29uc3QgZXBvY2hTY2hlZHVsZSA9IHJlcy5yZXN1bHQ7XG4gICAgcmV0dXJuIG5ldyBFcG9jaFNjaGVkdWxlKGVwb2NoU2NoZWR1bGUuc2xvdHNQZXJFcG9jaCwgZXBvY2hTY2hlZHVsZS5sZWFkZXJTY2hlZHVsZVNsb3RPZmZzZXQsIGVwb2NoU2NoZWR1bGUud2FybXVwLCBlcG9jaFNjaGVkdWxlLmZpcnN0Tm9ybWFsRXBvY2gsIGVwb2NoU2NoZWR1bGUuZmlyc3ROb3JtYWxTbG90KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgbGVhZGVyIHNjaGVkdWxlIGZvciB0aGUgY3VycmVudCBlcG9jaFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFJwY1Jlc3BvbnNlQW5kQ29udGV4dDxMZWFkZXJTY2hlZHVsZT4+fVxuICAgKi9cbiAgYXN5bmMgZ2V0TGVhZGVyU2NoZWR1bGUoKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0TGVhZGVyU2NoZWR1bGUnLCBbXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0TGVhZGVyU2NoZWR1bGVScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGxlYWRlciBzY2hlZHVsZScpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgbWluaW11bSBiYWxhbmNlIG5lZWRlZCB0byBleGVtcHQgYW4gYWNjb3VudCBvZiBgZGF0YUxlbmd0aGBcbiAgICogc2l6ZSBmcm9tIHJlbnRcbiAgICovXG4gIGFzeW5jIGdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvbihkYXRhTGVuZ3RoLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbZGF0YUxlbmd0aF0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvblJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1VuYWJsZSB0byBmZXRjaCBtaW5pbXVtIGJhbGFuY2UgZm9yIHJlbnQgZXhlbXB0aW9uJyk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSByZWNlbnQgYmxvY2toYXNoIGZyb20gdGhlIGNsdXN0ZXIsIHJldHVybiB3aXRoIGNvbnRleHRcbiAgICogQHJldHVybiB7UHJvbWlzZTxScGNSZXNwb25zZUFuZENvbnRleHQ8e2Jsb2NraGFzaDogQmxvY2toYXNoLCBmZWVDYWxjdWxhdG9yOiBGZWVDYWxjdWxhdG9yfT4+fVxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS45LjAuIFBsZWFzZSB1c2Uge0BsaW5rIGdldExhdGVzdEJsb2NraGFzaH0gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldFJlY2VudEJsb2NraGFzaEFuZENvbnRleHQoY29tbWl0bWVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB2YWx1ZToge1xuICAgICAgICBibG9ja2hhc2hcbiAgICAgIH1cbiAgICB9ID0gYXdhaXQgdGhpcy5nZXRMYXRlc3RCbG9ja2hhc2hBbmRDb250ZXh0KGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IGZlZUNhbGN1bGF0b3IgPSB7XG4gICAgICBnZXQgbGFtcG9ydHNQZXJTaWduYXR1cmUoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGNhcGFiaWxpdHkgdG8gZmV0Y2ggYGxhbXBvcnRzUGVyU2lnbmF0dXJlYCB1c2luZyB0aGUgYGdldFJlY2VudEJsb2NraGFzaGAgQVBJIGlzICcgKyAnbm8gbG9uZ2VyIG9mZmVyZWQgYnkgdGhlIG5ldHdvcmsuIFVzZSB0aGUgYGdldEZlZUZvck1lc3NhZ2VgIEFQSSB0byBvYnRhaW4gdGhlIGZlZSAnICsgJ2ZvciBhIGdpdmVuIG1lc3NhZ2UuJyk7XG4gICAgICB9LFxuICAgICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIGJsb2NraGFzaCxcbiAgICAgICAgZmVlQ2FsY3VsYXRvclxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggcmVjZW50IHBlcmZvcm1hbmNlIHNhbXBsZXNcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxQZXJmU2FtcGxlPj59XG4gICAqL1xuICBhc3luYyBnZXRSZWNlbnRQZXJmb3JtYW5jZVNhbXBsZXMobGltaXQpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRSZWNlbnRQZXJmb3JtYW5jZVNhbXBsZXMnLCBsaW1pdCA/IFtsaW1pdF0gOiBbXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UmVjZW50UGVyZm9ybWFuY2VTYW1wbGVzUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCByZWNlbnQgcGVyZm9ybWFuY2Ugc2FtcGxlcycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgZmVlIGNhbGN1bGF0b3IgZm9yIGEgcmVjZW50IGJsb2NraGFzaCBmcm9tIHRoZSBjbHVzdGVyLCByZXR1cm4gd2l0aCBjb250ZXh0XG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjkuMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0RmVlRm9yTWVzc2FnZX0gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldEZlZUNhbGN1bGF0b3JGb3JCbG9ja2hhc2goYmxvY2toYXNoLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbYmxvY2toYXNoXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0RmVlQ2FsY3VsYXRvckZvckJsb2NraGFzaCcsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEZlZUNhbGN1bGF0b3JScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGZlZSBjYWxjdWxhdG9yJyk7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB2YWx1ZVxuICAgIH0gPSByZXMucmVzdWx0O1xuICAgIHJldHVybiB7XG4gICAgICBjb250ZXh0LFxuICAgICAgdmFsdWU6IHZhbHVlICE9PSBudWxsID8gdmFsdWUuZmVlQ2FsY3VsYXRvciA6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBmZWUgZm9yIGEgbWVzc2FnZSBmcm9tIHRoZSBjbHVzdGVyLCByZXR1cm4gd2l0aCBjb250ZXh0XG4gICAqL1xuICBhc3luYyBnZXRGZWVGb3JNZXNzYWdlKG1lc3NhZ2UsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCB3aXJlTWVzc2FnZSA9IHRvQnVmZmVyKG1lc3NhZ2Uuc2VyaWFsaXplKCkpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFt3aXJlTWVzc2FnZV0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEZlZUZvck1lc3NhZ2UnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChudWxsYWJsZShudW1iZXIoKSkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBmZWUgZm9yIG1lc3NhZ2UnKTtcbiAgICB9XG4gICAgaWYgKHJlcy5yZXN1bHQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBibG9ja2hhc2gnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSBsaXN0IG9mIHByaW9yaXRpemF0aW9uIGZlZXMgZnJvbSByZWNlbnQgYmxvY2tzLlxuICAgKi9cbiAgYXN5bmMgZ2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzKGNvbmZpZykge1xuICAgIGNvbnN0IGFjY291bnRzID0gY29uZmlnPy5sb2NrZWRXcml0YWJsZUFjY291bnRzPy5tYXAoa2V5ID0+IGtleS50b0Jhc2U1OCgpKTtcbiAgICBjb25zdCBhcmdzID0gYWNjb3VudHM/Lmxlbmd0aCA/IFthY2NvdW50c10gOiBbXTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXMnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHJlY2VudCBwcmlvcml0aXphdGlvbiBmZWVzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBhIHJlY2VudCBibG9ja2hhc2ggZnJvbSB0aGUgY2x1c3RlclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPHtibG9ja2hhc2g6IEJsb2NraGFzaCwgZmVlQ2FsY3VsYXRvcjogRmVlQ2FsY3VsYXRvcn0+fVxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS44LjAuIFBsZWFzZSB1c2Uge0BsaW5rIGdldExhdGVzdEJsb2NraGFzaH0gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldFJlY2VudEJsb2NraGFzaChjb21taXRtZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZ2V0UmVjZW50QmxvY2toYXNoQW5kQ29udGV4dChjb21taXRtZW50KTtcbiAgICAgIHJldHVybiByZXMudmFsdWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gZ2V0IHJlY2VudCBibG9ja2hhc2g6ICcgKyBlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGxhdGVzdCBibG9ja2hhc2ggZnJvbSB0aGUgY2x1c3RlclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEJsb2NraGFzaFdpdGhFeHBpcnlCbG9ja0hlaWdodD59XG4gICAqL1xuICBhc3luYyBnZXRMYXRlc3RCbG9ja2hhc2goY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZ2V0TGF0ZXN0QmxvY2toYXNoQW5kQ29udGV4dChjb21taXRtZW50T3JDb25maWcpO1xuICAgICAgcmV0dXJuIHJlcy52YWx1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBnZXQgcmVjZW50IGJsb2NraGFzaDogJyArIGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgbGF0ZXN0IGJsb2NraGFzaCBmcm9tIHRoZSBjbHVzdGVyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QmxvY2toYXNoV2l0aEV4cGlyeUJsb2NrSGVpZ2h0Pn1cbiAgICovXG4gIGFzeW5jIGdldExhdGVzdEJsb2NraGFzaEFuZENvbnRleHQoY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0TGF0ZXN0QmxvY2toYXNoJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0TGF0ZXN0QmxvY2toYXNoUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBsYXRlc3QgYmxvY2toYXNoJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBhIGJsb2NraGFzaCBpcyBzdGlsbCB2YWxpZCBvciBub3RcbiAgICovXG4gIGFzeW5jIGlzQmxvY2toYXNoVmFsaWQoYmxvY2toYXNoLCByYXdDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhyYXdDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW2Jsb2NraGFzaF0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdpc0Jsb2NraGFzaFZhbGlkJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgSXNCbG9ja2hhc2hWYWxpZFJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBkZXRlcm1pbmUgaWYgdGhlIGJsb2NraGFzaCBgJyArIGJsb2NraGFzaCArICdgaXMgdmFsaWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIG5vZGUgdmVyc2lvblxuICAgKi9cbiAgYXN5bmMgZ2V0VmVyc2lvbigpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRWZXJzaW9uJywgW10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoVmVyc2lvblJlc3VsdCkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHZlcnNpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGdlbmVzaXMgaGFzaFxuICAgKi9cbiAgYXN5bmMgZ2V0R2VuZXNpc0hhc2goKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0R2VuZXNpc0hhc2gnLCBbXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChzdHJpbmcoKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGdlbmVzaXMgaGFzaCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIHByb2Nlc3NlZCBibG9jayBmcm9tIHRoZSBjbHVzdGVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBjYWxsIGBnZXRCbG9ja2AgdXNpbmcgYSBgR2V0VmVyc2lvbmVkQmxvY2tDb25maWdgIGJ5XG4gICAqIHNldHRpbmcgdGhlIGBtYXhTdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25gIHByb3BlcnR5LlxuICAgKi9cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCBgZ2V0QmxvY2tgIHVzaW5nIGEgYEdldFZlcnNpb25lZEJsb2NrQ29uZmlnYCBieVxuICAgKiBzZXR0aW5nIHRoZSBgbWF4U3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9uYCBwcm9wZXJ0eS5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCBgZ2V0QmxvY2tgIHVzaW5nIGEgYEdldFZlcnNpb25lZEJsb2NrQ29uZmlnYCBieVxuICAgKiBzZXR0aW5nIHRoZSBgbWF4U3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9uYCBwcm9wZXJ0eS5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvKipcbiAgICogRmV0Y2ggYSBwcm9jZXNzZWQgYmxvY2sgZnJvbSB0aGUgY2x1c3Rlci5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8qKlxuICAgKiBGZXRjaCBhIHByb2Nlc3NlZCBibG9jayBmcm9tIHRoZSBjbHVzdGVyLlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBhc3luYyBnZXRCbG9jayhzbG90LCByYXdDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhyYXdDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzbG90XSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEJsb2NrJywgYXJncyk7XG4gICAgdHJ5IHtcbiAgICAgIHN3aXRjaCAoY29uZmlnPy50cmFuc2FjdGlvbkRldGFpbHMpIHtcbiAgICAgICAgY2FzZSAnYWNjb3VudHMnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEFjY291bnRzTW9kZUJsb2NrUnBjUmVzdWx0KTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICAgICAgICB0aHJvdyByZXMuZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ25vbmUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldE5vbmVNb2RlQmxvY2tScGNSZXN1bHQpO1xuICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgICAgICAgIHRocm93IHJlcy5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRCbG9ja1JwY1Jlc3VsdCk7XG4gICAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgcmVzLmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICByZXN1bHRcbiAgICAgICAgICAgIH0gPSByZXM7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ID8ge1xuICAgICAgICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgICAgICAgIHRyYW5zYWN0aW9uczogcmVzdWx0LnRyYW5zYWN0aW9ucy5tYXAoKHtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICBtZXRhLFxuICAgICAgICAgICAgICAgIHZlcnNpb25cbiAgICAgICAgICAgICAgfSkgPT4gKHtcbiAgICAgICAgICAgICAgICBtZXRhLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAuLi50cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHZlcnNpb25lZE1lc3NhZ2VGcm9tUmVzcG9uc2UodmVyc2lvbiwgdHJhbnNhY3Rpb24ubWVzc2FnZSlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHZlcnNpb25cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICB9IDogbnVsbDtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihlLCAnZmFpbGVkIHRvIGdldCBjb25maXJtZWQgYmxvY2snKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggcGFyc2VkIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgY29uZmlybWVkIG9yIGZpbmFsaXplZCBibG9ja1xuICAgKi9cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgYXN5bmMgZ2V0UGFyc2VkQmxvY2soc2xvdCwgcmF3Q29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcocmF3Q29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2xvdF0sIGNvbW1pdG1lbnQsICdqc29uUGFyc2VkJywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCbG9jaycsIGFyZ3MpO1xuICAgIHRyeSB7XG4gICAgICBzd2l0Y2ggKGNvbmZpZz8udHJhbnNhY3Rpb25EZXRhaWxzKSB7XG4gICAgICAgIGNhc2UgJ2FjY291bnRzJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRBY2NvdW50c01vZGVCbG9ja1JwY1Jlc3VsdCk7XG4gICAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgcmVzLmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWROb25lTW9kZUJsb2NrUnBjUmVzdWx0KTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICAgICAgICB0aHJvdyByZXMuZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UGFyc2VkQmxvY2tScGNSZXN1bHQpO1xuICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgICAgICAgIHRocm93IHJlcy5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKGUsICdmYWlsZWQgdG8gZ2V0IGJsb2NrJyk7XG4gICAgfVxuICB9XG4gIC8qXG4gICAqIFJldHVybnMgcmVjZW50IGJsb2NrIHByb2R1Y3Rpb24gaW5mb3JtYXRpb24gZnJvbSB0aGUgY3VycmVudCBvciBwcmV2aW91cyBlcG9jaFxuICAgKi9cbiAgYXN5bmMgZ2V0QmxvY2tQcm9kdWN0aW9uKGNvbmZpZ09yQ29tbWl0bWVudCkge1xuICAgIGxldCBleHRyYTtcbiAgICBsZXQgY29tbWl0bWVudDtcbiAgICBpZiAodHlwZW9mIGNvbmZpZ09yQ29tbWl0bWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbW1pdG1lbnQgPSBjb25maWdPckNvbW1pdG1lbnQ7XG4gICAgfSBlbHNlIGlmIChjb25maWdPckNvbW1pdG1lbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29tbWl0bWVudDogYyxcbiAgICAgICAgLi4ucmVzdFxuICAgICAgfSA9IGNvbmZpZ09yQ29tbWl0bWVudDtcbiAgICAgIGNvbW1pdG1lbnQgPSBjO1xuICAgICAgZXh0cmEgPSByZXN0O1xuICAgIH1cbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50LCAnYmFzZTY0JywgZXh0cmEpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEJsb2NrUHJvZHVjdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEJsb2NrUHJvZHVjdGlvblJlc3BvbnNlU3RydWN0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBibG9jayBwcm9kdWN0aW9uIGluZm9ybWF0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgY29uZmlybWVkIG9yIGZpbmFsaXplZCB0cmFuc2FjdGlvbiBmcm9tIHRoZSBjbHVzdGVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBjYWxsIGBnZXRUcmFuc2FjdGlvbmAgdXNpbmcgYVxuICAgKiBgR2V0VmVyc2lvbmVkVHJhbnNhY3Rpb25Db25maWdgIGJ5IHNldHRpbmcgdGhlXG4gICAqIGBtYXhTdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25gIHByb3BlcnR5LlxuICAgKi9cblxuICAvKipcbiAgICogRmV0Y2ggYSBjb25maXJtZWQgb3IgZmluYWxpemVkIHRyYW5zYWN0aW9uIGZyb20gdGhlIGNsdXN0ZXIuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLyoqXG4gICAqIEZldGNoIGEgY29uZmlybWVkIG9yIGZpbmFsaXplZCB0cmFuc2FjdGlvbiBmcm9tIHRoZSBjbHVzdGVyLlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBhc3luYyBnZXRUcmFuc2FjdGlvbihzaWduYXR1cmUsIHJhd0NvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKHJhd0NvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3NpZ25hdHVyZV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUcmFuc2FjdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFRyYW5zYWN0aW9uUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0cmFuc2FjdGlvbicpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSByZXMucmVzdWx0O1xuICAgIGlmICghcmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXN1bHQsXG4gICAgICB0cmFuc2FjdGlvbjoge1xuICAgICAgICAuLi5yZXN1bHQudHJhbnNhY3Rpb24sXG4gICAgICAgIG1lc3NhZ2U6IHZlcnNpb25lZE1lc3NhZ2VGcm9tUmVzcG9uc2UocmVzdWx0LnZlcnNpb24sIHJlc3VsdC50cmFuc2FjdGlvbi5tZXNzYWdlKVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggcGFyc2VkIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgY29uZmlybWVkIG9yIGZpbmFsaXplZCB0cmFuc2FjdGlvblxuICAgKi9cbiAgYXN5bmMgZ2V0UGFyc2VkVHJhbnNhY3Rpb24oc2lnbmF0dXJlLCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzaWduYXR1cmVdLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcsIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VHJhbnNhY3Rpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggcGFyc2VkIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgYmF0Y2ggb2YgY29uZmlybWVkIHRyYW5zYWN0aW9uc1xuICAgKi9cbiAgYXN5bmMgZ2V0UGFyc2VkVHJhbnNhY3Rpb25zKHNpZ25hdHVyZXMsIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYmF0Y2ggPSBzaWduYXR1cmVzLm1hcChzaWduYXR1cmUgPT4ge1xuICAgICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3NpZ25hdHVyZV0sIGNvbW1pdG1lbnQsICdqc29uUGFyc2VkJywgY29uZmlnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1ldGhvZE5hbWU6ICdnZXRUcmFuc2FjdGlvbicsXG4gICAgICAgIGFyZ3NcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjQmF0Y2hSZXF1ZXN0KGJhdGNoKTtcbiAgICBjb25zdCByZXMgPSB1bnNhZmVSZXMubWFwKHVuc2FmZVJlcyA9PiB7XG4gICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHRyYW5zYWN0aW9ucycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGJhdGNoIG9mIGNvbmZpcm1lZCB0cmFuc2FjdGlvbnMuXG4gICAqIFNpbWlsYXIgdG8ge0BsaW5rIGdldFBhcnNlZFRyYW5zYWN0aW9uc30gYnV0IHJldHVybnMgYSB7QGxpbmsgVHJhbnNhY3Rpb25SZXNwb25zZX0uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwgYGdldFRyYW5zYWN0aW9uc2AgdXNpbmcgYVxuICAgKiBgR2V0VmVyc2lvbmVkVHJhbnNhY3Rpb25Db25maWdgIGJ5IHNldHRpbmcgdGhlXG4gICAqIGBtYXhTdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25gIHByb3BlcnR5LlxuICAgKi9cblxuICAvKipcbiAgICogRmV0Y2ggdHJhbnNhY3Rpb24gZGV0YWlscyBmb3IgYSBiYXRjaCBvZiBjb25maXJtZWQgdHJhbnNhY3Rpb25zLlxuICAgKiBTaW1pbGFyIHRvIHtAbGluayBnZXRQYXJzZWRUcmFuc2FjdGlvbnN9IGJ1dCByZXR1cm5zIGEge0BsaW5rXG4gICAqIFZlcnNpb25lZFRyYW5zYWN0aW9uUmVzcG9uc2V9LlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8qKlxuICAgKiBGZXRjaCB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGJhdGNoIG9mIGNvbmZpcm1lZCB0cmFuc2FjdGlvbnMuXG4gICAqIFNpbWlsYXIgdG8ge0BsaW5rIGdldFBhcnNlZFRyYW5zYWN0aW9uc30gYnV0IHJldHVybnMgYSB7QGxpbmtcbiAgICogVmVyc2lvbmVkVHJhbnNhY3Rpb25SZXNwb25zZX0uXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIGdldFRyYW5zYWN0aW9ucyhzaWduYXR1cmVzLCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGJhdGNoID0gc2lnbmF0dXJlcy5tYXAoc2lnbmF0dXJlID0+IHtcbiAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzaWduYXR1cmVdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZXRob2ROYW1lOiAnZ2V0VHJhbnNhY3Rpb24nLFxuICAgICAgICBhcmdzXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY0JhdGNoUmVxdWVzdChiYXRjaCk7XG4gICAgY29uc3QgcmVzID0gdW5zYWZlUmVzLm1hcCh1bnNhZmVSZXMgPT4ge1xuICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0VHJhbnNhY3Rpb25ScGNSZXN1bHQpO1xuICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0cmFuc2FjdGlvbnMnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHJlcy5yZXN1bHQ7XG4gICAgICBpZiAoIXJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICAuLi5yZXN1bHQudHJhbnNhY3Rpb24sXG4gICAgICAgICAgbWVzc2FnZTogdmVyc2lvbmVkTWVzc2FnZUZyb21SZXNwb25zZShyZXN1bHQudmVyc2lvbiwgcmVzdWx0LnRyYW5zYWN0aW9uLm1lc3NhZ2UpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIGxpc3Qgb2YgVHJhbnNhY3Rpb25zIGFuZCB0cmFuc2FjdGlvbiBzdGF0dXNlcyBmcm9tIHRoZSBjbHVzdGVyXG4gICAqIGZvciBhIGNvbmZpcm1lZCBibG9jay5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuNy4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRCbG9ja30gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldENvbmZpcm1lZEJsb2NrKHNsb3QsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2xvdF0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEJsb2NrJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0Q29uZmlybWVkQmxvY2tScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGNvbmZpcm1lZCBibG9jaycpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSByZXMucmVzdWx0O1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbmZpcm1lZCBibG9jayAnICsgc2xvdCArICcgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIGNvbnN0IGJsb2NrID0ge1xuICAgICAgLi4ucmVzdWx0LFxuICAgICAgdHJhbnNhY3Rpb25zOiByZXN1bHQudHJhbnNhY3Rpb25zLm1hcCgoe1xuICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgbWV0YVxuICAgICAgfSkgPT4ge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gbmV3IE1lc3NhZ2UodHJhbnNhY3Rpb24ubWVzc2FnZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWV0YSxcbiAgICAgICAgICB0cmFuc2FjdGlvbjoge1xuICAgICAgICAgICAgLi4udHJhbnNhY3Rpb24sXG4gICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAuLi5ibG9jayxcbiAgICAgIHRyYW5zYWN0aW9uczogYmxvY2sudHJhbnNhY3Rpb25zLm1hcCgoe1xuICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgbWV0YVxuICAgICAgfSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1ldGEsXG4gICAgICAgICAgdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uLnBvcHVsYXRlKHRyYW5zYWN0aW9uLm1lc3NhZ2UsIHRyYW5zYWN0aW9uLnNpZ25hdHVyZXMpXG4gICAgICAgIH07XG4gICAgICB9KVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggY29uZmlybWVkIGJsb2NrcyBiZXR3ZWVuIHR3byBzbG90c1xuICAgKi9cbiAgYXN5bmMgZ2V0QmxvY2tzKHN0YXJ0U2xvdCwgZW5kU2xvdCwgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKGVuZFNsb3QgIT09IHVuZGVmaW5lZCA/IFtzdGFydFNsb3QsIGVuZFNsb3RdIDogW3N0YXJ0U2xvdF0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEJsb2NrcycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoYXJyYXkobnVtYmVyKCkpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgYmxvY2tzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgbGlzdCBvZiBTaWduYXR1cmVzIGZyb20gdGhlIGNsdXN0ZXIgZm9yIGEgYmxvY2ssIGV4Y2x1ZGluZyByZXdhcmRzXG4gICAqL1xuICBhc3luYyBnZXRCbG9ja1NpZ25hdHVyZXMoc2xvdCwgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzbG90XSwgY29tbWl0bWVudCwgdW5kZWZpbmVkLCB7XG4gICAgICB0cmFuc2FjdGlvbkRldGFpbHM6ICdzaWduYXR1cmVzJyxcbiAgICAgIHJld2FyZHM6IGZhbHNlXG4gICAgfSk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2snLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRCbG9ja1NpZ25hdHVyZXNScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGJsb2NrJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHJlcy5yZXN1bHQ7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQmxvY2sgJyArIHNsb3QgKyAnIG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgbGlzdCBvZiBTaWduYXR1cmVzIGZyb20gdGhlIGNsdXN0ZXIgZm9yIGEgY29uZmlybWVkIGJsb2NrLCBleGNsdWRpbmcgcmV3YXJkc1xuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS43LjAuIFBsZWFzZSB1c2Uge0BsaW5rIGdldEJsb2NrU2lnbmF0dXJlc30gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldENvbmZpcm1lZEJsb2NrU2lnbmF0dXJlcyhzbG90LCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3Nsb3RdLCBjb21taXRtZW50LCB1bmRlZmluZWQsIHtcbiAgICAgIHRyYW5zYWN0aW9uRGV0YWlsczogJ3NpZ25hdHVyZXMnLFxuICAgICAgcmV3YXJkczogZmFsc2VcbiAgICB9KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCbG9jaycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEJsb2NrU2lnbmF0dXJlc1JwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgY29uZmlybWVkIGJsb2NrJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHJlcy5yZXN1bHQ7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ29uZmlybWVkIGJsb2NrICcgKyBzbG90ICsgJyBub3QgZm91bmQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgY29uZmlybWVkIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjcuMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0VHJhbnNhY3Rpb259IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRDb25maXJtZWRUcmFuc2FjdGlvbihzaWduYXR1cmUsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2lnbmF0dXJlXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VHJhbnNhY3Rpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gcmVzLnJlc3VsdDtcbiAgICBpZiAoIXJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICBjb25zdCBtZXNzYWdlID0gbmV3IE1lc3NhZ2UocmVzdWx0LnRyYW5zYWN0aW9uLm1lc3NhZ2UpO1xuICAgIGNvbnN0IHNpZ25hdHVyZXMgPSByZXN1bHQudHJhbnNhY3Rpb24uc2lnbmF0dXJlcztcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzdWx0LFxuICAgICAgdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uLnBvcHVsYXRlKG1lc3NhZ2UsIHNpZ25hdHVyZXMpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBwYXJzZWQgdHJhbnNhY3Rpb24gZGV0YWlscyBmb3IgYSBjb25maXJtZWQgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuNy4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRQYXJzZWRUcmFuc2FjdGlvbn0gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uKHNpZ25hdHVyZSwgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzaWduYXR1cmVdLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRyYW5zYWN0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UGFyc2VkVHJhbnNhY3Rpb25ScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGNvbmZpcm1lZCB0cmFuc2FjdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBwYXJzZWQgdHJhbnNhY3Rpb24gZGV0YWlscyBmb3IgYSBiYXRjaCBvZiBjb25maXJtZWQgdHJhbnNhY3Rpb25zXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjcuMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0UGFyc2VkVHJhbnNhY3Rpb25zfSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0UGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25zKHNpZ25hdHVyZXMsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBiYXRjaCA9IHNpZ25hdHVyZXMubWFwKHNpZ25hdHVyZSA9PiB7XG4gICAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2lnbmF0dXJlXSwgY29tbWl0bWVudCwgJ2pzb25QYXJzZWQnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1ldGhvZE5hbWU6ICdnZXRUcmFuc2FjdGlvbicsXG4gICAgICAgIGFyZ3NcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjQmF0Y2hSZXF1ZXN0KGJhdGNoKTtcbiAgICBjb25zdCByZXMgPSB1bnNhZmVSZXMubWFwKHVuc2FmZVJlcyA9PiB7XG4gICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGNvbmZpcm1lZCB0cmFuc2FjdGlvbnMnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSBsaXN0IG9mIGFsbCB0aGUgY29uZmlybWVkIHNpZ25hdHVyZXMgZm9yIHRyYW5zYWN0aW9ucyBpbnZvbHZpbmcgYW4gYWRkcmVzc1xuICAgKiB3aXRoaW4gYSBzcGVjaWZpZWQgc2xvdCByYW5nZS4gTWF4IHJhbmdlIGFsbG93ZWQgaXMgMTAsMDAwIHNsb3RzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS4zLiBQbGVhc2UgdXNlIHtAbGluayBnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczJ9IGluc3RlYWQuXG4gICAqXG4gICAqIEBwYXJhbSBhZGRyZXNzIHF1ZXJpZWQgYWRkcmVzc1xuICAgKiBAcGFyYW0gc3RhcnRTbG90IHN0YXJ0IHNsb3QsIGluY2x1c2l2ZVxuICAgKiBAcGFyYW0gZW5kU2xvdCBlbmQgc2xvdCwgaW5jbHVzaXZlXG4gICAqL1xuICBhc3luYyBnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzcyhhZGRyZXNzLCBzdGFydFNsb3QsIGVuZFNsb3QpIHtcbiAgICBsZXQgb3B0aW9ucyA9IHt9O1xuICAgIGxldCBmaXJzdEF2YWlsYWJsZUJsb2NrID0gYXdhaXQgdGhpcy5nZXRGaXJzdEF2YWlsYWJsZUJsb2NrKCk7XG4gICAgd2hpbGUgKCEoJ3VudGlsJyBpbiBvcHRpb25zKSkge1xuICAgICAgc3RhcnRTbG90LS07XG4gICAgICBpZiAoc3RhcnRTbG90IDw9IDAgfHwgc3RhcnRTbG90IDwgZmlyc3RBdmFpbGFibGVCbG9jaykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgdGhpcy5nZXRDb25maXJtZWRCbG9ja1NpZ25hdHVyZXMoc3RhcnRTbG90LCAnZmluYWxpemVkJyk7XG4gICAgICAgIGlmIChibG9jay5zaWduYXR1cmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBvcHRpb25zLnVudGlsID0gYmxvY2suc2lnbmF0dXJlc1tibG9jay5zaWduYXR1cmVzLmxlbmd0aCAtIDFdLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyLm1lc3NhZ2UuaW5jbHVkZXMoJ3NraXBwZWQnKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsZXQgaGlnaGVzdENvbmZpcm1lZFJvb3QgPSBhd2FpdCB0aGlzLmdldFNsb3QoJ2ZpbmFsaXplZCcpO1xuICAgIHdoaWxlICghKCdiZWZvcmUnIGluIG9wdGlvbnMpKSB7XG4gICAgICBlbmRTbG90Kys7XG4gICAgICBpZiAoZW5kU2xvdCA+IGhpZ2hlc3RDb25maXJtZWRSb290KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLmdldENvbmZpcm1lZEJsb2NrU2lnbmF0dXJlcyhlbmRTbG90KTtcbiAgICAgICAgaWYgKGJsb2NrLnNpZ25hdHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIG9wdGlvbnMuYmVmb3JlID0gYmxvY2suc2lnbmF0dXJlc1tibG9jay5zaWduYXR1cmVzLmxlbmd0aCAtIDFdLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyLm1lc3NhZ2UuaW5jbHVkZXMoJ3NraXBwZWQnKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjb25maXJtZWRTaWduYXR1cmVJbmZvID0gYXdhaXQgdGhpcy5nZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczIoYWRkcmVzcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGNvbmZpcm1lZFNpZ25hdHVyZUluZm8ubWFwKGluZm8gPT4gaW5mby5zaWduYXR1cmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgY29uZmlybWVkIHNpZ25hdHVyZXMgZm9yIHRyYW5zYWN0aW9ucyBpbnZvbHZpbmcgYW5cbiAgICogYWRkcmVzcyBiYWNrd2FyZHMgaW4gdGltZSBmcm9tIHRoZSBwcm92aWRlZCBzaWduYXR1cmUgb3IgbW9zdCByZWNlbnQgY29uZmlybWVkIGJsb2NrXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjcuMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0U2lnbmF0dXJlc0ZvckFkZHJlc3N9IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczIoYWRkcmVzcywgb3B0aW9ucywgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFthZGRyZXNzLnRvQmFzZTU4KCldLCBjb21taXRtZW50LCB1bmRlZmluZWQsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMlJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgY29uZmlybWVkIHNpZ25hdHVyZXMgZm9yIGFkZHJlc3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBjb25maXJtZWQgc2lnbmF0dXJlcyBmb3IgdHJhbnNhY3Rpb25zIGludm9sdmluZyBhblxuICAgKiBhZGRyZXNzIGJhY2t3YXJkcyBpbiB0aW1lIGZyb20gdGhlIHByb3ZpZGVkIHNpZ25hdHVyZSBvciBtb3N0IHJlY2VudCBjb25maXJtZWQgYmxvY2tcbiAgICpcbiAgICpcbiAgICogQHBhcmFtIGFkZHJlc3MgcXVlcmllZCBhZGRyZXNzXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqL1xuICBhc3luYyBnZXRTaWduYXR1cmVzRm9yQWRkcmVzcyhhZGRyZXNzLCBvcHRpb25zLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW2FkZHJlc3MudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0U2lnbmF0dXJlc0ZvckFkZHJlc3MnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRTaWduYXR1cmVzRm9yQWRkcmVzc1JwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgc2lnbmF0dXJlcyBmb3IgYWRkcmVzcycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuICBhc3luYyBnZXRBZGRyZXNzTG9va3VwVGFibGUoYWNjb3VudEtleSwgY29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZhbHVlOiBhY2NvdW50SW5mb1xuICAgIH0gPSBhd2FpdCB0aGlzLmdldEFjY291bnRJbmZvQW5kQ29udGV4dChhY2NvdW50S2V5LCBjb25maWcpO1xuICAgIGxldCB2YWx1ZSA9IG51bGw7XG4gICAgaWYgKGFjY291bnRJbmZvICE9PSBudWxsKSB7XG4gICAgICB2YWx1ZSA9IG5ldyBBZGRyZXNzTG9va3VwVGFibGVBY2NvdW50KHtcbiAgICAgICAga2V5OiBhY2NvdW50S2V5LFxuICAgICAgICBzdGF0ZTogQWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudC5kZXNlcmlhbGl6ZShhY2NvdW50SW5mby5kYXRhKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBjb250ZXh0LFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjb250ZW50cyBvZiBhIE5vbmNlIGFjY291bnQgZnJvbSB0aGUgY2x1c3RlciwgcmV0dXJuIHdpdGggY29udGV4dFxuICAgKi9cbiAgYXN5bmMgZ2V0Tm9uY2VBbmRDb250ZXh0KG5vbmNlQWNjb3VudCwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZhbHVlOiBhY2NvdW50SW5mb1xuICAgIH0gPSBhd2FpdCB0aGlzLmdldEFjY291bnRJbmZvQW5kQ29udGV4dChub25jZUFjY291bnQsIGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICBpZiAoYWNjb3VudEluZm8gIT09IG51bGwpIHtcbiAgICAgIHZhbHVlID0gTm9uY2VBY2NvdW50LmZyb21BY2NvdW50RGF0YShhY2NvdW50SW5mby5kYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGNvbnRlbnRzIG9mIGEgTm9uY2UgYWNjb3VudCBmcm9tIHRoZSBjbHVzdGVyXG4gICAqL1xuICBhc3luYyBnZXROb25jZShub25jZUFjY291bnQsIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldE5vbmNlQW5kQ29udGV4dChub25jZUFjY291bnQsIGNvbW1pdG1lbnRPckNvbmZpZykudGhlbih4ID0+IHgudmFsdWUpLmNhdGNoKGUgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gZ2V0IG5vbmNlIGZvciBhY2NvdW50ICcgKyBub25jZUFjY291bnQudG9CYXNlNTgoKSArICc6ICcgKyBlKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IGFuIGFsbG9jYXRpb24gb2YgbGFtcG9ydHMgdG8gdGhlIHNwZWNpZmllZCBhZGRyZXNzXG4gICAqXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogaW1wb3J0IHsgQ29ubmVjdGlvbiwgUHVibGljS2V5LCBMQU1QT1JUU19QRVJfU09MIH0gZnJvbSBcIkBzb2xhbmEvd2ViMy5qc1wiO1xuICAgKlxuICAgKiAoYXN5bmMgKCkgPT4ge1xuICAgKiAgIGNvbnN0IGNvbm5lY3Rpb24gPSBuZXcgQ29ubmVjdGlvbihcImh0dHBzOi8vYXBpLnRlc3RuZXQuc29sYW5hLmNvbVwiLCBcImNvbmZpcm1lZFwiKTtcbiAgICogICBjb25zdCBteUFkZHJlc3MgPSBuZXcgUHVibGljS2V5KFwiMm5yMWJIRlQ4Nlc5dEdueXZtWVc0dmNIS3NRQjNzVlFmbmRkYXN6NGtFeE1cIik7XG4gICAqICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgY29ubmVjdGlvbi5yZXF1ZXN0QWlyZHJvcChteUFkZHJlc3MsIExBTVBPUlRTX1BFUl9TT0wpO1xuICAgKiAgIGF3YWl0IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHNpZ25hdHVyZSk7XG4gICAqIH0pKCk7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgcmVxdWVzdEFpcmRyb3AodG8sIGxhbXBvcnRzKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgncmVxdWVzdEFpcmRyb3AnLCBbdG8udG9CYXNlNTgoKSwgbGFtcG9ydHNdKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBSZXF1ZXN0QWlyZHJvcFJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGFpcmRyb3AgdG8gJHt0by50b0Jhc2U1OCgpfSBmYWlsZWRgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhc3luYyBfYmxvY2toYXNoV2l0aEV4cGlyeUJsb2NrSGVpZ2h0KGRpc2FibGVDYWNoZSkge1xuICAgIGlmICghZGlzYWJsZUNhY2hlKSB7XG4gICAgICAvLyBXYWl0IGZvciBwb2xsaW5nIHRvIGZpbmlzaFxuICAgICAgd2hpbGUgKHRoaXMuX3BvbGxpbmdCbG9ja2hhc2gpIHtcbiAgICAgICAgYXdhaXQgc2xlZXAoMTAwKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRpbWVTaW5jZUZldGNoID0gRGF0ZS5ub3coKSAtIHRoaXMuX2Jsb2NraGFzaEluZm8ubGFzdEZldGNoO1xuICAgICAgY29uc3QgZXhwaXJlZCA9IHRpbWVTaW5jZUZldGNoID49IEJMT0NLSEFTSF9DQUNIRV9USU1FT1VUX01TO1xuICAgICAgaWYgKHRoaXMuX2Jsb2NraGFzaEluZm8ubGF0ZXN0QmxvY2toYXNoICE9PSBudWxsICYmICFleHBpcmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ibG9ja2hhc2hJbmZvLmxhdGVzdEJsb2NraGFzaDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX3BvbGxOZXdCbG9ja2hhc2goKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFzeW5jIF9wb2xsTmV3QmxvY2toYXNoKCkge1xuICAgIHRoaXMuX3BvbGxpbmdCbG9ja2hhc2ggPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgY29uc3QgY2FjaGVkTGF0ZXN0QmxvY2toYXNoID0gdGhpcy5fYmxvY2toYXNoSW5mby5sYXRlc3RCbG9ja2hhc2g7XG4gICAgICBjb25zdCBjYWNoZWRCbG9ja2hhc2ggPSBjYWNoZWRMYXRlc3RCbG9ja2hhc2ggPyBjYWNoZWRMYXRlc3RCbG9ja2hhc2guYmxvY2toYXNoIDogbnVsbDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTA7IGkrKykge1xuICAgICAgICBjb25zdCBsYXRlc3RCbG9ja2hhc2ggPSBhd2FpdCB0aGlzLmdldExhdGVzdEJsb2NraGFzaCgnZmluYWxpemVkJyk7XG4gICAgICAgIGlmIChjYWNoZWRCbG9ja2hhc2ggIT09IGxhdGVzdEJsb2NraGFzaC5ibG9ja2hhc2gpIHtcbiAgICAgICAgICB0aGlzLl9ibG9ja2hhc2hJbmZvID0ge1xuICAgICAgICAgICAgbGF0ZXN0QmxvY2toYXNoLFxuICAgICAgICAgICAgbGFzdEZldGNoOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25TaWduYXR1cmVzOiBbXSxcbiAgICAgICAgICAgIHNpbXVsYXRlZFNpZ25hdHVyZXM6IFtdXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gbGF0ZXN0QmxvY2toYXNoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2xlZXAgZm9yIGFwcHJveGltYXRlbHkgaGFsZiBhIHNsb3RcbiAgICAgICAgYXdhaXQgc2xlZXAoTVNfUEVSX1NMT1QgLyAyKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIG9idGFpbiBhIG5ldyBibG9ja2hhc2ggYWZ0ZXIgJHtEYXRlLm5vdygpIC0gc3RhcnRUaW1lfW1zYCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuX3BvbGxpbmdCbG9ja2hhc2ggPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRoZSBzdGFrZSBtaW5pbXVtIGRlbGVnYXRpb25cbiAgICovXG4gIGFzeW5jIGdldFN0YWtlTWluaW11bURlbGVnYXRpb24oY29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZzogY29uZmlnQXJnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQsICdiYXNlNjQnLCBjb25maWdBcmcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFN0YWtlTWluaW11bURlbGVnYXRpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChudW1iZXIoKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IHN0YWtlIG1pbmltdW0gZGVsZWdhdGlvbmApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaW11bGF0ZSBhIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwge0BsaW5rIHNpbXVsYXRlVHJhbnNhY3Rpb259IHdpdGgge0BsaW5rXG4gICAqIFZlcnNpb25lZFRyYW5zYWN0aW9ufSBhbmQge0BsaW5rIFNpbXVsYXRlVHJhbnNhY3Rpb25Db25maWd9IHBhcmFtZXRlcnNcbiAgICovXG5cbiAgLyoqXG4gICAqIFNpbXVsYXRlIGEgdHJhbnNhY3Rpb25cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvKipcbiAgICogU2ltdWxhdGUgYSB0cmFuc2FjdGlvblxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBhc3luYyBzaW11bGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uT3JNZXNzYWdlLCBjb25maWdPclNpZ25lcnMsIGluY2x1ZGVBY2NvdW50cykge1xuICAgIGlmICgnbWVzc2FnZScgaW4gdHJhbnNhY3Rpb25Pck1lc3NhZ2UpIHtcbiAgICAgIGNvbnN0IHZlcnNpb25lZFR4ID0gdHJhbnNhY3Rpb25Pck1lc3NhZ2U7XG4gICAgICBjb25zdCB3aXJlVHJhbnNhY3Rpb24gPSB2ZXJzaW9uZWRUeC5zZXJpYWxpemUoKTtcbiAgICAgIGNvbnN0IGVuY29kZWRUcmFuc2FjdGlvbiA9IEJ1ZmZlci5mcm9tKHdpcmVUcmFuc2FjdGlvbikudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnT3JTaWduZXJzKSB8fCBpbmNsdWRlQWNjb3VudHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb25maWcgPSBjb25maWdPclNpZ25lcnMgfHwge307XG4gICAgICBjb25maWcuZW5jb2RpbmcgPSAnYmFzZTY0JztcbiAgICAgIGlmICghKCdjb21taXRtZW50JyBpbiBjb25maWcpKSB7XG4gICAgICAgIGNvbmZpZy5jb21taXRtZW50ID0gdGhpcy5jb21taXRtZW50O1xuICAgICAgfVxuICAgICAgaWYgKGNvbmZpZ09yU2lnbmVycyAmJiB0eXBlb2YgY29uZmlnT3JTaWduZXJzID09PSAnb2JqZWN0JyAmJiAnaW5uZXJJbnN0cnVjdGlvbnMnIGluIGNvbmZpZ09yU2lnbmVycykge1xuICAgICAgICBjb25maWcuaW5uZXJJbnN0cnVjdGlvbnMgPSBjb25maWdPclNpZ25lcnMuaW5uZXJJbnN0cnVjdGlvbnM7XG4gICAgICB9XG4gICAgICBjb25zdCBhcmdzID0gW2VuY29kZWRUcmFuc2FjdGlvbiwgY29uZmlnXTtcbiAgICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ3NpbXVsYXRlVHJhbnNhY3Rpb24nLCBhcmdzKTtcbiAgICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIFNpbXVsYXRlZFRyYW5zYWN0aW9uUmVzcG9uc2VTdHJ1Y3QpO1xuICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIHNpbXVsYXRlIHRyYW5zYWN0aW9uOiAnICsgcmVzLmVycm9yLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgfVxuICAgIGxldCB0cmFuc2FjdGlvbjtcbiAgICBpZiAodHJhbnNhY3Rpb25Pck1lc3NhZ2UgaW5zdGFuY2VvZiBUcmFuc2FjdGlvbikge1xuICAgICAgbGV0IG9yaWdpbmFsVHggPSB0cmFuc2FjdGlvbk9yTWVzc2FnZTtcbiAgICAgIHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgICB0cmFuc2FjdGlvbi5mZWVQYXllciA9IG9yaWdpbmFsVHguZmVlUGF5ZXI7XG4gICAgICB0cmFuc2FjdGlvbi5pbnN0cnVjdGlvbnMgPSB0cmFuc2FjdGlvbk9yTWVzc2FnZS5pbnN0cnVjdGlvbnM7XG4gICAgICB0cmFuc2FjdGlvbi5ub25jZUluZm8gPSBvcmlnaW5hbFR4Lm5vbmNlSW5mbztcbiAgICAgIHRyYW5zYWN0aW9uLnNpZ25hdHVyZXMgPSBvcmlnaW5hbFR4LnNpZ25hdHVyZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zYWN0aW9uID0gVHJhbnNhY3Rpb24ucG9wdWxhdGUodHJhbnNhY3Rpb25Pck1lc3NhZ2UpO1xuICAgICAgLy8gSEFDSzogdGhpcyBmdW5jdGlvbiByZWxpZXMgb24gbXV0YXRpbmcgdGhlIHBvcHVsYXRlZCB0cmFuc2FjdGlvblxuICAgICAgdHJhbnNhY3Rpb24uX21lc3NhZ2UgPSB0cmFuc2FjdGlvbi5fanNvbiA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGNvbmZpZ09yU2lnbmVycyAhPT0gdW5kZWZpbmVkICYmICFBcnJheS5pc0FycmF5KGNvbmZpZ09yU2lnbmVycykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMnKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmVycyA9IGNvbmZpZ09yU2lnbmVycztcbiAgICBpZiAodHJhbnNhY3Rpb24ubm9uY2VJbmZvICYmIHNpZ25lcnMpIHtcbiAgICAgIHRyYW5zYWN0aW9uLnNpZ24oLi4uc2lnbmVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBkaXNhYmxlQ2FjaGUgPSB0aGlzLl9kaXNhYmxlQmxvY2toYXNoQ2FjaGluZztcbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgY29uc3QgbGF0ZXN0QmxvY2toYXNoID0gYXdhaXQgdGhpcy5fYmxvY2toYXNoV2l0aEV4cGlyeUJsb2NrSGVpZ2h0KGRpc2FibGVDYWNoZSk7XG4gICAgICAgIHRyYW5zYWN0aW9uLmxhc3RWYWxpZEJsb2NrSGVpZ2h0ID0gbGF0ZXN0QmxvY2toYXNoLmxhc3RWYWxpZEJsb2NrSGVpZ2h0O1xuICAgICAgICB0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBsYXRlc3RCbG9ja2hhc2guYmxvY2toYXNoO1xuICAgICAgICBpZiAoIXNpZ25lcnMpIGJyZWFrO1xuICAgICAgICB0cmFuc2FjdGlvbi5zaWduKC4uLnNpZ25lcnMpO1xuICAgICAgICBpZiAoIXRyYW5zYWN0aW9uLnNpZ25hdHVyZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignIXNpZ25hdHVyZScpOyAvLyBzaG91bGQgbmV2ZXIgaGFwcGVuXG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gdHJhbnNhY3Rpb24uc2lnbmF0dXJlLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgICAgaWYgKCF0aGlzLl9ibG9ja2hhc2hJbmZvLnNpbXVsYXRlZFNpZ25hdHVyZXMuaW5jbHVkZXMoc2lnbmF0dXJlKSAmJiAhdGhpcy5fYmxvY2toYXNoSW5mby50cmFuc2FjdGlvblNpZ25hdHVyZXMuaW5jbHVkZXMoc2lnbmF0dXJlKSkge1xuICAgICAgICAgIC8vIFRoZSBzaWduYXR1cmUgb2YgdGhpcyB0cmFuc2FjdGlvbiBoYXMgbm90IGJlZW4gc2VlbiBiZWZvcmUgd2l0aCB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IHJlY2VudEJsb2NraGFzaCwgYWxsIGRvbmUuIExldCdzIGJyZWFrXG4gICAgICAgICAgdGhpcy5fYmxvY2toYXNoSW5mby5zaW11bGF0ZWRTaWduYXR1cmVzLnB1c2goc2lnbmF0dXJlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGlzIHRyYW5zYWN0aW9uIHdvdWxkIGJlIHRyZWF0ZWQgYXMgZHVwbGljYXRlIChpdHMgZGVyaXZlZCBzaWduYXR1cmVcbiAgICAgICAgICAvLyBtYXRjaGVkIHRvIG9uZSBvZiBhbHJlYWR5IHJlY29yZGVkIHNpZ25hdHVyZXMpLlxuICAgICAgICAgIC8vIFNvLCB3ZSBtdXN0IGZldGNoIGEgbmV3IGJsb2NraGFzaCBmb3IgYSBkaWZmZXJlbnQgc2lnbmF0dXJlIGJ5IGRpc2FibGluZ1xuICAgICAgICAgIC8vIG91ciBjYWNoZSBub3QgdG8gd2FpdCBmb3IgdGhlIGNhY2hlIGV4cGlyYXRpb24gKEJMT0NLSEFTSF9DQUNIRV9USU1FT1VUX01TKS5cbiAgICAgICAgICBkaXNhYmxlQ2FjaGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2UgPSB0cmFuc2FjdGlvbi5fY29tcGlsZSgpO1xuICAgIGNvbnN0IHNpZ25EYXRhID0gbWVzc2FnZS5zZXJpYWxpemUoKTtcbiAgICBjb25zdCB3aXJlVHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbi5fc2VyaWFsaXplKHNpZ25EYXRhKTtcbiAgICBjb25zdCBlbmNvZGVkVHJhbnNhY3Rpb24gPSB3aXJlVHJhbnNhY3Rpb24udG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgIGVuY29kaW5nOiAnYmFzZTY0JyxcbiAgICAgIGNvbW1pdG1lbnQ6IHRoaXMuY29tbWl0bWVudFxuICAgIH07XG4gICAgaWYgKGluY2x1ZGVBY2NvdW50cykge1xuICAgICAgY29uc3QgYWRkcmVzc2VzID0gKEFycmF5LmlzQXJyYXkoaW5jbHVkZUFjY291bnRzKSA/IGluY2x1ZGVBY2NvdW50cyA6IG1lc3NhZ2Uubm9uUHJvZ3JhbUlkcygpKS5tYXAoa2V5ID0+IGtleS50b0Jhc2U1OCgpKTtcbiAgICAgIGNvbmZpZ1snYWNjb3VudHMnXSA9IHtcbiAgICAgICAgZW5jb2Rpbmc6ICdiYXNlNjQnLFxuICAgICAgICBhZGRyZXNzZXNcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChzaWduZXJzKSB7XG4gICAgICBjb25maWcuc2lnVmVyaWZ5ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZ09yU2lnbmVycyAmJiB0eXBlb2YgY29uZmlnT3JTaWduZXJzID09PSAnb2JqZWN0JyAmJiAnaW5uZXJJbnN0cnVjdGlvbnMnIGluIGNvbmZpZ09yU2lnbmVycykge1xuICAgICAgY29uZmlnLmlubmVySW5zdHJ1Y3Rpb25zID0gY29uZmlnT3JTaWduZXJzLmlubmVySW5zdHJ1Y3Rpb25zO1xuICAgIH1cbiAgICBjb25zdCBhcmdzID0gW2VuY29kZWRUcmFuc2FjdGlvbiwgY29uZmlnXTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdzaW11bGF0ZVRyYW5zYWN0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgU2ltdWxhdGVkVHJhbnNhY3Rpb25SZXNwb25zZVN0cnVjdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICBsZXQgbG9ncztcbiAgICAgIGlmICgnZGF0YScgaW4gcmVzLmVycm9yKSB7XG4gICAgICAgIGxvZ3MgPSByZXMuZXJyb3IuZGF0YS5sb2dzO1xuICAgICAgICBpZiAobG9ncyAmJiBBcnJheS5pc0FycmF5KGxvZ3MpKSB7XG4gICAgICAgICAgY29uc3QgdHJhY2VJbmRlbnQgPSAnXFxuICAgICc7XG4gICAgICAgICAgY29uc3QgbG9nVHJhY2UgPSB0cmFjZUluZGVudCArIGxvZ3Muam9pbih0cmFjZUluZGVudCk7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihyZXMuZXJyb3IubWVzc2FnZSwgbG9nVHJhY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgU2VuZFRyYW5zYWN0aW9uRXJyb3Ioe1xuICAgICAgICBhY3Rpb246ICdzaW11bGF0ZScsXG4gICAgICAgIHNpZ25hdHVyZTogJycsXG4gICAgICAgIHRyYW5zYWN0aW9uTWVzc2FnZTogcmVzLmVycm9yLm1lc3NhZ2UsXG4gICAgICAgIGxvZ3M6IGxvZ3NcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWduIGFuZCBzZW5kIGEgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCB7QGxpbmsgc2VuZFRyYW5zYWN0aW9ufSB3aXRoIGEge0BsaW5rXG4gICAqIFZlcnNpb25lZFRyYW5zYWN0aW9ufVxuICAgKi9cblxuICAvKipcbiAgICogU2VuZCBhIHNpZ25lZCB0cmFuc2FjdGlvblxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8qKlxuICAgKiBTaWduIGFuZCBzZW5kIGEgdHJhbnNhY3Rpb25cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgYXN5bmMgc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBzaWduZXJzT3JPcHRpb25zLCBvcHRpb25zKSB7XG4gICAgaWYgKCd2ZXJzaW9uJyBpbiB0cmFuc2FjdGlvbikge1xuICAgICAgaWYgKHNpZ25lcnNPck9wdGlvbnMgJiYgQXJyYXkuaXNBcnJheShzaWduZXJzT3JPcHRpb25zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgICB9XG4gICAgICBjb25zdCB3aXJlVHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbi5zZXJpYWxpemUoKTtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlbmRSYXdUcmFuc2FjdGlvbih3aXJlVHJhbnNhY3Rpb24sIHNpZ25lcnNPck9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoc2lnbmVyc09yT3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8ICFBcnJheS5pc0FycmF5KHNpZ25lcnNPck9wdGlvbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25lcnMgPSBzaWduZXJzT3JPcHRpb25zO1xuICAgIGlmICh0cmFuc2FjdGlvbi5ub25jZUluZm8pIHtcbiAgICAgIHRyYW5zYWN0aW9uLnNpZ24oLi4uc2lnbmVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBkaXNhYmxlQ2FjaGUgPSB0aGlzLl9kaXNhYmxlQmxvY2toYXNoQ2FjaGluZztcbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgY29uc3QgbGF0ZXN0QmxvY2toYXNoID0gYXdhaXQgdGhpcy5fYmxvY2toYXNoV2l0aEV4cGlyeUJsb2NrSGVpZ2h0KGRpc2FibGVDYWNoZSk7XG4gICAgICAgIHRyYW5zYWN0aW9uLmxhc3RWYWxpZEJsb2NrSGVpZ2h0ID0gbGF0ZXN0QmxvY2toYXNoLmxhc3RWYWxpZEJsb2NrSGVpZ2h0O1xuICAgICAgICB0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBsYXRlc3RCbG9ja2hhc2guYmxvY2toYXNoO1xuICAgICAgICB0cmFuc2FjdGlvbi5zaWduKC4uLnNpZ25lcnMpO1xuICAgICAgICBpZiAoIXRyYW5zYWN0aW9uLnNpZ25hdHVyZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignIXNpZ25hdHVyZScpOyAvLyBzaG91bGQgbmV2ZXIgaGFwcGVuXG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gdHJhbnNhY3Rpb24uc2lnbmF0dXJlLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgICAgaWYgKCF0aGlzLl9ibG9ja2hhc2hJbmZvLnRyYW5zYWN0aW9uU2lnbmF0dXJlcy5pbmNsdWRlcyhzaWduYXR1cmUpKSB7XG4gICAgICAgICAgLy8gVGhlIHNpZ25hdHVyZSBvZiB0aGlzIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBzZWVuIGJlZm9yZSB3aXRoIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgcmVjZW50QmxvY2toYXNoLCBhbGwgZG9uZS4gTGV0J3MgYnJlYWtcbiAgICAgICAgICB0aGlzLl9ibG9ja2hhc2hJbmZvLnRyYW5zYWN0aW9uU2lnbmF0dXJlcy5wdXNoKHNpZ25hdHVyZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhpcyB0cmFuc2FjdGlvbiB3b3VsZCBiZSB0cmVhdGVkIGFzIGR1cGxpY2F0ZSAoaXRzIGRlcml2ZWQgc2lnbmF0dXJlXG4gICAgICAgICAgLy8gbWF0Y2hlZCB0byBvbmUgb2YgYWxyZWFkeSByZWNvcmRlZCBzaWduYXR1cmVzKS5cbiAgICAgICAgICAvLyBTbywgd2UgbXVzdCBmZXRjaCBhIG5ldyBibG9ja2hhc2ggZm9yIGEgZGlmZmVyZW50IHNpZ25hdHVyZSBieSBkaXNhYmxpbmdcbiAgICAgICAgICAvLyBvdXIgY2FjaGUgbm90IHRvIHdhaXQgZm9yIHRoZSBjYWNoZSBleHBpcmF0aW9uIChCTE9DS0hBU0hfQ0FDSEVfVElNRU9VVF9NUykuXG4gICAgICAgICAgZGlzYWJsZUNhY2hlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB3aXJlVHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbi5zZXJpYWxpemUoKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZW5kUmF3VHJhbnNhY3Rpb24od2lyZVRyYW5zYWN0aW9uLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgdHJhbnNhY3Rpb24gdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHNpZ25lZCBhbmQgc2VyaWFsaXplZCBpbnRvIHRoZVxuICAgKiB3aXJlIGZvcm1hdFxuICAgKi9cbiAgYXN5bmMgc2VuZFJhd1RyYW5zYWN0aW9uKHJhd1RyYW5zYWN0aW9uLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZW5jb2RlZFRyYW5zYWN0aW9uID0gdG9CdWZmZXIocmF3VHJhbnNhY3Rpb24pLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnNlbmRFbmNvZGVkVHJhbnNhY3Rpb24oZW5jb2RlZFRyYW5zYWN0aW9uLCBvcHRpb25zKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSB0cmFuc2FjdGlvbiB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gc2lnbmVkLCBzZXJpYWxpemVkIGludG8gdGhlXG4gICAqIHdpcmUgZm9ybWF0LCBhbmQgZW5jb2RlZCBhcyBhIGJhc2U2NCBzdHJpbmdcbiAgICovXG4gIGFzeW5jIHNlbmRFbmNvZGVkVHJhbnNhY3Rpb24oZW5jb2RlZFRyYW5zYWN0aW9uLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgZW5jb2Rpbmc6ICdiYXNlNjQnXG4gICAgfTtcbiAgICBjb25zdCBza2lwUHJlZmxpZ2h0ID0gb3B0aW9ucyAmJiBvcHRpb25zLnNraXBQcmVmbGlnaHQ7XG4gICAgY29uc3QgcHJlZmxpZ2h0Q29tbWl0bWVudCA9IHNraXBQcmVmbGlnaHQgPT09IHRydWUgPyAncHJvY2Vzc2VkJyAvLyBGSVhNRSBSZW1vdmUgd2hlbiBodHRwczovL2dpdGh1Yi5jb20vYW56YS14eXovYWdhdmUvcHVsbC80ODMgaXMgZGVwbG95ZWQuXG4gICAgOiBvcHRpb25zICYmIG9wdGlvbnMucHJlZmxpZ2h0Q29tbWl0bWVudCB8fCB0aGlzLmNvbW1pdG1lbnQ7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5tYXhSZXRyaWVzICE9IG51bGwpIHtcbiAgICAgIGNvbmZpZy5tYXhSZXRyaWVzID0gb3B0aW9ucy5tYXhSZXRyaWVzO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm1pbkNvbnRleHRTbG90ICE9IG51bGwpIHtcbiAgICAgIGNvbmZpZy5taW5Db250ZXh0U2xvdCA9IG9wdGlvbnMubWluQ29udGV4dFNsb3Q7XG4gICAgfVxuICAgIGlmIChza2lwUHJlZmxpZ2h0KSB7XG4gICAgICBjb25maWcuc2tpcFByZWZsaWdodCA9IHNraXBQcmVmbGlnaHQ7XG4gICAgfVxuICAgIGlmIChwcmVmbGlnaHRDb21taXRtZW50KSB7XG4gICAgICBjb25maWcucHJlZmxpZ2h0Q29tbWl0bWVudCA9IHByZWZsaWdodENvbW1pdG1lbnQ7XG4gICAgfVxuICAgIGNvbnN0IGFyZ3MgPSBbZW5jb2RlZFRyYW5zYWN0aW9uLCBjb25maWddO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ3NlbmRUcmFuc2FjdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIFNlbmRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICBsZXQgbG9ncyA9IHVuZGVmaW5lZDtcbiAgICAgIGlmICgnZGF0YScgaW4gcmVzLmVycm9yKSB7XG4gICAgICAgIGxvZ3MgPSByZXMuZXJyb3IuZGF0YS5sb2dzO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFNlbmRUcmFuc2FjdGlvbkVycm9yKHtcbiAgICAgICAgYWN0aW9uOiBza2lwUHJlZmxpZ2h0ID8gJ3NlbmQnIDogJ3NpbXVsYXRlJyxcbiAgICAgICAgc2lnbmF0dXJlOiAnJyxcbiAgICAgICAgdHJhbnNhY3Rpb25NZXNzYWdlOiByZXMuZXJyb3IubWVzc2FnZSxcbiAgICAgICAgbG9nczogbG9nc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25PcGVuKCkge1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldENvbm5lY3RlZCA9IHRydWU7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0SGVhcnRiZWF0ID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgLy8gUGluZyBzZXJ2ZXIgZXZlcnkgNXMgdG8gcHJldmVudCBpZGxlIHRpbWVvdXRzXG4gICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHRoaXMuX3JwY1dlYlNvY2tldC5ub3RpZnkoJ3BpbmcnKTtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICAgICAgfSBjYXRjaCB7fVxuICAgICAgfSkoKTtcbiAgICB9LCA1MDAwKTtcbiAgICB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfd3NPbkVycm9yKGVycikge1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldENvbm5lY3RlZCA9IGZhbHNlO1xuICAgIGNvbnNvbGUuZXJyb3IoJ3dzIGVycm9yOicsIGVyci5tZXNzYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uQ2xvc2UoY29kZSkge1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldENvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldEdlbmVyYXRpb24gPSAodGhpcy5fcnBjV2ViU29ja2V0R2VuZXJhdGlvbiArIDEpICUgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgaWYgKHRoaXMuX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQpO1xuICAgICAgdGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcnBjV2ViU29ja2V0SGVhcnRiZWF0KSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuX3JwY1dlYlNvY2tldEhlYXJ0YmVhdCk7XG4gICAgICB0aGlzLl9ycGNXZWJTb2NrZXRIZWFydGJlYXQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoY29kZSA9PT0gMTAwMCkge1xuICAgICAgLy8gZXhwbGljaXQgY2xvc2UsIGNoZWNrIGlmIGFueSBzdWJzY3JpcHRpb25zIGhhdmUgYmVlbiBtYWRlIHNpbmNlIGNsb3NlXG4gICAgICB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaW1wbGljaXQgY2xvc2UsIHByZXBhcmUgc3Vic2NyaXB0aW9ucyBmb3IgYXV0by1yZWNvbm5lY3RcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25DYWxsYmFja3NCeVNlcnZlclN1YnNjcmlwdGlvbklkID0ge307XG4gICAgT2JqZWN0LmVudHJpZXModGhpcy5fc3Vic2NyaXB0aW9uc0J5SGFzaCkuZm9yRWFjaCgoW2hhc2gsIHN1YnNjcmlwdGlvbl0pID0+IHtcbiAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihoYXNoLCB7XG4gICAgICAgIC4uLnN1YnNjcmlwdGlvbixcbiAgICAgICAgc3RhdGU6ICdwZW5kaW5nJ1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfc2V0U3Vic2NyaXB0aW9uKGhhc2gsIG5leHRTdWJzY3JpcHRpb24pIHtcbiAgICBjb25zdCBwcmV2U3RhdGUgPSB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdPy5zdGF0ZTtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdID0gbmV4dFN1YnNjcmlwdGlvbjtcbiAgICBpZiAocHJldlN0YXRlICE9PSBuZXh0U3Vic2NyaXB0aW9uLnN0YXRlKSB7XG4gICAgICBjb25zdCBzdGF0ZUNoYW5nZUNhbGxiYWNrcyA9IHRoaXMuX3N1YnNjcmlwdGlvblN0YXRlQ2hhbmdlQ2FsbGJhY2tzQnlIYXNoW2hhc2hdO1xuICAgICAgaWYgKHN0YXRlQ2hhbmdlQ2FsbGJhY2tzKSB7XG4gICAgICAgIHN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmZvckVhY2goY2IgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjYihuZXh0U3Vic2NyaXB0aW9uLnN0YXRlKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgICAgICAgIH0gY2F0Y2gge31cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX29uU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2UoY2xpZW50U3Vic2NyaXB0aW9uSWQsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgaGFzaCA9IHRoaXMuX3N1YnNjcmlwdGlvbkhhc2hCeUNsaWVudFN1YnNjcmlwdGlvbklkW2NsaWVudFN1YnNjcmlwdGlvbklkXTtcbiAgICBpZiAoaGFzaCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gKCkgPT4ge307XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlQ2hhbmdlQ2FsbGJhY2tzID0gdGhpcy5fc3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VDYWxsYmFja3NCeUhhc2hbaGFzaF0gfHw9IG5ldyBTZXQoKTtcbiAgICBzdGF0ZUNoYW5nZUNhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzdGF0ZUNoYW5nZUNhbGxiYWNrcy5kZWxldGUoY2FsbGJhY2spO1xuICAgICAgaWYgKHN0YXRlQ2hhbmdlQ2FsbGJhY2tzLnNpemUgPT09IDApIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3N1YnNjcmlwdGlvblN0YXRlQ2hhbmdlQ2FsbGJhY2tzQnlIYXNoW2hhc2hdO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhc3luYyBfdXBkYXRlU3Vic2NyaXB0aW9ucygpIHtcbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy5fc3Vic2NyaXB0aW9uc0J5SGFzaCkubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAodGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkKSB7XG4gICAgICAgIHRoaXMuX3JwY1dlYlNvY2tldENvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fcnBjV2ViU29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBzd2FsbG93IGVycm9yIGlmIHNvY2tldCBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZC5cbiAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRXJyb3Igd2hlbiBjbG9zaW5nIHNvY2tldCBjb25uZWN0aW9uOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgNTAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQpO1xuICAgICAgdGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQgPSBudWxsO1xuICAgICAgdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9ycGNXZWJTb2NrZXRDb25uZWN0ZWQpIHtcbiAgICAgIHRoaXMuX3JwY1dlYlNvY2tldC5jb25uZWN0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFjdGl2ZVdlYlNvY2tldEdlbmVyYXRpb24gPSB0aGlzLl9ycGNXZWJTb2NrZXRHZW5lcmF0aW9uO1xuICAgIGNvbnN0IGlzQ3VycmVudENvbm5lY3Rpb25TdGlsbEFjdGl2ZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiBhY3RpdmVXZWJTb2NrZXRHZW5lcmF0aW9uID09PSB0aGlzLl9ycGNXZWJTb2NrZXRHZW5lcmF0aW9uO1xuICAgIH07XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgLy8gRG9uJ3QgYmUgdGVtcHRlZCB0byBjaGFuZ2UgdGhpcyB0byBgT2JqZWN0LmVudHJpZXNgLiBXZSBjYWxsXG4gICAgLy8gYF91cGRhdGVTdWJzY3JpcHRpb25zYCByZWN1cnNpdmVseSB3aGVuIHByb2Nlc3NpbmcgdGhlIHN0YXRlLFxuICAgIC8vIHNvIGl0J3MgaW1wb3J0YW50IHRoYXQgd2UgbG9vayB1cCB0aGUgKmN1cnJlbnQqIHZlcnNpb24gb2ZcbiAgICAvLyBlYWNoIHN1YnNjcmlwdGlvbiwgZXZlcnkgdGltZSB3ZSBwcm9jZXNzIGEgaGFzaC5cbiAgICBPYmplY3Qua2V5cyh0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoKS5tYXAoYXN5bmMgaGFzaCA9PiB7XG4gICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdO1xuICAgICAgaWYgKHN1YnNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIFRoaXMgZW50cnkgaGFzIHNpbmNlIGJlZW4gZGVsZXRlZC4gU2tpcC5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChzdWJzY3JpcHRpb24uc3RhdGUpIHtcbiAgICAgICAgY2FzZSAncGVuZGluZyc6XG4gICAgICAgIGNhc2UgJ3Vuc3Vic2NyaWJlZCc6XG4gICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5jYWxsYmFja3Muc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBZb3UgY2FuIGVuZCB1cCBoZXJlIHdoZW46XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogLSBhIHN1YnNjcmlwdGlvbiBoYXMgcmVjZW50bHkgdW5zdWJzY3JpYmVkXG4gICAgICAgICAgICAgKiAgIHdpdGhvdXQgaGF2aW5nIG5ldyBjYWxsYmFja3MgYWRkZWQgdG8gaXRcbiAgICAgICAgICAgICAqICAgd2hpbGUgdGhlIHVuc3Vic2NyaWJlIHdhcyBpbiBmbGlnaHQsIG9yXG4gICAgICAgICAgICAgKiAtIHdoZW4gYSBwZW5kaW5nIHN1YnNjcmlwdGlvbiBoYXMgaXRzXG4gICAgICAgICAgICAgKiAgIGxpc3RlbmVycyByZW1vdmVkIGJlZm9yZSBhIHJlcXVlc3Qgd2FzXG4gICAgICAgICAgICAgKiAgIHNlbnQgdG8gdGhlIHNlcnZlci5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBCZWluZyB0aGF0IG5vYm9keSBpcyBpbnRlcmVzdGVkIGluIHRoaXNcbiAgICAgICAgICAgICAqIHN1YnNjcmlwdGlvbiBhbnkgbG9uZ2VyLCBkZWxldGUgaXQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdO1xuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5zdGF0ZSA9PT0gJ3Vuc3Vic2NyaWJlZCcpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3N1YnNjcmlwdGlvbkNhbGxiYWNrc0J5U2VydmVyU3Vic2NyaXB0aW9uSWRbc3Vic2NyaXB0aW9uLnNlcnZlclN1YnNjcmlwdGlvbklkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgbWV0aG9kXG4gICAgICAgICAgICB9ID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgICAgICAgICAuLi5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgc3RhdGU6ICdzdWJzY3JpYmluZydcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnN0IHNlcnZlclN1YnNjcmlwdGlvbklkID0gYXdhaXQgdGhpcy5fcnBjV2ViU29ja2V0LmNhbGwobWV0aG9kLCBhcmdzKTtcbiAgICAgICAgICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgICAgICAgICAuLi5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgc2VydmVyU3Vic2NyaXB0aW9uSWQsXG4gICAgICAgICAgICAgICAgc3RhdGU6ICdzdWJzY3JpYmVkJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uQ2FsbGJhY2tzQnlTZXJ2ZXJTdWJzY3JpcHRpb25JZFtzZXJ2ZXJTdWJzY3JpcHRpb25JZF0gPSBzdWJzY3JpcHRpb24uY2FsbGJhY2tzO1xuICAgICAgICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFJlY2VpdmVkICR7ZSBpbnN0YW5jZW9mIEVycm9yID8gJycgOiAnSlNPTi1SUEMgJ31lcnJvciBjYWxsaW5nIFxcYCR7bWV0aG9kfVxcYGAsIHtcbiAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoIWlzQ3VycmVudENvbm5lY3Rpb25TdGlsbEFjdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIFRPRE86IE1heWJlIGFkZCBhbiAnZXJyb3JlZCcgc3RhdGUgb3IgYSByZXRyeSBsaW1pdD9cbiAgICAgICAgICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgICAgICAgICAuLi5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgc3RhdGU6ICdwZW5kaW5nJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N1YnNjcmliZWQnOlxuICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24uY2FsbGJhY2tzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIC8vIEJ5IHRoZSB0aW1lIHdlIHN1Y2Nlc3NmdWxseSBzZXQgdXAgYSBzdWJzY3JpcHRpb25cbiAgICAgICAgICAgIC8vIHdpdGggdGhlIHNlcnZlciwgdGhlIGNsaWVudCBzdG9wcGVkIGNhcmluZyBhYm91dCBpdC5cbiAgICAgICAgICAgIC8vIFRlYXIgaXQgZG93biBub3cuXG4gICAgICAgICAgICBhd2FpdCAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgc2VydmVyU3Vic2NyaXB0aW9uSWQsXG4gICAgICAgICAgICAgICAgdW5zdWJzY3JpYmVNZXRob2RcbiAgICAgICAgICAgICAgfSA9IHN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX3N1YnNjcmlwdGlvbnNBdXRvRGlzcG9zZWRCeVJwYy5oYXMoc2VydmVyU3Vic2NyaXB0aW9uSWQpKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogU3BlY2lhbCBjYXNlLlxuICAgICAgICAgICAgICAgICAqIElmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIHN1YnNjcmlwdGlvbiB0aGF0IGhhcyBiZWVuIGF1dG8tXG4gICAgICAgICAgICAgICAgICogZGlzcG9zZWQgYnkgdGhlIFJQQywgdGhlbiB3ZSBjYW4gc2tpcCB0aGUgUlBDIGNhbGwgdG9cbiAgICAgICAgICAgICAgICAgKiB0ZWFyIGRvd24gdGhlIHN1YnNjcmlwdGlvbiBoZXJlLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogTk9URTogVGhlcmUgaXMgYSBwcm9wb3NhbCB0byBlbGltaW5hdGUgdGhpcyBzcGVjaWFsIGNhc2UsIGhlcmU6XG4gICAgICAgICAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9pc3N1ZXMvMTg4OTJcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zQXV0b0Rpc3Bvc2VkQnlScGMuZGVsZXRlKHNlcnZlclN1YnNjcmlwdGlvbklkKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRTdWJzY3JpcHRpb24oaGFzaCwge1xuICAgICAgICAgICAgICAgICAgLi4uc3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgc3RhdGU6ICd1bnN1YnNjcmliaW5nJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihoYXNoLCB7XG4gICAgICAgICAgICAgICAgICAuLi5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogJ3Vuc3Vic2NyaWJpbmcnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3JwY1dlYlNvY2tldC5jYWxsKHVuc3Vic2NyaWJlTWV0aG9kLCBbc2VydmVyU3Vic2NyaXB0aW9uSWRdKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYCR7dW5zdWJzY3JpYmVNZXRob2R9IGVycm9yOmAsIGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoIWlzQ3VycmVudENvbm5lY3Rpb25TdGlsbEFjdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIFRPRE86IE1heWJlIGFkZCBhbiAnZXJyb3JlZCcgc3RhdGUgb3IgYSByZXRyeSBsaW1pdD9cbiAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihoYXNoLCB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6ICdzdWJzY3JpYmVkJ1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihoYXNoLCB7XG4gICAgICAgICAgICAgICAgLi4uc3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgIHN0YXRlOiAndW5zdWJzY3JpYmVkJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzZXJ2ZXJTdWJzY3JpcHRpb25JZCwgY2FsbGJhY2tBcmdzKSB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy5fc3Vic2NyaXB0aW9uQ2FsbGJhY2tzQnlTZXJ2ZXJTdWJzY3JpcHRpb25JZFtzZXJ2ZXJTdWJzY3JpcHRpb25JZF07XG4gICAgaWYgKGNhbGxiYWNrcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrcy5mb3JFYWNoKGNiID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNiKFxuICAgICAgICAvLyBJIGZhaWxlZCB0byBmaW5kIGEgd2F5IHRvIGNvbnZpbmNlIFR5cGVTY3JpcHQgdGhhdCBgY2JgIGlzIG9mIHR5cGVcbiAgICAgICAgLy8gYFRDYWxsYmFja2Agd2hpY2ggaXMgY2VydGFpbmx5IGNvbXBhdGlibGUgd2l0aCBgUGFyYW1ldGVyczxUQ2FsbGJhY2s+YC5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvNDc2MTVcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAuLi5jYWxsYmFja0FyZ3MpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25BY2NvdW50Tm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlc3VsdCxcbiAgICAgIHN1YnNjcmlwdGlvblxuICAgIH0gPSBjcmVhdGUobm90aWZpY2F0aW9uLCBBY2NvdW50Tm90aWZpY2F0aW9uUmVzdWx0KTtcbiAgICB0aGlzLl9oYW5kbGVTZXJ2ZXJOb3RpZmljYXRpb24oc3Vic2NyaXB0aW9uLCBbcmVzdWx0LnZhbHVlLCByZXN1bHQuY29udGV4dF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX21ha2VTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uQ29uZmlnLFxuICAvKipcbiAgICogV2hlbiBwcmVwYXJpbmcgYGFyZ3NgIGZvciBhIGNhbGwgdG8gYF9tYWtlU3Vic2NyaXB0aW9uYCwgYmUgc3VyZVxuICAgKiB0byBjYXJlZnVsbHkgYXBwbHkgYSBkZWZhdWx0IGBjb21taXRtZW50YCBwcm9wZXJ0eSwgaWYgbmVjZXNzYXJ5LlxuICAgKlxuICAgKiAtIElmIHRoZSB1c2VyIHN1cHBsaWVkIGEgYGNvbW1pdG1lbnRgIHVzZSB0aGF0LlxuICAgKiAtIE90aGVyd2lzZSwgaWYgdGhlIGBDb25uZWN0aW9uOjpjb21taXRtZW50YCBpcyBzZXQsIHVzZSB0aGF0LlxuICAgKiAtIE90aGVyd2lzZSwgc2V0IGl0IHRvIHRoZSBSUEMgc2VydmVyIGRlZmF1bHQ6IGBmaW5hbGl6ZWRgLlxuICAgKlxuICAgKiBUaGlzIGlzIGV4dHJlbWVseSBpbXBvcnRhbnQgdG8gZW5zdXJlIHRoYXQgdGhlc2UgdHdvIGZ1bmRhbWVudGFsbHlcbiAgICogaWRlbnRpY2FsIHN1YnNjcmlwdGlvbnMgcHJvZHVjZSB0aGUgc2FtZSBpZGVudGlmeWluZyBoYXNoOlxuICAgKlxuICAgKiAtIEEgc3Vic2NyaXB0aW9uIG1hZGUgd2l0aG91dCBzcGVjaWZ5aW5nIGEgY29tbWl0bWVudC5cbiAgICogLSBBIHN1YnNjcmlwdGlvbiBtYWRlIHdoZXJlIHRoZSBjb21taXRtZW50IHNwZWNpZmllZCBpcyB0aGUgc2FtZVxuICAgKiAgIGFzIHRoZSBkZWZhdWx0IGFwcGxpZWQgdG8gdGhlIHN1YnNjcmlwdGlvbiBhYm92ZS5cbiAgICpcbiAgICogRXhhbXBsZTsgdGhlc2UgdHdvIHN1YnNjcmlwdGlvbnMgbXVzdCBwcm9kdWNlIHRoZSBzYW1lIGhhc2g6XG4gICAqXG4gICAqIC0gQW4gYGFjY291bnRTdWJzY3JpYmVgIHN1YnNjcmlwdGlvbiBmb3IgYCdQVUJLRVknYFxuICAgKiAtIEFuIGBhY2NvdW50U3Vic2NyaWJlYCBzdWJzY3JpcHRpb24gZm9yIGAnUFVCS0VZJ2Agd2l0aCBjb21taXRtZW50XG4gICAqICAgYCdmaW5hbGl6ZWQnYC5cbiAgICpcbiAgICogU2VlIHRoZSAnbWFraW5nIGEgc3Vic2NyaXB0aW9uIHdpdGggZGVmYXVsdGVkIHBhcmFtcyBvbWl0dGVkJyB0ZXN0XG4gICAqIGluIGBjb25uZWN0aW9uLXN1YnNjcmlwdGlvbnMudHNgIGZvciBtb3JlLlxuICAgKi9cbiAgYXJncykge1xuICAgIGNvbnN0IGNsaWVudFN1YnNjcmlwdGlvbklkID0gdGhpcy5fbmV4dENsaWVudFN1YnNjcmlwdGlvbklkKys7XG4gICAgY29uc3QgaGFzaCA9IGZhc3RTdGFibGVTdHJpbmdpZnkoW3N1YnNjcmlwdGlvbkNvbmZpZy5tZXRob2QsIGFyZ3NdKTtcbiAgICBjb25zdCBleGlzdGluZ1N1YnNjcmlwdGlvbiA9IHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2hbaGFzaF07XG4gICAgaWYgKGV4aXN0aW5nU3Vic2NyaXB0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2hbaGFzaF0gPSB7XG4gICAgICAgIC4uLnN1YnNjcmlwdGlvbkNvbmZpZyxcbiAgICAgICAgYXJncyxcbiAgICAgICAgY2FsbGJhY2tzOiBuZXcgU2V0KFtzdWJzY3JpcHRpb25Db25maWcuY2FsbGJhY2tdKSxcbiAgICAgICAgc3RhdGU6ICdwZW5kaW5nJ1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmdTdWJzY3JpcHRpb24uY2FsbGJhY2tzLmFkZChzdWJzY3JpcHRpb25Db25maWcuY2FsbGJhY2spO1xuICAgIH1cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25IYXNoQnlDbGllbnRTdWJzY3JpcHRpb25JZFtjbGllbnRTdWJzY3JpcHRpb25JZF0gPSBoYXNoO1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbkRpc3Bvc2VGdW5jdGlvbnNCeUNsaWVudFN1YnNjcmlwdGlvbklkW2NsaWVudFN1YnNjcmlwdGlvbklkXSA9IGFzeW5jICgpID0+IHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9zdWJzY3JpcHRpb25EaXNwb3NlRnVuY3Rpb25zQnlDbGllbnRTdWJzY3JpcHRpb25JZFtjbGllbnRTdWJzY3JpcHRpb25JZF07XG4gICAgICBkZWxldGUgdGhpcy5fc3Vic2NyaXB0aW9uSGFzaEJ5Q2xpZW50U3Vic2NyaXB0aW9uSWRbY2xpZW50U3Vic2NyaXB0aW9uSWRdO1xuICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gdGhpcy5fc3Vic2NyaXB0aW9uc0J5SGFzaFtoYXNoXTtcbiAgICAgIGFzc2VydChzdWJzY3JpcHRpb24gIT09IHVuZGVmaW5lZCwgYENvdWxkIG5vdCBmaW5kIGEgXFxgU3Vic2NyaXB0aW9uXFxgIHdoZW4gdGVhcmluZyBkb3duIGNsaWVudCBzdWJzY3JpcHRpb24gIyR7Y2xpZW50U3Vic2NyaXB0aW9uSWR9YCk7XG4gICAgICBzdWJzY3JpcHRpb24uY2FsbGJhY2tzLmRlbGV0ZShzdWJzY3JpcHRpb25Db25maWcuY2FsbGJhY2spO1xuICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgIH07XG4gICAgdGhpcy5fdXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgIHJldHVybiBjbGllbnRTdWJzY3JpcHRpb25JZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbmV2ZXIgdGhlIHNwZWNpZmllZCBhY2NvdW50IGNoYW5nZXNcbiAgICpcbiAgICogQHBhcmFtIHB1YmxpY0tleSBQdWJsaWMga2V5IG9mIHRoZSBhY2NvdW50IHRvIG1vbml0b3JcbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGludm9rZSB3aGVuZXZlciB0aGUgYWNjb3VudCBpcyBjaGFuZ2VkXG4gICAqIEBwYXJhbSBjb25maWdcbiAgICogQHJldHVybiBzdWJzY3JpcHRpb24gaWRcbiAgICovXG5cbiAgLyoqIEBkZXByZWNhdGVkIEluc3RlYWQsIHBhc3MgaW4gYW4ge0BsaW5rIEFjY291bnRTdWJzY3JpcHRpb25Db25maWd9ICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIG9uQWNjb3VudENoYW5nZShwdWJsaWNLZXksIGNhbGxiYWNrLCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3B1YmxpY0tleS50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCB8fCB0aGlzLl9jb21taXRtZW50IHx8ICdmaW5hbGl6ZWQnLFxuICAgIC8vIEFwcGx5IGNvbm5lY3Rpb24vc2VydmVyIGRlZmF1bHQuXG4gICAgJ2Jhc2U2NCcsIGNvbmZpZyk7XG4gICAgcmV0dXJuIHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2ssXG4gICAgICBtZXRob2Q6ICdhY2NvdW50U3Vic2NyaWJlJyxcbiAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAnYWNjb3VudFVuc3Vic2NyaWJlJ1xuICAgIH0sIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYW4gYWNjb3VudCBub3RpZmljYXRpb24gY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3RlclxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlQWNjb3VudENoYW5nZUxpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKSB7XG4gICAgYXdhaXQgdGhpcy5fdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsICdhY2NvdW50IGNoYW5nZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25Qcm9ncmFtQWNjb3VudE5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICByZXN1bHQsXG4gICAgICBzdWJzY3JpcHRpb25cbiAgICB9ID0gY3JlYXRlKG5vdGlmaWNhdGlvbiwgUHJvZ3JhbUFjY291bnROb3RpZmljYXRpb25SZXN1bHQpO1xuICAgIHRoaXMuX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzdWJzY3JpcHRpb24sIFt7XG4gICAgICBhY2NvdW50SWQ6IHJlc3VsdC52YWx1ZS5wdWJrZXksXG4gICAgICBhY2NvdW50SW5mbzogcmVzdWx0LnZhbHVlLmFjY291bnRcbiAgICB9LCByZXN1bHQuY29udGV4dF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuZXZlciBhY2NvdW50cyBvd25lZCBieSB0aGVcbiAgICogc3BlY2lmaWVkIHByb2dyYW0gY2hhbmdlXG4gICAqXG4gICAqIEBwYXJhbSBwcm9ncmFtSWQgUHVibGljIGtleSBvZiB0aGUgcHJvZ3JhbSB0byBtb25pdG9yXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBpbnZva2Ugd2hlbmV2ZXIgdGhlIGFjY291bnQgaXMgY2hhbmdlZFxuICAgKiBAcGFyYW0gY29uZmlnXG4gICAqIEByZXR1cm4gc3Vic2NyaXB0aW9uIGlkXG4gICAqL1xuXG4gIC8qKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBwYXNzIGluIGEge0BsaW5rIFByb2dyYW1BY2NvdW50U3Vic2NyaXB0aW9uQ29uZmlnfSAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBvblByb2dyYW1BY2NvdW50Q2hhbmdlKHByb2dyYW1JZCwgY2FsbGJhY2ssIGNvbW1pdG1lbnRPckNvbmZpZywgbWF5YmVGaWx0ZXJzKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtwcm9ncmFtSWQudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQgfHwgdGhpcy5fY29tbWl0bWVudCB8fCAnZmluYWxpemVkJyxcbiAgICAvLyBBcHBseSBjb25uZWN0aW9uL3NlcnZlciBkZWZhdWx0LlxuICAgICdiYXNlNjQnIC8qIGVuY29kaW5nICovLCBjb25maWcgPyBjb25maWcgOiBtYXliZUZpbHRlcnMgPyB7XG4gICAgICBmaWx0ZXJzOiBhcHBseURlZmF1bHRNZW1jbXBFbmNvZGluZ1RvRmlsdGVycyhtYXliZUZpbHRlcnMpXG4gICAgfSA6IHVuZGVmaW5lZCAvKiBleHRyYSAqLyk7XG4gICAgcmV0dXJuIHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2ssXG4gICAgICBtZXRob2Q6ICdwcm9ncmFtU3Vic2NyaWJlJyxcbiAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAncHJvZ3JhbVVuc3Vic2NyaWJlJ1xuICAgIH0sIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYW4gYWNjb3VudCBub3RpZmljYXRpb24gY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3RlclxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlUHJvZ3JhbUFjY291bnRDaGFuZ2VMaXN0ZW5lcihjbGllbnRTdWJzY3JpcHRpb25JZCkge1xuICAgIGF3YWl0IHRoaXMuX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKGNsaWVudFN1YnNjcmlwdGlvbklkLCAncHJvZ3JhbSBhY2NvdW50IGNoYW5nZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbmV2ZXIgbG9ncyBhcmUgZW1pdHRlZC5cbiAgICovXG4gIG9uTG9ncyhmaWx0ZXIsIGNhbGxiYWNrLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbdHlwZW9mIGZpbHRlciA9PT0gJ29iamVjdCcgPyB7XG4gICAgICBtZW50aW9uczogW2ZpbHRlci50b1N0cmluZygpXVxuICAgIH0gOiBmaWx0ZXJdLCBjb21taXRtZW50IHx8IHRoaXMuX2NvbW1pdG1lbnQgfHwgJ2ZpbmFsaXplZCcgLy8gQXBwbHkgY29ubmVjdGlvbi9zZXJ2ZXIgZGVmYXVsdC5cbiAgICApO1xuICAgIHJldHVybiB0aGlzLl9tYWtlU3Vic2NyaXB0aW9uKHtcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgbWV0aG9kOiAnbG9nc1N1YnNjcmliZScsXG4gICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ2xvZ3NVbnN1YnNjcmliZSdcbiAgICB9LCBhcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIGEgbG9ncyBjYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3Rlci5cbiAgICovXG4gIGFzeW5jIHJlbW92ZU9uTG9nc0xpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKSB7XG4gICAgYXdhaXQgdGhpcy5fdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsICdsb2dzJyk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfd3NPbkxvZ3NOb3RpZmljYXRpb24obm90aWZpY2F0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVzdWx0LFxuICAgICAgc3Vic2NyaXB0aW9uXG4gICAgfSA9IGNyZWF0ZShub3RpZmljYXRpb24sIExvZ3NOb3RpZmljYXRpb25SZXN1bHQpO1xuICAgIHRoaXMuX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzdWJzY3JpcHRpb24sIFtyZXN1bHQudmFsdWUsIHJlc3VsdC5jb250ZXh0XSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfd3NPblNsb3ROb3RpZmljYXRpb24obm90aWZpY2F0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVzdWx0LFxuICAgICAgc3Vic2NyaXB0aW9uXG4gICAgfSA9IGNyZWF0ZShub3RpZmljYXRpb24sIFNsb3ROb3RpZmljYXRpb25SZXN1bHQpO1xuICAgIHRoaXMuX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzdWJzY3JpcHRpb24sIFtyZXN1bHRdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgdXBvbiBzbG90IGNoYW5nZXNcbiAgICpcbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGludm9rZSB3aGVuZXZlciB0aGUgc2xvdCBjaGFuZ2VzXG4gICAqIEByZXR1cm4gc3Vic2NyaXB0aW9uIGlkXG4gICAqL1xuICBvblNsb3RDaGFuZ2UoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbih7XG4gICAgICBjYWxsYmFjayxcbiAgICAgIG1ldGhvZDogJ3Nsb3RTdWJzY3JpYmUnLFxuICAgICAgdW5zdWJzY3JpYmVNZXRob2Q6ICdzbG90VW5zdWJzY3JpYmUnXG4gICAgfSwgW10gLyogYXJncyAqLyk7XG4gIH1cblxuICAvKipcbiAgICogRGVyZWdpc3RlciBhIHNsb3Qgbm90aWZpY2F0aW9uIGNhbGxiYWNrXG4gICAqXG4gICAqIEBwYXJhbSBjbGllbnRTdWJzY3JpcHRpb25JZCBjbGllbnQgc3Vic2NyaXB0aW9uIGlkIHRvIGRlcmVnaXN0ZXJcbiAgICovXG4gIGFzeW5jIHJlbW92ZVNsb3RDaGFuZ2VMaXN0ZW5lcihjbGllbnRTdWJzY3JpcHRpb25JZCkge1xuICAgIGF3YWl0IHRoaXMuX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKGNsaWVudFN1YnNjcmlwdGlvbklkLCAnc2xvdCBjaGFuZ2UnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uU2xvdFVwZGF0ZXNOb3RpZmljYXRpb24obm90aWZpY2F0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVzdWx0LFxuICAgICAgc3Vic2NyaXB0aW9uXG4gICAgfSA9IGNyZWF0ZShub3RpZmljYXRpb24sIFNsb3RVcGRhdGVOb3RpZmljYXRpb25SZXN1bHQpO1xuICAgIHRoaXMuX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzdWJzY3JpcHRpb24sIFtyZXN1bHRdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgdXBvbiBzbG90IHVwZGF0ZXMuIHtAbGluayBTbG90VXBkYXRlfSdzXG4gICAqIG1heSBiZSB1c2VmdWwgdG8gdHJhY2sgbGl2ZSBwcm9ncmVzcyBvZiBhIGNsdXN0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBpbnZva2Ugd2hlbmV2ZXIgdGhlIHNsb3QgdXBkYXRlc1xuICAgKiBAcmV0dXJuIHN1YnNjcmlwdGlvbiBpZFxuICAgKi9cbiAgb25TbG90VXBkYXRlKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2ssXG4gICAgICBtZXRob2Q6ICdzbG90c1VwZGF0ZXNTdWJzY3JpYmUnLFxuICAgICAgdW5zdWJzY3JpYmVNZXRob2Q6ICdzbG90c1VwZGF0ZXNVbnN1YnNjcmliZSdcbiAgICB9LCBbXSAvKiBhcmdzICovKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIGEgc2xvdCB1cGRhdGUgbm90aWZpY2F0aW9uIGNhbGxiYWNrXG4gICAqXG4gICAqIEBwYXJhbSBjbGllbnRTdWJzY3JpcHRpb25JZCBjbGllbnQgc3Vic2NyaXB0aW9uIGlkIHRvIGRlcmVnaXN0ZXJcbiAgICovXG4gIGFzeW5jIHJlbW92ZVNsb3RVcGRhdGVMaXN0ZW5lcihjbGllbnRTdWJzY3JpcHRpb25JZCkge1xuICAgIGF3YWl0IHRoaXMuX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKGNsaWVudFN1YnNjcmlwdGlvbklkLCAnc2xvdCB1cGRhdGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgYXN5bmMgX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKGNsaWVudFN1YnNjcmlwdGlvbklkLCBzdWJzY3JpcHRpb25OYW1lKSB7XG4gICAgY29uc3QgZGlzcG9zZSA9IHRoaXMuX3N1YnNjcmlwdGlvbkRpc3Bvc2VGdW5jdGlvbnNCeUNsaWVudFN1YnNjcmlwdGlvbklkW2NsaWVudFN1YnNjcmlwdGlvbklkXTtcbiAgICBpZiAoZGlzcG9zZSkge1xuICAgICAgYXdhaXQgZGlzcG9zZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0lnbm9yZWQgdW5zdWJzY3JpYmUgcmVxdWVzdCBiZWNhdXNlIGFuIGFjdGl2ZSBzdWJzY3JpcHRpb24gd2l0aCBpZCAnICsgYFxcYCR7Y2xpZW50U3Vic2NyaXB0aW9uSWR9XFxgIGZvciAnJHtzdWJzY3JpcHRpb25OYW1lfScgZXZlbnRzIGAgKyAnY291bGQgbm90IGJlIGZvdW5kLicpO1xuICAgIH1cbiAgfVxuICBfYnVpbGRBcmdzKGFyZ3MsIG92ZXJyaWRlLCBlbmNvZGluZywgZXh0cmEpIHtcbiAgICBjb25zdCBjb21taXRtZW50ID0gb3ZlcnJpZGUgfHwgdGhpcy5fY29tbWl0bWVudDtcbiAgICBpZiAoY29tbWl0bWVudCB8fCBlbmNvZGluZyB8fCBleHRyYSkge1xuICAgICAgbGV0IG9wdGlvbnMgPSB7fTtcbiAgICAgIGlmIChlbmNvZGluZykge1xuICAgICAgICBvcHRpb25zLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgICB9XG4gICAgICBpZiAoY29tbWl0bWVudCkge1xuICAgICAgICBvcHRpb25zLmNvbW1pdG1lbnQgPSBjb21taXRtZW50O1xuICAgICAgfVxuICAgICAgaWYgKGV4dHJhKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKG9wdGlvbnMsIGV4dHJhKTtcbiAgICAgIH1cbiAgICAgIGFyZ3MucHVzaChvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFyZ3M7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChhcmdzLCBvdmVycmlkZSwgZW5jb2RpbmcsIGV4dHJhKSB7XG4gICAgY29uc3QgY29tbWl0bWVudCA9IG92ZXJyaWRlIHx8IHRoaXMuX2NvbW1pdG1lbnQ7XG4gICAgaWYgKGNvbW1pdG1lbnQgJiYgIVsnY29uZmlybWVkJywgJ2ZpbmFsaXplZCddLmluY2x1ZGVzKGNvbW1pdG1lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzaW5nIENvbm5lY3Rpb24gd2l0aCBkZWZhdWx0IGNvbW1pdG1lbnQ6IGAnICsgdGhpcy5fY29tbWl0bWVudCArICdgLCBidXQgbWV0aG9kIHJlcXVpcmVzIGF0IGxlYXN0IGBjb25maXJtZWRgJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9idWlsZEFyZ3MoYXJncywgb3ZlcnJpZGUsIGVuY29kaW5nLCBleHRyYSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfd3NPblNpZ25hdHVyZU5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICByZXN1bHQsXG4gICAgICBzdWJzY3JpcHRpb25cbiAgICB9ID0gY3JlYXRlKG5vdGlmaWNhdGlvbiwgU2lnbmF0dXJlTm90aWZpY2F0aW9uUmVzdWx0KTtcbiAgICBpZiAocmVzdWx0LnZhbHVlICE9PSAncmVjZWl2ZWRTaWduYXR1cmUnKSB7XG4gICAgICAvKipcbiAgICAgICAqIFNwZWNpYWwgY2FzZS5cbiAgICAgICAqIEFmdGVyIGEgc2lnbmF0dXJlIGlzIHByb2Nlc3NlZCwgUlBDcyBhdXRvbWF0aWNhbGx5IGRpc3Bvc2Ugb2YgdGhlXG4gICAgICAgKiBzdWJzY3JpcHRpb24gb24gdGhlIHNlcnZlciBzaWRlLiBXZSBuZWVkIHRvIHRyYWNrIHdoaWNoIG9mIHRoZXNlXG4gICAgICAgKiBzdWJzY3JpcHRpb25zIGhhdmUgYmVlbiBkaXNwb3NlZCBpbiBzdWNoIGEgd2F5LCBzbyB0aGF0IHdlIGtub3dcbiAgICAgICAqIHdoZXRoZXIgdGhlIGNsaWVudCBpcyBkZWFsaW5nIHdpdGggYSBub3QteWV0LXByb2Nlc3NlZCBzaWduYXR1cmVcbiAgICAgICAqIChpbiB3aGljaCBjYXNlIHdlIG11c3QgdGVhciBkb3duIHRoZSBzZXJ2ZXIgc3Vic2NyaXB0aW9uKSBvciBhblxuICAgICAgICogYWxyZWFkeS1wcm9jZXNzZWQgc2lnbmF0dXJlIChpbiB3aGljaCBjYXNlIHRoZSBjbGllbnQgY2FuIHNpbXBseVxuICAgICAgICogY2xlYXIgb3V0IHRoZSBzdWJzY3JpcHRpb24gbG9jYWxseSB3aXRob3V0IHRlbGxpbmcgdGhlIHNlcnZlcikuXG4gICAgICAgKlxuICAgICAgICogTk9URTogVGhlcmUgaXMgYSBwcm9wb3NhbCB0byBlbGltaW5hdGUgdGhpcyBzcGVjaWFsIGNhc2UsIGhlcmU6XG4gICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2lzc3Vlcy8xODg5MlxuICAgICAgICovXG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb25zQXV0b0Rpc3Bvc2VkQnlScGMuYWRkKHN1YnNjcmlwdGlvbik7XG4gICAgfVxuICAgIHRoaXMuX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzdWJzY3JpcHRpb24sIHJlc3VsdC52YWx1ZSA9PT0gJ3JlY2VpdmVkU2lnbmF0dXJlJyA/IFt7XG4gICAgICB0eXBlOiAncmVjZWl2ZWQnXG4gICAgfSwgcmVzdWx0LmNvbnRleHRdIDogW3tcbiAgICAgIHR5cGU6ICdzdGF0dXMnLFxuICAgICAgcmVzdWx0OiByZXN1bHQudmFsdWVcbiAgICB9LCByZXN1bHQuY29udGV4dF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB1cG9uIHNpZ25hdHVyZSB1cGRhdGVzXG4gICAqXG4gICAqIEBwYXJhbSBzaWduYXR1cmUgVHJhbnNhY3Rpb24gc2lnbmF0dXJlIHN0cmluZyBpbiBiYXNlIDU4XG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBpbnZva2Ugb24gc2lnbmF0dXJlIG5vdGlmaWNhdGlvbnNcbiAgICogQHBhcmFtIGNvbW1pdG1lbnQgU3BlY2lmeSB0aGUgY29tbWl0bWVudCBsZXZlbCBzaWduYXR1cmUgbXVzdCByZWFjaCBiZWZvcmUgbm90aWZpY2F0aW9uXG4gICAqIEByZXR1cm4gc3Vic2NyaXB0aW9uIGlkXG4gICAqL1xuICBvblNpZ25hdHVyZShzaWduYXR1cmUsIGNhbGxiYWNrLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbc2lnbmF0dXJlXSwgY29tbWl0bWVudCB8fCB0aGlzLl9jb21taXRtZW50IHx8ICdmaW5hbGl6ZWQnIC8vIEFwcGx5IGNvbm5lY3Rpb24vc2VydmVyIGRlZmF1bHQuXG4gICAgKTtcbiAgICBjb25zdCBjbGllbnRTdWJzY3JpcHRpb25JZCA9IHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2s6IChub3RpZmljYXRpb24sIGNvbnRleHQpID0+IHtcbiAgICAgICAgaWYgKG5vdGlmaWNhdGlvbi50eXBlID09PSAnc3RhdHVzJykge1xuICAgICAgICAgIGNhbGxiYWNrKG5vdGlmaWNhdGlvbi5yZXN1bHQsIGNvbnRleHQpO1xuICAgICAgICAgIC8vIFNpZ25hdHVyZXMgc3Vic2NyaXB0aW9ucyBhcmUgYXV0by1yZW1vdmVkIGJ5IHRoZSBSUEMgc2VydmljZVxuICAgICAgICAgIC8vIHNvIG5vIG5lZWQgdG8gZXhwbGljaXRseSBzZW5kIGFuIHVuc3Vic2NyaWJlIG1lc3NhZ2UuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlU2lnbmF0dXJlTGlzdGVuZXIoY2xpZW50U3Vic2NyaXB0aW9uSWQpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgICAgfSBjYXRjaCAoX2Vycikge1xuICAgICAgICAgICAgLy8gQWxyZWFkeSByZW1vdmVkLlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1ldGhvZDogJ3NpZ25hdHVyZVN1YnNjcmliZScsXG4gICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ3NpZ25hdHVyZVVuc3Vic2NyaWJlJ1xuICAgIH0sIGFyZ3MpO1xuICAgIHJldHVybiBjbGllbnRTdWJzY3JpcHRpb25JZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiBhIHRyYW5zYWN0aW9uIGlzXG4gICAqIHJlY2VpdmVkIGFuZC9vciBwcm9jZXNzZWQuXG4gICAqXG4gICAqIEBwYXJhbSBzaWduYXR1cmUgVHJhbnNhY3Rpb24gc2lnbmF0dXJlIHN0cmluZyBpbiBiYXNlIDU4XG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBpbnZva2Ugb24gc2lnbmF0dXJlIG5vdGlmaWNhdGlvbnNcbiAgICogQHBhcmFtIG9wdGlvbnMgRW5hYmxlIHJlY2VpdmVkIG5vdGlmaWNhdGlvbnMgYW5kIHNldCB0aGUgY29tbWl0bWVudFxuICAgKiAgIGxldmVsIHRoYXQgc2lnbmF0dXJlIG11c3QgcmVhY2ggYmVmb3JlIG5vdGlmaWNhdGlvblxuICAgKiBAcmV0dXJuIHN1YnNjcmlwdGlvbiBpZFxuICAgKi9cbiAgb25TaWduYXR1cmVXaXRoT3B0aW9ucyhzaWduYXR1cmUsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIC4uLmV4dHJhXG4gICAgfSA9IHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBjb21taXRtZW50OiBvcHRpb25zICYmIG9wdGlvbnMuY29tbWl0bWVudCB8fCB0aGlzLl9jb21taXRtZW50IHx8ICdmaW5hbGl6ZWQnIC8vIEFwcGx5IGNvbm5lY3Rpb24vc2VydmVyIGRlZmF1bHQuXG4gICAgfTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtzaWduYXR1cmVdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGV4dHJhKTtcbiAgICBjb25zdCBjbGllbnRTdWJzY3JpcHRpb25JZCA9IHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2s6IChub3RpZmljYXRpb24sIGNvbnRleHQpID0+IHtcbiAgICAgICAgY2FsbGJhY2sobm90aWZpY2F0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgLy8gU2lnbmF0dXJlcyBzdWJzY3JpcHRpb25zIGFyZSBhdXRvLXJlbW92ZWQgYnkgdGhlIFJQQyBzZXJ2aWNlXG4gICAgICAgIC8vIHNvIG5vIG5lZWQgdG8gZXhwbGljaXRseSBzZW5kIGFuIHVuc3Vic2NyaWJlIG1lc3NhZ2UuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVTaWduYXR1cmVMaXN0ZW5lcihjbGllbnRTdWJzY3JpcHRpb25JZCk7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgIH0gY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgICAvLyBBbHJlYWR5IHJlbW92ZWQuXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtZXRob2Q6ICdzaWduYXR1cmVTdWJzY3JpYmUnLFxuICAgICAgdW5zdWJzY3JpYmVNZXRob2Q6ICdzaWduYXR1cmVVbnN1YnNjcmliZSdcbiAgICB9LCBhcmdzKTtcbiAgICByZXR1cm4gY2xpZW50U3Vic2NyaXB0aW9uSWQ7XG4gIH1cblxuICAvKipcbiAgICogRGVyZWdpc3RlciBhIHNpZ25hdHVyZSBub3RpZmljYXRpb24gY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3RlclxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlU2lnbmF0dXJlTGlzdGVuZXIoY2xpZW50U3Vic2NyaXB0aW9uSWQpIHtcbiAgICBhd2FpdCB0aGlzLl91bnN1YnNjcmliZUNsaWVudFN1YnNjcmlwdGlvbihjbGllbnRTdWJzY3JpcHRpb25JZCwgJ3NpZ25hdHVyZSByZXN1bHQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uUm9vdE5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICByZXN1bHQsXG4gICAgICBzdWJzY3JpcHRpb25cbiAgICB9ID0gY3JlYXRlKG5vdGlmaWNhdGlvbiwgUm9vdE5vdGlmaWNhdGlvblJlc3VsdCk7XG4gICAgdGhpcy5faGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHN1YnNjcmlwdGlvbiwgW3Jlc3VsdF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB1cG9uIHJvb3QgY2hhbmdlc1xuICAgKlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gaW52b2tlIHdoZW5ldmVyIHRoZSByb290IGNoYW5nZXNcbiAgICogQHJldHVybiBzdWJzY3JpcHRpb24gaWRcbiAgICovXG4gIG9uUm9vdENoYW5nZShjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl9tYWtlU3Vic2NyaXB0aW9uKHtcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgbWV0aG9kOiAncm9vdFN1YnNjcmliZScsXG4gICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ3Jvb3RVbnN1YnNjcmliZSdcbiAgICB9LCBbXSAvKiBhcmdzICovKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIGEgcm9vdCBub3RpZmljYXRpb24gY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3RlclxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlUm9vdENoYW5nZUxpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKSB7XG4gICAgYXdhaXQgdGhpcy5fdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsICdyb290IGNoYW5nZScpO1xuICB9XG59XG5cbi8qKlxuICogS2V5cGFpciBzaWduZXIgaW50ZXJmYWNlXG4gKi9cblxuLyoqXG4gKiBBbiBhY2NvdW50IGtleXBhaXIgdXNlZCBmb3Igc2lnbmluZyB0cmFuc2FjdGlvbnMuXG4gKi9cbmNsYXNzIEtleXBhaXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGtleXBhaXIgaW5zdGFuY2UuXG4gICAqIEdlbmVyYXRlIHJhbmRvbSBrZXlwYWlyIGlmIG5vIHtAbGluayBFZDI1NTE5S2V5cGFpcn0gaXMgcHJvdmlkZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RWQyNTUxOUtleXBhaXJ9IGtleXBhaXIgZWQyNTUxOSBrZXlwYWlyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihrZXlwYWlyKSB7XG4gICAgdGhpcy5fa2V5cGFpciA9IHZvaWQgMDtcbiAgICB0aGlzLl9rZXlwYWlyID0ga2V5cGFpciA/PyBnZW5lcmF0ZUtleXBhaXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIG5ldyByYW5kb20ga2V5cGFpclxuICAgKlxuICAgKiBAcmV0dXJucyB7S2V5cGFpcn0gS2V5cGFpclxuICAgKi9cbiAgc3RhdGljIGdlbmVyYXRlKCkge1xuICAgIHJldHVybiBuZXcgS2V5cGFpcihnZW5lcmF0ZUtleXBhaXIoKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEga2V5cGFpciBmcm9tIGEgcmF3IHNlY3JldCBrZXkgYnl0ZSBhcnJheS5cbiAgICpcbiAgICogVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgdXNlZCB0byByZWNyZWF0ZSBhIGtleXBhaXIgZnJvbSBhIHByZXZpb3VzbHlcbiAgICogZ2VuZXJhdGVkIHNlY3JldCBrZXkuIEdlbmVyYXRpbmcga2V5cGFpcnMgZnJvbSBhIHJhbmRvbSBzZWVkIHNob3VsZCBiZSBkb25lXG4gICAqIHdpdGggdGhlIHtAbGluayBLZXlwYWlyLmZyb21TZWVkfSBtZXRob2QuXG4gICAqXG4gICAqIEB0aHJvd3MgZXJyb3IgaWYgdGhlIHByb3ZpZGVkIHNlY3JldCBrZXkgaXMgaW52YWxpZCBhbmQgdmFsaWRhdGlvbiBpcyBub3Qgc2tpcHBlZC5cbiAgICpcbiAgICogQHBhcmFtIHNlY3JldEtleSBzZWNyZXQga2V5IGJ5dGUgYXJyYXlcbiAgICogQHBhcmFtIG9wdGlvbnMgc2tpcCBzZWNyZXQga2V5IHZhbGlkYXRpb25cbiAgICpcbiAgICogQHJldHVybnMge0tleXBhaXJ9IEtleXBhaXJcbiAgICovXG4gIHN0YXRpYyBmcm9tU2VjcmV0S2V5KHNlY3JldEtleSwgb3B0aW9ucykge1xuICAgIGlmIChzZWNyZXRLZXkuYnl0ZUxlbmd0aCAhPT0gNjQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHNlY3JldCBrZXkgc2l6ZScpO1xuICAgIH1cbiAgICBjb25zdCBwdWJsaWNLZXkgPSBzZWNyZXRLZXkuc2xpY2UoMzIsIDY0KTtcbiAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMuc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgIGNvbnN0IHByaXZhdGVTY2FsYXIgPSBzZWNyZXRLZXkuc2xpY2UoMCwgMzIpO1xuICAgICAgY29uc3QgY29tcHV0ZWRQdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXkocHJpdmF0ZVNjYWxhcik7XG4gICAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgMzI7IGlpKyspIHtcbiAgICAgICAgaWYgKHB1YmxpY0tleVtpaV0gIT09IGNvbXB1dGVkUHVibGljS2V5W2lpXSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvdmlkZWQgc2VjcmV0S2V5IGlzIGludmFsaWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IEtleXBhaXIoe1xuICAgICAgcHVibGljS2V5LFxuICAgICAgc2VjcmV0S2V5XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBrZXlwYWlyIGZyb20gYSAzMiBieXRlIHNlZWQuXG4gICAqXG4gICAqIEBwYXJhbSBzZWVkIHNlZWQgYnl0ZSBhcnJheVxuICAgKlxuICAgKiBAcmV0dXJucyB7S2V5cGFpcn0gS2V5cGFpclxuICAgKi9cbiAgc3RhdGljIGZyb21TZWVkKHNlZWQpIHtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXkoc2VlZCk7XG4gICAgY29uc3Qgc2VjcmV0S2V5ID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICAgIHNlY3JldEtleS5zZXQoc2VlZCk7XG4gICAgc2VjcmV0S2V5LnNldChwdWJsaWNLZXksIDMyKTtcbiAgICByZXR1cm4gbmV3IEtleXBhaXIoe1xuICAgICAgcHVibGljS2V5LFxuICAgICAgc2VjcmV0S2V5XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHB1YmxpYyBrZXkgZm9yIHRoaXMga2V5cGFpclxuICAgKlxuICAgKiBAcmV0dXJucyB7UHVibGljS2V5fSBQdWJsaWNLZXlcbiAgICovXG4gIGdldCBwdWJsaWNLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkodGhpcy5fa2V5cGFpci5wdWJsaWNLZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSByYXcgc2VjcmV0IGtleSBmb3IgdGhpcyBrZXlwYWlyXG4gICAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBTZWNyZXQga2V5IGluIGFuIGFycmF5IG9mIFVpbnQ4IGJ5dGVzXG4gICAqL1xuICBnZXQgc2VjcmV0S2V5KCkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheSh0aGlzLl9rZXlwYWlyLnNlY3JldEtleSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBMb29rdXBUYWJsZUluc3RydWN0aW9uVHlwZSdzXG4gKi9cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBhZGRyZXNzIGxvb2t1cCB0YWJsZSBJbnN0cnVjdGlvblR5cGUnc1xuICogQGludGVybmFsXG4gKi9cbmNvbnN0IExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTID0gT2JqZWN0LmZyZWV6ZSh7XG4gIENyZWF0ZUxvb2t1cFRhYmxlOiB7XG4gICAgaW5kZXg6IDAsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCB1NjQoJ3JlY2VudFNsb3QnKSwgQnVmZmVyTGF5b3V0LnU4KCdidW1wU2VlZCcpXSlcbiAgfSxcbiAgRnJlZXplTG9va3VwVGFibGU6IHtcbiAgICBpbmRleDogMSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyldKVxuICB9LFxuICBFeHRlbmRMb29rdXBUYWJsZToge1xuICAgIGluZGV4OiAyLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgdTY0KCksIEJ1ZmZlckxheW91dC5zZXEocHVibGljS2V5KCksIEJ1ZmZlckxheW91dC5vZmZzZXQoQnVmZmVyTGF5b3V0LnUzMigpLCAtOCksICdhZGRyZXNzZXMnKV0pXG4gIH0sXG4gIERlYWN0aXZhdGVMb29rdXBUYWJsZToge1xuICAgIGluZGV4OiAzLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH0sXG4gIENsb3NlTG9va3VwVGFibGU6IHtcbiAgICBpbmRleDogNCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyldKVxuICB9XG59KTtcbmNsYXNzIEFkZHJlc3NMb29rdXBUYWJsZUluc3RydWN0aW9uIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuICBzdGF0aWMgZGVjb2RlSW5zdHJ1Y3Rpb25UeXBlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGNvbnN0IGluc3RydWN0aW9uVHlwZUxheW91dCA9IEJ1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyk7XG4gICAgY29uc3QgaW5kZXggPSBpbnN0cnVjdGlvblR5cGVMYXlvdXQuZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpO1xuICAgIGxldCB0eXBlO1xuICAgIGZvciAoY29uc3QgW2xheW91dFR5cGUsIGxheW91dF0gb2YgT2JqZWN0LmVudHJpZXMoTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMpKSB7XG4gICAgICBpZiAobGF5b3V0LmluZGV4ID09IGluZGV4KSB7XG4gICAgICAgIHR5cGUgPSBsYXlvdXRUeXBlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSW5zdHJ1Y3Rpb24uIFNob3VsZCBiZSBhIExvb2t1cFRhYmxlIEluc3RydWN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIHN0YXRpYyBkZWNvZGVDcmVhdGVMb29rdXBUYWJsZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5c0xlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCA0KTtcbiAgICBjb25zdCB7XG4gICAgICByZWNlbnRTbG90XG4gICAgfSA9IGRlY29kZURhdGEkMShMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5DcmVhdGVMb29rdXBUYWJsZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGF1dGhvcml0eTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBwYXllcjogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXksXG4gICAgICByZWNlbnRTbG90OiBOdW1iZXIocmVjZW50U2xvdClcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBkZWNvZGVFeHRlbmRMb29rdXBUYWJsZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICBpZiAoaW5zdHJ1Y3Rpb24ua2V5cy5sZW5ndGggPCAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5zdHJ1Y3Rpb247IGZvdW5kICR7aW5zdHJ1Y3Rpb24ua2V5cy5sZW5ndGh9IGtleXMsIGV4cGVjdGVkIGF0IGxlYXN0IDJgKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYWRkcmVzc2VzXG4gICAgfSA9IGRlY29kZURhdGEkMShMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5FeHRlbmRMb29rdXBUYWJsZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvb2t1cFRhYmxlOiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml0eTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBwYXllcjogaW5zdHJ1Y3Rpb24ua2V5cy5sZW5ndGggPiAyID8gaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXkgOiB1bmRlZmluZWQsXG4gICAgICBhZGRyZXNzZXM6IGFkZHJlc3Nlcy5tYXAoYnVmZmVyID0+IG5ldyBQdWJsaWNLZXkoYnVmZmVyKSlcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBkZWNvZGVDbG9zZUxvb2t1cFRhYmxlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlzTGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIHJldHVybiB7XG4gICAgICBsb29rdXBUYWJsZTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpdHk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgcmVjaXBpZW50OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGRlY29kZUZyZWV6ZUxvb2t1cFRhYmxlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlzTGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuICAgIHJldHVybiB7XG4gICAgICBsb29rdXBUYWJsZTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpdHk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZGVjb2RlRGVhY3RpdmF0ZUxvb2t1cFRhYmxlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlzTGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuICAgIHJldHVybiB7XG4gICAgICBsb29rdXBUYWJsZTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpdHk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBjaGVja1Byb2dyYW1JZChwcm9ncmFtSWQpIHtcbiAgICBpZiAoIXByb2dyYW1JZC5lcXVhbHMoQWRkcmVzc0xvb2t1cFRhYmxlUHJvZ3JhbS5wcm9ncmFtSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5zdHJ1Y3Rpb247IHByb2dyYW1JZCBpcyBub3QgQWRkcmVzc0xvb2t1cFRhYmxlIFByb2dyYW0nKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGNoZWNrS2V5c0xlbmd0aChrZXlzLCBleHBlY3RlZExlbmd0aCkge1xuICAgIGlmIChrZXlzLmxlbmd0aCA8IGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5zdHJ1Y3Rpb247IGZvdW5kICR7a2V5cy5sZW5ndGh9IGtleXMsIGV4cGVjdGVkIGF0IGxlYXN0ICR7ZXhwZWN0ZWRMZW5ndGh9YCk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBBZGRyZXNzTG9va3VwVGFibGVQcm9ncmFtIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuICBzdGF0aWMgY3JlYXRlTG9va3VwVGFibGUocGFyYW1zKSB7XG4gICAgY29uc3QgW2xvb2t1cFRhYmxlQWRkcmVzcywgYnVtcFNlZWRdID0gUHVibGljS2V5LmZpbmRQcm9ncmFtQWRkcmVzc1N5bmMoW3BhcmFtcy5hdXRob3JpdHkudG9CdWZmZXIoKSwgdG9CdWZmZXJMRShCaWdJbnQocGFyYW1zLnJlY2VudFNsb3QpLCA4KV0sIHRoaXMucHJvZ3JhbUlkKTtcbiAgICBjb25zdCB0eXBlID0gTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQ3JlYXRlTG9va3VwVGFibGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgcmVjZW50U2xvdDogQmlnSW50KHBhcmFtcy5yZWNlbnRTbG90KSxcbiAgICAgIGJ1bXBTZWVkOiBidW1wU2VlZFxuICAgIH0pO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBsb29rdXBUYWJsZUFkZHJlc3MsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXR5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogcGFyYW1zLnBheWVyLFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBTeXN0ZW1Qcm9ncmFtLnByb2dyYW1JZCxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgcmV0dXJuIFtuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAga2V5czoga2V5cyxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KSwgbG9va3VwVGFibGVBZGRyZXNzXTtcbiAgfVxuICBzdGF0aWMgZnJlZXplTG9va3VwVGFibGUocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTLkZyZWV6ZUxvb2t1cFRhYmxlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUpO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBwYXJhbXMubG9va3VwVGFibGUsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXR5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAga2V5czoga2V5cyxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZXh0ZW5kTG9va3VwVGFibGUocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTLkV4dGVuZExvb2t1cFRhYmxlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGFkZHJlc3NlczogcGFyYW1zLmFkZHJlc3Nlcy5tYXAoYWRkciA9PiBhZGRyLnRvQnl0ZXMoKSlcbiAgICB9KTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogcGFyYW1zLmxvb2t1cFRhYmxlLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogcGFyYW1zLmF1dGhvcml0eSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9XTtcbiAgICBpZiAocGFyYW1zLnBheWVyKSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5wYXllcixcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTeXN0ZW1Qcm9ncmFtLnByb2dyYW1JZCxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAga2V5czoga2V5cyxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZGVhY3RpdmF0ZUxvb2t1cFRhYmxlKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5EZWFjdGl2YXRlTG9va3VwVGFibGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5sb29rdXBUYWJsZSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5hdXRob3JpdHksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBrZXlzOiBrZXlzLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBjbG9zZUxvb2t1cFRhYmxlKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5DbG9zZUxvb2t1cFRhYmxlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUpO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBwYXJhbXMubG9va3VwVGFibGUsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXR5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogcGFyYW1zLnJlY2lwaWVudCxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9XTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGtleXM6IGtleXMsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSk7XG4gIH1cbn1cbkFkZHJlc3NMb29rdXBUYWJsZVByb2dyYW0ucHJvZ3JhbUlkID0gbmV3IFB1YmxpY0tleSgnQWRkcmVzc0xvb2t1cFRhYjFlMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG4vKipcbiAqIENvbXB1dGUgQnVkZ2V0IEluc3RydWN0aW9uIGNsYXNzXG4gKi9cbmNsYXNzIENvbXB1dGVCdWRnZXRJbnN0cnVjdGlvbiB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogRGVjb2RlIGEgY29tcHV0ZSBidWRnZXQgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiB0eXBlLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUluc3RydWN0aW9uVHlwZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICBjb25zdCBpbnN0cnVjdGlvblR5cGVMYXlvdXQgPSBCdWZmZXJMYXlvdXQudTgoJ2luc3RydWN0aW9uJyk7XG4gICAgY29uc3QgdHlwZUluZGV4ID0gaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0LmRlY29kZShpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICBsZXQgdHlwZTtcbiAgICBmb3IgKGNvbnN0IFtpeFR5cGUsIGxheW91dF0gb2YgT2JqZWN0LmVudHJpZXMoQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUykpIHtcbiAgICAgIGlmIChsYXlvdXQuaW5kZXggPT0gdHlwZUluZGV4KSB7XG4gICAgICAgIHR5cGUgPSBpeFR5cGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5zdHJ1Y3Rpb24gdHlwZSBpbmNvcnJlY3Q7IG5vdCBhIENvbXB1dGVCdWRnZXRJbnN0cnVjdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgcmVxdWVzdCB1bml0cyBjb21wdXRlIGJ1ZGdldCBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVSZXF1ZXN0VW5pdHMoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3Qge1xuICAgICAgdW5pdHMsXG4gICAgICBhZGRpdGlvbmFsRmVlXG4gICAgfSA9IGRlY29kZURhdGEkMShDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlJlcXVlc3RVbml0cywgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVuaXRzLFxuICAgICAgYWRkaXRpb25hbEZlZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIHJlcXVlc3QgaGVhcCBmcmFtZSBjb21wdXRlIGJ1ZGdldCBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVSZXF1ZXN0SGVhcEZyYW1lKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGNvbnN0IHtcbiAgICAgIGJ5dGVzXG4gICAgfSA9IGRlY29kZURhdGEkMShDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlJlcXVlc3RIZWFwRnJhbWUsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBieXRlc1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIHNldCBjb21wdXRlIHVuaXQgbGltaXQgY29tcHV0ZSBidWRnZXQgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlU2V0Q29tcHV0ZVVuaXRMaW1pdChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICBjb25zdCB7XG4gICAgICB1bml0c1xuICAgIH0gPSBkZWNvZGVEYXRhJDEoQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5TZXRDb21wdXRlVW5pdExpbWl0LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgdW5pdHNcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBzZXQgY29tcHV0ZSB1bml0IHByaWNlIGNvbXB1dGUgYnVkZ2V0IGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVNldENvbXB1dGVVbml0UHJpY2UoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3Qge1xuICAgICAgbWljcm9MYW1wb3J0c1xuICAgIH0gPSBkZWNvZGVEYXRhJDEoQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5TZXRDb21wdXRlVW5pdFByaWNlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgbWljcm9MYW1wb3J0c1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tQcm9ncmFtSWQocHJvZ3JhbUlkKSB7XG4gICAgaWYgKCFwcm9ncmFtSWQuZXF1YWxzKENvbXB1dGVCdWRnZXRQcm9ncmFtLnByb2dyYW1JZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnN0cnVjdGlvbjsgcHJvZ3JhbUlkIGlzIG5vdCBDb21wdXRlQnVkZ2V0UHJvZ3JhbScpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIENvbXB1dGVCdWRnZXRJbnN0cnVjdGlvblR5cGUnc1xuICovXG5cbi8qKlxuICogUmVxdWVzdCB1bml0cyBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIFJlcXVlc3QgaGVhcCBmcmFtZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIFNldCBjb21wdXRlIHVuaXQgbGltaXQgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBTZXQgY29tcHV0ZSB1bml0IHByaWNlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgQ29tcHV0ZUJ1ZGdldCBJbnN0cnVjdGlvblR5cGUnc1xuICogQGludGVybmFsXG4gKi9cbmNvbnN0IENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMgPSBPYmplY3QuZnJlZXplKHtcbiAgUmVxdWVzdFVuaXRzOiB7XG4gICAgaW5kZXg6IDAsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTgoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dC51MzIoJ3VuaXRzJyksIEJ1ZmZlckxheW91dC51MzIoJ2FkZGl0aW9uYWxGZWUnKV0pXG4gIH0sXG4gIFJlcXVlc3RIZWFwRnJhbWU6IHtcbiAgICBpbmRleDogMSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgnaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0LnUzMignYnl0ZXMnKV0pXG4gIH0sXG4gIFNldENvbXB1dGVVbml0TGltaXQ6IHtcbiAgICBpbmRleDogMixcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgnaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0LnUzMigndW5pdHMnKV0pXG4gIH0sXG4gIFNldENvbXB1dGVVbml0UHJpY2U6IHtcbiAgICBpbmRleDogMyxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgnaW5zdHJ1Y3Rpb24nKSwgdTY0KCdtaWNyb0xhbXBvcnRzJyldKVxuICB9XG59KTtcblxuLyoqXG4gKiBGYWN0b3J5IGNsYXNzIGZvciB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbnMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgQ29tcHV0ZSBCdWRnZXQgcHJvZ3JhbVxuICovXG5jbGFzcyBDb21wdXRlQnVkZ2V0UHJvZ3JhbSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogUHVibGljIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIENvbXB1dGUgQnVkZ2V0IHByb2dyYW1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwge0BsaW5rIHNldENvbXB1dGVVbml0TGltaXR9IGFuZC9vciB7QGxpbmsgc2V0Q29tcHV0ZVVuaXRQcmljZX1cbiAgICovXG4gIHN0YXRpYyByZXF1ZXN0VW5pdHMocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMuUmVxdWVzdFVuaXRzO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHBhcmFtcyk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFtdLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgcmVxdWVzdEhlYXBGcmFtZShwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5SZXF1ZXN0SGVhcEZyYW1lO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHBhcmFtcyk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFtdLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgc2V0Q29tcHV0ZVVuaXRMaW1pdChwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5TZXRDb21wdXRlVW5pdExpbWl0O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHBhcmFtcyk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFtdLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgc2V0Q29tcHV0ZVVuaXRQcmljZShwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5TZXRDb21wdXRlVW5pdFByaWNlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIG1pY3JvTGFtcG9ydHM6IEJpZ0ludChwYXJhbXMubWljcm9MYW1wb3J0cylcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW10sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG59XG5Db21wdXRlQnVkZ2V0UHJvZ3JhbS5wcm9ncmFtSWQgPSBuZXcgUHVibGljS2V5KCdDb21wdXRlQnVkZ2V0MTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbmNvbnN0IFBSSVZBVEVfS0VZX0JZVEVTJDEgPSA2NDtcbmNvbnN0IFBVQkxJQ19LRVlfQllURVMkMSA9IDMyO1xuY29uc3QgU0lHTkFUVVJFX0JZVEVTID0gNjQ7XG5cbi8qKlxuICogUGFyYW1zIGZvciBjcmVhdGluZyBhbiBlZDI1NTE5IGluc3RydWN0aW9uIHVzaW5nIGEgcHVibGljIGtleVxuICovXG5cbi8qKlxuICogUGFyYW1zIGZvciBjcmVhdGluZyBhbiBlZDI1NTE5IGluc3RydWN0aW9uIHVzaW5nIGEgcHJpdmF0ZSBrZXlcbiAqL1xuXG5jb25zdCBFRDI1NTE5X0lOU1RSVUNUSU9OX0xBWU9VVCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgnbnVtU2lnbmF0dXJlcycpLCBCdWZmZXJMYXlvdXQudTgoJ3BhZGRpbmcnKSwgQnVmZmVyTGF5b3V0LnUxNignc2lnbmF0dXJlT2Zmc2V0JyksIEJ1ZmZlckxheW91dC51MTYoJ3NpZ25hdHVyZUluc3RydWN0aW9uSW5kZXgnKSwgQnVmZmVyTGF5b3V0LnUxNigncHVibGljS2V5T2Zmc2V0JyksIEJ1ZmZlckxheW91dC51MTYoJ3B1YmxpY0tleUluc3RydWN0aW9uSW5kZXgnKSwgQnVmZmVyTGF5b3V0LnUxNignbWVzc2FnZURhdGFPZmZzZXQnKSwgQnVmZmVyTGF5b3V0LnUxNignbWVzc2FnZURhdGFTaXplJyksIEJ1ZmZlckxheW91dC51MTYoJ21lc3NhZ2VJbnN0cnVjdGlvbkluZGV4JyldKTtcbmNsYXNzIEVkMjU1MTlQcm9ncmFtIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBQdWJsaWMga2V5IHRoYXQgaWRlbnRpZmllcyB0aGUgZWQyNTUxOSBwcm9ncmFtXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gZWQyNTUxOSBpbnN0cnVjdGlvbiB3aXRoIGEgcHVibGljIGtleSBhbmQgc2lnbmF0dXJlLiBUaGVcbiAgICogcHVibGljIGtleSBtdXN0IGJlIGEgYnVmZmVyIHRoYXQgaXMgMzIgYnl0ZXMgbG9uZywgYW5kIHRoZSBzaWduYXR1cmVcbiAgICogbXVzdCBiZSBhIGJ1ZmZlciBvZiA2NCBieXRlcy5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVJbnN0cnVjdGlvbldpdGhQdWJsaWNLZXkocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgcHVibGljS2V5LFxuICAgICAgbWVzc2FnZSxcbiAgICAgIHNpZ25hdHVyZSxcbiAgICAgIGluc3RydWN0aW9uSW5kZXhcbiAgICB9ID0gcGFyYW1zO1xuICAgIGFzc2VydChwdWJsaWNLZXkubGVuZ3RoID09PSBQVUJMSUNfS0VZX0JZVEVTJDEsIGBQdWJsaWMgS2V5IG11c3QgYmUgJHtQVUJMSUNfS0VZX0JZVEVTJDF9IGJ5dGVzIGJ1dCByZWNlaXZlZCAke3B1YmxpY0tleS5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgYXNzZXJ0KHNpZ25hdHVyZS5sZW5ndGggPT09IFNJR05BVFVSRV9CWVRFUywgYFNpZ25hdHVyZSBtdXN0IGJlICR7U0lHTkFUVVJFX0JZVEVTfSBieXRlcyBidXQgcmVjZWl2ZWQgJHtzaWduYXR1cmUubGVuZ3RofSBieXRlc2ApO1xuICAgIGNvbnN0IHB1YmxpY0tleU9mZnNldCA9IEVEMjU1MTlfSU5TVFJVQ1RJT05fTEFZT1VULnNwYW47XG4gICAgY29uc3Qgc2lnbmF0dXJlT2Zmc2V0ID0gcHVibGljS2V5T2Zmc2V0ICsgcHVibGljS2V5Lmxlbmd0aDtcbiAgICBjb25zdCBtZXNzYWdlRGF0YU9mZnNldCA9IHNpZ25hdHVyZU9mZnNldCArIHNpZ25hdHVyZS5sZW5ndGg7XG4gICAgY29uc3QgbnVtU2lnbmF0dXJlcyA9IDE7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0gQnVmZmVyLmFsbG9jKG1lc3NhZ2VEYXRhT2Zmc2V0ICsgbWVzc2FnZS5sZW5ndGgpO1xuICAgIGNvbnN0IGluZGV4ID0gaW5zdHJ1Y3Rpb25JbmRleCA9PSBudWxsID8gMHhmZmZmIC8vIEFuIGluZGV4IG9mIGB1MTY6Ok1BWGAgbWFrZXMgaXQgZGVmYXVsdCB0byB0aGUgY3VycmVudCBpbnN0cnVjdGlvbi5cbiAgICA6IGluc3RydWN0aW9uSW5kZXg7XG4gICAgRUQyNTUxOV9JTlNUUlVDVElPTl9MQVlPVVQuZW5jb2RlKHtcbiAgICAgIG51bVNpZ25hdHVyZXMsXG4gICAgICBwYWRkaW5nOiAwLFxuICAgICAgc2lnbmF0dXJlT2Zmc2V0LFxuICAgICAgc2lnbmF0dXJlSW5zdHJ1Y3Rpb25JbmRleDogaW5kZXgsXG4gICAgICBwdWJsaWNLZXlPZmZzZXQsXG4gICAgICBwdWJsaWNLZXlJbnN0cnVjdGlvbkluZGV4OiBpbmRleCxcbiAgICAgIG1lc3NhZ2VEYXRhT2Zmc2V0LFxuICAgICAgbWVzc2FnZURhdGFTaXplOiBtZXNzYWdlLmxlbmd0aCxcbiAgICAgIG1lc3NhZ2VJbnN0cnVjdGlvbkluZGV4OiBpbmRleFxuICAgIH0sIGluc3RydWN0aW9uRGF0YSk7XG4gICAgaW5zdHJ1Y3Rpb25EYXRhLmZpbGwocHVibGljS2V5LCBwdWJsaWNLZXlPZmZzZXQpO1xuICAgIGluc3RydWN0aW9uRGF0YS5maWxsKHNpZ25hdHVyZSwgc2lnbmF0dXJlT2Zmc2V0KTtcbiAgICBpbnN0cnVjdGlvbkRhdGEuZmlsbChtZXNzYWdlLCBtZXNzYWdlRGF0YU9mZnNldCk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFtdLFxuICAgICAgcHJvZ3JhbUlkOiBFZDI1NTE5UHJvZ3JhbS5wcm9ncmFtSWQsXG4gICAgICBkYXRhOiBpbnN0cnVjdGlvbkRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gZWQyNTUxOSBpbnN0cnVjdGlvbiB3aXRoIGEgcHJpdmF0ZSBrZXkuIFRoZSBwcml2YXRlIGtleVxuICAgKiBtdXN0IGJlIGEgYnVmZmVyIHRoYXQgaXMgNjQgYnl0ZXMgbG9uZy5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVJbnN0cnVjdGlvbldpdGhQcml2YXRlS2V5KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHByaXZhdGVLZXksXG4gICAgICBtZXNzYWdlLFxuICAgICAgaW5zdHJ1Y3Rpb25JbmRleFxuICAgIH0gPSBwYXJhbXM7XG4gICAgYXNzZXJ0KHByaXZhdGVLZXkubGVuZ3RoID09PSBQUklWQVRFX0tFWV9CWVRFUyQxLCBgUHJpdmF0ZSBrZXkgbXVzdCBiZSAke1BSSVZBVEVfS0VZX0JZVEVTJDF9IGJ5dGVzIGJ1dCByZWNlaXZlZCAke3ByaXZhdGVLZXkubGVuZ3RofSBieXRlc2ApO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBrZXlwYWlyID0gS2V5cGFpci5mcm9tU2VjcmV0S2V5KHByaXZhdGVLZXkpO1xuICAgICAgY29uc3QgcHVibGljS2V5ID0ga2V5cGFpci5wdWJsaWNLZXkudG9CeXRlcygpO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gc2lnbihtZXNzYWdlLCBrZXlwYWlyLnNlY3JldEtleSk7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVJbnN0cnVjdGlvbldpdGhQdWJsaWNLZXkoe1xuICAgICAgICBwdWJsaWNLZXksXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgaW5zdHJ1Y3Rpb25JbmRleFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgY3JlYXRpbmcgaW5zdHJ1Y3Rpb247ICR7ZXJyb3J9YCk7XG4gICAgfVxuICB9XG59XG5FZDI1NTE5UHJvZ3JhbS5wcm9ncmFtSWQgPSBuZXcgUHVibGljS2V5KCdFZDI1NTE5U2lnVmVyaWZ5MTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbmNvbnN0IGVjZHNhU2lnbiA9IChtc2dIYXNoLCBwcml2S2V5KSA9PiB7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IHNlY3AyNTZrMS5zaWduKG1zZ0hhc2gsIHByaXZLZXkpO1xuICByZXR1cm4gW3NpZ25hdHVyZS50b0NvbXBhY3RSYXdCeXRlcygpLCBzaWduYXR1cmUucmVjb3ZlcnldO1xufTtcbnNlY3AyNTZrMS51dGlscy5pc1ZhbGlkUHJpdmF0ZUtleTtcbmNvbnN0IHB1YmxpY0tleUNyZWF0ZSA9IHNlY3AyNTZrMS5nZXRQdWJsaWNLZXk7XG5cbmNvbnN0IFBSSVZBVEVfS0VZX0JZVEVTID0gMzI7XG5jb25zdCBFVEhFUkVVTV9BRERSRVNTX0JZVEVTID0gMjA7XG5jb25zdCBQVUJMSUNfS0VZX0JZVEVTID0gNjQ7XG5jb25zdCBTSUdOQVRVUkVfT0ZGU0VUU19TRVJJQUxJWkVEX1NJWkUgPSAxMTtcblxuLyoqXG4gKiBQYXJhbXMgZm9yIGNyZWF0aW5nIGFuIHNlY3AyNTZrMSBpbnN0cnVjdGlvbiB1c2luZyBhIHB1YmxpYyBrZXlcbiAqL1xuXG4vKipcbiAqIFBhcmFtcyBmb3IgY3JlYXRpbmcgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHVzaW5nIGFuIEV0aGVyZXVtIGFkZHJlc3NcbiAqL1xuXG4vKipcbiAqIFBhcmFtcyBmb3IgY3JlYXRpbmcgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHVzaW5nIGEgcHJpdmF0ZSBrZXlcbiAqL1xuXG5jb25zdCBTRUNQMjU2SzFfSU5TVFJVQ1RJT05fTEFZT1VUID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnU4KCdudW1TaWduYXR1cmVzJyksIEJ1ZmZlckxheW91dC51MTYoJ3NpZ25hdHVyZU9mZnNldCcpLCBCdWZmZXJMYXlvdXQudTgoJ3NpZ25hdHVyZUluc3RydWN0aW9uSW5kZXgnKSwgQnVmZmVyTGF5b3V0LnUxNignZXRoQWRkcmVzc09mZnNldCcpLCBCdWZmZXJMYXlvdXQudTgoJ2V0aEFkZHJlc3NJbnN0cnVjdGlvbkluZGV4JyksIEJ1ZmZlckxheW91dC51MTYoJ21lc3NhZ2VEYXRhT2Zmc2V0JyksIEJ1ZmZlckxheW91dC51MTYoJ21lc3NhZ2VEYXRhU2l6ZScpLCBCdWZmZXJMYXlvdXQudTgoJ21lc3NhZ2VJbnN0cnVjdGlvbkluZGV4JyksIEJ1ZmZlckxheW91dC5ibG9iKDIwLCAnZXRoQWRkcmVzcycpLCBCdWZmZXJMYXlvdXQuYmxvYig2NCwgJ3NpZ25hdHVyZScpLCBCdWZmZXJMYXlvdXQudTgoJ3JlY292ZXJ5SWQnKV0pO1xuY2xhc3MgU2VjcDI1NmsxUHJvZ3JhbSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogUHVibGljIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIHNlY3AyNTZrMSBwcm9ncmFtXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYW4gRXRoZXJldW0gYWRkcmVzcyBmcm9tIGEgc2VjcDI1NmsxIHB1YmxpYyBrZXkgYnVmZmVyLlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5IGEgNjQgYnl0ZSBzZWNwMjU2azEgcHVibGljIGtleSBidWZmZXJcbiAgICovXG4gIHN0YXRpYyBwdWJsaWNLZXlUb0V0aEFkZHJlc3MocHVibGljS2V5KSB7XG4gICAgYXNzZXJ0KHB1YmxpY0tleS5sZW5ndGggPT09IFBVQkxJQ19LRVlfQllURVMsIGBQdWJsaWMga2V5IG11c3QgYmUgJHtQVUJMSUNfS0VZX0JZVEVTfSBieXRlcyBidXQgcmVjZWl2ZWQgJHtwdWJsaWNLZXkubGVuZ3RofSBieXRlc2ApO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oa2VjY2FrXzI1Nih0b0J1ZmZlcihwdWJsaWNLZXkpKSkuc2xpY2UoLUVUSEVSRVVNX0FERFJFU1NfQllURVMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGNvbnN0cnVjdGluZyBFdGhlcmV1bSBhZGRyZXNzOiAke2Vycm9yfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHdpdGggYSBwdWJsaWMga2V5LiBUaGUgcHVibGljIGtleVxuICAgKiBtdXN0IGJlIGEgYnVmZmVyIHRoYXQgaXMgNjQgYnl0ZXMgbG9uZy5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVJbnN0cnVjdGlvbldpdGhQdWJsaWNLZXkocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgcHVibGljS2V5LFxuICAgICAgbWVzc2FnZSxcbiAgICAgIHNpZ25hdHVyZSxcbiAgICAgIHJlY292ZXJ5SWQsXG4gICAgICBpbnN0cnVjdGlvbkluZGV4XG4gICAgfSA9IHBhcmFtcztcbiAgICByZXR1cm4gU2VjcDI1NmsxUHJvZ3JhbS5jcmVhdGVJbnN0cnVjdGlvbldpdGhFdGhBZGRyZXNzKHtcbiAgICAgIGV0aEFkZHJlc3M6IFNlY3AyNTZrMVByb2dyYW0ucHVibGljS2V5VG9FdGhBZGRyZXNzKHB1YmxpY0tleSksXG4gICAgICBtZXNzYWdlLFxuICAgICAgc2lnbmF0dXJlLFxuICAgICAgcmVjb3ZlcnlJZCxcbiAgICAgIGluc3RydWN0aW9uSW5kZXhcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHdpdGggYW4gRXRoZXJldW0gYWRkcmVzcy4gVGhlIGFkZHJlc3NcbiAgICogbXVzdCBiZSBhIGhleCBzdHJpbmcgb3IgYSBidWZmZXIgdGhhdCBpcyAyMCBieXRlcyBsb25nLlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUluc3RydWN0aW9uV2l0aEV0aEFkZHJlc3MocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgZXRoQWRkcmVzczogcmF3QWRkcmVzcyxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBzaWduYXR1cmUsXG4gICAgICByZWNvdmVyeUlkLFxuICAgICAgaW5zdHJ1Y3Rpb25JbmRleCA9IDBcbiAgICB9ID0gcGFyYW1zO1xuICAgIGxldCBldGhBZGRyZXNzO1xuICAgIGlmICh0eXBlb2YgcmF3QWRkcmVzcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChyYXdBZGRyZXNzLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgZXRoQWRkcmVzcyA9IEJ1ZmZlci5mcm9tKHJhd0FkZHJlc3Muc3Vic3RyKDIpLCAnaGV4Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBldGhBZGRyZXNzID0gQnVmZmVyLmZyb20ocmF3QWRkcmVzcywgJ2hleCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBldGhBZGRyZXNzID0gcmF3QWRkcmVzcztcbiAgICB9XG4gICAgYXNzZXJ0KGV0aEFkZHJlc3MubGVuZ3RoID09PSBFVEhFUkVVTV9BRERSRVNTX0JZVEVTLCBgQWRkcmVzcyBtdXN0IGJlICR7RVRIRVJFVU1fQUREUkVTU19CWVRFU30gYnl0ZXMgYnV0IHJlY2VpdmVkICR7ZXRoQWRkcmVzcy5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgY29uc3QgZGF0YVN0YXJ0ID0gMSArIFNJR05BVFVSRV9PRkZTRVRTX1NFUklBTElaRURfU0laRTtcbiAgICBjb25zdCBldGhBZGRyZXNzT2Zmc2V0ID0gZGF0YVN0YXJ0O1xuICAgIGNvbnN0IHNpZ25hdHVyZU9mZnNldCA9IGRhdGFTdGFydCArIGV0aEFkZHJlc3MubGVuZ3RoO1xuICAgIGNvbnN0IG1lc3NhZ2VEYXRhT2Zmc2V0ID0gc2lnbmF0dXJlT2Zmc2V0ICsgc2lnbmF0dXJlLmxlbmd0aCArIDE7XG4gICAgY29uc3QgbnVtU2lnbmF0dXJlcyA9IDE7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0gQnVmZmVyLmFsbG9jKFNFQ1AyNTZLMV9JTlNUUlVDVElPTl9MQVlPVVQuc3BhbiArIG1lc3NhZ2UubGVuZ3RoKTtcbiAgICBTRUNQMjU2SzFfSU5TVFJVQ1RJT05fTEFZT1VULmVuY29kZSh7XG4gICAgICBudW1TaWduYXR1cmVzLFxuICAgICAgc2lnbmF0dXJlT2Zmc2V0LFxuICAgICAgc2lnbmF0dXJlSW5zdHJ1Y3Rpb25JbmRleDogaW5zdHJ1Y3Rpb25JbmRleCxcbiAgICAgIGV0aEFkZHJlc3NPZmZzZXQsXG4gICAgICBldGhBZGRyZXNzSW5zdHJ1Y3Rpb25JbmRleDogaW5zdHJ1Y3Rpb25JbmRleCxcbiAgICAgIG1lc3NhZ2VEYXRhT2Zmc2V0LFxuICAgICAgbWVzc2FnZURhdGFTaXplOiBtZXNzYWdlLmxlbmd0aCxcbiAgICAgIG1lc3NhZ2VJbnN0cnVjdGlvbkluZGV4OiBpbnN0cnVjdGlvbkluZGV4LFxuICAgICAgc2lnbmF0dXJlOiB0b0J1ZmZlcihzaWduYXR1cmUpLFxuICAgICAgZXRoQWRkcmVzczogdG9CdWZmZXIoZXRoQWRkcmVzcyksXG4gICAgICByZWNvdmVyeUlkXG4gICAgfSwgaW5zdHJ1Y3Rpb25EYXRhKTtcbiAgICBpbnN0cnVjdGlvbkRhdGEuZmlsbCh0b0J1ZmZlcihtZXNzYWdlKSwgU0VDUDI1NksxX0lOU1RSVUNUSU9OX0xBWU9VVC5zcGFuKTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW10sXG4gICAgICBwcm9ncmFtSWQ6IFNlY3AyNTZrMVByb2dyYW0ucHJvZ3JhbUlkLFxuICAgICAgZGF0YTogaW5zdHJ1Y3Rpb25EYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIHNlY3AyNTZrMSBpbnN0cnVjdGlvbiB3aXRoIGEgcHJpdmF0ZSBrZXkuIFRoZSBwcml2YXRlIGtleVxuICAgKiBtdXN0IGJlIGEgYnVmZmVyIHRoYXQgaXMgMzIgYnl0ZXMgbG9uZy5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVJbnN0cnVjdGlvbldpdGhQcml2YXRlS2V5KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHByaXZhdGVLZXk6IHBrZXksXG4gICAgICBtZXNzYWdlLFxuICAgICAgaW5zdHJ1Y3Rpb25JbmRleFxuICAgIH0gPSBwYXJhbXM7XG4gICAgYXNzZXJ0KHBrZXkubGVuZ3RoID09PSBQUklWQVRFX0tFWV9CWVRFUywgYFByaXZhdGUga2V5IG11c3QgYmUgJHtQUklWQVRFX0tFWV9CWVRFU30gYnl0ZXMgYnV0IHJlY2VpdmVkICR7cGtleS5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSB0b0J1ZmZlcihwa2V5KTtcbiAgICAgIGNvbnN0IHB1YmxpY0tleSA9IHB1YmxpY0tleUNyZWF0ZShwcml2YXRlS2V5LCBmYWxzZSAvKiBpc0NvbXByZXNzZWQgKi8pLnNsaWNlKDEpOyAvLyB0aHJvdyBhd2F5IGxlYWRpbmcgYnl0ZVxuICAgICAgY29uc3QgbWVzc2FnZUhhc2ggPSBCdWZmZXIuZnJvbShrZWNjYWtfMjU2KHRvQnVmZmVyKG1lc3NhZ2UpKSk7XG4gICAgICBjb25zdCBbc2lnbmF0dXJlLCByZWNvdmVyeUlkXSA9IGVjZHNhU2lnbihtZXNzYWdlSGFzaCwgcHJpdmF0ZUtleSk7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVJbnN0cnVjdGlvbldpdGhQdWJsaWNLZXkoe1xuICAgICAgICBwdWJsaWNLZXksXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgcmVjb3ZlcnlJZCxcbiAgICAgICAgaW5zdHJ1Y3Rpb25JbmRleFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgY3JlYXRpbmcgaW5zdHJ1Y3Rpb247ICR7ZXJyb3J9YCk7XG4gICAgfVxuICB9XG59XG5TZWNwMjU2azFQcm9ncmFtLnByb2dyYW1JZCA9IG5ldyBQdWJsaWNLZXkoJ0tlY2Nha1NlY3AyNTZrMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxudmFyIF9Mb2NrdXA7XG5cbi8qKlxuICogQWRkcmVzcyBvZiB0aGUgc3Rha2UgY29uZmlnIGFjY291bnQgd2hpY2ggY29uZmlndXJlcyB0aGUgcmF0ZVxuICogb2Ygc3Rha2Ugd2FybXVwIGFuZCBjb29sZG93biBhcyB3ZWxsIGFzIHRoZSBzbGFzaGluZyBwZW5hbHR5LlxuICovXG5jb25zdCBTVEFLRV9DT05GSUdfSUQgPSBuZXcgUHVibGljS2V5KCdTdGFrZUNvbmZpZzExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbi8qKlxuICogU3Rha2UgYWNjb3VudCBhdXRob3JpdHkgaW5mb1xuICovXG5jbGFzcyBBdXRob3JpemVkIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBBdXRob3JpemVkIG9iamVjdFxuICAgKiBAcGFyYW0gc3Rha2VyIHRoZSBzdGFrZSBhdXRob3JpdHlcbiAgICogQHBhcmFtIHdpdGhkcmF3ZXIgdGhlIHdpdGhkcmF3IGF1dGhvcml0eVxuICAgKi9cbiAgY29uc3RydWN0b3Ioc3Rha2VyLCB3aXRoZHJhd2VyKSB7XG4gICAgLyoqIHN0YWtlIGF1dGhvcml0eSAqL1xuICAgIHRoaXMuc3Rha2VyID0gdm9pZCAwO1xuICAgIC8qKiB3aXRoZHJhdyBhdXRob3JpdHkgKi9cbiAgICB0aGlzLndpdGhkcmF3ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGFrZXIgPSBzdGFrZXI7XG4gICAgdGhpcy53aXRoZHJhd2VyID0gd2l0aGRyYXdlcjtcbiAgfVxufVxuLyoqXG4gKiBTdGFrZSBhY2NvdW50IGxvY2t1cCBpbmZvXG4gKi9cbmNsYXNzIExvY2t1cCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgTG9ja3VwIG9iamVjdFxuICAgKi9cbiAgY29uc3RydWN0b3IodW5peFRpbWVzdGFtcCwgZXBvY2gsIGN1c3RvZGlhbikge1xuICAgIC8qKiBVbml4IHRpbWVzdGFtcCBvZiBsb2NrdXAgZXhwaXJhdGlvbiAqL1xuICAgIHRoaXMudW5peFRpbWVzdGFtcCA9IHZvaWQgMDtcbiAgICAvKiogRXBvY2ggb2YgbG9ja3VwIGV4cGlyYXRpb24gKi9cbiAgICB0aGlzLmVwb2NoID0gdm9pZCAwO1xuICAgIC8qKiBMb2NrdXAgY3VzdG9kaWFuIGF1dGhvcml0eSAqL1xuICAgIHRoaXMuY3VzdG9kaWFuID0gdm9pZCAwO1xuICAgIHRoaXMudW5peFRpbWVzdGFtcCA9IHVuaXhUaW1lc3RhbXA7XG4gICAgdGhpcy5lcG9jaCA9IGVwb2NoO1xuICAgIHRoaXMuY3VzdG9kaWFuID0gY3VzdG9kaWFuO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmF1bHQsIGluYWN0aXZlIExvY2t1cCB2YWx1ZVxuICAgKi9cbn1cbl9Mb2NrdXAgPSBMb2NrdXA7XG5Mb2NrdXAuZGVmYXVsdCA9IG5ldyBfTG9ja3VwKDAsIDAsIFB1YmxpY0tleS5kZWZhdWx0KTtcbi8qKlxuICogQ3JlYXRlIHN0YWtlIGFjY291bnQgdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogQ3JlYXRlIHN0YWtlIGFjY291bnQgd2l0aCBzZWVkIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIEluaXRpYWxpemUgc3Rha2UgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogRGVsZWdhdGUgc3Rha2UgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogQXV0aG9yaXplIHN0YWtlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIEF1dGhvcml6ZSBzdGFrZSBpbnN0cnVjdGlvbiBwYXJhbXMgdXNpbmcgYSBkZXJpdmVkIGtleVxuICovXG4vKipcbiAqIFNwbGl0IHN0YWtlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIFNwbGl0IHdpdGggc2VlZCB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuLyoqXG4gKiBXaXRoZHJhdyBzdGFrZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuLyoqXG4gKiBEZWFjdGl2YXRlIHN0YWtlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIE1lcmdlIHN0YWtlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIFN0YWtlIEluc3RydWN0aW9uIGNsYXNzXG4gKi9cbmNsYXNzIFN0YWtlSW5zdHJ1Y3Rpb24ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gdHlwZS5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVJbnN0cnVjdGlvblR5cGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKTtcbiAgICBjb25zdCB0eXBlSW5kZXggPSBpbnN0cnVjdGlvblR5cGVMYXlvdXQuZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpO1xuICAgIGxldCB0eXBlO1xuICAgIGZvciAoY29uc3QgW2l4VHlwZSwgbGF5b3V0XSBvZiBPYmplY3QuZW50cmllcyhTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTKSkge1xuICAgICAgaWYgKGxheW91dC5pbmRleCA9PSB0eXBlSW5kZXgpIHtcbiAgICAgICAgdHlwZSA9IGl4VHlwZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnN0cnVjdGlvbiB0eXBlIGluY29ycmVjdDsgbm90IGEgU3Rha2VJbnN0cnVjdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBpbml0aWFsaXplIHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUluaXRpYWxpemUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAyKTtcbiAgICBjb25zdCB7XG4gICAgICBhdXRob3JpemVkLFxuICAgICAgbG9ja3VwXG4gICAgfSA9IGRlY29kZURhdGEkMShTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkluaXRpYWxpemUsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkOiBuZXcgQXV0aG9yaXplZChuZXcgUHVibGljS2V5KGF1dGhvcml6ZWQuc3Rha2VyKSwgbmV3IFB1YmxpY0tleShhdXRob3JpemVkLndpdGhkcmF3ZXIpKSxcbiAgICAgIGxvY2t1cDogbmV3IExvY2t1cChsb2NrdXAudW5peFRpbWVzdGFtcCwgbG9ja3VwLmVwb2NoLCBuZXcgUHVibGljS2V5KGxvY2t1cC5jdXN0b2RpYW4pKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgZGVsZWdhdGUgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlRGVsZWdhdGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCA2KTtcbiAgICBkZWNvZGVEYXRhJDEoU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5EZWxlZ2F0ZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIHZvdGVQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1s1XS5wdWJrZXlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBhdXRob3JpemUgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQXV0aG9yaXplKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgY29uc3Qge1xuICAgICAgbmV3QXV0aG9yaXplZCxcbiAgICAgIHN0YWtlQXV0aG9yaXphdGlvblR5cGVcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICBjb25zdCBvID0ge1xuICAgICAgc3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXksXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5OiBuZXcgUHVibGljS2V5KG5ld0F1dGhvcml6ZWQpLFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZToge1xuICAgICAgICBpbmRleDogc3Rha2VBdXRob3JpemF0aW9uVHlwZVxuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGluc3RydWN0aW9uLmtleXMubGVuZ3RoID4gMykge1xuICAgICAgby5jdXN0b2RpYW5QdWJrZXkgPSBpbnN0cnVjdGlvbi5rZXlzWzNdLnB1YmtleTtcbiAgICB9XG4gICAgcmV0dXJuIG87XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGF1dGhvcml6ZS13aXRoLXNlZWQgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQXV0aG9yaXplV2l0aFNlZWQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAyKTtcbiAgICBjb25zdCB7XG4gICAgICBuZXdBdXRob3JpemVkLFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZSxcbiAgICAgIGF1dGhvcml0eVNlZWQsXG4gICAgICBhdXRob3JpdHlPd25lclxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemVXaXRoU2VlZCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgY29uc3QgbyA9IHtcbiAgICAgIHN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml0eUJhc2U6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgYXV0aG9yaXR5U2VlZDogYXV0aG9yaXR5U2VlZCxcbiAgICAgIGF1dGhvcml0eU93bmVyOiBuZXcgUHVibGljS2V5KGF1dGhvcml0eU93bmVyKSxcbiAgICAgIG5ld0F1dGhvcml6ZWRQdWJrZXk6IG5ldyBQdWJsaWNLZXkobmV3QXV0aG9yaXplZCksXG4gICAgICBzdGFrZUF1dGhvcml6YXRpb25UeXBlOiB7XG4gICAgICAgIGluZGV4OiBzdGFrZUF1dGhvcml6YXRpb25UeXBlXG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaW5zdHJ1Y3Rpb24ua2V5cy5sZW5ndGggPiAzKSB7XG4gICAgICBvLmN1c3RvZGlhblB1YmtleSA9IGluc3RydWN0aW9uLmtleXNbM10ucHVia2V5O1xuICAgIH1cbiAgICByZXR1cm4gbztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBzcGxpdCBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVTcGxpdChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhbXBvcnRzXG4gICAgfSA9IGRlY29kZURhdGEkMShTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLlNwbGl0LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgc3BsaXRTdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleSxcbiAgICAgIGxhbXBvcnRzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBtZXJnZSBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVNZXJnZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIGRlY29kZURhdGEkMShTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLk1lcmdlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgc291cmNlU3Rha2VQdWJLZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1s0XS5wdWJrZXlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHdpdGhkcmF3IHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVdpdGhkcmF3KGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgNSk7XG4gICAgY29uc3Qge1xuICAgICAgbGFtcG9ydHNcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuV2l0aGRyYXcsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIGNvbnN0IG8gPSB7XG4gICAgICBzdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICB0b1B1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzRdLnB1YmtleSxcbiAgICAgIGxhbXBvcnRzXG4gICAgfTtcbiAgICBpZiAoaW5zdHJ1Y3Rpb24ua2V5cy5sZW5ndGggPiA1KSB7XG4gICAgICBvLmN1c3RvZGlhblB1YmtleSA9IGluc3RydWN0aW9uLmtleXNbNV0ucHVia2V5O1xuICAgIH1cbiAgICByZXR1cm4gbztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBkZWFjdGl2YXRlIHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZURlYWN0aXZhdGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBkZWNvZGVEYXRhJDEoU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5EZWFjdGl2YXRlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGNoZWNrUHJvZ3JhbUlkKHByb2dyYW1JZCkge1xuICAgIGlmICghcHJvZ3JhbUlkLmVxdWFscyhTdGFrZVByb2dyYW0ucHJvZ3JhbUlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluc3RydWN0aW9uOyBwcm9ncmFtSWQgaXMgbm90IFN0YWtlUHJvZ3JhbScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBjaGVja0tleUxlbmd0aChrZXlzLCBleHBlY3RlZExlbmd0aCkge1xuICAgIGlmIChrZXlzLmxlbmd0aCA8IGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5zdHJ1Y3Rpb247IGZvdW5kICR7a2V5cy5sZW5ndGh9IGtleXMsIGV4cGVjdGVkIGF0IGxlYXN0ICR7ZXhwZWN0ZWRMZW5ndGh9YCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgU3Rha2VJbnN0cnVjdGlvblR5cGUnc1xuICovXG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgc3Rha2UgSW5zdHJ1Y3Rpb25UeXBlJ3NcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTID0gT2JqZWN0LmZyZWV6ZSh7XG4gIEluaXRpYWxpemU6IHtcbiAgICBpbmRleDogMCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIGF1dGhvcml6ZWQoKSwgbG9ja3VwKCldKVxuICB9LFxuICBBdXRob3JpemU6IHtcbiAgICBpbmRleDogMSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgnbmV3QXV0aG9yaXplZCcpLCBCdWZmZXJMYXlvdXQudTMyKCdzdGFrZUF1dGhvcml6YXRpb25UeXBlJyldKVxuICB9LFxuICBEZWxlZ2F0ZToge1xuICAgIGluZGV4OiAyLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH0sXG4gIFNwbGl0OiB7XG4gICAgaW5kZXg6IDMsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQubnM2NCgnbGFtcG9ydHMnKV0pXG4gIH0sXG4gIFdpdGhkcmF3OiB7XG4gICAgaW5kZXg6IDQsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQubnM2NCgnbGFtcG9ydHMnKV0pXG4gIH0sXG4gIERlYWN0aXZhdGU6IHtcbiAgICBpbmRleDogNSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyldKVxuICB9LFxuICBNZXJnZToge1xuICAgIGluZGV4OiA3LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH0sXG4gIEF1dGhvcml6ZVdpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDgsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ25ld0F1dGhvcml6ZWQnKSwgQnVmZmVyTGF5b3V0LnUzMignc3Rha2VBdXRob3JpemF0aW9uVHlwZScpLCBydXN0U3RyaW5nKCdhdXRob3JpdHlTZWVkJyksIHB1YmxpY0tleSgnYXV0aG9yaXR5T3duZXInKV0pXG4gIH1cbn0pO1xuXG4vKipcbiAqIFN0YWtlIGF1dGhvcml6YXRpb24gdHlwZVxuICovXG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgU3Rha2VBdXRob3JpemF0aW9uTGF5b3V0J3NcbiAqL1xuY29uc3QgU3Rha2VBdXRob3JpemF0aW9uTGF5b3V0ID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFN0YWtlcjoge1xuICAgIGluZGV4OiAwXG4gIH0sXG4gIFdpdGhkcmF3ZXI6IHtcbiAgICBpbmRleDogMVxuICB9XG59KTtcblxuLyoqXG4gKiBGYWN0b3J5IGNsYXNzIGZvciB0cmFuc2FjdGlvbnMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgU3Rha2UgcHJvZ3JhbVxuICovXG5jbGFzcyBTdGFrZVByb2dyYW0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBrZXkgdGhhdCBpZGVudGlmaWVzIHRoZSBTdGFrZSBwcm9ncmFtXG4gICAqL1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhbiBJbml0aWFsaXplIGluc3RydWN0aW9uIHRvIGFkZCB0byBhIFN0YWtlIENyZWF0ZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgc3RhdGljIGluaXRpYWxpemUocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkLFxuICAgICAgbG9ja3VwOiBtYXliZUxvY2t1cFxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgbG9ja3VwID0gbWF5YmVMb2NrdXAgfHwgTG9ja3VwLmRlZmF1bHQ7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuSW5pdGlhbGl6ZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBhdXRob3JpemVkOiB7XG4gICAgICAgIHN0YWtlcjogdG9CdWZmZXIoYXV0aG9yaXplZC5zdGFrZXIudG9CdWZmZXIoKSksXG4gICAgICAgIHdpdGhkcmF3ZXI6IHRvQnVmZmVyKGF1dGhvcml6ZWQud2l0aGRyYXdlci50b0J1ZmZlcigpKVxuICAgICAgfSxcbiAgICAgIGxvY2t1cDoge1xuICAgICAgICB1bml4VGltZXN0YW1wOiBsb2NrdXAudW5peFRpbWVzdGFtcCxcbiAgICAgICAgZXBvY2g6IGxvY2t1cC5lcG9jaCxcbiAgICAgICAgY3VzdG9kaWFuOiB0b0J1ZmZlcihsb2NrdXAuY3VzdG9kaWFuLnRvQnVmZmVyKCkpXG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0ge1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiBzdGFrZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1JFTlRfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb25EYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIFRyYW5zYWN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBTdGFrZSBhY2NvdW50IGF0XG4gICAqICAgYW4gYWRkcmVzcyBnZW5lcmF0ZWQgd2l0aCBgZnJvbWAsIGEgc2VlZCwgYW5kIHRoZSBTdGFrZSBwcm9ncmFtSWRcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVBY2NvdW50V2l0aFNlZWQocGFyYW1zKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50V2l0aFNlZWQoe1xuICAgICAgZnJvbVB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICBuZXdBY2NvdW50UHVia2V5OiBwYXJhbXMuc3Rha2VQdWJrZXksXG4gICAgICBiYXNlUHVia2V5OiBwYXJhbXMuYmFzZVB1YmtleSxcbiAgICAgIHNlZWQ6IHBhcmFtcy5zZWVkLFxuICAgICAgbGFtcG9ydHM6IHBhcmFtcy5sYW1wb3J0cyxcbiAgICAgIHNwYWNlOiB0aGlzLnNwYWNlLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZFxuICAgIH0pKTtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWQsXG4gICAgICBsb2NrdXBcbiAgICB9ID0gcGFyYW1zO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbi5hZGQodGhpcy5pbml0aWFsaXplKHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZCxcbiAgICAgIGxvY2t1cFxuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIFRyYW5zYWN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBTdGFrZSBhY2NvdW50XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlQWNjb3VudChwYXJhbXMpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLmNyZWF0ZUFjY291bnQoe1xuICAgICAgZnJvbVB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICBuZXdBY2NvdW50UHVia2V5OiBwYXJhbXMuc3Rha2VQdWJrZXksXG4gICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgc3BhY2U6IHRoaXMuc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkXG4gICAgfSkpO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZCxcbiAgICAgIGxvY2t1cFxuICAgIH0gPSBwYXJhbXM7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLmFkZCh0aGlzLmluaXRpYWxpemUoe1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkLFxuICAgICAgbG9ja3VwXG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBkZWxlZ2F0ZXMgU3Rha2UgdG9rZW5zIHRvIGEgdmFsaWRhdG9yXG4gICAqIFZvdGUgUHVibGljS2V5LiBUaGlzIHRyYW5zYWN0aW9uIGNhbiBhbHNvIGJlIHVzZWQgdG8gcmVkZWxlZ2F0ZSBTdGFrZVxuICAgKiB0byBhIG5ldyB2YWxpZGF0b3IgVm90ZSBQdWJsaWNLZXkuXG4gICAqL1xuICBzdGF0aWMgZGVsZWdhdGUocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5LFxuICAgICAgdm90ZVB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuRGVsZWdhdGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiB2b3RlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9TVEFLRV9ISVNUT1JZX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNUQUtFX0NPTkZJR19JRCxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBhdXRob3JpemVzIGEgbmV3IFB1YmxpY0tleSBhcyBTdGFrZXJcbiAgICogb3IgV2l0aGRyYXdlciBvbiB0aGUgU3Rha2UgYWNjb3VudC5cbiAgICovXG4gIHN0YXRpYyBhdXRob3JpemUocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5LFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleSxcbiAgICAgIHN0YWtlQXV0aG9yaXphdGlvblR5cGUsXG4gICAgICBjdXN0b2RpYW5QdWJrZXlcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBuZXdBdXRob3JpemVkOiB0b0J1ZmZlcihuZXdBdXRob3JpemVkUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZTogc3Rha2VBdXRob3JpemF0aW9uVHlwZS5pbmRleFxuICAgIH0pO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBzdGFrZVB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBhdXRob3JpemVkUHVia2V5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIGlmIChjdXN0b2RpYW5QdWJrZXkpIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogY3VzdG9kaWFuUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBhdXRob3JpemVzIGEgbmV3IFB1YmxpY0tleSBhcyBTdGFrZXJcbiAgICogb3IgV2l0aGRyYXdlciBvbiB0aGUgU3Rha2UgYWNjb3VudC5cbiAgICovXG4gIHN0YXRpYyBhdXRob3JpemVXaXRoU2VlZChwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml0eUJhc2UsXG4gICAgICBhdXRob3JpdHlTZWVkLFxuICAgICAgYXV0aG9yaXR5T3duZXIsXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5LFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZSxcbiAgICAgIGN1c3RvZGlhblB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplV2l0aFNlZWQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbmV3QXV0aG9yaXplZDogdG9CdWZmZXIobmV3QXV0aG9yaXplZFB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgIHN0YWtlQXV0aG9yaXphdGlvblR5cGU6IHN0YWtlQXV0aG9yaXphdGlvblR5cGUuaW5kZXgsXG4gICAgICBhdXRob3JpdHlTZWVkOiBhdXRob3JpdHlTZWVkLFxuICAgICAgYXV0aG9yaXR5T3duZXI6IHRvQnVmZmVyKGF1dGhvcml0eU93bmVyLnRvQnVmZmVyKCkpXG4gICAgfSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogYXV0aG9yaXR5QmFzZSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIGlmIChjdXN0b2RpYW5QdWJrZXkpIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogY3VzdG9kaWFuUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIHNwbGl0SW5zdHJ1Y3Rpb24ocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5LFxuICAgICAgc3BsaXRTdGFrZVB1YmtleSxcbiAgICAgIGxhbXBvcnRzXG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0eXBlID0gU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5TcGxpdDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBsYW1wb3J0c1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBzcGxpdFN0YWtlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBhdXRob3JpemVkUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIFRyYW5zYWN0aW9uIHRoYXQgc3BsaXRzIFN0YWtlIHRva2VucyBpbnRvIGFub3RoZXIgc3Rha2UgYWNjb3VudFxuICAgKi9cbiAgc3RhdGljIHNwbGl0KHBhcmFtcyxcbiAgLy8gQ29tcHV0ZSB0aGUgY29zdCBvZiBhbGxvY2F0aW5nIHRoZSBuZXcgc3Rha2UgYWNjb3VudCBpbiBsYW1wb3J0c1xuICByZW50RXhlbXB0UmVzZXJ2ZSkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0uY3JlYXRlQWNjb3VudCh7XG4gICAgICBmcm9tUHVia2V5OiBwYXJhbXMuYXV0aG9yaXplZFB1YmtleSxcbiAgICAgIG5ld0FjY291bnRQdWJrZXk6IHBhcmFtcy5zcGxpdFN0YWtlUHVia2V5LFxuICAgICAgbGFtcG9ydHM6IHJlbnRFeGVtcHRSZXNlcnZlLFxuICAgICAgc3BhY2U6IHRoaXMuc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkXG4gICAgfSkpO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbi5hZGQodGhpcy5zcGxpdEluc3RydWN0aW9uKHBhcmFtcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBzcGxpdHMgU3Rha2UgdG9rZW5zIGludG8gYW5vdGhlciBhY2NvdW50XG4gICAqIGRlcml2ZWQgZnJvbSBhIGJhc2UgcHVibGljIGtleSBhbmQgc2VlZFxuICAgKi9cbiAgc3RhdGljIHNwbGl0V2l0aFNlZWQocGFyYW1zLFxuICAvLyBJZiB0aGlzIHN0YWtlIGFjY291bnQgaXMgbmV3LCBjb21wdXRlIHRoZSBjb3N0IG9mIGFsbG9jYXRpbmcgaXQgaW4gbGFtcG9ydHNcbiAgcmVudEV4ZW1wdFJlc2VydmUpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBzcGxpdFN0YWtlUHVia2V5LFxuICAgICAgYmFzZVB1YmtleSxcbiAgICAgIHNlZWQsXG4gICAgICBsYW1wb3J0c1xuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5hbGxvY2F0ZSh7XG4gICAgICBhY2NvdW50UHVia2V5OiBzcGxpdFN0YWtlUHVia2V5LFxuICAgICAgYmFzZVB1YmtleSxcbiAgICAgIHNlZWQsXG4gICAgICBzcGFjZTogdGhpcy5zcGFjZSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWRcbiAgICB9KSk7XG4gICAgaWYgKHJlbnRFeGVtcHRSZXNlcnZlICYmIHJlbnRFeGVtcHRSZXNlcnZlID4gMCkge1xuICAgICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0udHJhbnNmZXIoe1xuICAgICAgICBmcm9tUHVia2V5OiBwYXJhbXMuYXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgdG9QdWJrZXk6IHNwbGl0U3Rha2VQdWJrZXksXG4gICAgICAgIGxhbXBvcnRzOiByZW50RXhlbXB0UmVzZXJ2ZVxuICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNhY3Rpb24uYWRkKHRoaXMuc3BsaXRJbnN0cnVjdGlvbih7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBzcGxpdFN0YWtlUHVia2V5LFxuICAgICAgbGFtcG9ydHNcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IG1lcmdlcyBTdGFrZSBhY2NvdW50cy5cbiAgICovXG4gIHN0YXRpYyBtZXJnZShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIHNvdXJjZVN0YWtlUHViS2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuTWVyZ2U7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBzb3VyY2VTdGFrZVB1YktleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9TVEFLRV9ISVNUT1JZX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCB3aXRoZHJhd3MgZGVhY3RpdmF0ZWQgU3Rha2UgdG9rZW5zLlxuICAgKi9cbiAgc3RhdGljIHdpdGhkcmF3KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleSxcbiAgICAgIHRvUHVia2V5LFxuICAgICAgbGFtcG9ydHMsXG4gICAgICBjdXN0b2RpYW5QdWJrZXlcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLldpdGhkcmF3O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGxhbXBvcnRzXG4gICAgfSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogdG9QdWJrZXksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFNZU1ZBUl9TVEFLRV9ISVNUT1JZX1BVQktFWSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBhdXRob3JpemVkUHVia2V5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIGlmIChjdXN0b2RpYW5QdWJrZXkpIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogY3VzdG9kaWFuUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBkZWFjdGl2YXRlcyBTdGFrZSB0b2tlbnMuXG4gICAqL1xuICBzdGF0aWMgZGVhY3RpdmF0ZShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXlcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkRlYWN0aXZhdGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogYXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cbn1cblN0YWtlUHJvZ3JhbS5wcm9ncmFtSWQgPSBuZXcgUHVibGljS2V5KCdTdGFrZTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG4vKipcbiAqIE1heCBzcGFjZSBvZiBhIFN0YWtlIGFjY291bnRcbiAqXG4gKiBUaGlzIGlzIGdlbmVyYXRlZCBmcm9tIHRoZSBzb2xhbmEtc3Rha2UtcHJvZ3JhbSBTdGFrZVN0YXRlIHN0cnVjdCBhc1xuICogYFN0YWtlU3RhdGVWMjo6c2l6ZV9vZigpYDpcbiAqIGh0dHBzOi8vZG9jcy5ycy9zb2xhbmEtc3Rha2UtcHJvZ3JhbS9sYXRlc3Qvc29sYW5hX3N0YWtlX3Byb2dyYW0vc3Rha2Vfc3RhdGUvZW51bS5TdGFrZVN0YXRlVjIuaHRtbFxuICovXG5TdGFrZVByb2dyYW0uc3BhY2UgPSAyMDA7XG5cbi8qKlxuICogVm90ZSBhY2NvdW50IGluZm9cbiAqL1xuY2xhc3MgVm90ZUluaXQge1xuICAvKiogWzAsIDEwMF0gKi9cblxuICBjb25zdHJ1Y3Rvcihub2RlUHVia2V5LCBhdXRob3JpemVkVm90ZXIsIGF1dGhvcml6ZWRXaXRoZHJhd2VyLCBjb21taXNzaW9uKSB7XG4gICAgdGhpcy5ub2RlUHVia2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuYXV0aG9yaXplZFZvdGVyID0gdm9pZCAwO1xuICAgIHRoaXMuYXV0aG9yaXplZFdpdGhkcmF3ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jb21taXNzaW9uID0gdm9pZCAwO1xuICAgIHRoaXMubm9kZVB1YmtleSA9IG5vZGVQdWJrZXk7XG4gICAgdGhpcy5hdXRob3JpemVkVm90ZXIgPSBhdXRob3JpemVkVm90ZXI7XG4gICAgdGhpcy5hdXRob3JpemVkV2l0aGRyYXdlciA9IGF1dGhvcml6ZWRXaXRoZHJhd2VyO1xuICAgIHRoaXMuY29tbWlzc2lvbiA9IGNvbW1pc3Npb247XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgdm90ZSBhY2NvdW50IHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogSW5pdGlhbGl6ZUFjY291bnQgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBdXRob3JpemUgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBdXRob3JpemVXaXRoU2VlZCBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIFdpdGhkcmF3IGZyb20gdm90ZSBhY2NvdW50IHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogVXBkYXRlIHZhbGlkYXRvciBpZGVudGl0eSAobm9kZSBwdWJrZXkpIHZvdGUgYWNjb3VudCBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gKi9cblxuLyoqXG4gKiBWb3RlIEluc3RydWN0aW9uIGNsYXNzXG4gKi9cbmNsYXNzIFZvdGVJbnN0cnVjdGlvbiB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogRGVjb2RlIGEgdm90ZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHR5cGUuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlSW5zdHJ1Y3Rpb25UeXBlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGNvbnN0IGluc3RydWN0aW9uVHlwZUxheW91dCA9IEJ1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyk7XG4gICAgY29uc3QgdHlwZUluZGV4ID0gaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0LmRlY29kZShpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICBsZXQgdHlwZTtcbiAgICBmb3IgKGNvbnN0IFtpeFR5cGUsIGxheW91dF0gb2YgT2JqZWN0LmVudHJpZXMoVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTKSkge1xuICAgICAgaWYgKGxheW91dC5pbmRleCA9PSB0eXBlSW5kZXgpIHtcbiAgICAgICAgdHlwZSA9IGl4VHlwZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnN0cnVjdGlvbiB0eXBlIGluY29ycmVjdDsgbm90IGEgVm90ZUluc3RydWN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBpbml0aWFsaXplIHZvdGUgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlSW5pdGlhbGl6ZUFjY291bnQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCA0KTtcbiAgICBjb25zdCB7XG4gICAgICB2b3RlSW5pdFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTLkluaXRpYWxpemVBY2NvdW50LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgdm90ZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBub2RlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzNdLnB1YmtleSxcbiAgICAgIHZvdGVJbml0OiBuZXcgVm90ZUluaXQobmV3IFB1YmxpY0tleSh2b3RlSW5pdC5ub2RlUHVia2V5KSwgbmV3IFB1YmxpY0tleSh2b3RlSW5pdC5hdXRob3JpemVkVm90ZXIpLCBuZXcgUHVibGljS2V5KHZvdGVJbml0LmF1dGhvcml6ZWRXaXRoZHJhd2VyKSwgdm90ZUluaXQuY29tbWlzc2lvbilcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBhdXRob3JpemUgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQXV0aG9yaXplKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgY29uc3Qge1xuICAgICAgbmV3QXV0aG9yaXplZCxcbiAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZVxuICAgIH0gPSBkZWNvZGVEYXRhJDEoVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZvdGVQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXksXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5OiBuZXcgUHVibGljS2V5KG5ld0F1dGhvcml6ZWQpLFxuICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlOiB7XG4gICAgICAgIGluZGV4OiB2b3RlQXV0aG9yaXphdGlvblR5cGVcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBhdXRob3JpemUgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQXV0aG9yaXplV2l0aFNlZWQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBjb25zdCB7XG4gICAgICB2b3RlQXV0aG9yaXplV2l0aFNlZWRBcmdzOiB7XG4gICAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5T3duZXJQdWJrZXksXG4gICAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5U2VlZCxcbiAgICAgICAgbmV3QXV0aG9yaXplZCxcbiAgICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlXG4gICAgICB9XG4gICAgfSA9IGRlY29kZURhdGEkMShWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplV2l0aFNlZWQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleUJhc2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5LFxuICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlPd25lclB1YmtleTogbmV3IFB1YmxpY0tleShjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5KSxcbiAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5U2VlZDogY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkLFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShuZXdBdXRob3JpemVkKSxcbiAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZToge1xuICAgICAgICBpbmRleDogdm90ZUF1dGhvcml6YXRpb25UeXBlXG4gICAgICB9LFxuICAgICAgdm90ZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHdpdGhkcmF3IGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVdpdGhkcmF3KGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgY29uc3Qge1xuICAgICAgbGFtcG9ydHNcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5XaXRoZHJhdywgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZvdGVQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFdpdGhkcmF3ZXJQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5LFxuICAgICAgbGFtcG9ydHMsXG4gICAgICB0b1B1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGNoZWNrUHJvZ3JhbUlkKHByb2dyYW1JZCkge1xuICAgIGlmICghcHJvZ3JhbUlkLmVxdWFscyhWb3RlUHJvZ3JhbS5wcm9ncmFtSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5zdHJ1Y3Rpb247IHByb2dyYW1JZCBpcyBub3QgVm90ZVByb2dyYW0nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tLZXlMZW5ndGgoa2V5cywgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICBpZiAoa2V5cy5sZW5ndGggPCBleHBlY3RlZExlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGluc3RydWN0aW9uOyBmb3VuZCAke2tleXMubGVuZ3RofSBrZXlzLCBleHBlY3RlZCBhdCBsZWFzdCAke2V4cGVjdGVkTGVuZ3RofWApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIFZvdGVJbnN0cnVjdGlvblR5cGUnc1xuICovXG5cbi8qKiBAaW50ZXJuYWwgKi9cblxuY29uc3QgVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTID0gT2JqZWN0LmZyZWV6ZSh7XG4gIEluaXRpYWxpemVBY2NvdW50OiB7XG4gICAgaW5kZXg6IDAsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCB2b3RlSW5pdCgpXSlcbiAgfSxcbiAgQXV0aG9yaXplOiB7XG4gICAgaW5kZXg6IDEsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ25ld0F1dGhvcml6ZWQnKSwgQnVmZmVyTGF5b3V0LnUzMigndm90ZUF1dGhvcml6YXRpb25UeXBlJyldKVxuICB9LFxuICBXaXRoZHJhdzoge1xuICAgIGluZGV4OiAzLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ2xhbXBvcnRzJyldKVxuICB9LFxuICBVcGRhdGVWYWxpZGF0b3JJZGVudGl0eToge1xuICAgIGluZGV4OiA0LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH0sXG4gIEF1dGhvcml6ZVdpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDEwLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgdm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJncygpXSlcbiAgfVxufSk7XG5cbi8qKlxuICogVm90ZUF1dGhvcml6ZSB0eXBlXG4gKi9cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBWb3RlQXV0aG9yaXphdGlvbiBsYXlvdXRzLlxuICovXG5jb25zdCBWb3RlQXV0aG9yaXphdGlvbkxheW91dCA9IE9iamVjdC5mcmVlemUoe1xuICBWb3Rlcjoge1xuICAgIGluZGV4OiAwXG4gIH0sXG4gIFdpdGhkcmF3ZXI6IHtcbiAgICBpbmRleDogMVxuICB9XG59KTtcblxuLyoqXG4gKiBGYWN0b3J5IGNsYXNzIGZvciB0cmFuc2FjdGlvbnMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgVm90ZSBwcm9ncmFtXG4gKi9cbmNsYXNzIFZvdGVQcm9ncmFtIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBQdWJsaWMga2V5IHRoYXQgaWRlbnRpZmllcyB0aGUgVm90ZSBwcm9ncmFtXG4gICAqL1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhbiBJbml0aWFsaXplIGluc3RydWN0aW9uLlxuICAgKi9cbiAgc3RhdGljIGluaXRpYWxpemVBY2NvdW50KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHZvdGVQdWJrZXksXG4gICAgICBub2RlUHVia2V5LFxuICAgICAgdm90ZUluaXRcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuSW5pdGlhbGl6ZUFjY291bnQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgdm90ZUluaXQ6IHtcbiAgICAgICAgbm9kZVB1YmtleTogdG9CdWZmZXIodm90ZUluaXQubm9kZVB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgICAgYXV0aG9yaXplZFZvdGVyOiB0b0J1ZmZlcih2b3RlSW5pdC5hdXRob3JpemVkVm90ZXIudG9CdWZmZXIoKSksXG4gICAgICAgIGF1dGhvcml6ZWRXaXRoZHJhd2VyOiB0b0J1ZmZlcih2b3RlSW5pdC5hdXRob3JpemVkV2l0aGRyYXdlci50b0J1ZmZlcigpKSxcbiAgICAgICAgY29tbWlzc2lvbjogdm90ZUluaXQuY29tbWlzc2lvblxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGluc3RydWN0aW9uRGF0YSA9IHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogdm90ZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1JFTlRfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IG5vZGVQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKGluc3RydWN0aW9uRGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgVm90ZSBhY2NvdW50LlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUFjY291bnQocGFyYW1zKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50KHtcbiAgICAgIGZyb21QdWJrZXk6IHBhcmFtcy5mcm9tUHVia2V5LFxuICAgICAgbmV3QWNjb3VudFB1YmtleTogcGFyYW1zLnZvdGVQdWJrZXksXG4gICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgc3BhY2U6IHRoaXMuc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkXG4gICAgfSkpO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbi5hZGQodGhpcy5pbml0aWFsaXplQWNjb3VudCh7XG4gICAgICB2b3RlUHVia2V5OiBwYXJhbXMudm90ZVB1YmtleSxcbiAgICAgIG5vZGVQdWJrZXk6IHBhcmFtcy52b3RlSW5pdC5ub2RlUHVia2V5LFxuICAgICAgdm90ZUluaXQ6IHBhcmFtcy52b3RlSW5pdFxuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIHRoYXQgYXV0aG9yaXplcyBhIG5ldyBWb3RlciBvciBXaXRoZHJhd2VyIG9uIHRoZSBWb3RlIGFjY291bnQuXG4gICAqL1xuICBzdGF0aWMgYXV0aG9yaXplKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHZvdGVQdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5LFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleSxcbiAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbmV3QXV0aG9yaXplZDogdG9CdWZmZXIobmV3QXV0aG9yaXplZFB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZTogdm90ZUF1dGhvcml6YXRpb25UeXBlLmluZGV4XG4gICAgfSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHZvdGVQdWJrZXksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIHRoYXQgYXV0aG9yaXplcyBhIG5ldyBWb3RlciBvciBXaXRoZHJhd2VyIG9uIHRoZSBWb3RlIGFjY291bnRcbiAgICogd2hlcmUgdGhlIGN1cnJlbnQgVm90ZXIgb3IgV2l0aGRyYXdlciBhdXRob3JpdHkgaXMgYSBkZXJpdmVkIGtleS5cbiAgICovXG4gIHN0YXRpYyBhdXRob3JpemVXaXRoU2VlZChwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleUJhc2VQdWJrZXksXG4gICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5LFxuICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkLFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleSxcbiAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZSxcbiAgICAgIHZvdGVQdWJrZXlcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplV2l0aFNlZWQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgdm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJnczoge1xuICAgICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5OiB0b0J1ZmZlcihjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleVNlZWQ6IGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5U2VlZCxcbiAgICAgICAgbmV3QXV0aG9yaXplZDogdG9CdWZmZXIobmV3QXV0aG9yaXplZFB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlOiB2b3RlQXV0aG9yaXphdGlvblR5cGUuaW5kZXhcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogdm90ZVB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlCYXNlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiB0byB3aXRoZHJhdyBmcm9tIGEgVm90ZSBhY2NvdW50LlxuICAgKi9cbiAgc3RhdGljIHdpdGhkcmF3KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHZvdGVQdWJrZXksXG4gICAgICBhdXRob3JpemVkV2l0aGRyYXdlclB1YmtleSxcbiAgICAgIGxhbXBvcnRzLFxuICAgICAgdG9QdWJrZXlcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuV2l0aGRyYXc7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbGFtcG9ydHNcbiAgICB9KTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogdm90ZVB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IHRvUHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogYXV0aG9yaXplZFdpdGhkcmF3ZXJQdWJrZXksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIHRvIHdpdGhkcmF3IHNhZmVseSBmcm9tIGEgVm90ZSBhY2NvdW50LlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdhcyBjcmVhdGVkIGFzIGEgc2FmZWd1YXJkIGZvciB2b3RlIGFjY291bnRzIHJ1bm5pbmcgdmFsaWRhdG9ycywgYHNhZmVXaXRoZHJhd2BcbiAgICogY2hlY2tzIHRoYXQgdGhlIHdpdGhkcmF3IGFtb3VudCB3aWxsIG5vdCBleGNlZWQgdGhlIHNwZWNpZmllZCBiYWxhbmNlIHdoaWxlIGxlYXZpbmcgZW5vdWdoIGxlZnRcbiAgICogdG8gY292ZXIgcmVudC4gSWYgeW91IHdpc2ggdG8gY2xvc2UgdGhlIHZvdGUgYWNjb3VudCBieSB3aXRoZHJhd2luZyB0aGUgZnVsbCBhbW91bnQsIGNhbGwgdGhlXG4gICAqIGB3aXRoZHJhd2AgbWV0aG9kIGRpcmVjdGx5LlxuICAgKi9cbiAgc3RhdGljIHNhZmVXaXRoZHJhdyhwYXJhbXMsIGN1cnJlbnRWb3RlQWNjb3VudEJhbGFuY2UsIHJlbnRFeGVtcHRNaW5pbXVtKSB7XG4gICAgaWYgKHBhcmFtcy5sYW1wb3J0cyA+IGN1cnJlbnRWb3RlQWNjb3VudEJhbGFuY2UgLSByZW50RXhlbXB0TWluaW11bSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaXRoZHJhdyB3aWxsIGxlYXZlIHZvdGUgYWNjb3VudCB3aXRoIGluc3VmZmljaWVudCBmdW5kcy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIFZvdGVQcm9ncmFtLndpdGhkcmF3KHBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiB0byB1cGRhdGUgdGhlIHZhbGlkYXRvciBpZGVudGl0eSAobm9kZSBwdWJrZXkpIG9mIGEgVm90ZSBhY2NvdW50LlxuICAgKi9cbiAgc3RhdGljIHVwZGF0ZVZhbGlkYXRvcklkZW50aXR5KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHZvdGVQdWJrZXksXG4gICAgICBhdXRob3JpemVkV2l0aGRyYXdlclB1YmtleSxcbiAgICAgIG5vZGVQdWJrZXlcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuVXBkYXRlVmFsaWRhdG9ySWRlbnRpdHk7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHZvdGVQdWJrZXksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBub2RlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogYXV0aG9yaXplZFdpdGhkcmF3ZXJQdWJrZXksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxufVxuVm90ZVByb2dyYW0ucHJvZ3JhbUlkID0gbmV3IFB1YmxpY0tleSgnVm90ZTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuLyoqXG4gKiBNYXggc3BhY2Ugb2YgYSBWb3RlIGFjY291bnRcbiAqXG4gKiBUaGlzIGlzIGdlbmVyYXRlZCBmcm9tIHRoZSBzb2xhbmEtdm90ZS1wcm9ncmFtIFZvdGVTdGF0ZSBzdHJ1Y3QgYXNcbiAqIGBWb3RlU3RhdGU6OnNpemVfb2YoKWA6XG4gKiBodHRwczovL2RvY3MucnMvc29sYW5hLXZvdGUtcHJvZ3JhbS8xLjkuNS9zb2xhbmFfdm90ZV9wcm9ncmFtL3ZvdGVfc3RhdGUvc3RydWN0LlZvdGVTdGF0ZS5odG1sI21ldGhvZC5zaXplX29mXG4gKlxuICogS0VFUCBJTiBTWU5DIFdJVEggYFZvdGVTdGF0ZTo6c2l6ZV9vZigpYCBpbiBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2Jsb2IvYTQ3NGNiMjRiOTIzOGY1ZWRjYzk4MmY2NWMwYjM3ZDRhMTA0NmY3ZS9zZGsvcHJvZ3JhbS9zcmMvdm90ZS9zdGF0ZS9tb2QucnMjTDM0MC1MMzQyXG4gKi9cblZvdGVQcm9ncmFtLnNwYWNlID0gMzc2MjtcblxuY29uc3QgVkFMSURBVE9SX0lORk9fS0VZID0gbmV3IFB1YmxpY0tleSgnVmExaWRhdG9yMW5mbzExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbi8qKlxuICogSW5mbyB1c2VkIHRvIGlkZW50aXR5IHZhbGlkYXRvcnMuXG4gKi9cblxuY29uc3QgSW5mb1N0cmluZyA9IHR5cGUoe1xuICBuYW1lOiBzdHJpbmcoKSxcbiAgd2Vic2l0ZTogb3B0aW9uYWwoc3RyaW5nKCkpLFxuICBkZXRhaWxzOiBvcHRpb25hbChzdHJpbmcoKSksXG4gIGljb25Vcmw6IG9wdGlvbmFsKHN0cmluZygpKSxcbiAga2V5YmFzZVVzZXJuYW1lOiBvcHRpb25hbChzdHJpbmcoKSlcbn0pO1xuXG4vKipcbiAqIFZhbGlkYXRvckluZm8gY2xhc3NcbiAqL1xuY2xhc3MgVmFsaWRhdG9ySW5mbyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSB2YWxpZCBWYWxpZGF0b3JJbmZvXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgdmFsaWRhdG9yIHB1YmxpYyBrZXlcbiAgICogQHBhcmFtIGluZm8gdmFsaWRhdG9yIGluZm9ybWF0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihrZXksIGluZm8pIHtcbiAgICAvKipcbiAgICAgKiB2YWxpZGF0b3IgcHVibGljIGtleVxuICAgICAqL1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIHZhbGlkYXRvciBpbmZvcm1hdGlvblxuICAgICAqL1xuICAgIHRoaXMuaW5mbyA9IHZvaWQgMDtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLmluZm8gPSBpbmZvO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIFZhbGlkYXRvckluZm8gZnJvbSB0aGUgY29uZmlnIGFjY291bnQgZGF0YS4gRXhhY3RseSB0d28gY29uZmlnXG4gICAqIGtleXMgYXJlIHJlcXVpcmVkIGluIHRoZSBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0gYnVmZmVyIGNvbmZpZyBhY2NvdW50IGRhdGFcbiAgICogQHJldHVybiBudWxsIGlmIGluZm8gd2FzIG5vdCBmb3VuZFxuICAgKi9cbiAgc3RhdGljIGZyb21Db25maWdEYXRhKGJ1ZmZlcikge1xuICAgIGxldCBieXRlQXJyYXkgPSBbLi4uYnVmZmVyXTtcbiAgICBjb25zdCBjb25maWdLZXlDb3VudCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgIGlmIChjb25maWdLZXlDb3VudCAhPT0gMikgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgY29uZmlnS2V5cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICBjb25zdCBwdWJsaWNLZXkgPSBuZXcgUHVibGljS2V5KGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBQVUJMSUNfS0VZX0xFTkdUSCkpO1xuICAgICAgY29uc3QgaXNTaWduZXIgPSBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KSA9PT0gMTtcbiAgICAgIGNvbmZpZ0tleXMucHVzaCh7XG4gICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgaXNTaWduZXJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoY29uZmlnS2V5c1swXS5wdWJsaWNLZXkuZXF1YWxzKFZBTElEQVRPUl9JTkZPX0tFWSkpIHtcbiAgICAgIGlmIChjb25maWdLZXlzWzFdLmlzU2lnbmVyKSB7XG4gICAgICAgIGNvbnN0IHJhd0luZm8gPSBydXN0U3RyaW5nKCkuZGVjb2RlKEJ1ZmZlci5mcm9tKGJ5dGVBcnJheSkpO1xuICAgICAgICBjb25zdCBpbmZvID0gSlNPTi5wYXJzZShyYXdJbmZvKTtcbiAgICAgICAgYXNzZXJ0JDEoaW5mbywgSW5mb1N0cmluZyk7XG4gICAgICAgIHJldHVybiBuZXcgVmFsaWRhdG9ySW5mbyhjb25maWdLZXlzWzFdLnB1YmxpY0tleSwgaW5mbyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmNvbnN0IFZPVEVfUFJPR1JBTV9JRCA9IG5ldyBQdWJsaWNLZXkoJ1ZvdGUxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuLyoqXG4gKiBIaXN0b3J5IG9mIGhvdyBtYW55IGNyZWRpdHMgZWFybmVkIGJ5IHRoZSBlbmQgb2YgZWFjaCBlcG9jaFxuICovXG5cbi8qKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvYmxvYi84YTEyZWQwMjljZmEzOGQ0YTQ1NDAwOTE2YzI0NjNmYjgyYmJlYzhjL3Byb2dyYW1zL3ZvdGVfYXBpL3NyYy92b3RlX3N0YXRlLnJzI0w2OC1MODhcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgVm90ZUFjY291bnRMYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtwdWJsaWNLZXkoJ25vZGVQdWJrZXknKSwgcHVibGljS2V5KCdhdXRob3JpemVkV2l0aGRyYXdlcicpLCBCdWZmZXJMYXlvdXQudTgoJ2NvbW1pc3Npb24nKSwgQnVmZmVyTGF5b3V0Lm51NjQoKSxcbi8vIHZvdGVzLmxlbmd0aFxuQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQubnU2NCgnc2xvdCcpLCBCdWZmZXJMYXlvdXQudTMyKCdjb25maXJtYXRpb25Db3VudCcpXSksIEJ1ZmZlckxheW91dC5vZmZzZXQoQnVmZmVyTGF5b3V0LnUzMigpLCAtOCksICd2b3RlcycpLCBCdWZmZXJMYXlvdXQudTgoJ3Jvb3RTbG90VmFsaWQnKSwgQnVmZmVyTGF5b3V0Lm51NjQoJ3Jvb3RTbG90JyksIEJ1ZmZlckxheW91dC5udTY0KCksXG4vLyBhdXRob3JpemVkVm90ZXJzLmxlbmd0aFxuQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQubnU2NCgnZXBvY2gnKSwgcHVibGljS2V5KCdhdXRob3JpemVkVm90ZXInKV0pLCBCdWZmZXJMYXlvdXQub2Zmc2V0KEJ1ZmZlckxheW91dC51MzIoKSwgLTgpLCAnYXV0aG9yaXplZFZvdGVycycpLCBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQuc2VxKEJ1ZmZlckxheW91dC5zdHJ1Y3QoW3B1YmxpY0tleSgnYXV0aG9yaXplZFB1YmtleScpLCBCdWZmZXJMYXlvdXQubnU2NCgnZXBvY2hPZkxhc3RBdXRob3JpemVkU3dpdGNoJyksIEJ1ZmZlckxheW91dC5udTY0KCd0YXJnZXRFcG9jaCcpXSksIDMyLCAnYnVmJyksIEJ1ZmZlckxheW91dC5udTY0KCdpZHgnKSwgQnVmZmVyTGF5b3V0LnU4KCdpc0VtcHR5JyldLCAncHJpb3JWb3RlcnMnKSwgQnVmZmVyTGF5b3V0Lm51NjQoKSxcbi8vIGVwb2NoQ3JlZGl0cy5sZW5ndGhcbkJ1ZmZlckxheW91dC5zZXEoQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0Lm51NjQoJ2Vwb2NoJyksIEJ1ZmZlckxheW91dC5udTY0KCdjcmVkaXRzJyksIEJ1ZmZlckxheW91dC5udTY0KCdwcmV2Q3JlZGl0cycpXSksIEJ1ZmZlckxheW91dC5vZmZzZXQoQnVmZmVyTGF5b3V0LnUzMigpLCAtOCksICdlcG9jaENyZWRpdHMnKSwgQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0Lm51NjQoJ3Nsb3QnKSwgQnVmZmVyTGF5b3V0Lm51NjQoJ3RpbWVzdGFtcCcpXSwgJ2xhc3RUaW1lc3RhbXAnKV0pO1xuLyoqXG4gKiBWb3RlQWNjb3VudCBjbGFzc1xuICovXG5jbGFzcyBWb3RlQWNjb3VudCB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICB0aGlzLm5vZGVQdWJrZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5hdXRob3JpemVkV2l0aGRyYXdlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbW1pc3Npb24gPSB2b2lkIDA7XG4gICAgdGhpcy5yb290U2xvdCA9IHZvaWQgMDtcbiAgICB0aGlzLnZvdGVzID0gdm9pZCAwO1xuICAgIHRoaXMuYXV0aG9yaXplZFZvdGVycyA9IHZvaWQgMDtcbiAgICB0aGlzLnByaW9yVm90ZXJzID0gdm9pZCAwO1xuICAgIHRoaXMuZXBvY2hDcmVkaXRzID0gdm9pZCAwO1xuICAgIHRoaXMubGFzdFRpbWVzdGFtcCA9IHZvaWQgMDtcbiAgICB0aGlzLm5vZGVQdWJrZXkgPSBhcmdzLm5vZGVQdWJrZXk7XG4gICAgdGhpcy5hdXRob3JpemVkV2l0aGRyYXdlciA9IGFyZ3MuYXV0aG9yaXplZFdpdGhkcmF3ZXI7XG4gICAgdGhpcy5jb21taXNzaW9uID0gYXJncy5jb21taXNzaW9uO1xuICAgIHRoaXMucm9vdFNsb3QgPSBhcmdzLnJvb3RTbG90O1xuICAgIHRoaXMudm90ZXMgPSBhcmdzLnZvdGVzO1xuICAgIHRoaXMuYXV0aG9yaXplZFZvdGVycyA9IGFyZ3MuYXV0aG9yaXplZFZvdGVycztcbiAgICB0aGlzLnByaW9yVm90ZXJzID0gYXJncy5wcmlvclZvdGVycztcbiAgICB0aGlzLmVwb2NoQ3JlZGl0cyA9IGFyZ3MuZXBvY2hDcmVkaXRzO1xuICAgIHRoaXMubGFzdFRpbWVzdGFtcCA9IGFyZ3MubGFzdFRpbWVzdGFtcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZSBWb3RlQWNjb3VudCBmcm9tIHRoZSBhY2NvdW50IGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgYWNjb3VudCBkYXRhXG4gICAqIEByZXR1cm4gVm90ZUFjY291bnRcbiAgICovXG4gIHN0YXRpYyBmcm9tQWNjb3VudERhdGEoYnVmZmVyKSB7XG4gICAgY29uc3QgdmVyc2lvbk9mZnNldCA9IDQ7XG4gICAgY29uc3QgdmEgPSBWb3RlQWNjb3VudExheW91dC5kZWNvZGUodG9CdWZmZXIoYnVmZmVyKSwgdmVyc2lvbk9mZnNldCk7XG4gICAgbGV0IHJvb3RTbG90ID0gdmEucm9vdFNsb3Q7XG4gICAgaWYgKCF2YS5yb290U2xvdFZhbGlkKSB7XG4gICAgICByb290U2xvdCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVm90ZUFjY291bnQoe1xuICAgICAgbm9kZVB1YmtleTogbmV3IFB1YmxpY0tleSh2YS5ub2RlUHVia2V5KSxcbiAgICAgIGF1dGhvcml6ZWRXaXRoZHJhd2VyOiBuZXcgUHVibGljS2V5KHZhLmF1dGhvcml6ZWRXaXRoZHJhd2VyKSxcbiAgICAgIGNvbW1pc3Npb246IHZhLmNvbW1pc3Npb24sXG4gICAgICB2b3RlczogdmEudm90ZXMsXG4gICAgICByb290U2xvdCxcbiAgICAgIGF1dGhvcml6ZWRWb3RlcnM6IHZhLmF1dGhvcml6ZWRWb3RlcnMubWFwKHBhcnNlQXV0aG9yaXplZFZvdGVyKSxcbiAgICAgIHByaW9yVm90ZXJzOiBnZXRQcmlvclZvdGVycyh2YS5wcmlvclZvdGVycyksXG4gICAgICBlcG9jaENyZWRpdHM6IHZhLmVwb2NoQ3JlZGl0cyxcbiAgICAgIGxhc3RUaW1lc3RhbXA6IHZhLmxhc3RUaW1lc3RhbXBcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VBdXRob3JpemVkVm90ZXIoe1xuICBhdXRob3JpemVkVm90ZXIsXG4gIGVwb2NoXG59KSB7XG4gIHJldHVybiB7XG4gICAgZXBvY2gsXG4gICAgYXV0aG9yaXplZFZvdGVyOiBuZXcgUHVibGljS2V5KGF1dGhvcml6ZWRWb3RlcilcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlUHJpb3JWb3RlcnMoe1xuICBhdXRob3JpemVkUHVia2V5LFxuICBlcG9jaE9mTGFzdEF1dGhvcml6ZWRTd2l0Y2gsXG4gIHRhcmdldEVwb2NoXG59KSB7XG4gIHJldHVybiB7XG4gICAgYXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShhdXRob3JpemVkUHVia2V5KSxcbiAgICBlcG9jaE9mTGFzdEF1dGhvcml6ZWRTd2l0Y2gsXG4gICAgdGFyZ2V0RXBvY2hcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFByaW9yVm90ZXJzKHtcbiAgYnVmLFxuICBpZHgsXG4gIGlzRW1wdHlcbn0pIHtcbiAgaWYgKGlzRW1wdHkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIFsuLi5idWYuc2xpY2UoaWR4ICsgMSkubWFwKHBhcnNlUHJpb3JWb3RlcnMpLCAuLi5idWYuc2xpY2UoMCwgaWR4KS5tYXAocGFyc2VQcmlvclZvdGVycyldO1xufVxuXG5jb25zdCBlbmRwb2ludCA9IHtcbiAgaHR0cDoge1xuICAgIGRldm5ldDogJ2h0dHA6Ly9hcGkuZGV2bmV0LnNvbGFuYS5jb20nLFxuICAgIHRlc3RuZXQ6ICdodHRwOi8vYXBpLnRlc3RuZXQuc29sYW5hLmNvbScsXG4gICAgJ21haW5uZXQtYmV0YSc6ICdodHRwOi8vYXBpLm1haW5uZXQtYmV0YS5zb2xhbmEuY29tLydcbiAgfSxcbiAgaHR0cHM6IHtcbiAgICBkZXZuZXQ6ICdodHRwczovL2FwaS5kZXZuZXQuc29sYW5hLmNvbScsXG4gICAgdGVzdG5ldDogJ2h0dHBzOi8vYXBpLnRlc3RuZXQuc29sYW5hLmNvbScsXG4gICAgJ21haW5uZXQtYmV0YSc6ICdodHRwczovL2FwaS5tYWlubmV0LWJldGEuc29sYW5hLmNvbS8nXG4gIH1cbn07XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgUlBDIEFQSSBVUkwgZm9yIHRoZSBzcGVjaWZpZWQgY2x1c3RlclxuICogQHBhcmFtIHtDbHVzdGVyfSBbY2x1c3Rlcj1cImRldm5ldFwiXSAtIFRoZSBjbHVzdGVyIG5hbWUgb2YgdGhlIFJQQyBBUEkgVVJMIHRvIHVzZS4gUG9zc2libGUgb3B0aW9uczogJ2Rldm5ldCcgfCAndGVzdG5ldCcgfCAnbWFpbm5ldC1iZXRhJ1xuICogQHBhcmFtIHtib29sZWFufSBbdGxzPVwiaHR0cFwiXSAtIFVzZSBUTFMgd2hlbiBjb25uZWN0aW5nIHRvIGNsdXN0ZXIuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVVJMIHN0cmluZyBvZiB0aGUgUlBDIGVuZHBvaW50XG4gKi9cbmZ1bmN0aW9uIGNsdXN0ZXJBcGlVcmwoY2x1c3RlciwgdGxzKSB7XG4gIGNvbnN0IGtleSA9IHRscyA9PT0gZmFsc2UgPyAnaHR0cCcgOiAnaHR0cHMnO1xuICBpZiAoIWNsdXN0ZXIpIHtcbiAgICByZXR1cm4gZW5kcG9pbnRba2V5XVsnZGV2bmV0J107XG4gIH1cbiAgY29uc3QgdXJsID0gZW5kcG9pbnRba2V5XVtjbHVzdGVyXTtcbiAgaWYgKCF1cmwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gJHtrZXl9IGNsdXN0ZXI6ICR7Y2x1c3Rlcn1gKTtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuXG4vKipcbiAqIFNlbmQgYW5kIGNvbmZpcm0gYSByYXcgdHJhbnNhY3Rpb25cbiAqXG4gKiBJZiBgY29tbWl0bWVudGAgb3B0aW9uIGlzIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvICdtYXgnIGNvbW1pdG1lbnQuXG4gKlxuICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uZWN0aW9uXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcmF3VHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb25Db25maXJtYXRpb25TdHJhdGVneX0gY29uZmlybWF0aW9uU3RyYXRlZ3lcbiAqIEBwYXJhbSB7Q29uZmlybU9wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb25TaWduYXR1cmU+fVxuICovXG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgQ2FsbGluZyBgc2VuZEFuZENvbmZpcm1SYXdUcmFuc2FjdGlvbigpYCB3aXRob3V0IGEgYGNvbmZpcm1hdGlvblN0cmF0ZWd5YFxuICogaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuYXN5bmMgZnVuY3Rpb24gc2VuZEFuZENvbmZpcm1SYXdUcmFuc2FjdGlvbihjb25uZWN0aW9uLCByYXdUcmFuc2FjdGlvbiwgY29uZmlybWF0aW9uU3RyYXRlZ3lPckNvbmZpcm1PcHRpb25zLCBtYXliZUNvbmZpcm1PcHRpb25zKSB7XG4gIGxldCBjb25maXJtYXRpb25TdHJhdGVneTtcbiAgbGV0IG9wdGlvbnM7XG4gIGlmIChjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnMgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucywgJ2xhc3RWYWxpZEJsb2NrSGVpZ2h0JykpIHtcbiAgICBjb25maXJtYXRpb25TdHJhdGVneSA9IGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucztcbiAgICBvcHRpb25zID0gbWF5YmVDb25maXJtT3B0aW9ucztcbiAgfSBlbHNlIGlmIChjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnMgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucywgJ25vbmNlVmFsdWUnKSkge1xuICAgIGNvbmZpcm1hdGlvblN0cmF0ZWd5ID0gY29uZmlybWF0aW9uU3RyYXRlZ3lPckNvbmZpcm1PcHRpb25zO1xuICAgIG9wdGlvbnMgPSBtYXliZUNvbmZpcm1PcHRpb25zO1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMgPSBjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnM7XG4gIH1cbiAgY29uc3Qgc2VuZE9wdGlvbnMgPSBvcHRpb25zICYmIHtcbiAgICBza2lwUHJlZmxpZ2h0OiBvcHRpb25zLnNraXBQcmVmbGlnaHQsXG4gICAgcHJlZmxpZ2h0Q29tbWl0bWVudDogb3B0aW9ucy5wcmVmbGlnaHRDb21taXRtZW50IHx8IG9wdGlvbnMuY29tbWl0bWVudCxcbiAgICBtaW5Db250ZXh0U2xvdDogb3B0aW9ucy5taW5Db250ZXh0U2xvdFxuICB9O1xuICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBjb25uZWN0aW9uLnNlbmRSYXdUcmFuc2FjdGlvbihyYXdUcmFuc2FjdGlvbiwgc2VuZE9wdGlvbnMpO1xuICBjb25zdCBjb21taXRtZW50ID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvbW1pdG1lbnQ7XG4gIGNvbnN0IGNvbmZpcm1hdGlvblByb21pc2UgPSBjb25maXJtYXRpb25TdHJhdGVneSA/IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKGNvbmZpcm1hdGlvblN0cmF0ZWd5LCBjb21taXRtZW50KSA6IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHNpZ25hdHVyZSwgY29tbWl0bWVudCk7XG4gIGNvbnN0IHN0YXR1cyA9IChhd2FpdCBjb25maXJtYXRpb25Qcm9taXNlKS52YWx1ZTtcbiAgaWYgKHN0YXR1cy5lcnIpIHtcbiAgICBpZiAoc2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBTZW5kVHJhbnNhY3Rpb25FcnJvcih7XG4gICAgICAgIGFjdGlvbjogc2VuZE9wdGlvbnM/LnNraXBQcmVmbGlnaHQgPyAnc2VuZCcgOiAnc2ltdWxhdGUnLFxuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZSxcbiAgICAgICAgdHJhbnNhY3Rpb25NZXNzYWdlOiBgU3RhdHVzOiAoJHtKU09OLnN0cmluZ2lmeShzdGF0dXMpfSlgXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBSYXcgdHJhbnNhY3Rpb24gJHtzaWduYXR1cmV9IGZhaWxlZCAoJHtKU09OLnN0cmluZ2lmeShzdGF0dXMpfSlgKTtcbiAgfVxuICByZXR1cm4gc2lnbmF0dXJlO1xufVxuXG4vKipcbiAqIFRoZXJlIGFyZSAxLWJpbGxpb24gbGFtcG9ydHMgaW4gb25lIFNPTFxuICovXG5jb25zdCBMQU1QT1JUU19QRVJfU09MID0gMTAwMDAwMDAwMDtcblxuZXhwb3J0IHsgQWNjb3VudCwgQWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudCwgQWRkcmVzc0xvb2t1cFRhYmxlSW5zdHJ1Y3Rpb24sIEFkZHJlc3NMb29rdXBUYWJsZVByb2dyYW0sIEF1dGhvcml6ZWQsIEJMT0NLSEFTSF9DQUNIRV9USU1FT1VUX01TLCBCUEZfTE9BREVSX0RFUFJFQ0FURURfUFJPR1JBTV9JRCwgQlBGX0xPQURFUl9QUk9HUkFNX0lELCBCcGZMb2FkZXIsIENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMsIENvbXB1dGVCdWRnZXRJbnN0cnVjdGlvbiwgQ29tcHV0ZUJ1ZGdldFByb2dyYW0sIENvbm5lY3Rpb24sIEVkMjU1MTlQcm9ncmFtLCBFbnVtLCBFcG9jaFNjaGVkdWxlLCBGZWVDYWxjdWxhdG9yTGF5b3V0LCBLZXlwYWlyLCBMQU1QT1JUU19QRVJfU09MLCBMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUywgTG9hZGVyLCBMb2NrdXAsIE1BWF9TRUVEX0xFTkdUSCwgTWVzc2FnZSwgTWVzc2FnZUFjY291bnRLZXlzLCBNZXNzYWdlVjAsIE5PTkNFX0FDQ09VTlRfTEVOR1RILCBOb25jZUFjY291bnQsIFBBQ0tFVF9EQVRBX1NJWkUsIFBVQkxJQ19LRVlfTEVOR1RILCBQdWJsaWNLZXksIFNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMsIFNPTEFOQV9TQ0hFTUEsIFNUQUtFX0NPTkZJR19JRCwgU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUywgU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMsIFNZU1ZBUl9DTE9DS19QVUJLRVksIFNZU1ZBUl9FUE9DSF9TQ0hFRFVMRV9QVUJLRVksIFNZU1ZBUl9JTlNUUlVDVElPTlNfUFVCS0VZLCBTWVNWQVJfUkVDRU5UX0JMT0NLSEFTSEVTX1BVQktFWSwgU1lTVkFSX1JFTlRfUFVCS0VZLCBTWVNWQVJfUkVXQVJEU19QVUJLRVksIFNZU1ZBUl9TTE9UX0hBU0hFU19QVUJLRVksIFNZU1ZBUl9TTE9UX0hJU1RPUllfUFVCS0VZLCBTWVNWQVJfU1RBS0VfSElTVE9SWV9QVUJLRVksIFNlY3AyNTZrMVByb2dyYW0sIFNlbmRUcmFuc2FjdGlvbkVycm9yLCBTb2xhbmFKU09OUlBDRXJyb3IsIFNvbGFuYUpTT05SUENFcnJvckNvZGUsIFN0YWtlQXV0aG9yaXphdGlvbkxheW91dCwgU3Rha2VJbnN0cnVjdGlvbiwgU3Rha2VQcm9ncmFtLCBTdHJ1Y3QsIFN5c3RlbUluc3RydWN0aW9uLCBTeXN0ZW1Qcm9ncmFtLCBUcmFuc2FjdGlvbiwgVHJhbnNhY3Rpb25FeHBpcmVkQmxvY2toZWlnaHRFeGNlZWRlZEVycm9yLCBUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvciwgVHJhbnNhY3Rpb25FeHBpcmVkVGltZW91dEVycm9yLCBUcmFuc2FjdGlvbkluc3RydWN0aW9uLCBUcmFuc2FjdGlvbk1lc3NhZ2UsIFRyYW5zYWN0aW9uU3RhdHVzLCBWQUxJREFUT1JfSU5GT19LRVksIFZFUlNJT05fUFJFRklYX01BU0ssIFZPVEVfUFJPR1JBTV9JRCwgVmFsaWRhdG9ySW5mbywgVmVyc2lvbmVkTWVzc2FnZSwgVmVyc2lvbmVkVHJhbnNhY3Rpb24sIFZvdGVBY2NvdW50LCBWb3RlQXV0aG9yaXphdGlvbkxheW91dCwgVm90ZUluaXQsIFZvdGVJbnN0cnVjdGlvbiwgVm90ZVByb2dyYW0sIGNsdXN0ZXJBcGlVcmwsIHNlbmRBbmRDb25maXJtUmF3VHJhbnNhY3Rpb24sIHNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJCdWZmZXIiLCJlZDI1NTE5IiwiQk4iLCJiczU4Iiwic2hhMjU2Iiwic2VyaWFsaXplIiwiZGVzZXJpYWxpemUiLCJkZXNlcmlhbGl6ZVVuY2hlY2tlZCIsIkJ1ZmZlckxheW91dCIsImJsb2IiLCJ0b0JpZ0ludExFIiwidG9CdWZmZXJMRSIsInJlcXVpcmUkJDAiLCJyZXF1aXJlJCQwJDEiLCJyZXF1aXJlJCQwJDIiLCJBZ2VudCIsImNvZXJjZSIsImluc3RhbmNlIiwic3RyaW5nIiwidHVwbGUiLCJsaXRlcmFsIiwidW5rbm93biIsInR5cGUiLCJudW1iZXIiLCJhcnJheSIsIm51bGxhYmxlIiwib3B0aW9uYWwiLCJib29sZWFuIiwicmVjb3JkIiwidW5pb24iLCJjcmVhdGUiLCJhbnkiLCJhc3NlcnQiLCJhc3NlcnQkMSIsIlJwY0NsaWVudCIsIm5vZGVGZXRjaCIsIkNvbW1vbkNsaWVudCIsIldlYlNvY2tldCIsImtlY2Nha18yNTYiLCJzZWNwMjU2azEiLCJnZW5lcmF0ZVByaXZhdGVLZXkiLCJ1dGlscyIsInJhbmRvbVByaXZhdGVLZXkiLCJnZW5lcmF0ZUtleXBhaXIiLCJwcml2YXRlU2NhbGFyIiwicHVibGljS2V5IiwiZ2V0UHVibGljS2V5Iiwic2VjcmV0S2V5IiwiVWludDhBcnJheSIsInNldCIsImlzT25DdXJ2ZSIsIkV4dGVuZGVkUG9pbnQiLCJmcm9tSGV4Iiwic2lnbiIsIm1lc3NhZ2UiLCJzbGljZSIsInZlcmlmeSIsInRvQnVmZmVyIiwiYXJyIiwiaXNCdWZmZXIiLCJmcm9tIiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJTdHJ1Y3QiLCJjb25zdHJ1Y3RvciIsInByb3BlcnRpZXMiLCJPYmplY3QiLCJhc3NpZ24iLCJlbmNvZGUiLCJTT0xBTkFfU0NIRU1BIiwiZGVjb2RlIiwiZGF0YSIsImRlY29kZVVuY2hlY2tlZCIsIkVudW0iLCJlbnVtIiwia2V5cyIsImxlbmd0aCIsIkVycm9yIiwibWFwIiwia2V5IiwiTWFwIiwiX1B1YmxpY0tleSIsIk1BWF9TRUVEX0xFTkdUSCIsIlBVQkxJQ19LRVlfTEVOR1RIIiwiaXNQdWJsaWNLZXlEYXRhIiwidmFsdWUiLCJfYm4iLCJ1bmRlZmluZWQiLCJ1bmlxdWVQdWJsaWNLZXlDb3VudGVyIiwiUHVibGljS2V5IiwiZGVjb2RlZCIsInVuaXF1ZSIsImVxdWFscyIsImVxIiwidG9CYXNlNTgiLCJ0b0J5dGVzIiwidG9KU09OIiwiYnVmIiwiYiIsInRvQXJyYXlMaWtlIiwiemVyb1BhZCIsImFsbG9jIiwiY29weSIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwidG9TdHJpbmciLCJjcmVhdGVXaXRoU2VlZCIsImZyb21QdWJsaWNLZXkiLCJzZWVkIiwicHJvZ3JhbUlkIiwiY29uY2F0IiwicHVibGljS2V5Qnl0ZXMiLCJjcmVhdGVQcm9ncmFtQWRkcmVzc1N5bmMiLCJzZWVkcyIsImZvckVhY2giLCJUeXBlRXJyb3IiLCJjcmVhdGVQcm9ncmFtQWRkcmVzcyIsImZpbmRQcm9ncmFtQWRkcmVzc1N5bmMiLCJub25jZSIsImFkZHJlc3MiLCJzZWVkc1dpdGhOb25jZSIsImVyciIsImZpbmRQcm9ncmFtQWRkcmVzcyIsInB1YmtleURhdGEiLCJwdWJrZXkiLCJkZWZhdWx0Iiwia2luZCIsImZpZWxkcyIsIkFjY291bnQiLCJfcHVibGljS2V5IiwiX3NlY3JldEtleSIsInNlY3JldEtleUJ1ZmZlciIsIkJQRl9MT0FERVJfREVQUkVDQVRFRF9QUk9HUkFNX0lEIiwiUEFDS0VUX0RBVEFfU0laRSIsIlZFUlNJT05fUFJFRklYX01BU0siLCJTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTIiwiVHJhbnNhY3Rpb25FeHBpcmVkQmxvY2toZWlnaHRFeGNlZWRlZEVycm9yIiwic2lnbmF0dXJlIiwiZGVmaW5lUHJvcGVydHkiLCJwcm90b3R5cGUiLCJUcmFuc2FjdGlvbkV4cGlyZWRUaW1lb3V0RXJyb3IiLCJ0aW1lb3V0U2Vjb25kcyIsInRvRml4ZWQiLCJUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvciIsIk1lc3NhZ2VBY2NvdW50S2V5cyIsInN0YXRpY0FjY291bnRLZXlzIiwiYWNjb3VudEtleXNGcm9tTG9va3VwcyIsImtleVNlZ21lbnRzIiwicHVzaCIsIndyaXRhYmxlIiwicmVhZG9ubHkiLCJnZXQiLCJpbmRleCIsImtleVNlZ21lbnQiLCJmbGF0IiwiY29tcGlsZUluc3RydWN0aW9ucyIsImluc3RydWN0aW9ucyIsIlU4X01BWCIsImtleUluZGV4TWFwIiwiZmluZEtleUluZGV4Iiwia2V5SW5kZXgiLCJpbnN0cnVjdGlvbiIsInByb2dyYW1JZEluZGV4IiwiYWNjb3VudEtleUluZGV4ZXMiLCJtZXRhIiwicHJvcGVydHkiLCJydXN0U3RyaW5nIiwicnNsIiwic3RydWN0IiwidTMyIiwib2Zmc2V0IiwiX2RlY29kZSIsImJpbmQiLCJfZW5jb2RlIiwicnNsU2hpbSIsInN0ciIsImNoYXJzIiwic3BhbiIsImF1dGhvcml6ZWQiLCJsb2NrdXAiLCJuczY0Iiwidm90ZUluaXQiLCJ1OCIsInZvdGVBdXRob3JpemVXaXRoU2VlZEFyZ3MiLCJnZXRBbGxvYyIsImdldEl0ZW1BbGxvYyIsIml0ZW0iLCJmaWVsZCIsIkFycmF5IiwiaXNBcnJheSIsImVsZW1lbnRMYXlvdXQiLCJsYXlvdXQiLCJkZWNvZGVMZW5ndGgiLCJieXRlcyIsImxlbiIsInNpemUiLCJlbGVtIiwic2hpZnQiLCJlbmNvZGVMZW5ndGgiLCJyZW1fbGVuIiwiY29uZGl0aW9uIiwiQ29tcGlsZWRLZXlzIiwicGF5ZXIiLCJrZXlNZXRhTWFwIiwiY29tcGlsZSIsImdldE9ySW5zZXJ0RGVmYXVsdCIsImtleU1ldGEiLCJpc1NpZ25lciIsImlzV3JpdGFibGUiLCJpc0ludm9rZWQiLCJwYXllcktleU1ldGEiLCJpeCIsImFjY291bnRNZXRhIiwiZ2V0TWVzc2FnZUNvbXBvbmVudHMiLCJtYXBFbnRyaWVzIiwiZW50cmllcyIsIndyaXRhYmxlU2lnbmVycyIsImZpbHRlciIsInJlYWRvbmx5U2lnbmVycyIsIndyaXRhYmxlTm9uU2lnbmVycyIsInJlYWRvbmx5Tm9uU2lnbmVycyIsImhlYWRlciIsIm51bVJlcXVpcmVkU2lnbmF0dXJlcyIsIm51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMiLCJudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHMiLCJwYXllckFkZHJlc3MiLCJleHRyYWN0VGFibGVMb29rdXAiLCJsb29rdXBUYWJsZSIsIndyaXRhYmxlSW5kZXhlcyIsImRyYWluZWRXcml0YWJsZUtleXMiLCJkcmFpbktleXNGb3VuZEluTG9va3VwVGFibGUiLCJzdGF0ZSIsImFkZHJlc3NlcyIsInJlYWRvbmx5SW5kZXhlcyIsImRyYWluZWRSZWFkb25seUtleXMiLCJhY2NvdW50S2V5IiwibG9va3VwVGFibGVFbnRyaWVzIiwia2V5TWV0YUZpbHRlciIsImxvb2t1cFRhYmxlSW5kZXhlcyIsImRyYWluZWRLZXlzIiwibG9va3VwVGFibGVJbmRleCIsImZpbmRJbmRleCIsImVudHJ5IiwiZGVsZXRlIiwiRU5EX09GX0JVRkZFUl9FUlJPUl9NRVNTQUdFIiwiZ3VhcmRlZFNoaWZ0IiwiYnl0ZUFycmF5IiwiZ3VhcmRlZFNwbGljZSIsImFyZ3MiLCJzdGFydCIsInNwbGljZSIsIk1lc3NhZ2UiLCJhY2NvdW50S2V5cyIsInJlY2VudEJsb2NraGFzaCIsImluZGV4VG9Qcm9ncmFtSWRzIiwiYWNjb3VudCIsInZlcnNpb24iLCJjb21waWxlZEluc3RydWN0aW9ucyIsImFjY291bnRzIiwiYWRkcmVzc1RhYmxlTG9va3VwcyIsImdldEFjY291bnRLZXlzIiwiY29tcGlsZWRLZXlzIiwicGF5ZXJLZXkiLCJpc0FjY291bnRTaWduZXIiLCJpc0FjY291bnRXcml0YWJsZSIsIm51bVNpZ25lZEFjY291bnRzIiwidW5zaWduZWRBY2NvdW50SW5kZXgiLCJudW1VbnNpZ25lZEFjY291bnRzIiwibnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzIiwibnVtV3JpdGFibGVTaWduZWRBY2NvdW50cyIsImlzUHJvZ3JhbUlkIiwiaGFzIiwicHJvZ3JhbUlkcyIsInZhbHVlcyIsIm5vblByb2dyYW1JZHMiLCJfIiwibnVtS2V5cyIsImtleUNvdW50Iiwia2V5SW5kaWNlc0NvdW50IiwiZGF0YUNvdW50Iiwia2V5SW5kaWNlcyIsImRhdGFMZW5ndGgiLCJpbnN0cnVjdGlvbkNvdW50IiwiaW5zdHJ1Y3Rpb25CdWZmZXIiLCJpbnN0cnVjdGlvbkJ1ZmZlckxlbmd0aCIsImluc3RydWN0aW9uTGF5b3V0Iiwic2VxIiwic2lnbkRhdGFMYXlvdXQiLCJ0cmFuc2FjdGlvbiIsInNpZ25EYXRhIiwiYWNjb3VudENvdW50IiwiaSIsImRhdGFTbGljZSIsIm1lc3NhZ2VBcmdzIiwiTWVzc2FnZVYwIiwibnVtQWNjb3VudEtleXNGcm9tTG9va3VwcyIsImNvdW50IiwibG9va3VwIiwiYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHMiLCJyZXNvbHZlQWRkcmVzc1RhYmxlTG9va3VwcyIsIm51bVN0YXRpY0FjY291bnRLZXlzIiwibG9va3VwQWNjb3VudEtleXNJbmRleCIsIm51bVdyaXRhYmxlTG9va3VwQWNjb3VudEtleXMiLCJyZWR1Y2UiLCJ0YWJsZUxvb2t1cCIsInRhYmxlQWNjb3VudCIsImZpbmQiLCJsb29rdXBUYWJsZUFjY291bnRzIiwiZXh0cmFjdFJlc3VsdCIsImFkZHJlc3NUYWJsZUxvb2t1cCIsImVuY29kZWRTdGF0aWNBY2NvdW50S2V5c0xlbmd0aCIsInNlcmlhbGl6ZWRJbnN0cnVjdGlvbnMiLCJzZXJpYWxpemVJbnN0cnVjdGlvbnMiLCJlbmNvZGVkSW5zdHJ1Y3Rpb25zTGVuZ3RoIiwic2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHMiLCJzZXJpYWxpemVBZGRyZXNzVGFibGVMb29rdXBzIiwiZW5jb2RlZEFkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGgiLCJtZXNzYWdlTGF5b3V0Iiwic2VyaWFsaXplZE1lc3NhZ2UiLCJNRVNTQUdFX1ZFUlNJT05fMF9QUkVGSVgiLCJzZXJpYWxpemVkTWVzc2FnZUxlbmd0aCIsInByZWZpeCIsInN0YXRpY0FjY291bnRLZXlzTGVuZ3RoIiwiaW5zdHJ1Y3Rpb25zTGVuZ3RoIiwiYWRkcmVzc1RhYmxlTG9va3Vwc0xlbmd0aCIsInNlcmlhbGl6ZWRMZW5ndGgiLCJlbmNvZGVkQWNjb3VudEtleUluZGV4ZXNMZW5ndGgiLCJlbmNvZGVkRGF0YUxlbmd0aCIsImVuY29kZWRXcml0YWJsZUluZGV4ZXNMZW5ndGgiLCJlbmNvZGVkUmVhZG9ubHlJbmRleGVzTGVuZ3RoIiwiYWRkcmVzc1RhYmxlTG9va3VwTGF5b3V0IiwibWFza2VkUHJlZml4IiwiYWNjb3VudEtleUluZGV4ZXNMZW5ndGgiLCJhZGRyZXNzVGFibGVMb29rdXBzQ291bnQiLCJ3cml0YWJsZUluZGV4ZXNMZW5ndGgiLCJyZWFkb25seUluZGV4ZXNMZW5ndGgiLCJWZXJzaW9uZWRNZXNzYWdlIiwiZGVzZXJpYWxpemVNZXNzYWdlVmVyc2lvbiIsIlRyYW5zYWN0aW9uU3RhdHVzIiwiREVGQVVMVF9TSUdOQVRVUkUiLCJmaWxsIiwiVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiIsIm9wdHMiLCJUcmFuc2FjdGlvbiIsInNpZ25hdHVyZXMiLCJmZWVQYXllciIsImxhc3RWYWxpZEJsb2NrSGVpZ2h0Iiwibm9uY2VJbmZvIiwibWluTm9uY2VDb250ZXh0U2xvdCIsIl9tZXNzYWdlIiwiX2pzb24iLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJtaW5Db250ZXh0U2xvdCIsImJsb2NraGFzaCIsIm5vbmNlSW5zdHJ1Y3Rpb24iLCJzaWduZXJzIiwiYWRkIiwiaXRlbXMiLCJjb21waWxlTWVzc2FnZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJjb25zb2xlIiwid2FybiIsImFjY291bnRNZXRhcyIsImluY2x1ZGVzIiwidW5pcXVlTWV0YXMiLCJwdWJrZXlTdHJpbmciLCJ1bmlxdWVJbmRleCIsIngiLCJzb3J0IiwieSIsIm9wdGlvbnMiLCJsb2NhbGVNYXRjaGVyIiwidXNhZ2UiLCJzZW5zaXRpdml0eSIsImlnbm9yZVB1bmN0dWF0aW9uIiwibnVtZXJpYyIsImNhc2VGaXJzdCIsImxvY2FsZUNvbXBhcmUiLCJmZWVQYXllckluZGV4IiwicGF5ZXJNZXRhIiwidW5zaGlmdCIsInNpZ25lZEtleXMiLCJ1bnNpZ25lZEtleXMiLCJpbmRleE9mIiwiX2NvbXBpbGUiLCJ2YWxpZCIsImV2ZXJ5IiwicGFpciIsInNlcmlhbGl6ZU1lc3NhZ2UiLCJnZXRFc3RpbWF0ZWRGZWUiLCJjb25uZWN0aW9uIiwiZ2V0RmVlRm9yTWVzc2FnZSIsInNldFNpZ25lcnMiLCJzZWVuIiwiU2V0IiwidW5pcXVlU2lnbmVycyIsInNpZ25lciIsIl9wYXJ0aWFsU2lnbiIsInBhcnRpYWxTaWduIiwiX2FkZFNpZ25hdHVyZSIsImFkZFNpZ25hdHVyZSIsInNpZ3BhaXIiLCJ2ZXJpZnlTaWduYXR1cmVzIiwicmVxdWlyZUFsbFNpZ25hdHVyZXMiLCJzaWduYXR1cmVFcnJvcnMiLCJfZ2V0TWVzc2FnZVNpZ25lZG5lc3NFcnJvcnMiLCJlcnJvcnMiLCJtaXNzaW5nIiwiaW52YWxpZCIsImNvbmZpZyIsInNpZ0Vycm9ycyIsImVycm9yTWVzc2FnZSIsInAiLCJqb2luIiwiX3NlcmlhbGl6ZSIsInNpZ25hdHVyZUNvdW50IiwidHJhbnNhY3Rpb25MZW5ndGgiLCJ3aXJlVHJhbnNhY3Rpb24iLCJrZXlPYmoiLCJwb3B1bGF0ZSIsInNpZ1B1YmtleVBhaXIiLCJzb21lIiwiVHJhbnNhY3Rpb25NZXNzYWdlIiwiZGVjb21waWxlIiwiY29tcGlsZWRJeCIsImNvbXBpbGVUb0xlZ2FjeU1lc3NhZ2UiLCJjb21waWxlVG9WME1lc3NhZ2UiLCJWZXJzaW9uZWRUcmFuc2FjdGlvbiIsImRlZmF1bHRTaWduYXR1cmVzIiwiZW5jb2RlZFNpZ25hdHVyZXNMZW5ndGgiLCJ0cmFuc2FjdGlvbkxheW91dCIsInNlcmlhbGl6ZWRUcmFuc2FjdGlvbiIsInNlcmlhbGl6ZWRUcmFuc2FjdGlvbkxlbmd0aCIsInNpZ25hdHVyZXNMZW5ndGgiLCJtZXNzYWdlRGF0YSIsInNpZ25lclB1YmtleXMiLCJzaWduZXJJbmRleCIsIk5VTV9USUNLU19QRVJfU0VDT05EIiwiREVGQVVMVF9USUNLU19QRVJfU0xPVCIsIk5VTV9TTE9UU19QRVJfU0VDT05EIiwiTVNfUEVSX1NMT1QiLCJTWVNWQVJfQ0xPQ0tfUFVCS0VZIiwiU1lTVkFSX0VQT0NIX1NDSEVEVUxFX1BVQktFWSIsIlNZU1ZBUl9JTlNUUlVDVElPTlNfUFVCS0VZIiwiU1lTVkFSX1JFQ0VOVF9CTE9DS0hBU0hFU19QVUJLRVkiLCJTWVNWQVJfUkVOVF9QVUJLRVkiLCJTWVNWQVJfUkVXQVJEU19QVUJLRVkiLCJTWVNWQVJfU0xPVF9IQVNIRVNfUFVCS0VZIiwiU1lTVkFSX1NMT1RfSElTVE9SWV9QVUJLRVkiLCJTWVNWQVJfU1RBS0VfSElTVE9SWV9QVUJLRVkiLCJTZW5kVHJhbnNhY3Rpb25FcnJvciIsImFjdGlvbiIsInRyYW5zYWN0aW9uTWVzc2FnZSIsImxvZ3MiLCJtYXliZUxvZ3NPdXRwdXQiLCJndWlkZVRleHQiLCJhIiwidHJhbnNhY3Rpb25Mb2dzIiwidHJhbnNhY3Rpb25FcnJvciIsImNhY2hlZExvZ3MiLCJnZXRMb2dzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJnZXRUcmFuc2FjdGlvbiIsInRoZW4iLCJ0eCIsImxvZ01lc3NhZ2VzIiwiY2F0Y2giLCJTb2xhbmFKU09OUlBDRXJyb3JDb2RlIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX0JMT0NLX0NMRUFORURfVVAiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfU0VORF9UUkFOU0FDVElPTl9QUkVGTElHSFRfRkFJTFVSRSIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9TSUdOQVRVUkVfVkVSSUZJQ0FUSU9OX0ZBSUxVUkUiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfQkxPQ0tfTk9UX0FWQUlMQUJMRSIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9OT0RFX1VOSEVBTFRIWSIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9QUkVDT01QSUxFX1ZFUklGSUNBVElPTl9GQUlMVVJFIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX1NMT1RfU0tJUFBFRCIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9OT19TTkFQU0hPVCIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9MT05HX1RFUk1fU1RPUkFHRV9TTE9UX1NLSVBQRUQiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfS0VZX0VYQ0xVREVEX0ZST01fU0VDT05EQVJZX0lOREVYIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX0hJU1RPUllfTk9UX0FWQUlMQUJMRSIsIkpTT05fUlBDX1NDQU5fRVJST1IiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fU0lHTkFUVVJFX0xFTl9NSVNNQVRDSCIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9CTE9DS19TVEFUVVNfTk9UX0FWQUlMQUJMRV9ZRVQiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfVU5TVVBQT1JURURfVFJBTlNBQ1RJT05fVkVSU0lPTiIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9NSU5fQ09OVEVYVF9TTE9UX05PVF9SRUFDSEVEIiwiU29sYW5hSlNPTlJQQ0Vycm9yIiwiY29kZSIsImN1c3RvbU1lc3NhZ2UiLCJuYW1lIiwic2VuZEFuZENvbmZpcm1UcmFuc2FjdGlvbiIsInNlbmRPcHRpb25zIiwic2tpcFByZWZsaWdodCIsInByZWZsaWdodENvbW1pdG1lbnQiLCJjb21taXRtZW50IiwibWF4UmV0cmllcyIsInNlbmRUcmFuc2FjdGlvbiIsInN0YXR1cyIsImNvbmZpcm1UcmFuc2FjdGlvbiIsImFib3J0U2lnbmFsIiwibm9uY2VBY2NvdW50UHVia2V5Iiwibm9uY2VWYWx1ZSIsInNsZWVwIiwibXMiLCJzZXRUaW1lb3V0IiwiZW5jb2RlRGF0YSIsImFsbG9jTGVuZ3RoIiwibGF5b3V0RmllbGRzIiwiZGVjb2RlRGF0YSQxIiwiRmVlQ2FsY3VsYXRvckxheW91dCIsIm51NjQiLCJOb25jZUFjY291bnRMYXlvdXQiLCJOT05DRV9BQ0NPVU5UX0xFTkdUSCIsIk5vbmNlQWNjb3VudCIsImF1dGhvcml6ZWRQdWJrZXkiLCJmZWVDYWxjdWxhdG9yIiwiZnJvbUFjY291bnREYXRhIiwibm9uY2VBY2NvdW50IiwiZW5jb2RlRGVjb2RlIiwiYmlnSW50IiwiYmlnSW50TGF5b3V0Iiwic3JjIiwidTY0IiwiU3lzdGVtSW5zdHJ1Y3Rpb24iLCJkZWNvZGVJbnN0cnVjdGlvblR5cGUiLCJjaGVja1Byb2dyYW1JZCIsImluc3RydWN0aW9uVHlwZUxheW91dCIsInR5cGVJbmRleCIsIml4VHlwZSIsIlNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTIiwiZGVjb2RlQ3JlYXRlQWNjb3VudCIsImNoZWNrS2V5TGVuZ3RoIiwibGFtcG9ydHMiLCJzcGFjZSIsIkNyZWF0ZSIsImZyb21QdWJrZXkiLCJuZXdBY2NvdW50UHVia2V5IiwiZGVjb2RlVHJhbnNmZXIiLCJUcmFuc2ZlciIsInRvUHVia2V5IiwiZGVjb2RlVHJhbnNmZXJXaXRoU2VlZCIsIlRyYW5zZmVyV2l0aFNlZWQiLCJiYXNlUHVia2V5IiwiZGVjb2RlQWxsb2NhdGUiLCJBbGxvY2F0ZSIsImFjY291bnRQdWJrZXkiLCJkZWNvZGVBbGxvY2F0ZVdpdGhTZWVkIiwiYmFzZSIsIkFsbG9jYXRlV2l0aFNlZWQiLCJkZWNvZGVBc3NpZ24iLCJBc3NpZ24iLCJkZWNvZGVBc3NpZ25XaXRoU2VlZCIsIkFzc2lnbldpdGhTZWVkIiwiZGVjb2RlQ3JlYXRlV2l0aFNlZWQiLCJDcmVhdGVXaXRoU2VlZCIsImRlY29kZU5vbmNlSW5pdGlhbGl6ZSIsIkluaXRpYWxpemVOb25jZUFjY291bnQiLCJub25jZVB1YmtleSIsImRlY29kZU5vbmNlQWR2YW5jZSIsIkFkdmFuY2VOb25jZUFjY291bnQiLCJkZWNvZGVOb25jZVdpdGhkcmF3IiwiV2l0aGRyYXdOb25jZUFjY291bnQiLCJkZWNvZGVOb25jZUF1dGhvcml6ZSIsIkF1dGhvcml6ZU5vbmNlQWNjb3VudCIsIm5ld0F1dGhvcml6ZWRQdWJrZXkiLCJTeXN0ZW1Qcm9ncmFtIiwiZXhwZWN0ZWRMZW5ndGgiLCJmcmVlemUiLCJVcGdyYWRlTm9uY2VBY2NvdW50IiwiY3JlYXRlQWNjb3VudCIsInBhcmFtcyIsInRyYW5zZmVyIiwiQmlnSW50IiwiY3JlYXRlQWNjb3VudFdpdGhTZWVkIiwiY3JlYXRlTm9uY2VBY2NvdW50IiwiaW5pdFBhcmFtcyIsIm5vbmNlSW5pdGlhbGl6ZSIsImluc3RydWN0aW9uRGF0YSIsIm5vbmNlQWR2YW5jZSIsIm5vbmNlV2l0aGRyYXciLCJub25jZUF1dGhvcml6ZSIsImFsbG9jYXRlIiwiQ0hVTktfU0laRSIsIkxvYWRlciIsImdldE1pbk51bVNpZ25hdHVyZXMiLCJNYXRoIiwiY2VpbCIsImNodW5rU2l6ZSIsImxvYWQiLCJwcm9ncmFtIiwiYmFsYW5jZU5lZWRlZCIsImdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvbiIsInByb2dyYW1JbmZvIiwiZ2V0QWNjb3VudEluZm8iLCJleGVjdXRhYmxlIiwiZXJyb3IiLCJvd25lciIsImRhdGFMYXlvdXQiLCJ0cmFuc2FjdGlvbnMiLCJieXRlc0xlbmd0aCIsImJ5dGVzTGVuZ3RoUGFkZGluZyIsIl9ycGNFbmRwb2ludCIsIlJFUVVFU1RTX1BFUl9TRUNPTkQiLCJhbGwiLCJkZXBsb3lDb21taXRtZW50IiwiZmluYWxpemVTaWduYXR1cmUiLCJjb250ZXh0IiwiY3VycmVudFNsb3QiLCJnZXRTbG90Iiwic2xvdCIsInJvdW5kIiwiQlBGX0xPQURFUl9QUk9HUkFNX0lEIiwiQnBmTG9hZGVyIiwiZWxmIiwibG9hZGVyUHJvZ3JhbUlkIiwiZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMiLCJfX2VzTW9kdWxlIiwiYWdlbnRrZWVwYWxpdmUiLCJleHBvcnRzIiwiaGFzUmVxdWlyZWRNcyIsInJlcXVpcmVNcyIsInMiLCJtIiwiaCIsImQiLCJ3IiwidmFsIiwicGFyc2UiLCJpc0Zpbml0ZSIsImxvbmciLCJmbXRMb25nIiwiZm10U2hvcnQiLCJTdHJpbmciLCJtYXRjaCIsImV4ZWMiLCJuIiwicGFyc2VGbG9hdCIsInRvTG93ZXJDYXNlIiwibXNBYnMiLCJhYnMiLCJwbHVyYWwiLCJpc1BsdXJhbCIsImh1bWFuaXplTXMiLCJoYXNSZXF1aXJlZEh1bWFuaXplTXMiLCJyZXF1aXJlSHVtYW5pemVNcyIsInV0aWwiLCJ0IiwiciIsImZvcm1hdCIsInN0YWNrIiwiY29uc3RhbnRzIiwiaGFzUmVxdWlyZWRDb25zdGFudHMiLCJyZXF1aXJlQ29uc3RhbnRzIiwiQ1VSUkVOVF9JRCIsIkNSRUFURV9JRCIsIklOSVRfU09DS0VUIiwiQ1JFQVRFX0hUVFBTX0NPTk5FQ1RJT04iLCJTT0NLRVRfQ1JFQVRFRF9USU1FIiwiU09DS0VUX05BTUUiLCJTT0NLRVRfUkVRVUVTVF9DT1VOVCIsIlNPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UIiwiYWdlbnQiLCJoYXNSZXF1aXJlZEFnZW50IiwicmVxdWlyZUFnZW50IiwiT3JpZ2luYWxBZ2VudCIsImRlYnVnIiwiZGVidWdsb2ciLCJkZWZhdWx0VGltZW91dExpc3RlbmVyQ291bnQiLCJtYWpvclZlcnNpb24iLCJwYXJzZUludCIsInByb2Nlc3MiLCJzcGxpdCIsInN1YnN0cmluZyIsImRlcHJlY2F0ZSIsImxvZyIsImtlZXBBbGl2ZSIsImZyZWVTb2NrZXRUaW1lb3V0Iiwia2VlcEFsaXZlVGltZW91dCIsImZyZWVTb2NrZXRLZWVwQWxpdmVUaW1lb3V0IiwidGltZW91dCIsIm1heCIsInNvY2tldEFjdGl2ZVRUTCIsImNyZWF0ZVNvY2tldENvdW50IiwiY3JlYXRlU29ja2V0Q291bnRMYXN0Q2hlY2siLCJjcmVhdGVTb2NrZXRFcnJvckNvdW50IiwiY3JlYXRlU29ja2V0RXJyb3JDb3VudExhc3RDaGVjayIsImNsb3NlU29ja2V0Q291bnQiLCJjbG9zZVNvY2tldENvdW50TGFzdENoZWNrIiwiZXJyb3JTb2NrZXRDb3VudCIsImVycm9yU29ja2V0Q291bnRMYXN0Q2hlY2siLCJyZXF1ZXN0Q291bnQiLCJyZXF1ZXN0Q291bnRMYXN0Q2hlY2siLCJ0aW1lb3V0U29ja2V0Q291bnQiLCJ0aW1lb3V0U29ja2V0Q291bnRMYXN0Q2hlY2siLCJvbiIsInNvY2tldCIsImNhbGNTb2NrZXRUaW1lb3V0IiwiYWxpdmVUaW1lIiwiRGF0ZSIsIm5vdyIsImRpZmYiLCJjdXN0b21GcmVlU29ja2V0VGltZW91dCIsImtlZXBTb2NrZXRBbGl2ZSIsInJlc3VsdCIsImN1c3RvbVRpbWVvdXQiLCJyZXVzZVNvY2tldCIsInJlcSIsInJldXNlZFNvY2tldCIsImFnZW50VGltZW91dCIsImdldFNvY2tldFRpbWVvdXQiLCJpZCIsIk51bWJlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJzZXROb0RlbGF5IiwiX2FnZW50S2V5IiwiaW5zdGFsbExpc3RlbmVycyIsImNyZWF0ZUNvbm5lY3Rpb24iLCJvbmNyZWF0ZSIsImNhbGxlZCIsIm9uTmV3Q3JlYXRlIiwibmV3U29ja2V0Iiwic3RhdHVzQ2hhbmdlZCIsImNoYW5nZWQiLCJnZXRDdXJyZW50U3RhdHVzIiwiZnJlZVNvY2tldHMiLCJpbnNwZWN0Iiwic29ja2V0cyIsInJlcXVlc3RzIiwiX2lkbGVUaW1lb3V0Iiwib25GcmVlIiwiX2h0dHBNZXNzYWdlIiwiZ2V0TmFtZSIsIm9uQ2xvc2UiLCJpc0Vycm9yIiwib25UaW1lb3V0IiwibGlzdGVuZXJDb3VudCIsImxpc3RlbmVycyIsInJlcVRpbWVvdXRMaXN0ZW5lckNvdW50IiwiZW5hYmxlZCIsImYiLCJkZXN0cm95IiwicmVtb3ZlU29ja2V0Iiwib25FcnJvciIsInJlbW92ZUxpc3RlbmVyIiwiZW1pdCIsIm9uUmVtb3ZlIiwib2JqIiwicmVzIiwiaHR0cHNfYWdlbnQiLCJoYXNSZXF1aXJlZEh0dHBzX2FnZW50IiwicmVxdWlyZUh0dHBzX2FnZW50IiwiT3JpZ2luYWxIdHRwc0FnZW50IiwiSHR0cEFnZW50IiwiSHR0cHNBZ2VudCIsImRlZmF1bHRQb3J0IiwicHJvdG9jb2wiLCJtYXhDYWNoZWRTZXNzaW9ucyIsIl9zZXNzaW9uQ2FjaGUiLCJsaXN0IiwibWV0aG9kIiwiaGFzUmVxdWlyZWRBZ2VudGtlZXBhbGl2ZSIsInJlcXVpcmVBZ2VudGtlZXBhbGl2ZSIsImFnZW50a2VlcGFsaXZlRXhwb3J0cyIsIkh0dHBLZWVwQWxpdmVBZ2VudCIsImZhc3RTdGFibGVTdHJpbmdpZnkkMSIsImhhc1JlcXVpcmVkRmFzdFN0YWJsZVN0cmluZ2lmeSIsInJlcXVpcmVGYXN0U3RhYmxlU3RyaW5naWZ5Iiwib2JqVG9TdHJpbmciLCJvYmpLZXlzIiwiaXNBcnJheVByb3AiLCJwcm9wVmFsIiwidG9TdHIiLCJyZXR1cm5WYWwiLCJmYXN0U3RhYmxlU3RyaW5naWZ5RXhwb3J0cyIsImZhc3RTdGFibGVTdHJpbmdpZnkiLCJNSU5JTVVNX1NMT1RfUEVSX0VQT0NIIiwidHJhaWxpbmdaZXJvcyIsIm5leHRQb3dlck9mVHdvIiwiRXBvY2hTY2hlZHVsZSIsInNsb3RzUGVyRXBvY2giLCJsZWFkZXJTY2hlZHVsZVNsb3RPZmZzZXQiLCJ3YXJtdXAiLCJmaXJzdE5vcm1hbEVwb2NoIiwiZmlyc3ROb3JtYWxTbG90IiwiZ2V0RXBvY2giLCJnZXRFcG9jaEFuZFNsb3RJbmRleCIsImVwb2NoIiwiZXBvY2hMZW4iLCJnZXRTbG90c0luRXBvY2giLCJzbG90SW5kZXgiLCJub3JtYWxTbG90SW5kZXgiLCJub3JtYWxFcG9jaEluZGV4IiwiZmxvb3IiLCJnZXRGaXJzdFNsb3RJbkVwb2NoIiwicG93IiwiZ2V0TGFzdFNsb3RJbkVwb2NoIiwiZmV0Y2hJbXBsIiwiZ2xvYmFsVGhpcyIsImZldGNoIiwiaW5wdXQiLCJpbml0IiwicHJvY2Vzc2VkSW5wdXQiLCJScGNXZWJTb2NrZXRDbGllbnQiLCJnZW5lcmF0ZV9yZXF1ZXN0X2lkIiwid2ViU29ja2V0RmFjdG9yeSIsInVybCIsInJwYyIsImF1dG9jb25uZWN0IiwibWF4X3JlY29ubmVjdHMiLCJyZWNvbm5lY3QiLCJyZWNvbm5lY3RfaW50ZXJ2YWwiLCJ1bmRlcmx5aW5nU29ja2V0IiwicmVhZHlTdGF0ZSIsIm5vdGlmeSIsImRlY29kZURhdGEiLCJMT09LVVBfVEFCTEVfTUVUQV9TSVpFIiwiQWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudCIsImlzQWN0aXZlIiwiVTY0X01BWCIsImRlYWN0aXZhdGlvblNsb3QiLCJhY2NvdW50RGF0YSIsIkxvb2t1cFRhYmxlTWV0YUxheW91dCIsInNlcmlhbGl6ZWRBZGRyZXNzZXNMZW4iLCJudW1TZXJpYWxpemVkQWRkcmVzc2VzIiwibGFzdEV4dGVuZGVkU2xvdCIsImxhc3RFeHRlbmRlZFNsb3RTdGFydEluZGV4IiwibGFzdEV4dGVuZGVkU3RhcnRJbmRleCIsImF1dGhvcml0eSIsIlVSTF9SRSIsIm1ha2VXZWJzb2NrZXRVcmwiLCJlbmRwb2ludCIsIm1hdGNoZXMiLCJob3N0aXNoIiwicG9ydFdpdGhDb2xvbiIsInJlc3QiLCJzdGFydHNXaXRoIiwic3RhcnRQb3J0Iiwid2Vic29ja2V0UG9ydCIsIlB1YmxpY0tleUZyb21TdHJpbmciLCJSYXdBY2NvdW50RGF0YVJlc3VsdCIsIkJ1ZmZlckZyb21SYXdBY2NvdW50RGF0YSIsIkJMT0NLSEFTSF9DQUNIRV9USU1FT1VUX01TIiwiYXNzZXJ0RW5kcG9pbnRVcmwiLCJwdXRhdGl2ZVVybCIsInRlc3QiLCJleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWciLCJjb21taXRtZW50T3JDb25maWciLCJzcGVjaWZpZWRDb21taXRtZW50Iiwic3BlY2lmaWVkQ29uZmlnIiwiYXBwbHlEZWZhdWx0TWVtY21wRW5jb2RpbmdUb0ZpbHRlcnMiLCJmaWx0ZXJzIiwibWVtY21wIiwiZW5jb2RpbmciLCJjcmVhdGVScGNSZXN1bHQiLCJqc29ucnBjIiwiVW5rbm93blJwY1Jlc3VsdCIsImpzb25ScGNSZXN1bHQiLCJzY2hlbWEiLCJqc29uUnBjUmVzdWx0QW5kQ29udGV4dCIsIm5vdGlmaWNhdGlvblJlc3VsdEFuZENvbnRleHQiLCJ2ZXJzaW9uZWRNZXNzYWdlRnJvbVJlc3BvbnNlIiwicmVzcG9uc2UiLCJHZXRJbmZsYXRpb25Hb3Zlcm5vclJlc3VsdCIsImZvdW5kYXRpb24iLCJmb3VuZGF0aW9uVGVybSIsImluaXRpYWwiLCJ0YXBlciIsInRlcm1pbmFsIiwiR2V0SW5mbGF0aW9uUmV3YXJkUmVzdWx0IiwiZWZmZWN0aXZlU2xvdCIsImFtb3VudCIsInBvc3RCYWxhbmNlIiwiY29tbWlzc2lvbiIsIkdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc1Jlc3VsdCIsInByaW9yaXRpemF0aW9uRmVlIiwiR2V0SW5mbGF0aW9uUmF0ZVJlc3VsdCIsInRvdGFsIiwidmFsaWRhdG9yIiwiR2V0RXBvY2hJbmZvUmVzdWx0Iiwic2xvdHNJbkVwb2NoIiwiYWJzb2x1dGVTbG90IiwiYmxvY2tIZWlnaHQiLCJ0cmFuc2FjdGlvbkNvdW50IiwiR2V0RXBvY2hTY2hlZHVsZVJlc3VsdCIsIkdldExlYWRlclNjaGVkdWxlUmVzdWx0IiwiVHJhbnNhY3Rpb25FcnJvclJlc3VsdCIsIlNpZ25hdHVyZVN0YXR1c1Jlc3VsdCIsIlNpZ25hdHVyZVJlY2VpdmVkUmVzdWx0IiwiVmVyc2lvblJlc3VsdCIsIlBhcnNlZEluc3RydWN0aW9uU3RydWN0IiwicGFyc2VkIiwiUGFydGlhbGx5RGVjb2RlZEluc3RydWN0aW9uU3RydWN0IiwiU2ltdWxhdGVkVHJhbnNhY3Rpb25SZXNwb25zZVN0cnVjdCIsInJlbnRFcG9jaCIsInVuaXRzQ29uc3VtZWQiLCJyZXR1cm5EYXRhIiwiaW5uZXJJbnN0cnVjdGlvbnMiLCJCbG9ja1Byb2R1Y3Rpb25SZXNwb25zZVN0cnVjdCIsImJ5SWRlbnRpdHkiLCJyYW5nZSIsImZpcnN0U2xvdCIsImxhc3RTbG90IiwiY3JlYXRlUnBjQ2xpZW50IiwiaHR0cEhlYWRlcnMiLCJjdXN0b21GZXRjaCIsImZldGNoTWlkZGxld2FyZSIsImRpc2FibGVSZXRyeU9uUmF0ZUxpbWl0IiwiaHR0cEFnZW50IiwiYWdlbnRPcHRpb25zIiwibWF4U29ja2V0cyIsImlzSHR0cHMiLCJmZXRjaFdpdGhNaWRkbGV3YXJlIiwiaW5mbyIsIm1vZGlmaWVkRmV0Y2hBcmdzIiwibW9kaWZpZWRJbmZvIiwibW9kaWZpZWRJbml0IiwiY2xpZW50QnJvd3NlciIsInJlcXVlc3QiLCJjYWxsYmFjayIsImJvZHkiLCJoZWFkZXJzIiwiQ09NTU9OX0hUVFBfSEVBREVSUyIsInRvb19tYW55X3JlcXVlc3RzX3JldHJpZXMiLCJ3YWl0VGltZSIsInN0YXR1c1RleHQiLCJ0ZXh0Iiwib2siLCJjcmVhdGVScGNSZXF1ZXN0IiwiY2xpZW50IiwiY3JlYXRlUnBjQmF0Y2hSZXF1ZXN0IiwiYmF0Y2giLCJtZXRob2ROYW1lIiwiR2V0SW5mbGF0aW9uR292ZXJub3JScGNSZXN1bHQiLCJHZXRJbmZsYXRpb25SYXRlUnBjUmVzdWx0IiwiR2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzUnBjUmVzdWx0IiwiR2V0RXBvY2hJbmZvUnBjUmVzdWx0IiwiR2V0RXBvY2hTY2hlZHVsZVJwY1Jlc3VsdCIsIkdldExlYWRlclNjaGVkdWxlUnBjUmVzdWx0IiwiU2xvdFJwY1Jlc3VsdCIsIkdldFN1cHBseVJwY1Jlc3VsdCIsImNpcmN1bGF0aW5nIiwibm9uQ2lyY3VsYXRpbmciLCJub25DaXJjdWxhdGluZ0FjY291bnRzIiwiVG9rZW5BbW91bnRSZXN1bHQiLCJ1aUFtb3VudCIsImRlY2ltYWxzIiwidWlBbW91bnRTdHJpbmciLCJHZXRUb2tlbkxhcmdlc3RBY2NvdW50c1Jlc3VsdCIsIkdldFRva2VuQWNjb3VudHNCeU93bmVyIiwiUGFyc2VkQWNjb3VudERhdGFSZXN1bHQiLCJHZXRQYXJzZWRUb2tlbkFjY291bnRzQnlPd25lciIsIkdldExhcmdlc3RBY2NvdW50c1JwY1Jlc3VsdCIsIkFjY291bnRJbmZvUmVzdWx0IiwiS2V5ZWRBY2NvdW50SW5mb1Jlc3VsdCIsIlBhcnNlZE9yUmF3QWNjb3VudERhdGEiLCJQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdCIsIktleWVkUGFyc2VkQWNjb3VudEluZm9SZXN1bHQiLCJTdGFrZUFjdGl2YXRpb25SZXN1bHQiLCJhY3RpdmUiLCJpbmFjdGl2ZSIsIkdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMlJwY1Jlc3VsdCIsIm1lbW8iLCJibG9ja1RpbWUiLCJHZXRTaWduYXR1cmVzRm9yQWRkcmVzc1JwY1Jlc3VsdCIsIkFjY291bnROb3RpZmljYXRpb25SZXN1bHQiLCJzdWJzY3JpcHRpb24iLCJQcm9ncmFtQWNjb3VudEluZm9SZXN1bHQiLCJQcm9ncmFtQWNjb3VudE5vdGlmaWNhdGlvblJlc3VsdCIsIlNsb3RJbmZvUmVzdWx0IiwicGFyZW50Iiwicm9vdCIsIlNsb3ROb3RpZmljYXRpb25SZXN1bHQiLCJTbG90VXBkYXRlUmVzdWx0IiwidGltZXN0YW1wIiwic3RhdHMiLCJudW1UcmFuc2FjdGlvbkVudHJpZXMiLCJudW1TdWNjZXNzZnVsVHJhbnNhY3Rpb25zIiwibnVtRmFpbGVkVHJhbnNhY3Rpb25zIiwibWF4VHJhbnNhY3Rpb25zUGVyRW50cnkiLCJTbG90VXBkYXRlTm90aWZpY2F0aW9uUmVzdWx0IiwiU2lnbmF0dXJlTm90aWZpY2F0aW9uUmVzdWx0IiwiUm9vdE5vdGlmaWNhdGlvblJlc3VsdCIsIkNvbnRhY3RJbmZvUmVzdWx0IiwiZ29zc2lwIiwidHB1IiwiVm90ZUFjY291bnRJbmZvUmVzdWx0Iiwidm90ZVB1YmtleSIsIm5vZGVQdWJrZXkiLCJhY3RpdmF0ZWRTdGFrZSIsImVwb2NoVm90ZUFjY291bnQiLCJlcG9jaENyZWRpdHMiLCJsYXN0Vm90ZSIsInJvb3RTbG90IiwiR2V0Vm90ZUFjY291bnRzIiwiY3VycmVudCIsImRlbGlucXVlbnQiLCJDb25maXJtYXRpb25TdGF0dXMiLCJTaWduYXR1cmVTdGF0dXNSZXNwb25zZSIsImNvbmZpcm1hdGlvbnMiLCJjb25maXJtYXRpb25TdGF0dXMiLCJHZXRTaWduYXR1cmVTdGF0dXNlc1JwY1Jlc3VsdCIsIkdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvblJwY1Jlc3VsdCIsIkFkZHJlc3NUYWJsZUxvb2t1cFN0cnVjdCIsIkNvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0IiwiQW5ub3RhdGVkQWNjb3VudEtleSIsInNvdXJjZSIsIkNvbmZpcm1lZFRyYW5zYWN0aW9uQWNjb3VudHNNb2RlUmVzdWx0IiwiUGFyc2VkSW5zdHJ1Y3Rpb25SZXN1bHQiLCJSYXdJbnN0cnVjdGlvblJlc3VsdCIsIkluc3RydWN0aW9uUmVzdWx0IiwiVW5rbm93bkluc3RydWN0aW9uUmVzdWx0IiwiUGFyc2VkT3JSYXdJbnN0cnVjdGlvbiIsIlBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0IiwiVG9rZW5CYWxhbmNlUmVzdWx0IiwiYWNjb3VudEluZGV4IiwibWludCIsInVpVG9rZW5BbW91bnQiLCJMb2FkZWRBZGRyZXNzZXNSZXN1bHQiLCJDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQiLCJmZWUiLCJwcmVCYWxhbmNlcyIsInBvc3RCYWxhbmNlcyIsInByZVRva2VuQmFsYW5jZXMiLCJwb3N0VG9rZW5CYWxhbmNlcyIsImxvYWRlZEFkZHJlc3NlcyIsImNvbXB1dGVVbml0c0NvbnN1bWVkIiwiUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0IiwiVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0IiwiUmV3YXJkc1Jlc3VsdCIsInJld2FyZFR5cGUiLCJHZXRCbG9ja1JwY1Jlc3VsdCIsInByZXZpb3VzQmxvY2toYXNoIiwicGFyZW50U2xvdCIsInJld2FyZHMiLCJHZXROb25lTW9kZUJsb2NrUnBjUmVzdWx0IiwiR2V0QWNjb3VudHNNb2RlQmxvY2tScGNSZXN1bHQiLCJHZXRQYXJzZWRCbG9ja1JwY1Jlc3VsdCIsIkdldFBhcnNlZEFjY291bnRzTW9kZUJsb2NrUnBjUmVzdWx0IiwiR2V0UGFyc2VkTm9uZU1vZGVCbG9ja1JwY1Jlc3VsdCIsIkdldENvbmZpcm1lZEJsb2NrUnBjUmVzdWx0IiwiR2V0QmxvY2tTaWduYXR1cmVzUnBjUmVzdWx0IiwiR2V0VHJhbnNhY3Rpb25ScGNSZXN1bHQiLCJHZXRQYXJzZWRUcmFuc2FjdGlvblJwY1Jlc3VsdCIsIkdldExhdGVzdEJsb2NraGFzaFJwY1Jlc3VsdCIsIklzQmxvY2toYXNoVmFsaWRScGNSZXN1bHQiLCJQZXJmU2FtcGxlUmVzdWx0IiwibnVtVHJhbnNhY3Rpb25zIiwibnVtU2xvdHMiLCJzYW1wbGVQZXJpb2RTZWNzIiwiR2V0UmVjZW50UGVyZm9ybWFuY2VTYW1wbGVzUnBjUmVzdWx0IiwiR2V0RmVlQ2FsY3VsYXRvclJwY1Jlc3VsdCIsImxhbXBvcnRzUGVyU2lnbmF0dXJlIiwiUmVxdWVzdEFpcmRyb3BScGNSZXN1bHQiLCJTZW5kVHJhbnNhY3Rpb25ScGNSZXN1bHQiLCJMb2dzUmVzdWx0IiwiTG9nc05vdGlmaWNhdGlvblJlc3VsdCIsIkNvbm5lY3Rpb24iLCJfY29tbWl0bWVudE9yQ29uZmlnIiwiX2NvbW1pdG1lbnQiLCJfY29uZmlybVRyYW5zYWN0aW9uSW5pdGlhbFRpbWVvdXQiLCJfcnBjV3NFbmRwb2ludCIsIl9ycGNDbGllbnQiLCJfcnBjUmVxdWVzdCIsIl9ycGNCYXRjaFJlcXVlc3QiLCJfcnBjV2ViU29ja2V0IiwiX3JwY1dlYlNvY2tldENvbm5lY3RlZCIsIl9ycGNXZWJTb2NrZXRIZWFydGJlYXQiLCJfcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQiLCJfcnBjV2ViU29ja2V0R2VuZXJhdGlvbiIsIl9kaXNhYmxlQmxvY2toYXNoQ2FjaGluZyIsIl9wb2xsaW5nQmxvY2toYXNoIiwiX2Jsb2NraGFzaEluZm8iLCJsYXRlc3RCbG9ja2hhc2giLCJsYXN0RmV0Y2giLCJ0cmFuc2FjdGlvblNpZ25hdHVyZXMiLCJzaW11bGF0ZWRTaWduYXR1cmVzIiwiX25leHRDbGllbnRTdWJzY3JpcHRpb25JZCIsIl9zdWJzY3JpcHRpb25EaXNwb3NlRnVuY3Rpb25zQnlDbGllbnRTdWJzY3JpcHRpb25JZCIsIl9zdWJzY3JpcHRpb25IYXNoQnlDbGllbnRTdWJzY3JpcHRpb25JZCIsIl9zdWJzY3JpcHRpb25TdGF0ZUNoYW5nZUNhbGxiYWNrc0J5SGFzaCIsIl9zdWJzY3JpcHRpb25DYWxsYmFja3NCeVNlcnZlclN1YnNjcmlwdGlvbklkIiwiX3N1YnNjcmlwdGlvbnNCeUhhc2giLCJfc3Vic2NyaXB0aW9uc0F1dG9EaXNwb3NlZEJ5UnBjIiwiZ2V0QmxvY2tIZWlnaHQiLCJyZXF1ZXN0UHJvbWlzZXMiLCJfYnVpbGRBcmdzIiwicmVxdWVzdEhhc2giLCJ1bnNhZmVSZXMiLCJ3c0VuZHBvaW50IiwiY29uZmlybVRyYW5zYWN0aW9uSW5pdGlhbFRpbWVvdXQiLCJJbmZpbml0eSIsIl93c09uT3BlbiIsIl93c09uRXJyb3IiLCJfd3NPbkNsb3NlIiwiX3dzT25BY2NvdW50Tm90aWZpY2F0aW9uIiwiX3dzT25Qcm9ncmFtQWNjb3VudE5vdGlmaWNhdGlvbiIsIl93c09uU2xvdE5vdGlmaWNhdGlvbiIsIl93c09uU2xvdFVwZGF0ZXNOb3RpZmljYXRpb24iLCJfd3NPblNpZ25hdHVyZU5vdGlmaWNhdGlvbiIsIl93c09uUm9vdE5vdGlmaWNhdGlvbiIsIl93c09uTG9nc05vdGlmaWNhdGlvbiIsInJwY0VuZHBvaW50IiwiZ2V0QmFsYW5jZUFuZENvbnRleHQiLCJnZXRCYWxhbmNlIiwiZSIsImdldEJsb2NrVGltZSIsImdldE1pbmltdW1MZWRnZXJTbG90IiwiZ2V0Rmlyc3RBdmFpbGFibGVCbG9jayIsImdldFN1cHBseSIsImNvbmZpZ0FyZyIsImdldFRva2VuU3VwcGx5IiwidG9rZW5NaW50QWRkcmVzcyIsImdldFRva2VuQWNjb3VudEJhbGFuY2UiLCJ0b2tlbkFkZHJlc3MiLCJnZXRUb2tlbkFjY291bnRzQnlPd25lciIsIm93bmVyQWRkcmVzcyIsIl9hcmdzIiwiZ2V0UGFyc2VkVG9rZW5BY2NvdW50c0J5T3duZXIiLCJnZXRMYXJnZXN0QWNjb3VudHMiLCJhcmciLCJnZXRUb2tlbkxhcmdlc3RBY2NvdW50cyIsIm1pbnRBZGRyZXNzIiwiZ2V0QWNjb3VudEluZm9BbmRDb250ZXh0IiwiZ2V0UGFyc2VkQWNjb3VudEluZm8iLCJnZXRNdWx0aXBsZVBhcnNlZEFjY291bnRzIiwicHVibGljS2V5cyIsInJhd0NvbmZpZyIsImdldE11bHRpcGxlQWNjb3VudHNJbmZvQW5kQ29udGV4dCIsImdldE11bHRpcGxlQWNjb3VudHNJbmZvIiwiZ2V0U3Rha2VBY3RpdmF0aW9uIiwiZ2V0UHJvZ3JhbUFjY291bnRzIiwiY29uZmlnT3JDb21taXRtZW50IiwiY29uZmlnV2l0aG91dEVuY29kaW5nIiwiYmFzZVNjaGVtYSIsIndpdGhDb250ZXh0IiwiZ2V0UGFyc2VkUHJvZ3JhbUFjY291bnRzIiwic3RyYXRlZ3kiLCJyYXdTaWduYXR1cmUiLCJhYm9ydGVkIiwicmVhc29uIiwiZGVjb2RlZFNpZ25hdHVyZSIsImNvbmZpcm1UcmFuc2FjdGlvblVzaW5nTGVnYWN5VGltZW91dFN0cmF0ZWd5IiwiY29uZmlybVRyYW5zYWN0aW9uVXNpbmdCbG9ja0hlaWdodEV4Y2VlZGFuY2VTdHJhdGVneSIsImNvbmZpcm1UcmFuc2FjdGlvblVzaW5nRHVyYWJsZU5vbmNlU3RyYXRlZ3kiLCJnZXRDYW5jZWxsYXRpb25Qcm9taXNlIiwic2lnbmFsIiwiYWRkRXZlbnRMaXN0ZW5lciIsImdldFRyYW5zYWN0aW9uQ29uZmlybWF0aW9uUHJvbWlzZSIsInNpZ25hdHVyZVN1YnNjcmlwdGlvbklkIiwiZGlzcG9zZVNpZ25hdHVyZVN1YnNjcmlwdGlvblN0YXRlQ2hhbmdlT2JzZXJ2ZXIiLCJkb25lIiwiY29uZmlybWF0aW9uUHJvbWlzZSIsIm9uU2lnbmF0dXJlIiwiX190eXBlIiwiUFJPQ0VTU0VEIiwic3Vic2NyaXB0aW9uU2V0dXBQcm9taXNlIiwicmVzb2x2ZVN1YnNjcmlwdGlvblNldHVwIiwiX29uU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2UiLCJuZXh0U3RhdGUiLCJnZXRTaWduYXR1cmVTdGF0dXMiLCJhYm9ydENvbmZpcm1hdGlvbiIsInJlbW92ZVNpZ25hdHVyZUxpc3RlbmVyIiwiZXhwaXJ5UHJvbWlzZSIsImNoZWNrQmxvY2tIZWlnaHQiLCJfZSIsImN1cnJlbnRCbG9ja0hlaWdodCIsIkJMT0NLSEVJR0hUX0VYQ0VFREVEIiwiY2FuY2VsbGF0aW9uUHJvbWlzZSIsIm91dGNvbWUiLCJyYWNlIiwiY3VycmVudE5vbmNlVmFsdWUiLCJsYXN0Q2hlY2tlZFNsb3QiLCJnZXRDdXJyZW50Tm9uY2VWYWx1ZSIsImdldE5vbmNlQW5kQ29udGV4dCIsIk5PTkNFX0lOVkFMSUQiLCJzbG90SW5XaGljaE5vbmNlRGlkQWR2YW5jZSIsInNpZ25hdHVyZVN0YXR1cyIsImNvbW1pdG1lbnRGb3JTdGF0dXMiLCJ0aW1lb3V0SWQiLCJ0aW1lb3V0TXMiLCJUSU1FRF9PVVQiLCJjbGVhclRpbWVvdXQiLCJnZXRDbHVzdGVyTm9kZXMiLCJnZXRWb3RlQWNjb3VudHMiLCJnZXRTbG90TGVhZGVyIiwiZ2V0U2xvdExlYWRlcnMiLCJzdGFydFNsb3QiLCJsaW1pdCIsImdldFNpZ25hdHVyZVN0YXR1c2VzIiwiZ2V0VHJhbnNhY3Rpb25Db3VudCIsImdldFRvdGFsU3VwcGx5IiwiZXhjbHVkZU5vbkNpcmN1bGF0aW5nQWNjb3VudHNMaXN0IiwiZ2V0SW5mbGF0aW9uR292ZXJub3IiLCJnZXRJbmZsYXRpb25SZXdhcmQiLCJnZXRJbmZsYXRpb25SYXRlIiwiZ2V0RXBvY2hJbmZvIiwiZ2V0RXBvY2hTY2hlZHVsZSIsImVwb2NoU2NoZWR1bGUiLCJnZXRMZWFkZXJTY2hlZHVsZSIsImdldFJlY2VudEJsb2NraGFzaEFuZENvbnRleHQiLCJnZXRMYXRlc3RCbG9ja2hhc2hBbmRDb250ZXh0IiwiZ2V0UmVjZW50UGVyZm9ybWFuY2VTYW1wbGVzIiwiZ2V0RmVlQ2FsY3VsYXRvckZvckJsb2NraGFzaCIsIndpcmVNZXNzYWdlIiwiZ2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzIiwibG9ja2VkV3JpdGFibGVBY2NvdW50cyIsImdldFJlY2VudEJsb2NraGFzaCIsImdldExhdGVzdEJsb2NraGFzaCIsImlzQmxvY2toYXNoVmFsaWQiLCJnZXRWZXJzaW9uIiwiZ2V0R2VuZXNpc0hhc2giLCJnZXRCbG9jayIsIl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkIiwidHJhbnNhY3Rpb25EZXRhaWxzIiwiZ2V0UGFyc2VkQmxvY2siLCJnZXRCbG9ja1Byb2R1Y3Rpb24iLCJleHRyYSIsImMiLCJnZXRQYXJzZWRUcmFuc2FjdGlvbiIsImdldFBhcnNlZFRyYW5zYWN0aW9ucyIsImdldFRyYW5zYWN0aW9ucyIsImdldENvbmZpcm1lZEJsb2NrIiwiYmxvY2siLCJnZXRCbG9ja3MiLCJlbmRTbG90IiwiZ2V0QmxvY2tTaWduYXR1cmVzIiwiZ2V0Q29uZmlybWVkQmxvY2tTaWduYXR1cmVzIiwiZ2V0Q29uZmlybWVkVHJhbnNhY3Rpb24iLCJnZXRQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbiIsImdldFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9ucyIsImdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzIiwiZmlyc3RBdmFpbGFibGVCbG9jayIsInVudGlsIiwiaGlnaGVzdENvbmZpcm1lZFJvb3QiLCJiZWZvcmUiLCJjb25maXJtZWRTaWduYXR1cmVJbmZvIiwiZ2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyIiwiZ2V0U2lnbmF0dXJlc0ZvckFkZHJlc3MiLCJnZXRBZGRyZXNzTG9va3VwVGFibGUiLCJhY2NvdW50SW5mbyIsImdldE5vbmNlIiwicmVxdWVzdEFpcmRyb3AiLCJ0byIsIl9ibG9ja2hhc2hXaXRoRXhwaXJ5QmxvY2tIZWlnaHQiLCJkaXNhYmxlQ2FjaGUiLCJ0aW1lU2luY2VGZXRjaCIsImV4cGlyZWQiLCJfcG9sbE5ld0Jsb2NraGFzaCIsInN0YXJ0VGltZSIsImNhY2hlZExhdGVzdEJsb2NraGFzaCIsImNhY2hlZEJsb2NraGFzaCIsImdldFN0YWtlTWluaW11bURlbGVnYXRpb24iLCJzaW11bGF0ZVRyYW5zYWN0aW9uIiwidHJhbnNhY3Rpb25Pck1lc3NhZ2UiLCJjb25maWdPclNpZ25lcnMiLCJpbmNsdWRlQWNjb3VudHMiLCJ2ZXJzaW9uZWRUeCIsImVuY29kZWRUcmFuc2FjdGlvbiIsIm9yaWdpbmFsVHgiLCJzaWdWZXJpZnkiLCJ0cmFjZUluZGVudCIsImxvZ1RyYWNlIiwic2lnbmVyc09yT3B0aW9ucyIsInNlbmRSYXdUcmFuc2FjdGlvbiIsInJhd1RyYW5zYWN0aW9uIiwic2VuZEVuY29kZWRUcmFuc2FjdGlvbiIsInNldEludGVydmFsIiwiX3VwZGF0ZVN1YnNjcmlwdGlvbnMiLCJjbGVhckludGVydmFsIiwiaGFzaCIsIl9zZXRTdWJzY3JpcHRpb24iLCJuZXh0U3Vic2NyaXB0aW9uIiwicHJldlN0YXRlIiwic3RhdGVDaGFuZ2VDYWxsYmFja3MiLCJjYiIsImNsaWVudFN1YnNjcmlwdGlvbklkIiwiY2xvc2UiLCJjb25uZWN0IiwiYWN0aXZlV2ViU29ja2V0R2VuZXJhdGlvbiIsImlzQ3VycmVudENvbm5lY3Rpb25TdGlsbEFjdGl2ZSIsImNhbGxiYWNrcyIsInNlcnZlclN1YnNjcmlwdGlvbklkIiwidW5zdWJzY3JpYmVNZXRob2QiLCJfaGFuZGxlU2VydmVyTm90aWZpY2F0aW9uIiwiY2FsbGJhY2tBcmdzIiwibm90aWZpY2F0aW9uIiwiX21ha2VTdWJzY3JpcHRpb24iLCJzdWJzY3JpcHRpb25Db25maWciLCJleGlzdGluZ1N1YnNjcmlwdGlvbiIsIm9uQWNjb3VudENoYW5nZSIsInJlbW92ZUFjY291bnRDaGFuZ2VMaXN0ZW5lciIsIl91bnN1YnNjcmliZUNsaWVudFN1YnNjcmlwdGlvbiIsImFjY291bnRJZCIsIm9uUHJvZ3JhbUFjY291bnRDaGFuZ2UiLCJtYXliZUZpbHRlcnMiLCJyZW1vdmVQcm9ncmFtQWNjb3VudENoYW5nZUxpc3RlbmVyIiwib25Mb2dzIiwibWVudGlvbnMiLCJyZW1vdmVPbkxvZ3NMaXN0ZW5lciIsIm9uU2xvdENoYW5nZSIsInJlbW92ZVNsb3RDaGFuZ2VMaXN0ZW5lciIsIm9uU2xvdFVwZGF0ZSIsInJlbW92ZVNsb3RVcGRhdGVMaXN0ZW5lciIsInN1YnNjcmlwdGlvbk5hbWUiLCJkaXNwb3NlIiwib3ZlcnJpZGUiLCJfZXJyIiwib25TaWduYXR1cmVXaXRoT3B0aW9ucyIsIm9uUm9vdENoYW5nZSIsInJlbW92ZVJvb3RDaGFuZ2VMaXN0ZW5lciIsIktleXBhaXIiLCJrZXlwYWlyIiwiX2tleXBhaXIiLCJnZW5lcmF0ZSIsImZyb21TZWNyZXRLZXkiLCJza2lwVmFsaWRhdGlvbiIsImNvbXB1dGVkUHVibGljS2V5IiwiaWkiLCJmcm9tU2VlZCIsIkxPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTIiwiQ3JlYXRlTG9va3VwVGFibGUiLCJGcmVlemVMb29rdXBUYWJsZSIsIkV4dGVuZExvb2t1cFRhYmxlIiwiRGVhY3RpdmF0ZUxvb2t1cFRhYmxlIiwiQ2xvc2VMb29rdXBUYWJsZSIsIkFkZHJlc3NMb29rdXBUYWJsZUluc3RydWN0aW9uIiwibGF5b3V0VHlwZSIsImRlY29kZUNyZWF0ZUxvb2t1cFRhYmxlIiwiY2hlY2tLZXlzTGVuZ3RoIiwicmVjZW50U2xvdCIsImRlY29kZUV4dGVuZExvb2t1cFRhYmxlIiwiZGVjb2RlQ2xvc2VMb29rdXBUYWJsZSIsInJlY2lwaWVudCIsImRlY29kZUZyZWV6ZUxvb2t1cFRhYmxlIiwiZGVjb2RlRGVhY3RpdmF0ZUxvb2t1cFRhYmxlIiwiQWRkcmVzc0xvb2t1cFRhYmxlUHJvZ3JhbSIsImNyZWF0ZUxvb2t1cFRhYmxlIiwibG9va3VwVGFibGVBZGRyZXNzIiwiYnVtcFNlZWQiLCJmcmVlemVMb29rdXBUYWJsZSIsImV4dGVuZExvb2t1cFRhYmxlIiwiYWRkciIsImRlYWN0aXZhdGVMb29rdXBUYWJsZSIsImNsb3NlTG9va3VwVGFibGUiLCJDb21wdXRlQnVkZ2V0SW5zdHJ1Y3Rpb24iLCJDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTIiwiZGVjb2RlUmVxdWVzdFVuaXRzIiwidW5pdHMiLCJhZGRpdGlvbmFsRmVlIiwiUmVxdWVzdFVuaXRzIiwiZGVjb2RlUmVxdWVzdEhlYXBGcmFtZSIsIlJlcXVlc3RIZWFwRnJhbWUiLCJkZWNvZGVTZXRDb21wdXRlVW5pdExpbWl0IiwiU2V0Q29tcHV0ZVVuaXRMaW1pdCIsImRlY29kZVNldENvbXB1dGVVbml0UHJpY2UiLCJtaWNyb0xhbXBvcnRzIiwiU2V0Q29tcHV0ZVVuaXRQcmljZSIsIkNvbXB1dGVCdWRnZXRQcm9ncmFtIiwicmVxdWVzdFVuaXRzIiwicmVxdWVzdEhlYXBGcmFtZSIsInNldENvbXB1dGVVbml0TGltaXQiLCJzZXRDb21wdXRlVW5pdFByaWNlIiwiUFJJVkFURV9LRVlfQllURVMkMSIsIlBVQkxJQ19LRVlfQllURVMkMSIsIlNJR05BVFVSRV9CWVRFUyIsIkVEMjU1MTlfSU5TVFJVQ1RJT05fTEFZT1VUIiwidTE2IiwiRWQyNTUxOVByb2dyYW0iLCJjcmVhdGVJbnN0cnVjdGlvbldpdGhQdWJsaWNLZXkiLCJpbnN0cnVjdGlvbkluZGV4IiwicHVibGljS2V5T2Zmc2V0Iiwic2lnbmF0dXJlT2Zmc2V0IiwibWVzc2FnZURhdGFPZmZzZXQiLCJudW1TaWduYXR1cmVzIiwicGFkZGluZyIsInNpZ25hdHVyZUluc3RydWN0aW9uSW5kZXgiLCJwdWJsaWNLZXlJbnN0cnVjdGlvbkluZGV4IiwibWVzc2FnZURhdGFTaXplIiwibWVzc2FnZUluc3RydWN0aW9uSW5kZXgiLCJjcmVhdGVJbnN0cnVjdGlvbldpdGhQcml2YXRlS2V5IiwicHJpdmF0ZUtleSIsImVjZHNhU2lnbiIsIm1zZ0hhc2giLCJwcml2S2V5IiwidG9Db21wYWN0UmF3Qnl0ZXMiLCJyZWNvdmVyeSIsImlzVmFsaWRQcml2YXRlS2V5IiwicHVibGljS2V5Q3JlYXRlIiwiUFJJVkFURV9LRVlfQllURVMiLCJFVEhFUkVVTV9BRERSRVNTX0JZVEVTIiwiUFVCTElDX0tFWV9CWVRFUyIsIlNJR05BVFVSRV9PRkZTRVRTX1NFUklBTElaRURfU0laRSIsIlNFQ1AyNTZLMV9JTlNUUlVDVElPTl9MQVlPVVQiLCJTZWNwMjU2azFQcm9ncmFtIiwicHVibGljS2V5VG9FdGhBZGRyZXNzIiwicmVjb3ZlcnlJZCIsImNyZWF0ZUluc3RydWN0aW9uV2l0aEV0aEFkZHJlc3MiLCJldGhBZGRyZXNzIiwicmF3QWRkcmVzcyIsInN1YnN0ciIsImRhdGFTdGFydCIsImV0aEFkZHJlc3NPZmZzZXQiLCJldGhBZGRyZXNzSW5zdHJ1Y3Rpb25JbmRleCIsInBrZXkiLCJtZXNzYWdlSGFzaCIsIl9Mb2NrdXAiLCJTVEFLRV9DT05GSUdfSUQiLCJBdXRob3JpemVkIiwic3Rha2VyIiwid2l0aGRyYXdlciIsIkxvY2t1cCIsInVuaXhUaW1lc3RhbXAiLCJjdXN0b2RpYW4iLCJTdGFrZUluc3RydWN0aW9uIiwiU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUyIsImRlY29kZUluaXRpYWxpemUiLCJJbml0aWFsaXplIiwic3Rha2VQdWJrZXkiLCJkZWNvZGVEZWxlZ2F0ZSIsIkRlbGVnYXRlIiwiZGVjb2RlQXV0aG9yaXplIiwibmV3QXV0aG9yaXplZCIsInN0YWtlQXV0aG9yaXphdGlvblR5cGUiLCJBdXRob3JpemUiLCJvIiwiY3VzdG9kaWFuUHVia2V5IiwiZGVjb2RlQXV0aG9yaXplV2l0aFNlZWQiLCJhdXRob3JpdHlTZWVkIiwiYXV0aG9yaXR5T3duZXIiLCJBdXRob3JpemVXaXRoU2VlZCIsImF1dGhvcml0eUJhc2UiLCJkZWNvZGVTcGxpdCIsIlNwbGl0Iiwic3BsaXRTdGFrZVB1YmtleSIsImRlY29kZU1lcmdlIiwiTWVyZ2UiLCJzb3VyY2VTdGFrZVB1YktleSIsImRlY29kZVdpdGhkcmF3IiwiV2l0aGRyYXciLCJkZWNvZGVEZWFjdGl2YXRlIiwiRGVhY3RpdmF0ZSIsIlN0YWtlUHJvZ3JhbSIsIlN0YWtlQXV0aG9yaXphdGlvbkxheW91dCIsIlN0YWtlciIsIldpdGhkcmF3ZXIiLCJpbml0aWFsaXplIiwibWF5YmVMb2NrdXAiLCJkZWxlZ2F0ZSIsImF1dGhvcml6ZSIsImF1dGhvcml6ZVdpdGhTZWVkIiwic3BsaXRJbnN0cnVjdGlvbiIsInJlbnRFeGVtcHRSZXNlcnZlIiwic3BsaXRXaXRoU2VlZCIsIm1lcmdlIiwid2l0aGRyYXciLCJkZWFjdGl2YXRlIiwiVm90ZUluaXQiLCJhdXRob3JpemVkVm90ZXIiLCJhdXRob3JpemVkV2l0aGRyYXdlciIsIlZvdGVJbnN0cnVjdGlvbiIsIlZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUyIsImRlY29kZUluaXRpYWxpemVBY2NvdW50IiwiSW5pdGlhbGl6ZUFjY291bnQiLCJ2b3RlQXV0aG9yaXphdGlvblR5cGUiLCJjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5IiwiY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkIiwiY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlCYXNlUHVia2V5IiwiYXV0aG9yaXplZFdpdGhkcmF3ZXJQdWJrZXkiLCJWb3RlUHJvZ3JhbSIsIlVwZGF0ZVZhbGlkYXRvcklkZW50aXR5IiwiVm90ZUF1dGhvcml6YXRpb25MYXlvdXQiLCJWb3RlciIsImluaXRpYWxpemVBY2NvdW50Iiwic2FmZVdpdGhkcmF3IiwiY3VycmVudFZvdGVBY2NvdW50QmFsYW5jZSIsInJlbnRFeGVtcHRNaW5pbXVtIiwidXBkYXRlVmFsaWRhdG9ySWRlbnRpdHkiLCJWQUxJREFUT1JfSU5GT19LRVkiLCJJbmZvU3RyaW5nIiwid2Vic2l0ZSIsImRldGFpbHMiLCJpY29uVXJsIiwia2V5YmFzZVVzZXJuYW1lIiwiVmFsaWRhdG9ySW5mbyIsImZyb21Db25maWdEYXRhIiwiY29uZmlnS2V5Q291bnQiLCJjb25maWdLZXlzIiwicmF3SW5mbyIsIlZPVEVfUFJPR1JBTV9JRCIsIlZvdGVBY2NvdW50TGF5b3V0IiwiVm90ZUFjY291bnQiLCJ2b3RlcyIsImF1dGhvcml6ZWRWb3RlcnMiLCJwcmlvclZvdGVycyIsImxhc3RUaW1lc3RhbXAiLCJ2ZXJzaW9uT2Zmc2V0IiwidmEiLCJyb290U2xvdFZhbGlkIiwicGFyc2VBdXRob3JpemVkVm90ZXIiLCJnZXRQcmlvclZvdGVycyIsInBhcnNlUHJpb3JWb3RlcnMiLCJlcG9jaE9mTGFzdEF1dGhvcml6ZWRTd2l0Y2giLCJ0YXJnZXRFcG9jaCIsImlkeCIsImlzRW1wdHkiLCJodHRwIiwiZGV2bmV0IiwidGVzdG5ldCIsImh0dHBzIiwiY2x1c3RlckFwaVVybCIsImNsdXN0ZXIiLCJ0bHMiLCJzZW5kQW5kQ29uZmlybVJhd1RyYW5zYWN0aW9uIiwiY29uZmlybWF0aW9uU3RyYXRlZ3lPckNvbmZpcm1PcHRpb25zIiwibWF5YmVDb25maXJtT3B0aW9ucyIsImNvbmZpcm1hdGlvblN0cmF0ZWd5IiwiTEFNUE9SVFNfUEVSX1NPTCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/node_modules/@solana/web3.js/lib/index.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/node_modules/base-x/src/index.js":
/*!**************************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/node_modules/base-x/src/index.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n// @ts-ignore\nvar _Buffer = (__webpack_require__(/*! safe-buffer */ \"(ssr)/../node_modules/safe-buffer/index.js\").Buffer);\nfunction base(ALPHABET) {\n    if (ALPHABET.length >= 255) {\n        throw new TypeError(\"Alphabet too long\");\n    }\n    var BASE_MAP = new Uint8Array(256);\n    for(var j = 0; j < BASE_MAP.length; j++){\n        BASE_MAP[j] = 255;\n    }\n    for(var i = 0; i < ALPHABET.length; i++){\n        var x = ALPHABET.charAt(i);\n        var xc = x.charCodeAt(0);\n        if (BASE_MAP[xc] !== 255) {\n            throw new TypeError(x + \" is ambiguous\");\n        }\n        BASE_MAP[xc] = i;\n    }\n    var BASE = ALPHABET.length;\n    var LEADER = ALPHABET.charAt(0);\n    var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n    ;\n    var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n    ;\n    function encode(source) {\n        if (Array.isArray(source) || source instanceof Uint8Array) {\n            source = _Buffer.from(source);\n        }\n        if (!_Buffer.isBuffer(source)) {\n            throw new TypeError(\"Expected Buffer\");\n        }\n        if (source.length === 0) {\n            return \"\";\n        }\n        // Skip & count leading zeroes.\n        var zeroes = 0;\n        var length = 0;\n        var pbegin = 0;\n        var pend = source.length;\n        while(pbegin !== pend && source[pbegin] === 0){\n            pbegin++;\n            zeroes++;\n        }\n        // Allocate enough space in big-endian base58 representation.\n        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;\n        var b58 = new Uint8Array(size);\n        // Process the bytes.\n        while(pbegin !== pend){\n            var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n            var i = 0;\n            for(var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++){\n                carry += 256 * b58[it1] >>> 0;\n                b58[it1] = carry % BASE >>> 0;\n                carry = carry / BASE >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error(\"Non-zero carry\");\n            }\n            length = i;\n            pbegin++;\n        }\n        // Skip leading zeroes in base58 result.\n        var it2 = size - length;\n        while(it2 !== size && b58[it2] === 0){\n            it2++;\n        }\n        // Translate the result into a string.\n        var str = LEADER.repeat(zeroes);\n        for(; it2 < size; ++it2){\n            str += ALPHABET.charAt(b58[it2]);\n        }\n        return str;\n    }\n    function decodeUnsafe(source) {\n        if (typeof source !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n        if (source.length === 0) {\n            return _Buffer.alloc(0);\n        }\n        var psz = 0;\n        // Skip and count leading '1's.\n        var zeroes = 0;\n        var length = 0;\n        while(source[psz] === LEADER){\n            zeroes++;\n            psz++;\n        }\n        // Allocate enough space in big-endian base256 representation.\n        var size = (source.length - psz) * FACTOR + 1 >>> 0 // log(58) / log(256), rounded up.\n        ;\n        var b256 = new Uint8Array(size);\n        // Process the characters.\n        while(psz < source.length){\n            // Find code of next character\n            var charCode = source.charCodeAt(psz);\n            // Base map can not be indexed using char code\n            if (charCode > 255) {\n                return;\n            }\n            // Decode character\n            var carry = BASE_MAP[charCode];\n            // Invalid character\n            if (carry === 255) {\n                return;\n            }\n            var i = 0;\n            for(var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++){\n                carry += BASE * b256[it3] >>> 0;\n                b256[it3] = carry % 256 >>> 0;\n                carry = carry / 256 >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error(\"Non-zero carry\");\n            }\n            length = i;\n            psz++;\n        }\n        // Skip leading zeroes in b256.\n        var it4 = size - length;\n        while(it4 !== size && b256[it4] === 0){\n            it4++;\n        }\n        var vch = _Buffer.allocUnsafe(zeroes + (size - it4));\n        vch.fill(0x00, 0, zeroes);\n        var j = zeroes;\n        while(it4 !== size){\n            vch[j++] = b256[it4++];\n        }\n        return vch;\n    }\n    function decode(string) {\n        var buffer = decodeUnsafe(string);\n        if (buffer) {\n            return buffer;\n        }\n        throw new Error(\"Non-base\" + BASE + \" character\");\n    }\n    return {\n        encode: encode,\n        decodeUnsafe: decodeUnsafe,\n        decode: decode\n    };\n}\nmodule.exports = base;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL25vZGVfbW9kdWxlcy9iYXNlLXgvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsNkJBQTZCO0FBQzdCLHlDQUF5QztBQUN6QyxtRUFBbUU7QUFDbkUsbUVBQW1FO0FBQ25FLHNFQUFzRTtBQUN0RSxhQUFhO0FBQ2IsSUFBSUEsVUFBVUMsNkZBQTZCO0FBQzNDLFNBQVNFLEtBQU1DLFFBQVE7SUFDckIsSUFBSUEsU0FBU0MsTUFBTSxJQUFJLEtBQUs7UUFBRSxNQUFNLElBQUlDLFVBQVU7SUFBcUI7SUFDdkUsSUFBSUMsV0FBVyxJQUFJQyxXQUFXO0lBQzlCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRixTQUFTRixNQUFNLEVBQUVJLElBQUs7UUFDeENGLFFBQVEsQ0FBQ0UsRUFBRSxHQUFHO0lBQ2hCO0lBQ0EsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlOLFNBQVNDLE1BQU0sRUFBRUssSUFBSztRQUN4QyxJQUFJQyxJQUFJUCxTQUFTUSxNQUFNLENBQUNGO1FBQ3hCLElBQUlHLEtBQUtGLEVBQUVHLFVBQVUsQ0FBQztRQUN0QixJQUFJUCxRQUFRLENBQUNNLEdBQUcsS0FBSyxLQUFLO1lBQUUsTUFBTSxJQUFJUCxVQUFVSyxJQUFJO1FBQWlCO1FBQ3JFSixRQUFRLENBQUNNLEdBQUcsR0FBR0g7SUFDakI7SUFDQSxJQUFJSyxPQUFPWCxTQUFTQyxNQUFNO0lBQzFCLElBQUlXLFNBQVNaLFNBQVNRLE1BQU0sQ0FBQztJQUM3QixJQUFJSyxTQUFTQyxLQUFLQyxHQUFHLENBQUNKLFFBQVFHLEtBQUtDLEdBQUcsQ0FBQyxLQUFLLG1DQUFtQzs7SUFDL0UsSUFBSUMsVUFBVUYsS0FBS0MsR0FBRyxDQUFDLE9BQU9ELEtBQUtDLEdBQUcsQ0FBQ0osTUFBTSxtQ0FBbUM7O0lBQ2hGLFNBQVNNLE9BQVFDLE1BQU07UUFDckIsSUFBSUMsTUFBTUMsT0FBTyxDQUFDRixXQUFX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QUFPakMsSUFBSztnQkFDaEZzQixTQUFTLE9BQVFTLElBQUksQ0FBQ0UsSUFBSSxLQUFNO2dCQUNoQ0YsSUFBSSxDQUFDRSxJQUFJLEdBQUcsUUFBUyxRQUFTO2dCQUM5QlgsUUFBUSxRQUFTLFFBQVM7WUFDNUI7WUFDQSxJQUFJQSxVQUFVLEdBQUc7Z0JBQUUsTUFBTSxJQUFJRSxNQUFNO1lBQWtCO1lBQ3JEN0IsU0FBU0s7WUFDVDhCO1FBQ0Y7UUFDSSwrQkFBK0I7UUFDbkMsSUFBSUksTUFBTWQsT0FBT3pCO1FBQ2pCLE1BQU91QyxRQUFRZCxRQUFRVyxJQUFJLENBQUNHLElBQUksS0FBSyxFQUFHO1lBQ3RDQTtRQUNGO1FBQ0EsSUFBSUMsTUFBTTdDLFFBQVE4QyxXQUFXLENBQUNuQixTQUFVRyxDQUFBQSxPQUFPYyxHQUFFO1FBQ2pEQyxJQUFJRSxJQUFJLENBQUMsTUFBTSxHQUFHcEI7UUFDbEIsSUFBSWxCLElBQUlrQjtRQUNSLE1BQU9pQixRQUFRZCxLQUFNO1lBQ25CZSxHQUFHLENBQUNwQyxJQUFJLEdBQUdnQyxJQUFJLENBQUNHLE1BQU07UUFDeEI7UUFDQSxPQUFPQztJQUNUO0lBQ0EsU0FBU0csT0FBUUMsTUFBTTtRQUNyQixJQUFJQyxTQUFTWixhQUFhVztRQUMxQixJQUFJQyxRQUFRO1lBQUUsT0FBT0E7UUFBTztRQUM1QixNQUFNLElBQUloQixNQUFNLGFBQWFuQixPQUFPO0lBQ3RDO0lBQ0EsT0FBTztRQUNMTSxRQUFRQTtRQUNSaUIsY0FBY0E7UUFDZFUsUUFBUUE7SUFDVjtBQUNGO0FBQ0FHLE9BQU9DLE9BQU8sR0FBR2pEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AY29yYWwteHl6L2FuY2hvci9ub2RlX21vZHVsZXMvYmFzZS14L3NyYy9pbmRleC5qcz9iMTg4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuLy8gYmFzZS14IGVuY29kaW5nIC8gZGVjb2Rpbmdcbi8vIENvcHlyaWdodCAoYykgMjAxOCBiYXNlLXggY29udHJpYnV0b3JzXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxOCBUaGUgQml0Y29pbiBDb3JlIGRldmVsb3BlcnMgKGJhc2U1OC5jcHApXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIHNvZnR3YXJlIGxpY2Vuc2UsIHNlZSB0aGUgYWNjb21wYW55aW5nXG4vLyBmaWxlIExJQ0VOU0Ugb3IgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAuXG4vLyBAdHMtaWdub3JlXG52YXIgX0J1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5mdW5jdGlvbiBiYXNlIChBTFBIQUJFVCkge1xuICBpZiAoQUxQSEFCRVQubGVuZ3RoID49IDI1NSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHBoYWJldCB0b28gbG9uZycpIH1cbiAgdmFyIEJBU0VfTUFQID0gbmV3IFVpbnQ4QXJyYXkoMjU2KVxuICBmb3IgKHZhciBqID0gMDsgaiA8IEJBU0VfTUFQLmxlbmd0aDsgaisrKSB7XG4gICAgQkFTRV9NQVBbal0gPSAyNTVcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IEFMUEhBQkVULmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHggPSBBTFBIQUJFVC5jaGFyQXQoaSlcbiAgICB2YXIgeGMgPSB4LmNoYXJDb2RlQXQoMClcbiAgICBpZiAoQkFTRV9NQVBbeGNdICE9PSAyNTUpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcih4ICsgJyBpcyBhbWJpZ3VvdXMnKSB9XG4gICAgQkFTRV9NQVBbeGNdID0gaVxuICB9XG4gIHZhciBCQVNFID0gQUxQSEFCRVQubGVuZ3RoXG4gIHZhciBMRUFERVIgPSBBTFBIQUJFVC5jaGFyQXQoMClcbiAgdmFyIEZBQ1RPUiA9IE1hdGgubG9nKEJBU0UpIC8gTWF0aC5sb2coMjU2KSAvLyBsb2coQkFTRSkgLyBsb2coMjU2KSwgcm91bmRlZCB1cFxuICB2YXIgaUZBQ1RPUiA9IE1hdGgubG9nKDI1NikgLyBNYXRoLmxvZyhCQVNFKSAvLyBsb2coMjU2KSAvIGxvZyhCQVNFKSwgcm91bmRlZCB1cFxuICBmdW5jdGlvbiBlbmNvZGUgKHNvdXJjZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkgfHwgc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSkgeyBzb3VyY2UgPSBfQnVmZmVyLmZyb20oc291cmNlKSB9XG4gICAgaWYgKCFfQnVmZmVyLmlzQnVmZmVyKHNvdXJjZSkpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgQnVmZmVyJykgfVxuICAgIGlmIChzb3VyY2UubGVuZ3RoID09PSAwKSB7IHJldHVybiAnJyB9XG4gICAgICAgIC8vIFNraXAgJiBjb3VudCBsZWFkaW5nIHplcm9lcy5cbiAgICB2YXIgemVyb2VzID0gMFxuICAgIHZhciBsZW5ndGggPSAwXG4gICAgdmFyIHBiZWdpbiA9IDBcbiAgICB2YXIgcGVuZCA9IHNvdXJjZS5sZW5ndGhcbiAgICB3aGlsZSAocGJlZ2luICE9PSBwZW5kICYmIHNvdXJjZVtwYmVnaW5dID09PSAwKSB7XG4gICAgICBwYmVnaW4rK1xuICAgICAgemVyb2VzKytcbiAgICB9XG4gICAgICAgIC8vIEFsbG9jYXRlIGVub3VnaCBzcGFjZSBpbiBiaWctZW5kaWFuIGJhc2U1OCByZXByZXNlbnRhdGlvbi5cbiAgICB2YXIgc2l6ZSA9ICgocGVuZCAtIHBiZWdpbikgKiBpRkFDVE9SICsgMSkgPj4+IDBcbiAgICB2YXIgYjU4ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSlcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgYnl0ZXMuXG4gICAgd2hpbGUgKHBiZWdpbiAhPT0gcGVuZCkge1xuICAgICAgdmFyIGNhcnJ5ID0gc291cmNlW3BiZWdpbl1cbiAgICAgICAgICAgIC8vIEFwcGx5IFwiYjU4ID0gYjU4ICogMjU2ICsgY2hcIi5cbiAgICAgIHZhciBpID0gMFxuICAgICAgZm9yICh2YXIgaXQxID0gc2l6ZSAtIDE7IChjYXJyeSAhPT0gMCB8fCBpIDwgbGVuZ3RoKSAmJiAoaXQxICE9PSAtMSk7IGl0MS0tLCBpKyspIHtcbiAgICAgICAgY2FycnkgKz0gKDI1NiAqIGI1OFtpdDFdKSA+Pj4gMFxuICAgICAgICBiNThbaXQxXSA9IChjYXJyeSAlIEJBU0UpID4+PiAwXG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gQkFTRSkgPj4+IDBcbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoJ05vbi16ZXJvIGNhcnJ5JykgfVxuICAgICAgbGVuZ3RoID0gaVxuICAgICAgcGJlZ2luKytcbiAgICB9XG4gICAgICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXMgaW4gYmFzZTU4IHJlc3VsdC5cbiAgICB2YXIgaXQyID0gc2l6ZSAtIGxlbmd0aFxuICAgIHdoaWxlIChpdDIgIT09IHNpemUgJiYgYjU4W2l0Ml0gPT09IDApIHtcbiAgICAgIGl0MisrXG4gICAgfVxuICAgICAgICAvLyBUcmFuc2xhdGUgdGhlIHJlc3VsdCBpbnRvIGEgc3RyaW5nLlxuICAgIHZhciBzdHIgPSBMRUFERVIucmVwZWF0KHplcm9lcylcbiAgICBmb3IgKDsgaXQyIDwgc2l6ZTsgKytpdDIpIHsgc3RyICs9IEFMUEhBQkVULmNoYXJBdChiNThbaXQyXSkgfVxuICAgIHJldHVybiBzdHJcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGVVbnNhZmUgKHNvdXJjZSkge1xuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnc3RyaW5nJykgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBTdHJpbmcnKSB9XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHsgcmV0dXJuIF9CdWZmZXIuYWxsb2MoMCkgfVxuICAgIHZhciBwc3ogPSAwXG4gICAgICAgIC8vIFNraXAgYW5kIGNvdW50IGxlYWRpbmcgJzEncy5cbiAgICB2YXIgemVyb2VzID0gMFxuICAgIHZhciBsZW5ndGggPSAwXG4gICAgd2hpbGUgKHNvdXJjZVtwc3pdID09PSBMRUFERVIpIHtcbiAgICAgIHplcm9lcysrXG4gICAgICBwc3orK1xuICAgIH1cbiAgICAgICAgLy8gQWxsb2NhdGUgZW5vdWdoIHNwYWNlIGluIGJpZy1lbmRpYW4gYmFzZTI1NiByZXByZXNlbnRhdGlvbi5cbiAgICB2YXIgc2l6ZSA9ICgoKHNvdXJjZS5sZW5ndGggLSBwc3opICogRkFDVE9SKSArIDEpID4+PiAwIC8vIGxvZyg1OCkgLyBsb2coMjU2KSwgcm91bmRlZCB1cC5cbiAgICB2YXIgYjI1NiA9IG5ldyBVaW50OEFycmF5KHNpemUpXG4gICAgICAgIC8vIFByb2Nlc3MgdGhlIGNoYXJhY3RlcnMuXG4gICAgd2hpbGUgKHBzeiA8IHNvdXJjZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIEZpbmQgY29kZSBvZiBuZXh0IGNoYXJhY3RlclxuICAgICAgdmFyIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocHN6KVxuICAgICAgICAgICAgLy8gQmFzZSBtYXAgY2FuIG5vdCBiZSBpbmRleGVkIHVzaW5nIGNoYXIgY29kZVxuICAgICAgaWYgKGNoYXJDb2RlID4gMjU1KSB7IHJldHVybiB9XG4gICAgICAgICAgICAvLyBEZWNvZGUgY2hhcmFjdGVyXG4gICAgICB2YXIgY2FycnkgPSBCQVNFX01BUFtjaGFyQ29kZV1cbiAgICAgICAgICAgIC8vIEludmFsaWQgY2hhcmFjdGVyXG4gICAgICBpZiAoY2FycnkgPT09IDI1NSkgeyByZXR1cm4gfVxuICAgICAgdmFyIGkgPSAwXG4gICAgICBmb3IgKHZhciBpdDMgPSBzaXplIC0gMTsgKGNhcnJ5ICE9PSAwIHx8IGkgPCBsZW5ndGgpICYmIChpdDMgIT09IC0xKTsgaXQzLS0sIGkrKykge1xuICAgICAgICBjYXJyeSArPSAoQkFTRSAqIGIyNTZbaXQzXSkgPj4+IDBcbiAgICAgICAgYjI1NltpdDNdID0gKGNhcnJ5ICUgMjU2KSA+Pj4gMFxuICAgICAgICBjYXJyeSA9IChjYXJyeSAvIDI1NikgPj4+IDBcbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoJ05vbi16ZXJvIGNhcnJ5JykgfVxuICAgICAgbGVuZ3RoID0gaVxuICAgICAgcHN6KytcbiAgICB9XG4gICAgICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXMgaW4gYjI1Ni5cbiAgICB2YXIgaXQ0ID0gc2l6ZSAtIGxlbmd0aFxuICAgIHdoaWxlIChpdDQgIT09IHNpemUgJiYgYjI1NltpdDRdID09PSAwKSB7XG4gICAgICBpdDQrK1xuICAgIH1cbiAgICB2YXIgdmNoID0gX0J1ZmZlci5hbGxvY1Vuc2FmZSh6ZXJvZXMgKyAoc2l6ZSAtIGl0NCkpXG4gICAgdmNoLmZpbGwoMHgwMCwgMCwgemVyb2VzKVxuICAgIHZhciBqID0gemVyb2VzXG4gICAgd2hpbGUgKGl0NCAhPT0gc2l6ZSkge1xuICAgICAgdmNoW2orK10gPSBiMjU2W2l0NCsrXVxuICAgIH1cbiAgICByZXR1cm4gdmNoXG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlIChzdHJpbmcpIHtcbiAgICB2YXIgYnVmZmVyID0gZGVjb2RlVW5zYWZlKHN0cmluZylcbiAgICBpZiAoYnVmZmVyKSB7IHJldHVybiBidWZmZXIgfVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uLWJhc2UnICsgQkFTRSArICcgY2hhcmFjdGVyJylcbiAgfVxuICByZXR1cm4ge1xuICAgIGVuY29kZTogZW5jb2RlLFxuICAgIGRlY29kZVVuc2FmZTogZGVjb2RlVW5zYWZlLFxuICAgIGRlY29kZTogZGVjb2RlXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gYmFzZVxuIl0sIm5hbWVzIjpbIl9CdWZmZXIiLCJyZXF1aXJlIiwiQnVmZmVyIiwiYmFzZSIsIkFMUEhBQkVUIiwibGVuZ3RoIiwiVHlwZUVycm9yIiwiQkFTRV9NQVAiLCJVaW50OEFycmF5IiwiaiIsImkiLCJ4IiwiY2hhckF0IiwieGMiLCJjaGFyQ29kZUF0IiwiQkFTRSIsIkxFQURFUiIsIkZBQ1RPUiIsIk1hdGgiLCJsb2ciLCJpRkFDVE9SIiwiZW5jb2RlIiwic291cmNlIiwiQXJyYXkiLCJpc0FycmF5IiwiZnJvbSIsImlzQnVmZmVyIiwiemVyb2VzIiwicGJlZ2luIiwicGVuZCIsInNpemUiLCJiNTgiLCJjYXJyeSIsIml0MSIsIkVycm9yIiwiaXQyIiwic3RyIiwicmVwZWF0IiwiZGVjb2RlVW5zYWZlIiwiYWxsb2MiLCJwc3oiLCJiMjU2IiwiY2hhckNvZGUiLCJpdDMiLCJpdDQiLCJ2Y2giLCJhbGxvY1Vuc2FmZSIsImZpbGwiLCJkZWNvZGUiLCJzdHJpbmciLCJidWZmZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/node_modules/base-x/src/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/node_modules/bs58/index.js":
/*!********************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/node_modules/bs58/index.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var basex = __webpack_require__(/*! base-x */ \"(ssr)/../node_modules/@coral-xyz/anchor/node_modules/base-x/src/index.js\");\nvar ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nmodule.exports = basex(ALPHABET);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL25vZGVfbW9kdWxlcy9iczU4L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLElBQUlBLFFBQVFDLG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlDLFdBQVc7QUFFZkMsT0FBT0MsT0FBTyxHQUFHSixNQUFNRSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGNvcmFsLXh5ei9hbmNob3Ivbm9kZV9tb2R1bGVzL2JzNTgvaW5kZXguanM/MGY3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYmFzZXggPSByZXF1aXJlKCdiYXNlLXgnKVxudmFyIEFMUEhBQkVUID0gJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonXG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZXgoQUxQSEFCRVQpXG4iXSwibmFtZXMiOlsiYmFzZXgiLCJyZXF1aXJlIiwiQUxQSEFCRVQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/node_modules/bs58/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/node_modules/rpc-websockets/node_modules/eventemitter3/index.js":
/*!*********************************************************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/node_modules/rpc-websockets/node_modules/eventemitter3/index.js ***!
  \*********************************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\nvar has = Object.prototype.hasOwnProperty, prefix = \"~\";\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */ function Events() {}\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n    Events.prototype = Object.create(null);\n    //\n    // This hack is needed because the `__proto__` property is still inherited in\n    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n    //\n    if (!new Events().__proto__) prefix = false;\n}\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */ function EE(fn, context, once) {\n    this.fn = fn;\n    this.context = context;\n    this.once = once || false;\n}\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */ function addListener(emitter, event, fn, context, once) {\n    if (typeof fn !== \"function\") {\n        throw new TypeError(\"The listener must be a function\");\n    }\n    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;\n    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n    else emitter._events[evt] = [\n        emitter._events[evt],\n        listener\n    ];\n    return emitter;\n}\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */ function clearEvent(emitter, evt) {\n    if (--emitter._eventsCount === 0) emitter._events = new Events();\n    else delete emitter._events[evt];\n}\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */ function EventEmitter() {\n    this._events = new Events();\n    this._eventsCount = 0;\n}\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */ EventEmitter.prototype.eventNames = function eventNames() {\n    var names = [], events, name;\n    if (this._eventsCount === 0) return names;\n    for(name in events = this._events){\n        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n    }\n    if (Object.getOwnPropertySymbols) {\n        return names.concat(Object.getOwnPropertySymbols(events));\n    }\n    return names;\n};\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */ EventEmitter.prototype.listeners = function listeners(event) {\n    var evt = prefix ? prefix + event : event, handlers = this._events[evt];\n    if (!handlers) return [];\n    if (handlers.fn) return [\n        handlers.fn\n    ];\n    for(var i = 0, l = handlers.length, ee = new Array(l); i < l; i++){\n        ee[i] = handlers[i].fn;\n    }\n    return ee;\n};\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */ EventEmitter.prototype.listenerCount = function listenerCount(event) {\n    var evt = prefix ? prefix + event : event, listeners = this._events[evt];\n    if (!listeners) return 0;\n    if (listeners.fn) return 1;\n    return listeners.length;\n};\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */ EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n    var evt = prefix ? prefix + event : event;\n    if (!this._events[evt]) return false;\n    var listeners = this._events[evt], len = arguments.length, args, i;\n    if (listeners.fn) {\n        if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n        switch(len){\n            case 1:\n                return listeners.fn.call(listeners.context), true;\n            case 2:\n                return listeners.fn.call(listeners.context, a1), true;\n            case 3:\n                return listeners.fn.call(listeners.context, a1, a2), true;\n            case 4:\n                return listeners.fn.call(listeners.context, a1, a2, a3), true;\n            case 5:\n                return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n            case 6:\n                return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n        }\n        for(i = 1, args = new Array(len - 1); i < len; i++){\n            args[i - 1] = arguments[i];\n        }\n        listeners.fn.apply(listeners.context, args);\n    } else {\n        var length = listeners.length, j;\n        for(i = 0; i < length; i++){\n            if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n            switch(len){\n                case 1:\n                    listeners[i].fn.call(listeners[i].context);\n                    break;\n                case 2:\n                    listeners[i].fn.call(listeners[i].context, a1);\n                    break;\n                case 3:\n                    listeners[i].fn.call(listeners[i].context, a1, a2);\n                    break;\n                case 4:\n                    listeners[i].fn.call(listeners[i].context, a1, a2, a3);\n                    break;\n                default:\n                    if (!args) for(j = 1, args = new Array(len - 1); j < len; j++){\n                        args[j - 1] = arguments[j];\n                    }\n                    listeners[i].fn.apply(listeners[i].context, args);\n            }\n        }\n    }\n    return true;\n};\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */ EventEmitter.prototype.on = function on(event, fn, context) {\n    return addListener(this, event, fn, context, false);\n};\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */ EventEmitter.prototype.once = function once(event, fn, context) {\n    return addListener(this, event, fn, context, true);\n};\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */ EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n    var evt = prefix ? prefix + event : event;\n    if (!this._events[evt]) return this;\n    if (!fn) {\n        clearEvent(this, evt);\n        return this;\n    }\n    var listeners = this._events[evt];\n    if (listeners.fn) {\n        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {\n            clearEvent(this, evt);\n        }\n    } else {\n        for(var i = 0, events = [], length = listeners.length; i < length; i++){\n            if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {\n                events.push(listeners[i]);\n            }\n        }\n        //\n        // Reset the array, or remove it completely if we have no more listeners.\n        //\n        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n        else clearEvent(this, evt);\n    }\n    return this;\n};\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */ EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n    var evt;\n    if (event) {\n        evt = prefix ? prefix + event : event;\n        if (this._events[evt]) clearEvent(this, evt);\n    } else {\n        this._events = new Events();\n        this._eventsCount = 0;\n    }\n    return this;\n};\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n//\n// Expose the module.\n//\nif (true) {\n    module.exports = EventEmitter;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL25vZGVfbW9kdWxlcy9ycGMtd2Vic29ja2V0cy9ub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLElBQUlBLE1BQU1DLE9BQU9DLFNBQVMsQ0FBQ0MsY0FBYyxFQUNyQ0MsU0FBUztBQUViOzs7Ozs7Q0FNQyxHQUNELFNBQVNDLFVBQVU7QUFFbkIsRUFBRTtBQUNGLDZFQUE2RTtBQUM3RSw4RUFBOEU7QUFDOUUsNkVBQTZFO0FBQzdFLHFFQUFxRTtBQUNyRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLElBQUlKLE9BQU9LLE1BQU0sRUFBRTtJQUNqQkQsT0FBT0gsU0FBUyxHQUFHRCxPQUFPSyxNQUFNLENBQUM7SUFFakMsRUFBRTtJQUNGLDZFQUE2RTtJQUM3RSx1RUFBdUU7SUFDdkUsRUFBRTtJQUNGLElBQUksQ0FBQyxJQUFJRCxTQUFTRSxTQUFTLEVBQUVILFNBQVM7QUFDeEM7QUFFQTs7Ozs7Ozs7Q0FRQyxHQUNELFNBQVNJLEdBQUdDLEVBQUUsRUFBRUMsT0FBTyxFQUFFQyxJQUFJO0lBQzNCLElBQUksQ0FBQ0YsRUFBRSxHQUFHQTtJQUNWLElBQUksQ0FBQ0MsT0FBTyxHQUFHQTtJQUNmLElBQUksQ0FBQ0MsSUFBSSxHQUFHQSxRQUFRO0FBQ3RCO0FBRUE7Ozs7Ozs7Ozs7Q0FVQyxHQUNELFNBQVNDLFlBQVlDLE9BQU8sRUFBRUMsS0FBSyxFQUFFTCxFQUFFLEVBQUVDLE9BQU8sRUFBRUMsSUFBSTtJQUNwRCxJQUFJLE9BQU9GLE9BQU8sWUFBWTtRQUM1QixNQUFNLElBQUlNLFVBQVU7SUFDdEI7SUFFQSxJQUFJQyxXQUFXLElBQUlSLEdBQUdDLElBQUlDLFdBQVdHLFNBQVNGLE9BQzFDTSxNQUFNYixTQUFTQSxTQUFTVSxRQUFRQTtJQUVwQyxJQUFJLENBQUNELFFBQVFLLE9BQU8sQ0FBQ0QsSUFBSSxFQUFFSixRQUFRSyxPQUFP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LCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL25vZGVfbW9kdWxlcy9ycGMtd2Vic29ja2V0cy9ub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5qcz84N2Q2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBwcmVmaXggPSAnfic7XG5cbi8qKlxuICogQ29uc3RydWN0b3IgdG8gY3JlYXRlIGEgc3RvcmFnZSBmb3Igb3VyIGBFRWAgb2JqZWN0cy5cbiAqIEFuIGBFdmVudHNgIGluc3RhbmNlIGlzIGEgcGxhaW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgYXJlIGV2ZW50IG5hbWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRXZlbnRzKCkge31cblxuLy9cbi8vIFdlIHRyeSB0byBub3QgaW5oZXJpdCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC4gSW4gc29tZSBlbmdpbmVzIGNyZWF0aW5nIGFuXG4vLyBpbnN0YW5jZSBpbiB0aGlzIHdheSBpcyBmYXN0ZXIgdGhhbiBjYWxsaW5nIGBPYmplY3QuY3JlYXRlKG51bGwpYCBkaXJlY3RseS5cbi8vIElmIGBPYmplY3QuY3JlYXRlKG51bGwpYCBpcyBub3Qgc3VwcG9ydGVkIHdlIHByZWZpeCB0aGUgZXZlbnQgbmFtZXMgd2l0aCBhXG4vLyBjaGFyYWN0ZXIgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGJ1aWx0LWluIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3Rcbi8vIG92ZXJyaWRkZW4gb3IgdXNlZCBhcyBhbiBhdHRhY2sgdmVjdG9yLlxuLy9cbmlmIChPYmplY3QuY3JlYXRlKSB7XG4gIEV2ZW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vXG4gIC8vIFRoaXMgaGFjayBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgYF9fcHJvdG9fX2AgcHJvcGVydHkgaXMgc3RpbGwgaW5oZXJpdGVkIGluXG4gIC8vIHNvbWUgb2xkIGJyb3dzZXJzIGxpa2UgQW5kcm9pZCA0LCBpUGhvbmUgNS4xLCBPcGVyYSAxMSBhbmQgU2FmYXJpIDUuXG4gIC8vXG4gIGlmICghbmV3IEV2ZW50cygpLl9fcHJvdG9fXykgcHJlZml4ID0gZmFsc2U7XG59XG5cbi8qKlxuICogUmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29uY2U9ZmFsc2VdIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEVFKGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHRoaXMuZm4gPSBmbjtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5vbmNlID0gb25jZSB8fCBmYWxzZTtcbn1cblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IGVtaXR0ZXIsIG9uY2UpXG4gICAgLCBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0pIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gbGlzdGVuZXIsIGVtaXR0ZXIuX2V2ZW50c0NvdW50Kys7XG4gIGVsc2UgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XS5mbikgZW1pdHRlci5fZXZlbnRzW2V2dF0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2UgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBbZW1pdHRlci5fZXZlbnRzW2V2dF0sIGxpc3RlbmVyXTtcblxuICByZXR1cm4gZW1pdHRlcjtcbn1cblxuLyoqXG4gKiBDbGVhciBldmVudCBieSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZ0IFRoZSBFdmVudCBuYW1lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2xlYXJFdmVudChlbWl0dGVyLCBldnQpIHtcbiAgaWYgKC0tZW1pdHRlci5fZXZlbnRzQ291bnQgPT09IDApIGVtaXR0ZXIuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgZWxzZSBkZWxldGUgZW1pdHRlci5fZXZlbnRzW2V2dF07XG59XG5cbi8qKlxuICogTWluaW1hbCBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UgdGhhdCBpcyBtb2xkZWQgYWdhaW5zdCB0aGUgTm9kZS5qc1xuICogYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBsaXN0aW5nIHRoZSBldmVudHMgZm9yIHdoaWNoIHRoZSBlbWl0dGVyIGhhcyByZWdpc3RlcmVkXG4gKiBsaXN0ZW5lcnMuXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICB2YXIgbmFtZXMgPSBbXVxuICAgICwgZXZlbnRzXG4gICAgLCBuYW1lO1xuXG4gIGlmICh0aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgcmV0dXJuIG5hbWVzO1xuXG4gIGZvciAobmFtZSBpbiAoZXZlbnRzID0gdGhpcy5fZXZlbnRzKSkge1xuICAgIGlmIChoYXMuY2FsbChldmVudHMsIG5hbWUpKSBuYW1lcy5wdXNoKHByZWZpeCA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lKTtcbiAgfVxuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgcmV0dXJuIG5hbWVzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGV2ZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIG5hbWVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgaGFuZGxlcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWhhbmRsZXJzKSByZXR1cm4gW107XG4gIGlmIChoYW5kbGVycy5mbikgcmV0dXJuIFtoYW5kbGVycy5mbl07XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGgsIGVlID0gbmV3IEFycmF5KGwpOyBpIDwgbDsgaSsrKSB7XG4gICAgZWVbaV0gPSBoYW5kbGVyc1tpXS5mbjtcbiAgfVxuXG4gIHJldHVybiBlZTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGxpc3RlbmluZyB0byBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWxpc3RlbmVycykgcmV0dXJuIDA7XG4gIGlmIChsaXN0ZW5lcnMuZm4pIHJldHVybiAxO1xuICByZXR1cm4gbGlzdGVuZXJzLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQ2FsbHMgZWFjaCBvZiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZXZlbnQgaGFkIGxpc3RlbmVycywgZWxzZSBgZmFsc2VgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XVxuICAgICwgbGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgYXJnc1xuICAgICwgaTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKGxpc3RlbmVycy5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnMuZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgY2FzZSAxOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQpLCB0cnVlO1xuICAgICAgY2FzZSAyOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExKSwgdHJ1ZTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIpLCB0cnVlO1xuICAgICAgY2FzZSA0OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMpLCB0cnVlO1xuICAgICAgY2FzZSA1OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgNjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCwgYTUpLCB0cnVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm4uYXBwbHkobGlzdGVuZXJzLmNvbnRleHQsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoXG4gICAgICAsIGo7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2ldLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgICBjYXNlIDE6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0KTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMik7IGJyZWFrO1xuICAgICAgICBjYXNlIDQ6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIsIGEzKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFhcmdzKSBmb3IgKGogPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBvbmUtdGltZSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZShldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgbGlzdGVuZXJzIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IG1hdGNoIHRoaXMgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IGhhdmUgdGhpcyBjb250ZXh0LlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIE9ubHkgcmVtb3ZlIG9uZS10aW1lIGxpc3RlbmVycy5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gdGhpcztcbiAgaWYgKCFmbikge1xuICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKFxuICAgICAgbGlzdGVuZXJzLmZuID09PSBmbiAmJlxuICAgICAgKCFvbmNlIHx8IGxpc3RlbmVycy5vbmNlKSAmJlxuICAgICAgKCFjb250ZXh0IHx8IGxpc3RlbmVycy5jb250ZXh0ID09PSBjb250ZXh0KVxuICAgICkge1xuICAgICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMCwgZXZlbnRzID0gW10sIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKFxuICAgICAgICBsaXN0ZW5lcnNbaV0uZm4gIT09IGZuIHx8XG4gICAgICAgIChvbmNlICYmICFsaXN0ZW5lcnNbaV0ub25jZSkgfHxcbiAgICAgICAgKGNvbnRleHQgJiYgbGlzdGVuZXJzW2ldLmNvbnRleHQgIT09IGNvbnRleHQpXG4gICAgICApIHtcbiAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIFJlc2V0IHRoZSBhcnJheSwgb3IgcmVtb3ZlIGl0IGNvbXBsZXRlbHkgaWYgd2UgaGF2ZSBubyBtb3JlIGxpc3RlbmVycy5cbiAgICAvL1xuICAgIGlmIChldmVudHMubGVuZ3RoKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGV2ZW50cy5sZW5ndGggPT09IDEgPyBldmVudHNbMF0gOiBldmVudHM7XG4gICAgZWxzZSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMsIG9yIHRob3NlIG9mIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IFtldmVudF0gVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQ7XG5cbiAgaWYgKGV2ZW50KSB7XG4gICAgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgICBpZiAodGhpcy5fZXZlbnRzW2V2dF0pIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gQWxpYXMgbWV0aG9kcyBuYW1lcyBiZWNhdXNlIHBlb3BsZSByb2xsIGxpa2UgdGhhdC5cbi8vXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgcHJlZml4LlxuLy9cbkV2ZW50RW1pdHRlci5wcmVmaXhlZCA9IHByZWZpeDtcblxuLy9cbi8vIEFsbG93IGBFdmVudEVtaXR0ZXJgIHRvIGJlIGltcG9ydGVkIGFzIG1vZHVsZSBuYW1lc3BhY2UuXG4vL1xuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG1vZHVsZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbn1cbiJdLCJuYW1lcyI6WyJoYXMiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsInByZWZpeCIsIkV2ZW50cyIsImNyZWF0ZSIsIl9fcHJvdG9fXyIsIkVFIiwiZm4iLCJjb250ZXh0Iiwib25jZSIsImFkZExpc3RlbmVyIiwiZW1pdHRlciIsImV2ZW50IiwiVHlwZUVycm9yIiwibGlzdGVuZXIiLCJldnQiLCJfZXZlbnRzIiwiX2V2ZW50c0NvdW50IiwicHVzaCIsImNsZWFyRXZlbnQiLCJFdmVudEVtaXR0ZXIiLCJldmVudE5hbWVzIiwibmFtZXMiLCJldmVudHMiLCJuYW1lIiwiY2FsbCIsInNsaWNlIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiY29uY2F0IiwibGlzdGVuZXJzIiwiaGFuZGxlcnMiLCJpIiwibCIsImxlbmd0aCIsImVlIiwiQXJyYXkiLCJsaXN0ZW5lckNvdW50IiwiZW1pdCIsImExIiwiYTIiLCJhMyIsImE0IiwiYTUiLCJsZW4iLCJhcmd1bWVudHMiLCJhcmdzIiwicmVtb3ZlTGlzdGVuZXIiLCJ1bmRlZmluZWQiLCJhcHBseSIsImoiLCJvbiIsInJlbW92ZUFsbExpc3RlbmVycyIsIm9mZiIsInByZWZpeGVkIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/node_modules/rpc-websockets/node_modules/eventemitter3/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/node_modules/@solana/web3.js/node_modules/superstruct/dist/index.mjs":
/*!**************************************************************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/node_modules/@solana/web3.js/node_modules/superstruct/dist/index.mjs ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Struct: () => (/* binding */ Struct),\n/* harmony export */   StructError: () => (/* binding */ StructError),\n/* harmony export */   any: () => (/* binding */ any),\n/* harmony export */   array: () => (/* binding */ array),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assign: () => (/* binding */ assign),\n/* harmony export */   bigint: () => (/* binding */ bigint),\n/* harmony export */   boolean: () => (/* binding */ boolean),\n/* harmony export */   coerce: () => (/* binding */ coerce),\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   date: () => (/* binding */ date),\n/* harmony export */   defaulted: () => (/* binding */ defaulted),\n/* harmony export */   define: () => (/* binding */ define),\n/* harmony export */   deprecated: () => (/* binding */ deprecated),\n/* harmony export */   dynamic: () => (/* binding */ dynamic),\n/* harmony export */   empty: () => (/* binding */ empty),\n/* harmony export */   enums: () => (/* binding */ enums),\n/* harmony export */   func: () => (/* binding */ func),\n/* harmony export */   instance: () => (/* binding */ instance),\n/* harmony export */   integer: () => (/* binding */ integer),\n/* harmony export */   intersection: () => (/* binding */ intersection),\n/* harmony export */   is: () => (/* binding */ is),\n/* harmony export */   lazy: () => (/* binding */ lazy),\n/* harmony export */   literal: () => (/* binding */ literal),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   mask: () => (/* binding */ mask),\n/* harmony export */   max: () => (/* binding */ max),\n/* harmony export */   min: () => (/* binding */ min),\n/* harmony export */   never: () => (/* binding */ never),\n/* harmony export */   nonempty: () => (/* binding */ nonempty),\n/* harmony export */   nullable: () => (/* binding */ nullable),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   object: () => (/* binding */ object),\n/* harmony export */   omit: () => (/* binding */ omit),\n/* harmony export */   optional: () => (/* binding */ optional),\n/* harmony export */   partial: () => (/* binding */ partial),\n/* harmony export */   pattern: () => (/* binding */ pattern),\n/* harmony export */   pick: () => (/* binding */ pick),\n/* harmony export */   record: () => (/* binding */ record),\n/* harmony export */   refine: () => (/* binding */ refine),\n/* harmony export */   regexp: () => (/* binding */ regexp),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   string: () => (/* binding */ string),\n/* harmony export */   struct: () => (/* binding */ struct),\n/* harmony export */   trimmed: () => (/* binding */ trimmed),\n/* harmony export */   tuple: () => (/* binding */ tuple),\n/* harmony export */   type: () => (/* binding */ type),\n/* harmony export */   union: () => (/* binding */ union),\n/* harmony export */   unknown: () => (/* binding */ unknown),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/**\n * A `StructFailure` represents a single specific failure in validation.\n */ /**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */ class StructError extends TypeError {\n    constructor(failure, failures){\n        let cached;\n        const { message, explanation, ...rest } = failure;\n        const { path } = failure;\n        const msg = path.length === 0 ? message : `At path: ${path.join(\".\")} -- ${message}`;\n        super(explanation ?? msg);\n        if (explanation != null) this.cause = msg;\n        Object.assign(this, rest);\n        this.name = this.constructor.name;\n        this.failures = ()=>{\n            return cached ?? (cached = [\n                failure,\n                ...failures()\n            ]);\n        };\n    }\n}\n/**\n * Check if a value is an iterator.\n */ function isIterable(x) {\n    return isObject(x) && typeof x[Symbol.iterator] === \"function\";\n}\n/**\n * Check if a value is a plain object.\n */ function isObject(x) {\n    return typeof x === \"object\" && x != null;\n}\n/**\n * Check if a value is a non-array object.\n */ function isNonArrayObject(x) {\n    return isObject(x) && !Array.isArray(x);\n}\n/**\n * Check if a value is a plain object.\n */ function isPlainObject(x) {\n    if (Object.prototype.toString.call(x) !== \"[object Object]\") {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(x);\n    return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */ function print(value) {\n    if (typeof value === \"symbol\") {\n        return value.toString();\n    }\n    return typeof value === \"string\" ? JSON.stringify(value) : `${value}`;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */ function shiftIterator(input) {\n    const { done, value } = input.next();\n    return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */ function toFailure(result, context, struct, value) {\n    if (result === true) {\n        return;\n    } else if (result === false) {\n        result = {};\n    } else if (typeof result === \"string\") {\n        result = {\n            message: result\n        };\n    }\n    const { path, branch } = context;\n    const { type } = struct;\n    const { refinement, message = `Expected a value of type \\`${type}\\`${refinement ? ` with refinement \\`${refinement}\\`` : \"\"}, but received: \\`${print(value)}\\`` } = result;\n    return {\n        value,\n        type,\n        refinement,\n        key: path[path.length - 1],\n        path,\n        branch,\n        ...result,\n        message\n    };\n}\n/**\n * Convert a validation result to an iterable of failures.\n */ function* toFailures(result, context, struct, value) {\n    if (!isIterable(result)) {\n        result = [\n            result\n        ];\n    }\n    for (const r of result){\n        const failure = toFailure(r, context, struct, value);\n        if (failure) {\n            yield failure;\n        }\n    }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */ function* run(value, struct, options = {}) {\n    const { path = [], branch = [\n        value\n    ], coerce = false, mask = false } = options;\n    const ctx = {\n        path,\n        branch,\n        mask\n    };\n    if (coerce) {\n        value = struct.coercer(value, ctx);\n    }\n    let status = \"valid\";\n    for (const failure of struct.validator(value, ctx)){\n        failure.explanation = options.message;\n        status = \"not_valid\";\n        yield [\n            failure,\n            undefined\n        ];\n    }\n    for (let [k, v, s] of struct.entries(value, ctx)){\n        const ts = run(v, s, {\n            path: k === undefined ? path : [\n                ...path,\n                k\n            ],\n            branch: k === undefined ? branch : [\n                ...branch,\n                v\n            ],\n            coerce,\n            mask,\n            message: options.message\n        });\n        for (const t of ts){\n            if (t[0]) {\n                status = t[0].refinement != null ? \"not_refined\" : \"not_valid\";\n                yield [\n                    t[0],\n                    undefined\n                ];\n            } else if (coerce) {\n                v = t[1];\n                if (k === undefined) {\n                    value = v;\n                } else if (value instanceof Map) {\n                    value.set(k, v);\n                } else if (value instanceof Set) {\n                    value.add(v);\n                } else if (isObject(value)) {\n                    if (v !== undefined || k in value) value[k] = v;\n                }\n            }\n        }\n    }\n    if (status !== \"not_valid\") {\n        for (const failure of struct.refiner(value, ctx)){\n            failure.explanation = options.message;\n            status = \"not_refined\";\n            yield [\n                failure,\n                undefined\n            ];\n        }\n    }\n    if (status === \"valid\") {\n        yield [\n            undefined,\n            value\n        ];\n    }\n}\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */ class Struct {\n    constructor(props){\n        const { type, schema, validator, refiner, coercer = (value)=>value, entries = function*() {} } = props;\n        this.type = type;\n        this.schema = schema;\n        this.entries = entries;\n        this.coercer = coercer;\n        if (validator) {\n            this.validator = (value, context)=>{\n                const result = validator(value, context);\n                return toFailures(result, context, this, value);\n            };\n        } else {\n            this.validator = ()=>[];\n        }\n        if (refiner) {\n            this.refiner = (value, context)=>{\n                const result = refiner(value, context);\n                return toFailures(result, context, this, value);\n            };\n        } else {\n            this.refiner = ()=>[];\n        }\n    }\n    /**\n     * Assert that a value passes the struct's validation, throwing if it doesn't.\n     */ assert(value, message) {\n        return assert(value, this, message);\n    }\n    /**\n     * Create a value with the struct's coercion logic, then validate it.\n     */ create(value, message) {\n        return create(value, this, message);\n    }\n    /**\n     * Check if a value passes the struct's validation.\n     */ is(value) {\n        return is(value, this);\n    }\n    /**\n     * Mask a value, coercing and validating it, but returning only the subset of\n     * properties defined by the struct's schema. Masking applies recursively to\n     * props of `object` structs only.\n     */ mask(value, message) {\n        return mask(value, this, message);\n    }\n    /**\n     * Validate a value with the struct's validation logic, returning a tuple\n     * representing the result.\n     *\n     * You may optionally pass `true` for the `coerce` argument to coerce\n     * the value before attempting to validate it. If you do, the result will\n     * contain the coerced result when successful. Also, `mask` will turn on\n     * masking of the unknown `object` props recursively if passed.\n     */ validate(value, options = {}) {\n        return validate(value, this, options);\n    }\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */ function assert(value, struct, message) {\n    const result = validate(value, struct, {\n        message\n    });\n    if (result[0]) {\n        throw result[0];\n    }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */ function create(value, struct, message) {\n    const result = validate(value, struct, {\n        coerce: true,\n        message\n    });\n    if (result[0]) {\n        throw result[0];\n    } else {\n        return result[1];\n    }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */ function mask(value, struct, message) {\n    const result = validate(value, struct, {\n        coerce: true,\n        mask: true,\n        message\n    });\n    if (result[0]) {\n        throw result[0];\n    } else {\n        return result[1];\n    }\n}\n/**\n * Check if a value passes a struct.\n */ function is(value, struct) {\n    const result = validate(value, struct);\n    return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */ function validate(value, struct, options = {}) {\n    const tuples = run(value, struct, options);\n    const tuple = shiftIterator(tuples);\n    if (tuple[0]) {\n        const error = new StructError(tuple[0], function*() {\n            for (const t of tuples){\n                if (t[0]) {\n                    yield t[0];\n                }\n            }\n        });\n        return [\n            error,\n            undefined\n        ];\n    } else {\n        const v = tuple[1];\n        return [\n            undefined,\n            v\n        ];\n    }\n}\nfunction assign(...Structs) {\n    const isType = Structs[0].type === \"type\";\n    const schemas = Structs.map((s)=>s.schema);\n    const schema = Object.assign({}, ...schemas);\n    return isType ? type(schema) : object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */ function define(name, validator) {\n    return new Struct({\n        type: name,\n        schema: null,\n        validator\n    });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */ function deprecated(struct, log) {\n    return new Struct({\n        ...struct,\n        refiner: (value, ctx)=>value === undefined || struct.refiner(value, ctx),\n        validator (value, ctx) {\n            if (value === undefined) {\n                return true;\n            } else {\n                log(value, ctx);\n                return struct.validator(value, ctx);\n            }\n        }\n    });\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */ function dynamic(fn) {\n    return new Struct({\n        type: \"dynamic\",\n        schema: null,\n        *entries (value, ctx) {\n            const struct = fn(value, ctx);\n            yield* struct.entries(value, ctx);\n        },\n        validator (value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.validator(value, ctx);\n        },\n        coercer (value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.coercer(value, ctx);\n        },\n        refiner (value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.refiner(value, ctx);\n        }\n    });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */ function lazy(fn) {\n    let struct;\n    return new Struct({\n        type: \"lazy\",\n        schema: null,\n        *entries (value, ctx) {\n            struct ?? (struct = fn());\n            yield* struct.entries(value, ctx);\n        },\n        validator (value, ctx) {\n            struct ?? (struct = fn());\n            return struct.validator(value, ctx);\n        },\n        coercer (value, ctx) {\n            struct ?? (struct = fn());\n            return struct.coercer(value, ctx);\n        },\n        refiner (value, ctx) {\n            struct ?? (struct = fn());\n            return struct.refiner(value, ctx);\n        }\n    });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */ function omit(struct, keys) {\n    const { schema } = struct;\n    const subschema = {\n        ...schema\n    };\n    for (const key of keys){\n        delete subschema[key];\n    }\n    switch(struct.type){\n        case \"type\":\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */ function partial(struct) {\n    const isStruct = struct instanceof Struct;\n    const schema = isStruct ? {\n        ...struct.schema\n    } : {\n        ...struct\n    };\n    for(const key in schema){\n        schema[key] = optional(schema[key]);\n    }\n    if (isStruct && struct.type === \"type\") {\n        return type(schema);\n    }\n    return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */ function pick(struct, keys) {\n    const { schema } = struct;\n    const subschema = {};\n    for (const key of keys){\n        subschema[key] = schema[key];\n    }\n    switch(struct.type){\n        case \"type\":\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */ function struct(name, validator) {\n    console.warn(\"superstruct@0.11 - The `struct` helper has been renamed to `define`.\");\n    return define(name, validator);\n}\n/**\n * Ensure that any value passes validation.\n */ function any() {\n    return define(\"any\", ()=>true);\n}\nfunction array(Element) {\n    return new Struct({\n        type: \"array\",\n        schema: Element,\n        *entries (value) {\n            if (Element && Array.isArray(value)) {\n                for (const [i, v] of value.entries()){\n                    yield [\n                        i,\n                        v,\n                        Element\n                    ];\n                }\n            }\n        },\n        coercer (value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n        validator (value) {\n            return Array.isArray(value) || `Expected an array value, but received: ${print(value)}`;\n        }\n    });\n}\n/**\n * Ensure that a value is a bigint.\n */ function bigint() {\n    return define(\"bigint\", (value)=>{\n        return typeof value === \"bigint\";\n    });\n}\n/**\n * Ensure that a value is a boolean.\n */ function boolean() {\n    return define(\"boolean\", (value)=>{\n        return typeof value === \"boolean\";\n    });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */ function date() {\n    return define(\"date\", (value)=>{\n        return value instanceof Date && !isNaN(value.getTime()) || `Expected a valid \\`Date\\` object, but received: ${print(value)}`;\n    });\n}\nfunction enums(values) {\n    const schema = {};\n    const description = values.map((v)=>print(v)).join();\n    for (const key of values){\n        schema[key] = key;\n    }\n    return new Struct({\n        type: \"enums\",\n        schema,\n        validator (value) {\n            return values.includes(value) || `Expected one of \\`${description}\\`, but received: ${print(value)}`;\n        }\n    });\n}\n/**\n * Ensure that a value is a function.\n */ function func() {\n    return define(\"func\", (value)=>{\n        return typeof value === \"function\" || `Expected a function, but received: ${print(value)}`;\n    });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */ function instance(Class) {\n    return define(\"instance\", (value)=>{\n        return value instanceof Class || `Expected a \\`${Class.name}\\` instance, but received: ${print(value)}`;\n    });\n}\n/**\n * Ensure that a value is an integer.\n */ function integer() {\n    return define(\"integer\", (value)=>{\n        return typeof value === \"number\" && !isNaN(value) && Number.isInteger(value) || `Expected an integer, but received: ${print(value)}`;\n    });\n}\n/**\n * Ensure that a value matches all of a set of types.\n */ function intersection(Structs) {\n    return new Struct({\n        type: \"intersection\",\n        schema: null,\n        *entries (value, ctx) {\n            for (const S of Structs){\n                yield* S.entries(value, ctx);\n            }\n        },\n        *validator (value, ctx) {\n            for (const S of Structs){\n                yield* S.validator(value, ctx);\n            }\n        },\n        *refiner (value, ctx) {\n            for (const S of Structs){\n                yield* S.refiner(value, ctx);\n            }\n        }\n    });\n}\nfunction literal(constant) {\n    const description = print(constant);\n    const t = typeof constant;\n    return new Struct({\n        type: \"literal\",\n        schema: t === \"string\" || t === \"number\" || t === \"boolean\" ? constant : null,\n        validator (value) {\n            return value === constant || `Expected the literal \\`${description}\\`, but received: ${print(value)}`;\n        }\n    });\n}\nfunction map(Key, Value) {\n    return new Struct({\n        type: \"map\",\n        schema: null,\n        *entries (value) {\n            if (Key && Value && value instanceof Map) {\n                for (const [k, v] of value.entries()){\n                    yield [\n                        k,\n                        k,\n                        Key\n                    ];\n                    yield [\n                        k,\n                        v,\n                        Value\n                    ];\n                }\n            }\n        },\n        coercer (value) {\n            return value instanceof Map ? new Map(value) : value;\n        },\n        validator (value) {\n            return value instanceof Map || `Expected a \\`Map\\` object, but received: ${print(value)}`;\n        }\n    });\n}\n/**\n * Ensure that no value ever passes validation.\n */ function never() {\n    return define(\"never\", ()=>false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n */ function nullable(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx)=>value === null || struct.validator(value, ctx),\n        refiner: (value, ctx)=>value === null || struct.refiner(value, ctx)\n    });\n}\n/**\n * Ensure that a value is a number.\n */ function number() {\n    return define(\"number\", (value)=>{\n        return typeof value === \"number\" && !isNaN(value) || `Expected a number, but received: ${print(value)}`;\n    });\n}\nfunction object(schema) {\n    const knowns = schema ? Object.keys(schema) : [];\n    const Never = never();\n    return new Struct({\n        type: \"object\",\n        schema: schema ? schema : null,\n        *entries (value) {\n            if (schema && isObject(value)) {\n                const unknowns = new Set(Object.keys(value));\n                for (const key of knowns){\n                    unknowns.delete(key);\n                    yield [\n                        key,\n                        value[key],\n                        schema[key]\n                    ];\n                }\n                for (const key of unknowns){\n                    yield [\n                        key,\n                        value[key],\n                        Never\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return isNonArrayObject(value) || `Expected an object, but received: ${print(value)}`;\n        },\n        coercer (value, ctx) {\n            if (!isNonArrayObject(value)) {\n                return value;\n            }\n            const coerced = {\n                ...value\n            };\n            // The `object` struct has special behaviour enabled by the mask flag.\n            // When masking, properties that are not in the schema are deleted from\n            // the coerced object instead of eventually failing validaiton.\n            if (ctx.mask && schema) {\n                for(const key in coerced){\n                    if (schema[key] === undefined) {\n                        delete coerced[key];\n                    }\n                }\n            }\n            return coerced;\n        }\n    });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */ function optional(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx)=>value === undefined || struct.validator(value, ctx),\n        refiner: (value, ctx)=>value === undefined || struct.refiner(value, ctx)\n    });\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */ function record(Key, Value) {\n    return new Struct({\n        type: \"record\",\n        schema: null,\n        *entries (value) {\n            if (isObject(value)) {\n                for(const k in value){\n                    const v = value[k];\n                    yield [\n                        k,\n                        k,\n                        Key\n                    ];\n                    yield [\n                        k,\n                        v,\n                        Value\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return isNonArrayObject(value) || `Expected an object, but received: ${print(value)}`;\n        },\n        coercer (value) {\n            return isNonArrayObject(value) ? {\n                ...value\n            } : value;\n        }\n    });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */ function regexp() {\n    return define(\"regexp\", (value)=>{\n        return value instanceof RegExp;\n    });\n}\nfunction set(Element) {\n    return new Struct({\n        type: \"set\",\n        schema: null,\n        *entries (value) {\n            if (Element && value instanceof Set) {\n                for (const v of value){\n                    yield [\n                        v,\n                        v,\n                        Element\n                    ];\n                }\n            }\n        },\n        coercer (value) {\n            return value instanceof Set ? new Set(value) : value;\n        },\n        validator (value) {\n            return value instanceof Set || `Expected a \\`Set\\` object, but received: ${print(value)}`;\n        }\n    });\n}\n/**\n * Ensure that a value is a string.\n */ function string() {\n    return define(\"string\", (value)=>{\n        return typeof value === \"string\" || `Expected a string, but received: ${print(value)}`;\n    });\n}\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n */ function tuple(Structs) {\n    const Never = never();\n    return new Struct({\n        type: \"tuple\",\n        schema: null,\n        *entries (value) {\n            if (Array.isArray(value)) {\n                const length = Math.max(Structs.length, value.length);\n                for(let i = 0; i < length; i++){\n                    yield [\n                        i,\n                        value[i],\n                        Structs[i] || Never\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return Array.isArray(value) || `Expected an array, but received: ${print(value)}`;\n        },\n        coercer (value) {\n            return Array.isArray(value) ? value.slice() : value;\n        }\n    });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */ function type(schema) {\n    const keys = Object.keys(schema);\n    return new Struct({\n        type: \"type\",\n        schema,\n        *entries (value) {\n            if (isObject(value)) {\n                for (const k of keys){\n                    yield [\n                        k,\n                        value[k],\n                        schema[k]\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return isNonArrayObject(value) || `Expected an object, but received: ${print(value)}`;\n        },\n        coercer (value) {\n            return isNonArrayObject(value) ? {\n                ...value\n            } : value;\n        }\n    });\n}\n/**\n * Ensure that a value matches one of a set of types.\n */ function union(Structs) {\n    const description = Structs.map((s)=>s.type).join(\" | \");\n    return new Struct({\n        type: \"union\",\n        schema: null,\n        coercer (value, ctx) {\n            for (const S of Structs){\n                const [error, coerced] = S.validate(value, {\n                    coerce: true,\n                    mask: ctx.mask\n                });\n                if (!error) {\n                    return coerced;\n                }\n            }\n            return value;\n        },\n        validator (value, ctx) {\n            const failures = [];\n            for (const S of Structs){\n                const [...tuples] = run(value, S, ctx);\n                const [first] = tuples;\n                if (!first[0]) {\n                    return [];\n                } else {\n                    for (const [failure] of tuples){\n                        if (failure) {\n                            failures.push(failure);\n                        }\n                    }\n                }\n            }\n            return [\n                `Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(value)}`,\n                ...failures\n            ];\n        }\n    });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */ function unknown() {\n    return define(\"unknown\", ()=>true);\n}\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validation—for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */ function coerce(struct, condition, coercer) {\n    return new Struct({\n        ...struct,\n        coercer: (value, ctx)=>{\n            return is(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx);\n        }\n    });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */ function defaulted(struct, fallback, options = {}) {\n    return coerce(struct, unknown(), (x)=>{\n        const f = typeof fallback === \"function\" ? fallback() : fallback;\n        if (x === undefined) {\n            return f;\n        }\n        if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n            const ret = {\n                ...x\n            };\n            let changed = false;\n            for(const key in f){\n                if (ret[key] === undefined) {\n                    ret[key] = f[key];\n                    changed = true;\n                }\n            }\n            if (changed) {\n                return ret;\n            }\n        }\n        return x;\n    });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */ function trimmed(struct) {\n    return coerce(struct, string(), (x)=>x.trim());\n}\n/**\n * Ensure that a string, array, map, or set is empty.\n */ function empty(struct) {\n    return refine(struct, \"empty\", (value)=>{\n        const size = getSize(value);\n        return size === 0 || `Expected an empty ${struct.type} but received one with a size of \\`${size}\\``;\n    });\n}\nfunction getSize(value) {\n    if (value instanceof Map || value instanceof Set) {\n        return value.size;\n    } else {\n        return value.length;\n    }\n}\n/**\n * Ensure that a number or date is below a threshold.\n */ function max(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, \"max\", (value)=>{\n        return exclusive ? value < threshold : value <= threshold || `Expected a ${struct.type} less than ${exclusive ? \"\" : \"or equal to \"}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */ function min(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, \"min\", (value)=>{\n        return exclusive ? value > threshold : value >= threshold || `Expected a ${struct.type} greater than ${exclusive ? \"\" : \"or equal to \"}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a string, array, map or set is not empty.\n */ function nonempty(struct) {\n    return refine(struct, \"nonempty\", (value)=>{\n        const size = getSize(value);\n        return size > 0 || `Expected a nonempty ${struct.type} but received an empty one`;\n    });\n}\n/**\n * Ensure that a string matches a regular expression.\n */ function pattern(struct, regexp) {\n    return refine(struct, \"pattern\", (value)=>{\n        return regexp.test(value) || `Expected a ${struct.type} matching \\`/${regexp.source}/\\` but received \"${value}\"`;\n    });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */ function size(struct, min, max = min) {\n    const expected = `Expected a ${struct.type}`;\n    const of = min === max ? `of \\`${min}\\`` : `between \\`${min}\\` and \\`${max}\\``;\n    return refine(struct, \"size\", (value)=>{\n        if (typeof value === \"number\" || value instanceof Date) {\n            return min <= value && value <= max || `${expected} ${of} but received \\`${value}\\``;\n        } else if (value instanceof Map || value instanceof Set) {\n            const { size } = value;\n            return min <= size && size <= max || `${expected} with a size ${of} but received one with a size of \\`${size}\\``;\n        } else {\n            const { length } = value;\n            return min <= length && length <= max || `${expected} with a length ${of} but received one with a length of \\`${length}\\``;\n        }\n    });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */ function refine(struct, name, refiner) {\n    return new Struct({\n        ...struct,\n        *refiner (value, ctx) {\n            yield* struct.refiner(value, ctx);\n            const result = refiner(value, ctx);\n            const failures = toFailures(result, ctx, struct, value);\n            for (const failure of failures){\n                yield {\n                    ...failure,\n                    refinement: name\n                };\n            }\n        }\n    });\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbm9kZV9tb2R1bGVzL3N1cGVyc3RydWN0L2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztDQUVDLEdBQ0Q7Ozs7Ozs7Q0FPQyxHQUNELE1BQU1BLG9CQUFvQkM7SUFDdEJDLFlBQVlDLE9BQU8sRUFBRUMsUUFBUSxDQUFFO1FBQzNCLElBQUlDO1FBQ0osTUFBTSxFQUFFQyxPQUFPLEVBQUVDLFdBQVcsRUFBRSxHQUFHQyxNQUFNLEdBQUdMO1FBQzFDLE1BQU0sRUFBRU0sSUFBSSxFQUFFLEdBQUdOO1FBQ2pCLE1BQU1PLE1BQU1ELEtBQUtFLE1BQU0sS0FBSyxJQUFJTCxVQUFVLENBQUMsU0FBUyxFQUFFRyxLQUFLRyxJQUFJLENBQUMsS0FBSyxJQUFJLEVBQUVOLFFBQVEsQ0FBQztRQUNwRixLQUFLLENBQUNDLGVBQWVHO1FBQ3JCLElBQUlILGVBQWUsTUFDZixJQUFJLENBQUNNLEtBQUssR0FBR0g7UUFDakJJLE9BQU9DLE1BQU0sQ0FBQyxJQUFJLEVBQUVQO1FBQ3BCLElBQUksQ0FBQ1EsSUFBSSxHQUFHLElBQUksQ0FBQ2QsV0FBVyxDQUFDYyxJQUFJO1FBQ2pDLElBQUksQ0FBQ1osUUFBUSxHQUFHO1lBQ1osT0FBUUMsVUFBV0EsQ0FBQUEsU0FBUztnQkFBQ0Y7bUJBQVlDO2FBQVc7UUFDeEQ7SUFDSjtBQUNKO0FBRUE7O0NBRUMsR0FDRCxTQUFTYSxXQUFXQyxDQUFDO0lBQ2pCLE9BQU9DLFNBQVNELE1BQU0sT0FBT0EsQ0FBQyxDQUFDRSxPQUFPQyxRQUFRLENBQUMsS0FBSztBQUN4RDtBQUNBOztDQUVDLEdBQ0QsU0FBU0YsU0FBU0QsQ0FBQztJQUNmLE9BQU8sT0FBT0EsTUFBTSxZQUFZQSxLQUFLO0FBQ3pDO0FBQ0E7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RyxxQ0FBcUMsRUFBRXpKLE9BQU8sRUFBRSxDQUFDO1FBQ3pGO0lBQ0o7QUFDSjtBQUNBOzs7Ozs7Q0FNQyxHQUNELFNBQVM4SSxPQUFPL0csTUFBTSxFQUFFMUIsSUFBSSxFQUFFbUQsT0FBTztJQUNqQyxPQUFPLElBQUlDLE9BQU87UUFDZCxHQUFHMUIsTUFBTTtRQUNULENBQUN5QixTQUFRcEMsS0FBSyxFQUFFc0IsR0FBRztZQUNmLE9BQU9YLE9BQU95QixPQUFPLENBQUNwQyxPQUFPc0I7WUFDN0IsTUFBTWIsU0FBUzJCLFFBQVFwQyxPQUFPc0I7WUFDOUIsTUFBTWpELFdBQVcyQyxXQUFXUCxRQUFRYSxLQUFLWCxRQUFRWDtZQUNqRCxLQUFLLE1BQU01QixXQUFXQyxTQUFVO2dCQUM1QixNQUFNO29CQUFFLEdBQUdELE9BQU87b0JBQUUwQyxZQUFZN0I7Z0JBQUs7WUFDekM7UUFDSjtJQUNKO0FBQ0o7QUFFNlosQ0FDN1osa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AY29yYWwteHl6L2FuY2hvci9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9zdXBlcnN0cnVjdC9kaXN0L2luZGV4Lm1qcz80ZGYwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQSBgU3RydWN0RmFpbHVyZWAgcmVwcmVzZW50cyBhIHNpbmdsZSBzcGVjaWZpYyBmYWlsdXJlIGluIHZhbGlkYXRpb24uXG4gKi9cbi8qKlxuICogYFN0cnVjdEVycm9yYCBvYmplY3RzIGFyZSB0aHJvd24gKG9yIHJldHVybmVkKSB3aGVuIHZhbGlkYXRpb24gZmFpbHMuXG4gKlxuICogVmFsaWRhdGlvbiBsb2dpYyBpcyBkZXNpZ24gdG8gZXhpdCBlYXJseSBmb3IgbWF4aW11bSBwZXJmb3JtYW5jZS4gVGhlIGVycm9yXG4gKiByZXByZXNlbnRzIHRoZSBmaXJzdCBlcnJvciBlbmNvdW50ZXJlZCBkdXJpbmcgdmFsaWRhdGlvbi4gRm9yIG1vcmUgZGV0YWlsLFxuICogdGhlIGBlcnJvci5mYWlsdXJlc2AgcHJvcGVydHkgaXMgYSBnZW5lcmF0b3IgZnVuY3Rpb24gdGhhdCBjYW4gYmUgcnVuIHRvXG4gKiBjb250aW51ZSB2YWxpZGF0aW9uIGFuZCByZWNlaXZlIGFsbCB0aGUgZmFpbHVyZXMgaW4gdGhlIGRhdGEuXG4gKi9cbmNsYXNzIFN0cnVjdEVycm9yIGV4dGVuZHMgVHlwZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihmYWlsdXJlLCBmYWlsdXJlcykge1xuICAgICAgICBsZXQgY2FjaGVkO1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2UsIGV4cGxhbmF0aW9uLCAuLi5yZXN0IH0gPSBmYWlsdXJlO1xuICAgICAgICBjb25zdCB7IHBhdGggfSA9IGZhaWx1cmU7XG4gICAgICAgIGNvbnN0IG1zZyA9IHBhdGgubGVuZ3RoID09PSAwID8gbWVzc2FnZSA6IGBBdCBwYXRoOiAke3BhdGguam9pbignLicpfSAtLSAke21lc3NhZ2V9YDtcbiAgICAgICAgc3VwZXIoZXhwbGFuYXRpb24gPz8gbXNnKTtcbiAgICAgICAgaWYgKGV4cGxhbmF0aW9uICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLmNhdXNlID0gbXNnO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHJlc3QpO1xuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIHRoaXMuZmFpbHVyZXMgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKGNhY2hlZCA/PyAoY2FjaGVkID0gW2ZhaWx1cmUsIC4uLmZhaWx1cmVzKCldKSk7XG4gICAgICAgIH07XG4gICAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYW4gaXRlcmF0b3IuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmFibGUoeCkge1xuICAgIHJldHVybiBpc09iamVjdCh4KSAmJiB0eXBlb2YgeFtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc09iamVjdCh4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9IG51bGw7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBub24tYXJyYXkgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc05vbkFycmF5T2JqZWN0KHgpIHtcbiAgICByZXR1cm4gaXNPYmplY3QoeCkgJiYgIUFycmF5LmlzQXJyYXkoeCk7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QoeCkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgIT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHgpO1xuICAgIHJldHVybiBwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlO1xufVxuLyoqXG4gKiBSZXR1cm4gYSB2YWx1ZSBhcyBhIHByaW50YWJsZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHByaW50KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gSlNPTi5zdHJpbmdpZnkodmFsdWUpIDogYCR7dmFsdWV9YDtcbn1cbi8qKlxuICogU2hpZnRzIChyZW1vdmVzIGFuZCByZXR1cm5zKSB0aGUgZmlyc3QgdmFsdWUgZnJvbSB0aGUgYGlucHV0YCBpdGVyYXRvci5cbiAqIExpa2UgYEFycmF5LnByb3RvdHlwZS5zaGlmdCgpYCBidXQgZm9yIGFuIGBJdGVyYXRvcmAuXG4gKi9cbmZ1bmN0aW9uIHNoaWZ0SXRlcmF0b3IoaW5wdXQpIHtcbiAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBpbnB1dC5uZXh0KCk7XG4gICAgcmV0dXJuIGRvbmUgPyB1bmRlZmluZWQgOiB2YWx1ZTtcbn1cbi8qKlxuICogQ29udmVydCBhIHNpbmdsZSB2YWxpZGF0aW9uIHJlc3VsdCB0byBhIGZhaWx1cmUuXG4gKi9cbmZ1bmN0aW9uIHRvRmFpbHVyZShyZXN1bHQsIGNvbnRleHQsIHN0cnVjdCwgdmFsdWUpIHtcbiAgICBpZiAocmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICByZXN1bHQgPSB7fTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmVzdWx0ID0geyBtZXNzYWdlOiByZXN1bHQgfTtcbiAgICB9XG4gICAgY29uc3QgeyBwYXRoLCBicmFuY2ggfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgeyB0eXBlIH0gPSBzdHJ1Y3Q7XG4gICAgY29uc3QgeyByZWZpbmVtZW50LCBtZXNzYWdlID0gYEV4cGVjdGVkIGEgdmFsdWUgb2YgdHlwZSBcXGAke3R5cGV9XFxgJHtyZWZpbmVtZW50ID8gYCB3aXRoIHJlZmluZW1lbnQgXFxgJHtyZWZpbmVtZW50fVxcYGAgOiAnJ30sIGJ1dCByZWNlaXZlZDogXFxgJHtwcmludCh2YWx1ZSl9XFxgYCwgfSA9IHJlc3VsdDtcbiAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcmVmaW5lbWVudCxcbiAgICAgICAga2V5OiBwYXRoW3BhdGgubGVuZ3RoIC0gMV0sXG4gICAgICAgIHBhdGgsXG4gICAgICAgIGJyYW5jaCxcbiAgICAgICAgLi4ucmVzdWx0LFxuICAgICAgICBtZXNzYWdlLFxuICAgIH07XG59XG4vKipcbiAqIENvbnZlcnQgYSB2YWxpZGF0aW9uIHJlc3VsdCB0byBhbiBpdGVyYWJsZSBvZiBmYWlsdXJlcy5cbiAqL1xuZnVuY3Rpb24qIHRvRmFpbHVyZXMocmVzdWx0LCBjb250ZXh0LCBzdHJ1Y3QsIHZhbHVlKSB7XG4gICAgaWYgKCFpc0l0ZXJhYmxlKHJlc3VsdCkpIHtcbiAgICAgICAgcmVzdWx0ID0gW3Jlc3VsdF07XG4gICAgfVxuICAgIGZvciAoY29uc3QgciBvZiByZXN1bHQpIHtcbiAgICAgICAgY29uc3QgZmFpbHVyZSA9IHRvRmFpbHVyZShyLCBjb250ZXh0LCBzdHJ1Y3QsIHZhbHVlKTtcbiAgICAgICAgaWYgKGZhaWx1cmUpIHtcbiAgICAgICAgICAgIHlpZWxkIGZhaWx1cmU7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIENoZWNrIGEgdmFsdWUgYWdhaW5zdCBhIHN0cnVjdCwgdHJhdmVyc2luZyBkZWVwbHkgaW50byBuZXN0ZWQgdmFsdWVzLCBhbmRcbiAqIHJldHVybmluZyBhbiBpdGVyYXRvciBvZiBmYWlsdXJlcyBvciBzdWNjZXNzLlxuICovXG5mdW5jdGlvbiogcnVuKHZhbHVlLCBzdHJ1Y3QsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgcGF0aCA9IFtdLCBicmFuY2ggPSBbdmFsdWVdLCBjb2VyY2UgPSBmYWxzZSwgbWFzayA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGN0eCA9IHsgcGF0aCwgYnJhbmNoLCBtYXNrIH07XG4gICAgaWYgKGNvZXJjZSkge1xuICAgICAgICB2YWx1ZSA9IHN0cnVjdC5jb2VyY2VyKHZhbHVlLCBjdHgpO1xuICAgIH1cbiAgICBsZXQgc3RhdHVzID0gJ3ZhbGlkJztcbiAgICBmb3IgKGNvbnN0IGZhaWx1cmUgb2Ygc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY3R4KSkge1xuICAgICAgICBmYWlsdXJlLmV4cGxhbmF0aW9uID0gb3B0aW9ucy5tZXNzYWdlO1xuICAgICAgICBzdGF0dXMgPSAnbm90X3ZhbGlkJztcbiAgICAgICAgeWllbGQgW2ZhaWx1cmUsIHVuZGVmaW5lZF07XG4gICAgfVxuICAgIGZvciAobGV0IFtrLCB2LCBzXSBvZiBzdHJ1Y3QuZW50cmllcyh2YWx1ZSwgY3R4KSkge1xuICAgICAgICBjb25zdCB0cyA9IHJ1bih2LCBzLCB7XG4gICAgICAgICAgICBwYXRoOiBrID09PSB1bmRlZmluZWQgPyBwYXRoIDogWy4uLnBhdGgsIGtdLFxuICAgICAgICAgICAgYnJhbmNoOiBrID09PSB1bmRlZmluZWQgPyBicmFuY2ggOiBbLi4uYnJhbmNoLCB2XSxcbiAgICAgICAgICAgIGNvZXJjZSxcbiAgICAgICAgICAgIG1hc2ssXG4gICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLm1lc3NhZ2UsXG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IHQgb2YgdHMpIHtcbiAgICAgICAgICAgIGlmICh0WzBdKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gdFswXS5yZWZpbmVtZW50ICE9IG51bGwgPyAnbm90X3JlZmluZWQnIDogJ25vdF92YWxpZCc7XG4gICAgICAgICAgICAgICAgeWllbGQgW3RbMF0sIHVuZGVmaW5lZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb2VyY2UpIHtcbiAgICAgICAgICAgICAgICB2ID0gdFsxXTtcbiAgICAgICAgICAgICAgICBpZiAoayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuc2V0KGssIHYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5hZGQodik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkIHx8IGsgaW4gdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtrXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzdGF0dXMgIT09ICdub3RfdmFsaWQnKSB7XG4gICAgICAgIGZvciAoY29uc3QgZmFpbHVyZSBvZiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KSkge1xuICAgICAgICAgICAgZmFpbHVyZS5leHBsYW5hdGlvbiA9IG9wdGlvbnMubWVzc2FnZTtcbiAgICAgICAgICAgIHN0YXR1cyA9ICdub3RfcmVmaW5lZCc7XG4gICAgICAgICAgICB5aWVsZCBbZmFpbHVyZSwgdW5kZWZpbmVkXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSAndmFsaWQnKSB7XG4gICAgICAgIHlpZWxkIFt1bmRlZmluZWQsIHZhbHVlXTtcbiAgICB9XG59XG5cbi8qKlxuICogYFN0cnVjdGAgb2JqZWN0cyBlbmNhcHN1bGF0ZSB0aGUgdmFsaWRhdGlvbiBsb2dpYyBmb3IgYSBzcGVjaWZpYyB0eXBlIG9mXG4gKiB2YWx1ZXMuIE9uY2UgY29uc3RydWN0ZWQsIHlvdSB1c2UgdGhlIGBhc3NlcnRgLCBgaXNgIG9yIGB2YWxpZGF0ZWAgaGVscGVycyB0b1xuICogdmFsaWRhdGUgdW5rbm93biBpbnB1dCBkYXRhIGFnYWluc3QgdGhlIHN0cnVjdC5cbiAqL1xuY2xhc3MgU3RydWN0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBjb25zdCB7IHR5cGUsIHNjaGVtYSwgdmFsaWRhdG9yLCByZWZpbmVyLCBjb2VyY2VyID0gKHZhbHVlKSA9PiB2YWx1ZSwgZW50cmllcyA9IGZ1bmN0aW9uKiAoKSB7IH0sIH0gPSBwcm9wcztcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMuZW50cmllcyA9IGVudHJpZXM7XG4gICAgICAgIHRoaXMuY29lcmNlciA9IGNvZXJjZXI7XG4gICAgICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdG9yID0gKHZhbHVlLCBjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdG9yKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRvciA9ICgpID0+IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWZpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlZmluZXIgPSAodmFsdWUsIGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZWZpbmVyKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlZmluZXIgPSAoKSA9PiBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlcnQgdGhhdCBhIHZhbHVlIHBhc3NlcyB0aGUgc3RydWN0J3MgdmFsaWRhdGlvbiwgdGhyb3dpbmcgaWYgaXQgZG9lc24ndC5cbiAgICAgKi9cbiAgICBhc3NlcnQodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIGFzc2VydCh2YWx1ZSwgdGhpcywgbWVzc2FnZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHZhbHVlIHdpdGggdGhlIHN0cnVjdCdzIGNvZXJjaW9uIGxvZ2ljLCB0aGVuIHZhbGlkYXRlIGl0LlxuICAgICAqL1xuICAgIGNyZWF0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlKHZhbHVlLCB0aGlzLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSB2YWx1ZSBwYXNzZXMgdGhlIHN0cnVjdCdzIHZhbGlkYXRpb24uXG4gICAgICovXG4gICAgaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzKHZhbHVlLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFzayBhIHZhbHVlLCBjb2VyY2luZyBhbmQgdmFsaWRhdGluZyBpdCwgYnV0IHJldHVybmluZyBvbmx5IHRoZSBzdWJzZXQgb2ZcbiAgICAgKiBwcm9wZXJ0aWVzIGRlZmluZWQgYnkgdGhlIHN0cnVjdCdzIHNjaGVtYS4gTWFza2luZyBhcHBsaWVzIHJlY3Vyc2l2ZWx5IHRvXG4gICAgICogcHJvcHMgb2YgYG9iamVjdGAgc3RydWN0cyBvbmx5LlxuICAgICAqL1xuICAgIG1hc2sodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG1hc2sodmFsdWUsIHRoaXMsIG1lc3NhZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSBhIHZhbHVlIHdpdGggdGhlIHN0cnVjdCdzIHZhbGlkYXRpb24gbG9naWMsIHJldHVybmluZyBhIHR1cGxlXG4gICAgICogcmVwcmVzZW50aW5nIHRoZSByZXN1bHQuXG4gICAgICpcbiAgICAgKiBZb3UgbWF5IG9wdGlvbmFsbHkgcGFzcyBgdHJ1ZWAgZm9yIHRoZSBgY29lcmNlYCBhcmd1bWVudCB0byBjb2VyY2VcbiAgICAgKiB0aGUgdmFsdWUgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdmFsaWRhdGUgaXQuIElmIHlvdSBkbywgdGhlIHJlc3VsdCB3aWxsXG4gICAgICogY29udGFpbiB0aGUgY29lcmNlZCByZXN1bHQgd2hlbiBzdWNjZXNzZnVsLiBBbHNvLCBgbWFza2Agd2lsbCB0dXJuIG9uXG4gICAgICogbWFza2luZyBvZiB0aGUgdW5rbm93biBgb2JqZWN0YCBwcm9wcyByZWN1cnNpdmVseSBpZiBwYXNzZWQuXG4gICAgICovXG4gICAgdmFsaWRhdGUodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUodmFsdWUsIHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cbn1cbi8qKlxuICogQXNzZXJ0IHRoYXQgYSB2YWx1ZSBwYXNzZXMgYSBzdHJ1Y3QsIHRocm93aW5nIGlmIGl0IGRvZXNuJ3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydCh2YWx1ZSwgc3RydWN0LCBtZXNzYWdlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCwgeyBtZXNzYWdlIH0pO1xuICAgIGlmIChyZXN1bHRbMF0pIHtcbiAgICAgICAgdGhyb3cgcmVzdWx0WzBdO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlIGEgdmFsdWUgd2l0aCB0aGUgY29lcmNpb24gbG9naWMgb2Ygc3RydWN0IGFuZCB2YWxpZGF0ZSBpdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlKHZhbHVlLCBzdHJ1Y3QsIG1lc3NhZ2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0LCB7IGNvZXJjZTogdHJ1ZSwgbWVzc2FnZSB9KTtcbiAgICBpZiAocmVzdWx0WzBdKSB7XG4gICAgICAgIHRocm93IHJlc3VsdFswXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHRbMV07XG4gICAgfVxufVxuLyoqXG4gKiBNYXNrIGEgdmFsdWUsIHJldHVybmluZyBvbmx5IHRoZSBzdWJzZXQgb2YgcHJvcGVydGllcyBkZWZpbmVkIGJ5IGEgc3RydWN0LlxuICovXG5mdW5jdGlvbiBtYXNrKHZhbHVlLCBzdHJ1Y3QsIG1lc3NhZ2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0LCB7IGNvZXJjZTogdHJ1ZSwgbWFzazogdHJ1ZSwgbWVzc2FnZSB9KTtcbiAgICBpZiAocmVzdWx0WzBdKSB7XG4gICAgICAgIHRocm93IHJlc3VsdFswXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHRbMV07XG4gICAgfVxufVxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIHBhc3NlcyBhIHN0cnVjdC5cbiAqL1xuZnVuY3Rpb24gaXModmFsdWUsIHN0cnVjdCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QpO1xuICAgIHJldHVybiAhcmVzdWx0WzBdO1xufVxuLyoqXG4gKiBWYWxpZGF0ZSBhIHZhbHVlIGFnYWluc3QgYSBzdHJ1Y3QsIHJldHVybmluZyBhbiBlcnJvciBpZiBpbnZhbGlkLCBvciB0aGVcbiAqIHZhbHVlICh3aXRoIHBvdGVudGlhbCBjb2VyY2lvbikgaWYgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHR1cGxlcyA9IHJ1bih2YWx1ZSwgc3RydWN0LCBvcHRpb25zKTtcbiAgICBjb25zdCB0dXBsZSA9IHNoaWZ0SXRlcmF0b3IodHVwbGVzKTtcbiAgICBpZiAodHVwbGVbMF0pIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgU3RydWN0RXJyb3IodHVwbGVbMF0sIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHQgb2YgdHVwbGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdFswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gW2Vycm9yLCB1bmRlZmluZWRdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgdiA9IHR1cGxlWzFdO1xuICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgdl07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhc3NpZ24oLi4uU3RydWN0cykge1xuICAgIGNvbnN0IGlzVHlwZSA9IFN0cnVjdHNbMF0udHlwZSA9PT0gJ3R5cGUnO1xuICAgIGNvbnN0IHNjaGVtYXMgPSBTdHJ1Y3RzLm1hcCgocykgPT4gcy5zY2hlbWEpO1xuICAgIGNvbnN0IHNjaGVtYSA9IE9iamVjdC5hc3NpZ24oe30sIC4uLnNjaGVtYXMpO1xuICAgIHJldHVybiBpc1R5cGUgPyB0eXBlKHNjaGVtYSkgOiBvYmplY3Qoc2NoZW1hKTtcbn1cbi8qKlxuICogRGVmaW5lIGEgbmV3IHN0cnVjdCB0eXBlIHdpdGggYSBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gZGVmaW5lKG5hbWUsIHZhbGlkYXRvcikge1xuICAgIHJldHVybiBuZXcgU3RydWN0KHsgdHlwZTogbmFtZSwgc2NoZW1hOiBudWxsLCB2YWxpZGF0b3IgfSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzdHJ1Y3QgYmFzZWQgb24gYW4gZXhpc3Rpbmcgc3RydWN0LCBidXQgdGhlIHZhbHVlIGlzIGFsbG93ZWQgdG9cbiAqIGJlIGB1bmRlZmluZWRgLiBgbG9nYCB3aWxsIGJlIGNhbGxlZCBpZiB0aGUgdmFsdWUgaXMgbm90IGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBkZXByZWNhdGVkKHN0cnVjdCwgbG9nKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAuLi5zdHJ1Y3QsXG4gICAgICAgIHJlZmluZXI6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpLFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZyh2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgc3RydWN0IHdpdGggZHluYW1pYyB2YWxpZGF0aW9uIGxvZ2ljLlxuICpcbiAqIFRoZSBjYWxsYmFjayB3aWxsIHJlY2VpdmUgdGhlIHZhbHVlIGN1cnJlbnRseSBiZWluZyB2YWxpZGF0ZWQsIGFuZCBtdXN0XG4gKiByZXR1cm4gYSBzdHJ1Y3Qgb2JqZWN0IHRvIHZhbGlkYXRlIGl0IHdpdGguIFRoaXMgY2FuIGJlIHVzZWZ1bCB0byBtb2RlbFxuICogdmFsaWRhdGlvbiBsb2dpYyB0aGF0IGNoYW5nZXMgYmFzZWQgb24gaXRzIGlucHV0LlxuICovXG5mdW5jdGlvbiBkeW5hbWljKGZuKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAnZHluYW1pYycsXG4gICAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgICAgKmVudHJpZXModmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgY29uc3Qgc3RydWN0ID0gZm4odmFsdWUsIGN0eCk7XG4gICAgICAgICAgICB5aWVsZCogc3RydWN0LmVudHJpZXModmFsdWUsIGN0eCk7XG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBjb25zdCBzdHJ1Y3QgPSBmbih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgICAgICB9LFxuICAgICAgICBjb2VyY2VyKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cnVjdC5jb2VyY2VyKHZhbHVlLCBjdHgpO1xuICAgICAgICB9LFxuICAgICAgICByZWZpbmVyKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBzdHJ1Y3Qgd2l0aCBsYXppbHkgZXZhbHVhdGVkIHZhbGlkYXRpb24gbG9naWMuXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdmFsaWRhdGlvbiBpcyBydW4gd2l0aCB0aGUgc3RydWN0LCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWRcbiAqIGFuZCBtdXN0IHJldHVybiBhIHN0cnVjdCBvYmplY3QgdG8gdXNlLiBUaGlzIGlzIHVzZWZ1bCBmb3IgY2FzZXMgd2hlcmUgeW91XG4gKiB3YW50IHRvIGhhdmUgc2VsZi1yZWZlcmVudGlhbCBzdHJ1Y3RzIGZvciBuZXN0ZWQgZGF0YSBzdHJ1Y3R1cmVzIHRvIGF2b2lkIGFcbiAqIGNpcmN1bGFyIGRlZmluaXRpb24gcHJvYmxlbS5cbiAqL1xuZnVuY3Rpb24gbGF6eShmbikge1xuICAgIGxldCBzdHJ1Y3Q7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAnbGF6eScsXG4gICAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgICAgKmVudHJpZXModmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgc3RydWN0ID8/IChzdHJ1Y3QgPSBmbigpKTtcbiAgICAgICAgICAgIHlpZWxkKiBzdHJ1Y3QuZW50cmllcyh2YWx1ZSwgY3R4KTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIHN0cnVjdCA/PyAoc3RydWN0ID0gZm4oKSk7XG4gICAgICAgICAgICByZXR1cm4gc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgfSxcbiAgICAgICAgY29lcmNlcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBzdHJ1Y3QgPz8gKHN0cnVjdCA9IGZuKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cnVjdC5jb2VyY2VyKHZhbHVlLCBjdHgpO1xuICAgICAgICB9LFxuICAgICAgICByZWZpbmVyKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIHN0cnVjdCA/PyAoc3RydWN0ID0gZm4oKSk7XG4gICAgICAgICAgICByZXR1cm4gc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzdHJ1Y3QgYmFzZWQgb24gYW4gZXhpc3Rpbmcgb2JqZWN0IHN0cnVjdCwgYnV0IGV4Y2x1ZGluZ1xuICogc3BlY2lmaWMgcHJvcGVydGllcy5cbiAqXG4gKiBMaWtlIFR5cGVTY3JpcHQncyBgT21pdGAgdXRpbGl0eS5cbiAqL1xuZnVuY3Rpb24gb21pdChzdHJ1Y3QsIGtleXMpIHtcbiAgICBjb25zdCB7IHNjaGVtYSB9ID0gc3RydWN0O1xuICAgIGNvbnN0IHN1YnNjaGVtYSA9IHsgLi4uc2NoZW1hIH07XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBkZWxldGUgc3Vic2NoZW1hW2tleV07XG4gICAgfVxuICAgIHN3aXRjaCAoc3RydWN0LnR5cGUpIHtcbiAgICAgICAgY2FzZSAndHlwZSc6XG4gICAgICAgICAgICByZXR1cm4gdHlwZShzdWJzY2hlbWEpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdChzdWJzY2hlbWEpO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBvYmplY3Qgc3RydWN0LCBidXQgd2l0aCBhbGwgb2YgaXRzXG4gKiBwcm9wZXJ0aWVzIGFsbG93ZWQgdG8gYmUgYHVuZGVmaW5lZGAuXG4gKlxuICogTGlrZSBUeXBlU2NyaXB0J3MgYFBhcnRpYWxgIHV0aWxpdHkuXG4gKi9cbmZ1bmN0aW9uIHBhcnRpYWwoc3RydWN0KSB7XG4gICAgY29uc3QgaXNTdHJ1Y3QgPSBzdHJ1Y3QgaW5zdGFuY2VvZiBTdHJ1Y3Q7XG4gICAgY29uc3Qgc2NoZW1hID0gaXNTdHJ1Y3QgPyB7IC4uLnN0cnVjdC5zY2hlbWEgfSA6IHsgLi4uc3RydWN0IH07XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgIHNjaGVtYVtrZXldID0gb3B0aW9uYWwoc2NoZW1hW2tleV0pO1xuICAgIH1cbiAgICBpZiAoaXNTdHJ1Y3QgJiYgc3RydWN0LnR5cGUgPT09ICd0eXBlJykge1xuICAgICAgICByZXR1cm4gdHlwZShzY2hlbWEpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0KHNjaGVtYSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzdHJ1Y3QgYmFzZWQgb24gYW4gZXhpc3Rpbmcgb2JqZWN0IHN0cnVjdCwgYnV0IG9ubHkgaW5jbHVkaW5nXG4gKiBzcGVjaWZpYyBwcm9wZXJ0aWVzLlxuICpcbiAqIExpa2UgVHlwZVNjcmlwdCdzIGBQaWNrYCB1dGlsaXR5LlxuICovXG5mdW5jdGlvbiBwaWNrKHN0cnVjdCwga2V5cykge1xuICAgIGNvbnN0IHsgc2NoZW1hIH0gPSBzdHJ1Y3Q7XG4gICAgY29uc3Qgc3Vic2NoZW1hID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBzdWJzY2hlbWFba2V5XSA9IHNjaGVtYVtrZXldO1xuICAgIH1cbiAgICBzd2l0Y2ggKHN0cnVjdC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3R5cGUnOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGUoc3Vic2NoZW1hKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Qoc3Vic2NoZW1hKTtcbiAgICB9XG59XG4vKipcbiAqIERlZmluZSBhIG5ldyBzdHJ1Y3QgdHlwZSB3aXRoIGEgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb24uXG4gKlxuICogQGRlcHJlY2F0ZWQgVGhpcyBmdW5jdGlvbiBoYXMgYmVlbiByZW5hbWVkIHRvIGBkZWZpbmVgLlxuICovXG5mdW5jdGlvbiBzdHJ1Y3QobmFtZSwgdmFsaWRhdG9yKSB7XG4gICAgY29uc29sZS53YXJuKCdzdXBlcnN0cnVjdEAwLjExIC0gVGhlIGBzdHJ1Y3RgIGhlbHBlciBoYXMgYmVlbiByZW5hbWVkIHRvIGBkZWZpbmVgLicpO1xuICAgIHJldHVybiBkZWZpbmUobmFtZSwgdmFsaWRhdG9yKTtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhbnkgdmFsdWUgcGFzc2VzIHZhbGlkYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGFueSgpIHtcbiAgICByZXR1cm4gZGVmaW5lKCdhbnknLCAoKSA9PiB0cnVlKTtcbn1cbmZ1bmN0aW9uIGFycmF5KEVsZW1lbnQpIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgIHNjaGVtYTogRWxlbWVudCxcbiAgICAgICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChFbGVtZW50ICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaSwgdl0gb2YgdmFsdWUuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFtpLCB2LCBFbGVtZW50XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLnNsaWNlKCkgOiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIGFuIGFycmF5IHZhbHVlLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgYmlnaW50LlxuICovXG5mdW5jdGlvbiBiaWdpbnQoKSB7XG4gICAgcmV0dXJuIGRlZmluZSgnYmlnaW50JywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnO1xuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgYm9vbGVhbi5cbiAqL1xuZnVuY3Rpb24gYm9vbGVhbigpIHtcbiAgICByZXR1cm4gZGVmaW5lKCdib29sZWFuJywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIHZhbGlkIGBEYXRlYC5cbiAqXG4gKiBOb3RlOiB0aGlzIGFsc28gZW5zdXJlcyB0aGF0IHRoZSB2YWx1ZSBpcyAqbm90KiBhbiBpbnZhbGlkIGBEYXRlYCBvYmplY3QsXG4gKiB3aGljaCBjYW4gb2NjdXIgd2hlbiBwYXJzaW5nIGEgZGF0ZSBmYWlscyBidXQgc3RpbGwgcmV0dXJucyBhIGBEYXRlYC5cbiAqL1xuZnVuY3Rpb24gZGF0ZSgpIHtcbiAgICByZXR1cm4gZGVmaW5lKCdkYXRlJywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiAoKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4odmFsdWUuZ2V0VGltZSgpKSkgfHxcbiAgICAgICAgICAgIGBFeHBlY3RlZCBhIHZhbGlkIFxcYERhdGVcXGAgb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZW51bXModmFsdWVzKSB7XG4gICAgY29uc3Qgc2NoZW1hID0ge307XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSB2YWx1ZXMubWFwKCh2KSA9PiBwcmludCh2KSkuam9pbigpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHZhbHVlcykge1xuICAgICAgICBzY2hlbWFba2V5XSA9IGtleTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAnZW51bXMnLFxuICAgICAgICBzY2hlbWEsXG4gICAgICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZXMuaW5jbHVkZXModmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIG9uZSBvZiBcXGAke2Rlc2NyaXB0aW9ufVxcYCwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBmdW5jKCkge1xuICAgIHJldHVybiBkZWZpbmUoJ2Z1bmMnLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgIGBFeHBlY3RlZCBhIGZ1bmN0aW9uLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGFuIGluc3RhbmNlIG9mIGEgc3BlY2lmaWMgY2xhc3MuXG4gKi9cbmZ1bmN0aW9uIGluc3RhbmNlKENsYXNzKSB7XG4gICAgcmV0dXJuIGRlZmluZSgnaW5zdGFuY2UnLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSBpbnN0YW5jZW9mIENsYXNzIHx8XG4gICAgICAgICAgICBgRXhwZWN0ZWQgYSBcXGAke0NsYXNzLm5hbWV9XFxgIGluc3RhbmNlLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGFuIGludGVnZXIuXG4gKi9cbmZ1bmN0aW9uIGludGVnZXIoKSB7XG4gICAgcmV0dXJuIGRlZmluZSgnaW50ZWdlcicsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gKCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSkgJiYgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkpIHx8XG4gICAgICAgICAgICBgRXhwZWN0ZWQgYW4gaW50ZWdlciwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBtYXRjaGVzIGFsbCBvZiBhIHNldCBvZiB0eXBlcy5cbiAqL1xuZnVuY3Rpb24gaW50ZXJzZWN0aW9uKFN0cnVjdHMpIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdpbnRlcnNlY3Rpb24nLFxuICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgICplbnRyaWVzKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgUyBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIFMuZW50cmllcyh2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgKnZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFMgb2YgU3RydWN0cykge1xuICAgICAgICAgICAgICAgIHlpZWxkKiBTLnZhbGlkYXRvcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgKnJlZmluZXIodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogUy5yZWZpbmVyKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xufVxuZnVuY3Rpb24gbGl0ZXJhbChjb25zdGFudCkge1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gcHJpbnQoY29uc3RhbnQpO1xuICAgIGNvbnN0IHQgPSB0eXBlb2YgY29uc3RhbnQ7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAnbGl0ZXJhbCcsXG4gICAgICAgIHNjaGVtYTogdCA9PT0gJ3N0cmluZycgfHwgdCA9PT0gJ251bWJlcicgfHwgdCA9PT0gJ2Jvb2xlYW4nID8gY29uc3RhbnQgOiBudWxsLFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUgPT09IGNvbnN0YW50IHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIHRoZSBsaXRlcmFsIFxcYCR7ZGVzY3JpcHRpb259XFxgLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuZnVuY3Rpb24gbWFwKEtleSwgVmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdtYXAnLFxuICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoS2V5ICYmIFZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgdmFsdWUuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFtrLCBrLCBLZXldO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBbaywgdiwgVmFsdWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTWFwID8gbmV3IE1hcCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlIGluc3RhbmNlb2YgTWFwIHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIGEgXFxgTWFwXFxgIG9iamVjdCwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgbm8gdmFsdWUgZXZlciBwYXNzZXMgdmFsaWRhdGlvbi5cbiAqL1xuZnVuY3Rpb24gbmV2ZXIoKSB7XG4gICAgcmV0dXJuIGRlZmluZSgnbmV2ZXInLCAoKSA9PiBmYWxzZSk7XG59XG4vKipcbiAqIEF1Z21lbnQgYW4gZXhpc3Rpbmcgc3RydWN0IHRvIGFsbG93IGBudWxsYCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIG51bGxhYmxlKHN0cnVjdCkge1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgLi4uc3RydWN0LFxuICAgICAgICB2YWxpZGF0b3I6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gbnVsbCB8fCBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpLFxuICAgICAgICByZWZpbmVyOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IG51bGwgfHwgc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCksXG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBudW1iZXIuXG4gKi9cbmZ1bmN0aW9uIG51bWJlcigpIHtcbiAgICByZXR1cm4gZGVmaW5lKCdudW1iZXInLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuICgodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpKSB8fFxuICAgICAgICAgICAgYEV4cGVjdGVkIGEgbnVtYmVyLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gb2JqZWN0KHNjaGVtYSkge1xuICAgIGNvbnN0IGtub3ducyA9IHNjaGVtYSA/IE9iamVjdC5rZXlzKHNjaGVtYSkgOiBbXTtcbiAgICBjb25zdCBOZXZlciA9IG5ldmVyKCk7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWEgPyBzY2hlbWEgOiBudWxsLFxuICAgICAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHNjaGVtYSAmJiBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1bmtub3ducyA9IG5ldyBTZXQoT2JqZWN0LmtleXModmFsdWUpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrbm93bnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5rbm93bnMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFtrZXksIHZhbHVlW2tleV0sIHNjaGVtYVtrZXldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdW5rbm93bnMpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgW2tleSwgdmFsdWVba2V5XSwgTmV2ZXJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKGlzTm9uQXJyYXlPYmplY3QodmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIGFuIG9iamVjdCwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29lcmNlcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBpZiAoIWlzTm9uQXJyYXlPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29lcmNlZCA9IHsgLi4udmFsdWUgfTtcbiAgICAgICAgICAgIC8vIFRoZSBgb2JqZWN0YCBzdHJ1Y3QgaGFzIHNwZWNpYWwgYmVoYXZpb3VyIGVuYWJsZWQgYnkgdGhlIG1hc2sgZmxhZy5cbiAgICAgICAgICAgIC8vIFdoZW4gbWFza2luZywgcHJvcGVydGllcyB0aGF0IGFyZSBub3QgaW4gdGhlIHNjaGVtYSBhcmUgZGVsZXRlZCBmcm9tXG4gICAgICAgICAgICAvLyB0aGUgY29lcmNlZCBvYmplY3QgaW5zdGVhZCBvZiBldmVudHVhbGx5IGZhaWxpbmcgdmFsaWRhaXRvbi5cbiAgICAgICAgICAgIGlmIChjdHgubWFzayAmJiBzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjb2VyY2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWFba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgY29lcmNlZFtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvZXJjZWQ7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIEF1Z21lbnQgYSBzdHJ1Y3QgdG8gYWxsb3cgYHVuZGVmaW5lZGAgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBvcHRpb25hbChzdHJ1Y3QpIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIC4uLnN0cnVjdCxcbiAgICAgICAgdmFsaWRhdG9yOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpLFxuICAgICAgICByZWZpbmVyOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KSxcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBrZXlzIGFuZCB2YWx1ZXMgb2Ygc3BlY2lmaWMgdHlwZXMsIGJ1dFxuICogd2l0aG91dCBlbnN1cmluZyBhbnkgc3BlY2lmaWMgc2hhcGUgb2YgcHJvcGVydGllcy5cbiAqXG4gKiBMaWtlIFR5cGVTY3JpcHQncyBgUmVjb3JkYCB1dGlsaXR5LlxuICovXG5mdW5jdGlvbiByZWNvcmQoS2V5LCBWYWx1ZSkge1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgdHlwZTogJ3JlY29yZCcsXG4gICAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHZhbHVlW2tdO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBbaywgaywgS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgW2ssIHYsIFZhbHVlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIChpc05vbkFycmF5T2JqZWN0KHZhbHVlKSB8fFxuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhbiBvYmplY3QsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpc05vbkFycmF5T2JqZWN0KHZhbHVlKSA/IHsgLi4udmFsdWUgfSA6IHZhbHVlO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgYFJlZ0V4cGAuXG4gKlxuICogTm90ZTogdGhpcyBkb2VzIG5vdCB0ZXN0IHRoZSB2YWx1ZSBhZ2FpbnN0IHRoZSByZWd1bGFyIGV4cHJlc3Npb24hIEZvciB0aGF0XG4gKiB5b3UgbmVlZCB0byB1c2UgdGhlIGBwYXR0ZXJuKClgIHJlZmluZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHJlZ2V4cCgpIHtcbiAgICByZXR1cm4gZGVmaW5lKCdyZWdleHAnLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gc2V0KEVsZW1lbnQpIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdzZXQnLFxuICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoRWxlbWVudCAmJiB2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBbdiwgdiwgRWxlbWVudF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBTZXQgPyBuZXcgU2V0KHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUgaW5zdGFuY2VvZiBTZXQgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYSBcXGBTZXRcXGAgb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBzdHJpbmcoKSB7XG4gICAgcmV0dXJuIGRlZmluZSgnc3RyaW5nJywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgYEV4cGVjdGVkIGEgc3RyaW5nLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgdHVwbGUgb2YgYSBzcGVjaWZpYyBsZW5ndGgsIGFuZCB0aGF0IGVhY2ggb2YgaXRzXG4gKiBlbGVtZW50cyBpcyBvZiBhIHNwZWNpZmljIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHR1cGxlKFN0cnVjdHMpIHtcbiAgICBjb25zdCBOZXZlciA9IG5ldmVyKCk7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAndHVwbGUnLFxuICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChTdHJ1Y3RzLmxlbmd0aCwgdmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFtpLCB2YWx1ZVtpXSwgU3RydWN0c1tpXSB8fCBOZXZlcl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYW4gYXJyYXksIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLnNsaWNlKCkgOiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBoYXMgYSBzZXQgb2Yga25vd24gcHJvcGVydGllcyBvZiBzcGVjaWZpYyB0eXBlcy5cbiAqXG4gKiBOb3RlOiBVbnJlY29nbml6ZWQgcHJvcGVydGllcyBhcmUgYWxsb3dlZCBhbmQgdW50b3VjaGVkLiBUaGlzIGlzIHNpbWlsYXIgdG9cbiAqIGhvdyBUeXBlU2NyaXB0J3Mgc3RydWN0dXJhbCB0eXBpbmcgd29ya3MuXG4gKi9cbmZ1bmN0aW9uIHR5cGUoc2NoZW1hKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNjaGVtYSk7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAndHlwZScsXG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGsgb2Yga2V5cykge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBbaywgdmFsdWVba10sIHNjaGVtYVtrXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoaXNOb25BcnJheU9iamVjdCh2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYW4gb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgICAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNOb25BcnJheU9iamVjdCh2YWx1ZSkgPyB7IC4uLnZhbHVlIH0gOiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBtYXRjaGVzIG9uZSBvZiBhIHNldCBvZiB0eXBlcy5cbiAqL1xuZnVuY3Rpb24gdW5pb24oU3RydWN0cykge1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gU3RydWN0cy5tYXAoKHMpID0+IHMudHlwZSkuam9pbignIHwgJyk7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAndW5pb24nLFxuICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgIGNvZXJjZXIodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbZXJyb3IsIGNvZXJjZWRdID0gUy52YWxpZGF0ZSh2YWx1ZSwge1xuICAgICAgICAgICAgICAgICAgICBjb2VyY2U6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG1hc2s6IGN0eC5tYXNrLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvZXJjZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgY29uc3QgZmFpbHVyZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgUyBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgWy4uLnR1cGxlc10gPSBydW4odmFsdWUsIFMsIGN0eCk7XG4gICAgICAgICAgICAgICAgY29uc3QgW2ZpcnN0XSA9IHR1cGxlcztcbiAgICAgICAgICAgICAgICBpZiAoIWZpcnN0WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2ZhaWx1cmVdIG9mIHR1cGxlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlcy5wdXNoKGZhaWx1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgdGhlIHZhbHVlIHRvIHNhdGlzZnkgYSB1bmlvbiBvZiBcXGAke2Rlc2NyaXB0aW9ufVxcYCwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gLFxuICAgICAgICAgICAgICAgIC4uLmZhaWx1cmVzLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYW55IHZhbHVlIHBhc3NlcyB2YWxpZGF0aW9uLCB3aXRob3V0IHdpZGVuaW5nIGl0cyB0eXBlIHRvIGBhbnlgLlxuICovXG5mdW5jdGlvbiB1bmtub3duKCkge1xuICAgIHJldHVybiBkZWZpbmUoJ3Vua25vd24nLCAoKSA9PiB0cnVlKTtcbn1cblxuLyoqXG4gKiBBdWdtZW50IGEgYFN0cnVjdGAgdG8gYWRkIGFuIGFkZGl0aW9uYWwgY29lcmNpb24gc3RlcCB0byBpdHMgaW5wdXQuXG4gKlxuICogVGhpcyBhbGxvd3MgeW91IHRvIHRyYW5zZm9ybSBpbnB1dCBkYXRhIGJlZm9yZSB2YWxpZGF0aW5nIGl0LCB0byBpbmNyZWFzZSB0aGVcbiAqIGxpa2VsaWhvb2QgdGhhdCBpdCBwYXNzZXMgdmFsaWRhdGlvbuKAlGZvciBleGFtcGxlIGZvciBkZWZhdWx0IHZhbHVlcywgcGFyc2luZ1xuICogZGlmZmVyZW50IGZvcm1hdHMsIGV0Yy5cbiAqXG4gKiBOb3RlOiBZb3UgbXVzdCB1c2UgYGNyZWF0ZSh2YWx1ZSwgU3RydWN0KWAgb24gdGhlIHZhbHVlIHRvIGhhdmUgdGhlIGNvZXJjaW9uXG4gKiB0YWtlIGVmZmVjdCEgVXNpbmcgc2ltcGx5IGBhc3NlcnQoKWAgb3IgYGlzKClgIHdpbGwgbm90IHVzZSBjb2VyY2lvbi5cbiAqL1xuZnVuY3Rpb24gY29lcmNlKHN0cnVjdCwgY29uZGl0aW9uLCBjb2VyY2VyKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAuLi5zdHJ1Y3QsXG4gICAgICAgIGNvZXJjZXI6ICh2YWx1ZSwgY3R4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaXModmFsdWUsIGNvbmRpdGlvbilcbiAgICAgICAgICAgICAgICA/IHN0cnVjdC5jb2VyY2VyKGNvZXJjZXIodmFsdWUsIGN0eCksIGN0eClcbiAgICAgICAgICAgICAgICA6IHN0cnVjdC5jb2VyY2VyKHZhbHVlLCBjdHgpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBBdWdtZW50IGEgc3RydWN0IHRvIHJlcGxhY2UgYHVuZGVmaW5lZGAgdmFsdWVzIHdpdGggYSBkZWZhdWx0LlxuICpcbiAqIE5vdGU6IFlvdSBtdXN0IHVzZSBgY3JlYXRlKHZhbHVlLCBTdHJ1Y3QpYCBvbiB0aGUgdmFsdWUgdG8gaGF2ZSB0aGUgY29lcmNpb25cbiAqIHRha2UgZWZmZWN0ISBVc2luZyBzaW1wbHkgYGFzc2VydCgpYCBvciBgaXMoKWAgd2lsbCBub3QgdXNlIGNvZXJjaW9uLlxuICovXG5mdW5jdGlvbiBkZWZhdWx0ZWQoc3RydWN0LCBmYWxsYmFjaywgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIGNvZXJjZShzdHJ1Y3QsIHVua25vd24oKSwgKHgpID0+IHtcbiAgICAgICAgY29uc3QgZiA9IHR5cGVvZiBmYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IGZhbGxiYWNrKCkgOiBmYWxsYmFjaztcbiAgICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRpb25zLnN0cmljdCAmJiBpc1BsYWluT2JqZWN0KHgpICYmIGlzUGxhaW5PYmplY3QoZikpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHsgLi4ueCB9O1xuICAgICAgICAgICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGYpIHtcbiAgICAgICAgICAgICAgICBpZiAocmV0W2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXRba2V5XSA9IGZba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgIH0pO1xufVxuLyoqXG4gKiBBdWdtZW50IGEgc3RydWN0IHRvIHRyaW0gc3RyaW5nIGlucHV0cy5cbiAqXG4gKiBOb3RlOiBZb3UgbXVzdCB1c2UgYGNyZWF0ZSh2YWx1ZSwgU3RydWN0KWAgb24gdGhlIHZhbHVlIHRvIGhhdmUgdGhlIGNvZXJjaW9uXG4gKiB0YWtlIGVmZmVjdCEgVXNpbmcgc2ltcGx5IGBhc3NlcnQoKWAgb3IgYGlzKClgIHdpbGwgbm90IHVzZSBjb2VyY2lvbi5cbiAqL1xuZnVuY3Rpb24gdHJpbW1lZChzdHJ1Y3QpIHtcbiAgICByZXR1cm4gY29lcmNlKHN0cnVjdCwgc3RyaW5nKCksICh4KSA9PiB4LnRyaW0oKSk7XG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgYSBzdHJpbmcsIGFycmF5LCBtYXAsIG9yIHNldCBpcyBlbXB0eS5cbiAqL1xuZnVuY3Rpb24gZW1wdHkoc3RydWN0KSB7XG4gICAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdlbXB0eScsICh2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBzaXplID0gZ2V0U2l6ZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiAoc2l6ZSA9PT0gMCB8fFxuICAgICAgICAgICAgYEV4cGVjdGVkIGFuIGVtcHR5ICR7c3RydWN0LnR5cGV9IGJ1dCByZWNlaXZlZCBvbmUgd2l0aCBhIHNpemUgb2YgXFxgJHtzaXplfVxcYGApO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0U2l6ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCB8fCB2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICByZXR1cm4gdmFsdWUuc2l6ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGg7XG4gICAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIG51bWJlciBvciBkYXRlIGlzIGJlbG93IGEgdGhyZXNob2xkLlxuICovXG5mdW5jdGlvbiBtYXgoc3RydWN0LCB0aHJlc2hvbGQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgZXhjbHVzaXZlIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiByZWZpbmUoc3RydWN0LCAnbWF4JywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiBleGNsdXNpdmVcbiAgICAgICAgICAgID8gdmFsdWUgPCB0aHJlc2hvbGRcbiAgICAgICAgICAgIDogdmFsdWUgPD0gdGhyZXNob2xkIHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIGEgJHtzdHJ1Y3QudHlwZX0gbGVzcyB0aGFuICR7ZXhjbHVzaXZlID8gJycgOiAnb3IgZXF1YWwgdG8gJ30ke3RocmVzaG9sZH0gYnV0IHJlY2VpdmVkIFxcYCR7dmFsdWV9XFxgYDtcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSBudW1iZXIgb3IgZGF0ZSBpcyBhYm92ZSBhIHRocmVzaG9sZC5cbiAqL1xuZnVuY3Rpb24gbWluKHN0cnVjdCwgdGhyZXNob2xkLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGV4Y2x1c2l2ZSB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ21pbicsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gZXhjbHVzaXZlXG4gICAgICAgICAgICA/IHZhbHVlID4gdGhyZXNob2xkXG4gICAgICAgICAgICA6IHZhbHVlID49IHRocmVzaG9sZCB8fFxuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhICR7c3RydWN0LnR5cGV9IGdyZWF0ZXIgdGhhbiAke2V4Y2x1c2l2ZSA/ICcnIDogJ29yIGVxdWFsIHRvICd9JHt0aHJlc2hvbGR9IGJ1dCByZWNlaXZlZCBcXGAke3ZhbHVlfVxcYGA7XG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nLCBhcnJheSwgbWFwIG9yIHNldCBpcyBub3QgZW1wdHkuXG4gKi9cbmZ1bmN0aW9uIG5vbmVtcHR5KHN0cnVjdCkge1xuICAgIHJldHVybiByZWZpbmUoc3RydWN0LCAnbm9uZW1wdHknLCAodmFsdWUpID0+IHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGdldFNpemUodmFsdWUpO1xuICAgICAgICByZXR1cm4gKHNpemUgPiAwIHx8IGBFeHBlY3RlZCBhIG5vbmVtcHR5ICR7c3RydWN0LnR5cGV9IGJ1dCByZWNlaXZlZCBhbiBlbXB0eSBvbmVgKTtcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSBzdHJpbmcgbWF0Y2hlcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqL1xuZnVuY3Rpb24gcGF0dGVybihzdHJ1Y3QsIHJlZ2V4cCkge1xuICAgIHJldHVybiByZWZpbmUoc3RydWN0LCAncGF0dGVybicsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gKHJlZ2V4cC50ZXN0KHZhbHVlKSB8fFxuICAgICAgICAgICAgYEV4cGVjdGVkIGEgJHtzdHJ1Y3QudHlwZX0gbWF0Y2hpbmcgXFxgLyR7cmVnZXhwLnNvdXJjZX0vXFxgIGJ1dCByZWNlaXZlZCBcIiR7dmFsdWV9XCJgKTtcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSBzdHJpbmcsIGFycmF5LCBudW1iZXIsIGRhdGUsIG1hcCwgb3Igc2V0IGhhcyBhIHNpemUgKG9yIGxlbmd0aCwgb3IgdGltZSkgYmV0d2VlbiBgbWluYCBhbmQgYG1heGAuXG4gKi9cbmZ1bmN0aW9uIHNpemUoc3RydWN0LCBtaW4sIG1heCA9IG1pbikge1xuICAgIGNvbnN0IGV4cGVjdGVkID0gYEV4cGVjdGVkIGEgJHtzdHJ1Y3QudHlwZX1gO1xuICAgIGNvbnN0IG9mID0gbWluID09PSBtYXggPyBgb2YgXFxgJHttaW59XFxgYCA6IGBiZXR3ZWVuIFxcYCR7bWlufVxcYCBhbmQgXFxgJHttYXh9XFxgYDtcbiAgICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ3NpemUnLCAodmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gKChtaW4gPD0gdmFsdWUgJiYgdmFsdWUgPD0gbWF4KSB8fFxuICAgICAgICAgICAgICAgIGAke2V4cGVjdGVkfSAke29mfSBidXQgcmVjZWl2ZWQgXFxgJHt2YWx1ZX1cXGBgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCB8fCB2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgY29uc3QgeyBzaXplIH0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiAoKG1pbiA8PSBzaXplICYmIHNpemUgPD0gbWF4KSB8fFxuICAgICAgICAgICAgICAgIGAke2V4cGVjdGVkfSB3aXRoIGEgc2l6ZSAke29mfSBidXQgcmVjZWl2ZWQgb25lIHdpdGggYSBzaXplIG9mIFxcYCR7c2l6ZX1cXGBgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiAoKG1pbiA8PSBsZW5ndGggJiYgbGVuZ3RoIDw9IG1heCkgfHxcbiAgICAgICAgICAgICAgICBgJHtleHBlY3RlZH0gd2l0aCBhIGxlbmd0aCAke29mfSBidXQgcmVjZWl2ZWQgb25lIHdpdGggYSBsZW5ndGggb2YgXFxgJHtsZW5ndGh9XFxgYCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuICogQXVnbWVudCBhIGBTdHJ1Y3RgIHRvIGFkZCBhbiBhZGRpdGlvbmFsIHJlZmluZW1lbnQgdG8gdGhlIHZhbGlkYXRpb24uXG4gKlxuICogVGhlIHJlZmluZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZWNlaXZlIGEgdmFsdWUgb2YgdGhlIHN0cnVjdCdzIHR5cGUsXG4gKiBiZWNhdXNlIHRoZSBzdHJ1Y3QncyBleGlzdGluZyB2YWxpZGF0aW9uIHdpbGwgYWxyZWFkeSBoYXZlIHBhc3NlZC4gVGhpc1xuICogYWxsb3dzIHlvdSB0byBsYXllciBhZGRpdGlvbmFsIHZhbGlkYXRpb24gb24gdG9wIG9mIGV4aXN0aW5nIHN0cnVjdHMuXG4gKi9cbmZ1bmN0aW9uIHJlZmluZShzdHJ1Y3QsIG5hbWUsIHJlZmluZXIpIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIC4uLnN0cnVjdCxcbiAgICAgICAgKnJlZmluZXIodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgeWllbGQqIHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVzID0gdG9GYWlsdXJlcyhyZXN1bHQsIGN0eCwgc3RydWN0LCB2YWx1ZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZhaWx1cmUgb2YgZmFpbHVyZXMpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB7IC4uLmZhaWx1cmUsIHJlZmluZW1lbnQ6IG5hbWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuZXhwb3J0IHsgU3RydWN0LCBTdHJ1Y3RFcnJvciwgYW55LCBhcnJheSwgYXNzZXJ0LCBhc3NpZ24sIGJpZ2ludCwgYm9vbGVhbiwgY29lcmNlLCBjcmVhdGUsIGRhdGUsIGRlZmF1bHRlZCwgZGVmaW5lLCBkZXByZWNhdGVkLCBkeW5hbWljLCBlbXB0eSwgZW51bXMsIGZ1bmMsIGluc3RhbmNlLCBpbnRlZ2VyLCBpbnRlcnNlY3Rpb24sIGlzLCBsYXp5LCBsaXRlcmFsLCBtYXAsIG1hc2ssIG1heCwgbWluLCBuZXZlciwgbm9uZW1wdHksIG51bGxhYmxlLCBudW1iZXIsIG9iamVjdCwgb21pdCwgb3B0aW9uYWwsIHBhcnRpYWwsIHBhdHRlcm4sIHBpY2ssIHJlY29yZCwgcmVmaW5lLCByZWdleHAsIHNldCwgc2l6ZSwgc3RyaW5nLCBzdHJ1Y3QsIHRyaW1tZWQsIHR1cGxlLCB0eXBlLCB1bmlvbiwgdW5rbm93biwgdmFsaWRhdGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6WyJTdHJ1Y3RFcnJvciIsIlR5cGVFcnJvciIsImNvbnN0cnVjdG9yIiwiZmFpbHVyZSIsImZhaWx1cmVzIiwiY2FjaGVkIiwibWVzc2FnZSIsImV4cGxhbmF0aW9uIiwicmVzdCIsInBhdGgiLCJtc2ciLCJsZW5ndGgiLCJqb2luIiwiY2F1c2UiLCJPYmplY3QiLCJhc3NpZ24iLCJuYW1lIiwiaXNJdGVyYWJsZSIsIngiLCJpc09iamVjdCIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiaXNOb25BcnJheU9iamVjdCIsIkFycmF5IiwiaXNBcnJheSIsImlzUGxhaW5PYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJnZXRQcm90b3R5cGVPZiIsInByaW50IiwidmFsdWUiLCJKU09OIiwic3RyaW5naWZ5Iiwic2hpZnRJdGVyYXRvciIsImlucHV0IiwiZG9uZSIsIm5leHQiLCJ1bmRlZmluZWQiLCJ0b0ZhaWx1cmUiLCJyZXN1bHQiLCJjb250ZXh0Iiwic3RydWN0IiwiYnJhbmNoIiwidHlwZSIsInJlZmluZW1lbnQiLCJrZXkiLCJ0b0ZhaWx1cmVzIiwiciIsInJ1biIsIm9wdGlvbnMiLCJjb2VyY2UiLCJtYXNrIiwiY3R4IiwiY29lcmNlciIsInN0YXR1cyIsInZhbGlkYXRvciIsImsiLCJ2IiwicyIsImVudHJpZXMiLCJ0cyIsInQiLCJNYXAiLCJzZXQiLCJTZXQiLCJhZGQiLCJyZWZpbmVyIiwiU3RydWN0IiwicHJvcHMiLCJzY2hlbWEiLCJhc3NlcnQiLCJjcmVhdGUiLCJpcyIsInZhbGlkYXRlIiwidHVwbGVzIiwidHVwbGUiLCJlcnJvciIsIlN0cnVjdHMiLCJpc1R5cGUiLCJzY2hlbWFzIiwibWFwIiwib2JqZWN0IiwiZGVmaW5lIiwiZGVwcmVjYXRlZCIsImxvZyIsImR5bmFtaWMiLCJmbiIsImxhenkiLCJvbWl0Iiwia2V5cyIsInN1YnNjaGVtYSIsInBhcnRpYWwiLCJpc1N0cnVjdCIsIm9wdGlvbmFsIiwicGljayIsImNvbnNvbGUiLCJ3YXJuIiwiYW55IiwiYXJyYXkiLCJFbGVtZW50IiwiaSIsInNsaWNlIiwiYmlnaW50IiwiYm9vbGVhbiIsImRhdGUiLCJEYXRlIiwiaXNOYU4iLCJnZXRUaW1lIiwiZW51bXMiLCJ2YWx1ZXMiLCJkZXNjcmlwdGlvbiIsImluY2x1ZGVzIiwiZnVuYyIsImluc3RhbmNlIiwiQ2xhc3MiLCJpbnRlZ2VyIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiaW50ZXJzZWN0aW9uIiwiUyIsImxpdGVyYWwiLCJjb25zdGFudCIsIktleSIsIlZhbHVlIiwibmV2ZXIiLCJudWxsYWJsZSIsIm51bWJlciIsImtub3ducyIsIk5ldmVyIiwidW5rbm93bnMiLCJkZWxldGUiLCJjb2VyY2VkIiwicmVjb3JkIiwicmVnZXhwIiwiUmVnRXhwIiwic3RyaW5nIiwiTWF0aCIsIm1heCIsInVuaW9uIiwiZmlyc3QiLCJwdXNoIiwidW5rbm93biIsImNvbmRpdGlvbiIsImRlZmF1bHRlZCIsImZhbGxiYWNrIiwiZiIsInN0cmljdCIsInJldCIsImNoYW5nZWQiLCJ0cmltbWVkIiwidHJpbSIsImVtcHR5IiwicmVmaW5lIiwic2l6ZSIsImdldFNpemUiLCJ0aHJlc2hvbGQiLCJleGNsdXNpdmUiLCJtaW4iLCJub25lbXB0eSIsInBhdHRlcm4iLCJ0ZXN0Iiwic291cmNlIiwiZXhwZWN0ZWQiLCJvZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/node_modules/@solana/web3.js/node_modules/superstruct/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/node_modules/rpc-websockets/dist/index.mjs":
/*!************************************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/node_modules/rpc-websockets/dist/index.mjs ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* binding */ Client),\n/* harmony export */   CommonClient: () => (/* binding */ CommonClient),\n/* harmony export */   DefaultDataPack: () => (/* binding */ DefaultDataPack),\n/* harmony export */   Server: () => (/* binding */ Server),\n/* harmony export */   WebSocket: () => (/* binding */ WebSocket),\n/* harmony export */   createError: () => (/* binding */ createError)\n/* harmony export */ });\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ws */ \"(ssr)/../node_modules/ws/wrapper.mjs\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! eventemitter3 */ \"(ssr)/../node_modules/@coral-xyz/anchor/node_modules/rpc-websockets/node_modules/eventemitter3/index.mjs\");\n/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:url */ \"node:url\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uuid */ \"(ssr)/../node_modules/uuid/dist/esm-node/v1.js\");\n\n\n\n\n// src/lib/client/websocket.ts\nfunction WebSocket(address, options) {\n    return new ws__WEBPACK_IMPORTED_MODULE_0__[\"default\"](address, options);\n}\n// src/lib/utils.ts\nvar DefaultDataPack = class {\n    encode(value) {\n        return JSON.stringify(value);\n    }\n    decode(value) {\n        return JSON.parse(value);\n    }\n};\n// src/lib/client.ts\nvar CommonClient = class extends eventemitter3__WEBPACK_IMPORTED_MODULE_1__.EventEmitter {\n    /**\n  * Instantiate a Client class.\n  * @constructor\n  * @param {webSocketFactory} webSocketFactory - factory method for WebSocket\n  * @param {String} address - url to a websocket server\n  * @param {Object} options - ws options object with reconnect parameters\n  * @param {Function} generate_request_id - custom generation request Id\n  * @param {DataPack} dataPack - data pack contains encoder and decoder\n  * @return {CommonClient}\n  */ constructor(webSocketFactory, address = \"ws://localhost:8080\", { autoconnect = true, reconnect = true, reconnect_interval = 1e3, max_reconnects = 5, ...rest_options } = {}, generate_request_id, dataPack){\n        super();\n        this.webSocketFactory = webSocketFactory;\n        this.queue = {};\n        this.rpc_id = 0;\n        this.address = address;\n        this.autoconnect = autoconnect;\n        this.ready = false;\n        this.reconnect = reconnect;\n        this.reconnect_timer_id = void 0;\n        this.reconnect_interval = reconnect_interval;\n        this.max_reconnects = max_reconnects;\n        this.rest_options = rest_options;\n        this.current_reconnects = 0;\n        this.generate_request_id = generate_request_id || (()=>typeof this.rpc_id === \"number\" ? ++this.rpc_id : Number(this.rpc_id) + 1);\n        if (!dataPack) this.dataPack = new DefaultDataPack();\n        else this.dataPack = dataPack;\n        if (this.autoconnect) this._connect(this.address, {\n            autoconnect: this.autoconnect,\n            reconnect: this.reconnect,\n            reconnect_interval: this.reconnect_interval,\n            max_reconnects: this.max_reconnects,\n            ...this.rest_options\n        });\n    }\n    /**\n  * Connects to a defined server if not connected already.\n  * @method\n  * @return {Undefined}\n  */ connect() {\n        if (this.socket) return;\n        this._connect(this.address, {\n            autoconnect: this.autoconnect,\n            reconnect: this.reconnect,\n            reconnect_interval: this.reconnect_interval,\n            max_reconnects: this.max_reconnects,\n            ...this.rest_options\n        });\n    }\n    /**\n  * Calls a registered RPC method on server.\n  * @method\n  * @param {String} method - RPC method name\n  * @param {Object|Array} params - optional method parameters\n  * @param {Number} timeout - RPC reply timeout value\n  * @param {Object} ws_opts - options passed to ws\n  * @return {Promise}\n  */ call(method, params, timeout, ws_opts) {\n        if (!ws_opts && \"object\" === typeof timeout) {\n            ws_opts = timeout;\n            timeout = null;\n        }\n        return new Promise((resolve, reject)=>{\n            if (!this.ready) return reject(new Error(\"socket not ready\"));\n            const rpc_id = this.generate_request_id(method, params);\n            const message = {\n                jsonrpc: \"2.0\",\n                method,\n                params: params || void 0,\n                id: rpc_id\n            };\n            this.socket.send(this.dataPack.encode(message), ws_opts, (error)=>{\n                if (error) return reject(error);\n                this.queue[rpc_id] = {\n                    promise: [\n                        resolve,\n                        reject\n                    ]\n                };\n                if (timeout) {\n                    this.queue[rpc_id].timeout = setTimeout(()=>{\n                        delete this.queue[rpc_id];\n                        reject(new Error(\"reply timeout\"));\n                    }, timeout);\n                }\n            });\n        });\n    }\n    /**\n  * Logins with the other side of the connection.\n  * @method\n  * @param {Object} params - Login credentials object\n  * @return {Promise}\n  */ async login(params) {\n        const resp = await this.call(\"rpc.login\", params);\n        if (!resp) throw new Error(\"authentication failed\");\n        return resp;\n    }\n    /**\n  * Fetches a list of client's methods registered on server.\n  * @method\n  * @return {Array}\n  */ async listMethods() {\n        return await this.call(\"__listMethods\");\n    }\n    /**\n  * Sends a JSON-RPC 2.0 notification to server.\n  * @method\n  * @param {String} method - RPC method name\n  * @param {Object} params - optional method parameters\n  * @return {Promise}\n  */ notify(method, params) {\n        return new Promise((resolve, reject)=>{\n            if (!this.ready) return reject(new Error(\"socket not ready\"));\n            const message = {\n                jsonrpc: \"2.0\",\n                method,\n                params\n            };\n            this.socket.send(this.dataPack.encode(message), (error)=>{\n                if (error) return reject(error);\n                resolve();\n            });\n        });\n    }\n    /**\n  * Subscribes for a defined event.\n  * @method\n  * @param {String|Array} event - event name\n  * @return {Undefined}\n  * @throws {Error}\n  */ async subscribe(event) {\n        if (typeof event === \"string\") event = [\n            event\n        ];\n        const result = await this.call(\"rpc.on\", event);\n        if (typeof event === \"string\" && result[event] !== \"ok\") throw new Error(\"Failed subscribing to an event '\" + event + \"' with: \" + result[event]);\n        return result;\n    }\n    /**\n  * Unsubscribes from a defined event.\n  * @method\n  * @param {String|Array} event - event name\n  * @return {Undefined}\n  * @throws {Error}\n  */ async unsubscribe(event) {\n        if (typeof event === \"string\") event = [\n            event\n        ];\n        const result = await this.call(\"rpc.off\", event);\n        if (typeof event === \"string\" && result[event] !== \"ok\") throw new Error(\"Failed unsubscribing from an event with: \" + result);\n        return result;\n    }\n    /**\n  * Closes a WebSocket connection gracefully.\n  * @method\n  * @param {Number} code - socket close code\n  * @param {String} data - optional data to be sent before closing\n  * @return {Undefined}\n  */ close(code, data) {\n        this.socket.close(code || 1e3, data);\n    }\n    /**\n  * Enable / disable automatic reconnection.\n  * @method\n  * @param {Boolean} reconnect - enable / disable reconnection\n  * @return {Undefined}\n  */ setAutoReconnect(reconnect) {\n        this.reconnect = reconnect;\n    }\n    /**\n  * Set the interval between reconnection attempts.\n  * @method\n  * @param {Number} interval - reconnection interval in milliseconds\n  * @return {Undefined}\n  */ setReconnectInterval(interval) {\n        this.reconnect_interval = interval;\n    }\n    /**\n  * Set the maximum number of reconnection attempts.\n  * @method\n  * @param {Number} max_reconnects - maximum reconnection attempts\n  * @return {Undefined}\n  */ setMaxReconnects(max_reconnects) {\n        this.max_reconnects = max_reconnects;\n    }\n    /**\n  * Connection/Message handler.\n  * @method\n  * @private\n  * @param {String} address - WebSocket API address\n  * @param {Object} options - ws options object\n  * @return {Undefined}\n  */ _connect(address, options) {\n        clearTimeout(this.reconnect_timer_id);\n        this.socket = this.webSocketFactory(address, options);\n        this.socket.addEventListener(\"open\", ()=>{\n            this.ready = true;\n            this.emit(\"open\");\n            this.current_reconnects = 0;\n        });\n        this.socket.addEventListener(\"message\", ({ data: message })=>{\n            if (message instanceof ArrayBuffer) message = Buffer.from(message).toString();\n            try {\n                message = this.dataPack.decode(message);\n            } catch (error) {\n                return;\n            }\n            if (message.notification && this.listeners(message.notification).length) {\n                if (!Object.keys(message.params).length) return this.emit(message.notification);\n                const args = [\n                    message.notification\n                ];\n                if (message.params.constructor === Object) args.push(message.params);\n                else for(let i = 0; i < message.params.length; i++)args.push(message.params[i]);\n                return Promise.resolve().then(()=>{\n                    this.emit.apply(this, args);\n                });\n            }\n            if (!this.queue[message.id]) {\n                if (message.method) {\n                    return Promise.resolve().then(()=>{\n                        this.emit(message.method, message?.params);\n                    });\n                }\n                return;\n            }\n            if (\"error\" in message === \"result\" in message) this.queue[message.id].promise[1](new Error('Server response malformed. Response must include either \"result\" or \"error\", but not both.'));\n            if (this.queue[message.id].timeout) clearTimeout(this.queue[message.id].timeout);\n            if (message.error) this.queue[message.id].promise[1](message.error);\n            else this.queue[message.id].promise[0](message.result);\n            delete this.queue[message.id];\n        });\n        this.socket.addEventListener(\"error\", (error)=>this.emit(\"error\", error));\n        this.socket.addEventListener(\"close\", ({ code, reason })=>{\n            if (this.ready) setTimeout(()=>this.emit(\"close\", code, reason), 0);\n            this.ready = false;\n            this.socket = void 0;\n            if (code === 1e3) return;\n            this.current_reconnects++;\n            if (this.reconnect && (this.max_reconnects > this.current_reconnects || this.max_reconnects === 0)) this.reconnect_timer_id = setTimeout(()=>this._connect(address, options), this.reconnect_interval);\n        });\n    }\n};\nvar Server = class extends eventemitter3__WEBPACK_IMPORTED_MODULE_1__.EventEmitter {\n    /**\n  * Instantiate a Server class.\n  * @constructor\n  * @param {Object} options - ws constructor's parameters with rpc\n  * @param {DataPack} dataPack - data pack contains encoder and decoder\n  * @return {Server} - returns a new Server instance\n  */ constructor(options, dataPack){\n        super();\n        this.namespaces = {};\n        if (!dataPack) this.dataPack = new DefaultDataPack();\n        else this.dataPack = dataPack;\n        this.wss = new ws__WEBPACK_IMPORTED_MODULE_0__.WebSocketServer(options);\n        this.wss.on(\"listening\", ()=>this.emit(\"listening\"));\n        this.wss.on(\"connection\", (socket, request)=>{\n            const u = node_url__WEBPACK_IMPORTED_MODULE_2__.parse(request.url, true);\n            const ns = u.pathname;\n            if (u.query.socket_id) socket._id = u.query.socket_id;\n            else socket._id = (0,uuid__WEBPACK_IMPORTED_MODULE_3__[\"default\"])();\n            socket[\"_authenticated\"] = false;\n            socket.on(\"error\", (error)=>this.emit(\"socket-error\", socket, error));\n            socket.on(\"close\", ()=>{\n                this.namespaces[ns].clients.delete(socket._id);\n                for (const event of Object.keys(this.namespaces[ns].events)){\n                    const index = this.namespaces[ns].events[event].sockets.indexOf(socket._id);\n                    if (index >= 0) this.namespaces[ns].events[event].sockets.splice(index, 1);\n                }\n                this.emit(\"disconnection\", socket);\n            });\n            if (!this.namespaces[ns]) this._generateNamespace(ns);\n            this.namespaces[ns].clients.set(socket._id, socket);\n            this.emit(\"connection\", socket, request);\n            return this._handleRPC(socket, ns);\n        });\n        this.wss.on(\"error\", (error)=>this.emit(\"error\", error));\n    }\n    /**\n  * Registers an RPC method.\n  * @method\n  * @param {String} name - method name\n  * @param {Function} fn - a callee function\n  * @param {String} ns - namespace identifier\n  * @throws {TypeError}\n  * @return {Object} - returns an IMethod object\n  */ register(name, fn, ns = \"/\") {\n        if (!this.namespaces[ns]) this._generateNamespace(ns);\n        this.namespaces[ns].rpc_methods[name] = {\n            fn,\n            protected: false\n        };\n        return {\n            protected: ()=>this._makeProtectedMethod(name, ns),\n            public: ()=>this._makePublicMethod(name, ns)\n        };\n    }\n    /**\n  * Sets an auth method.\n  * @method\n  * @param {Function} fn - an arbitrary auth method\n  * @param {String} ns - namespace identifier\n  * @throws {TypeError}\n  * @return {Undefined}\n  */ setAuth(fn, ns = \"/\") {\n        this.register(\"rpc.login\", fn, ns);\n    }\n    /**\n  * Marks an RPC method as protected.\n  * @method\n  * @param {String} name - method name\n  * @param {String} ns - namespace identifier\n  * @return {Undefined}\n  */ _makeProtectedMethod(name, ns = \"/\") {\n        this.namespaces[ns].rpc_methods[name].protected = true;\n    }\n    /**\n  * Marks an RPC method as public.\n  * @method\n  * @param {String} name - method name\n  * @param {String} ns - namespace identifier\n  * @return {Undefined}\n  */ _makePublicMethod(name, ns = \"/\") {\n        this.namespaces[ns].rpc_methods[name].protected = false;\n    }\n    /**\n  * Marks an event as protected.\n  * @method\n  * @param {String} name - event name\n  * @param {String} ns - namespace identifier\n  * @return {Undefined}\n  */ _makeProtectedEvent(name, ns = \"/\") {\n        this.namespaces[ns].events[name].protected = true;\n    }\n    /**\n  * Marks an event as public.\n  * @method\n  * @param {String} name - event name\n  * @param {String} ns - namespace identifier\n  * @return {Undefined}\n  */ _makePublicEvent(name, ns = \"/\") {\n        this.namespaces[ns].events[name].protected = false;\n    }\n    /**\n  * Removes a namespace and closes all connections\n  * @method\n  * @param {String} ns - namespace identifier\n  * @throws {TypeError}\n  * @return {Undefined}\n  */ closeNamespace(ns) {\n        const namespace = this.namespaces[ns];\n        if (namespace) {\n            delete namespace.rpc_methods;\n            delete namespace.events;\n            for (const socket of namespace.clients.values())socket.close();\n            delete this.namespaces[ns];\n        }\n    }\n    /**\n  * Creates a new event that can be emitted to clients.\n  * @method\n  * @param {String} name - event name\n  * @param {String} ns - namespace identifier\n  * @throws {TypeError}\n  * @return {Object} - returns an IEvent object\n  */ event(name, ns = \"/\") {\n        if (!this.namespaces[ns]) this._generateNamespace(ns);\n        else {\n            const index = this.namespaces[ns].events[name];\n            if (index !== void 0) throw new Error(`Already registered event ${ns}${name}`);\n        }\n        this.namespaces[ns].events[name] = {\n            sockets: [],\n            protected: false\n        };\n        this.on(name, (...params)=>{\n            if (params.length === 1 && params[0] instanceof Object) params = params[0];\n            for (const socket_id of this.namespaces[ns].events[name].sockets){\n                const socket = this.namespaces[ns].clients.get(socket_id);\n                if (!socket) continue;\n                socket.send(this.dataPack.encode({\n                    notification: name,\n                    params\n                }));\n            }\n        });\n        return {\n            protected: ()=>this._makeProtectedEvent(name, ns),\n            public: ()=>this._makePublicEvent(name, ns)\n        };\n    }\n    /**\n  * Returns a requested namespace object\n  * @method\n  * @param {String} name - namespace identifier\n  * @throws {TypeError}\n  * @return {Object} - namespace object\n  */ of(name) {\n        if (!this.namespaces[name]) this._generateNamespace(name);\n        const self = this;\n        return {\n            // self.register convenience method\n            register (fn_name, fn) {\n                if (arguments.length !== 2) throw new Error(\"must provide exactly two arguments\");\n                if (typeof fn_name !== \"string\") throw new Error(\"name must be a string\");\n                if (typeof fn !== \"function\") throw new Error(\"handler must be a function\");\n                return self.register(fn_name, fn, name);\n            },\n            // self.event convenience method\n            event (ev_name) {\n                if (arguments.length !== 1) throw new Error(\"must provide exactly one argument\");\n                if (typeof ev_name !== \"string\") throw new Error(\"name must be a string\");\n                return self.event(ev_name, name);\n            },\n            // self.eventList convenience method\n            get eventList () {\n                return Object.keys(self.namespaces[name].events);\n            },\n            /**\n      * Emits a specified event to this namespace.\n      * @inner\n      * @method\n      * @param {String} event - event name\n      * @param {Array} params - event parameters\n      * @return {Undefined}\n      */ emit (event, ...params) {\n                const socket_ids = [\n                    ...self.namespaces[name].clients.keys()\n                ];\n                for(let i = 0, id; id = socket_ids[i]; ++i){\n                    self.namespaces[name].clients.get(id).send(self.dataPack.encode({\n                        notification: event,\n                        params: params || []\n                    }));\n                }\n            },\n            /**\n      * Returns a name of this namespace.\n      * @inner\n      * @method\n      * @kind constant\n      * @return {String}\n      */ get name () {\n                return name;\n            },\n            /**\n      * Returns a hash of websocket objects connected to this namespace.\n      * @inner\n      * @method\n      * @return {Object}\n      */ connected () {\n                const socket_ids = [\n                    ...self.namespaces[name].clients.keys()\n                ];\n                return socket_ids.reduce((acc, curr)=>({\n                        ...acc,\n                        [curr]: self.namespaces[name].clients.get(curr)\n                    }), {});\n            },\n            /**\n      * Returns a list of client unique identifiers connected to this namespace.\n      * @inner\n      * @method\n      * @return {Array}\n      */ clients () {\n                return self.namespaces[name];\n            }\n        };\n    }\n    /**\n  * Lists all created events in a given namespace. Defaults to \"/\".\n  * @method\n  * @param {String} ns - namespaces identifier\n  * @readonly\n  * @return {Array} - returns a list of created events\n  */ eventList(ns = \"/\") {\n        if (!this.namespaces[ns]) return [];\n        return Object.keys(this.namespaces[ns].events);\n    }\n    /**\n  * Creates a JSON-RPC 2.0 compliant error\n  * @method\n  * @param {Number} code - indicates the error type that occurred\n  * @param {String} message - provides a short description of the error\n  * @param {String|Object} data - details containing additional information about the error\n  * @return {Object}\n  */ createError(code, message, data) {\n        return {\n            code,\n            message,\n            data: data || null\n        };\n    }\n    /**\n  * Closes the server and terminates all clients.\n  * @method\n  * @return {Promise}\n  */ close() {\n        return new Promise((resolve, reject)=>{\n            try {\n                this.wss.close();\n                this.emit(\"close\");\n                resolve();\n            } catch (error) {\n                reject(error);\n            }\n        });\n    }\n    /**\n  * Handles all WebSocket JSON RPC 2.0 requests.\n  * @private\n  * @param {Object} socket - ws socket instance\n  * @param {String} ns - namespaces identifier\n  * @return {Undefined}\n  */ _handleRPC(socket, ns = \"/\") {\n        socket.on(\"message\", async (data)=>{\n            const msg_options = {};\n            if (data instanceof ArrayBuffer) {\n                msg_options.binary = true;\n                data = Buffer.from(data).toString();\n            }\n            if (socket.readyState !== 1) return;\n            let parsedData;\n            try {\n                parsedData = this.dataPack.decode(data);\n            } catch (error) {\n                return socket.send(this.dataPack.encode({\n                    jsonrpc: \"2.0\",\n                    error: createError(-32700, error.toString()),\n                    id: null\n                }), msg_options);\n            }\n            if (Array.isArray(parsedData)) {\n                if (!parsedData.length) return socket.send(this.dataPack.encode({\n                    jsonrpc: \"2.0\",\n                    error: createError(-32600, \"Invalid array\"),\n                    id: null\n                }), msg_options);\n                const responses = [];\n                for (const message of parsedData){\n                    const response2 = await this._runMethod(message, socket._id, ns);\n                    if (!response2) continue;\n                    responses.push(response2);\n                }\n                if (!responses.length) return;\n                return socket.send(this.dataPack.encode(responses), msg_options);\n            }\n            const response = await this._runMethod(parsedData, socket._id, ns);\n            if (!response) return;\n            return socket.send(this.dataPack.encode(response), msg_options);\n        });\n    }\n    /**\n  * Runs a defined RPC method.\n  * @private\n  * @param {Object} message - a message received\n  * @param {Object} socket_id - user's socket id\n  * @param {String} ns - namespaces identifier\n  * @return {Object|undefined}\n  */ async _runMethod(message, socket_id, ns = \"/\") {\n        if (typeof message !== \"object\" || message === null) return {\n            jsonrpc: \"2.0\",\n            error: createError(-32600),\n            id: null\n        };\n        if (message.jsonrpc !== \"2.0\") return {\n            jsonrpc: \"2.0\",\n            error: createError(-32600, \"Invalid JSON RPC version\"),\n            id: message.id || null\n        };\n        if (!message.method) return {\n            jsonrpc: \"2.0\",\n            error: createError(-32602, \"Method not specified\"),\n            id: message.id || null\n        };\n        if (typeof message.method !== \"string\") return {\n            jsonrpc: \"2.0\",\n            error: createError(-32600, \"Invalid method name\"),\n            id: message.id || null\n        };\n        if (message.params && typeof message.params === \"string\") return {\n            jsonrpc: \"2.0\",\n            error: createError(-32600),\n            id: message.id || null\n        };\n        if (message.method === \"rpc.on\") {\n            if (!message.params) return {\n                jsonrpc: \"2.0\",\n                error: createError(-32e3),\n                id: message.id || null\n            };\n            const results = {};\n            const event_names = Object.keys(this.namespaces[ns].events);\n            for (const name of message.params){\n                const index = event_names.indexOf(name);\n                const namespace = this.namespaces[ns];\n                if (index === -1) {\n                    results[name] = \"provided event invalid\";\n                    continue;\n                }\n                if (namespace.events[event_names[index]].protected === true && namespace.clients.get(socket_id)[\"_authenticated\"] === false) {\n                    return {\n                        jsonrpc: \"2.0\",\n                        error: createError(-32606),\n                        id: message.id || null\n                    };\n                }\n                const socket_index = namespace.events[event_names[index]].sockets.indexOf(socket_id);\n                if (socket_index >= 0) {\n                    results[name] = \"socket has already been subscribed to event\";\n                    continue;\n                }\n                namespace.events[event_names[index]].sockets.push(socket_id);\n                results[name] = \"ok\";\n            }\n            return {\n                jsonrpc: \"2.0\",\n                result: results,\n                id: message.id || null\n            };\n        } else if (message.method === \"rpc.off\") {\n            if (!message.params) return {\n                jsonrpc: \"2.0\",\n                error: createError(-32e3),\n                id: message.id || null\n            };\n            const results = {};\n            for (const name of message.params){\n                if (!this.namespaces[ns].events[name]) {\n                    results[name] = \"provided event invalid\";\n                    continue;\n                }\n                const index = this.namespaces[ns].events[name].sockets.indexOf(socket_id);\n                if (index === -1) {\n                    results[name] = \"not subscribed\";\n                    continue;\n                }\n                this.namespaces[ns].events[name].sockets.splice(index, 1);\n                results[name] = \"ok\";\n            }\n            return {\n                jsonrpc: \"2.0\",\n                result: results,\n                id: message.id || null\n            };\n        } else if (message.method === \"rpc.login\") {\n            if (!message.params) return {\n                jsonrpc: \"2.0\",\n                error: createError(-32604),\n                id: message.id || null\n            };\n        }\n        if (!this.namespaces[ns].rpc_methods[message.method]) {\n            return {\n                jsonrpc: \"2.0\",\n                error: createError(-32601),\n                id: message.id || null\n            };\n        }\n        let response = null;\n        if (this.namespaces[ns].rpc_methods[message.method].protected === true && this.namespaces[ns].clients.get(socket_id)[\"_authenticated\"] === false) {\n            return {\n                jsonrpc: \"2.0\",\n                error: createError(-32605),\n                id: message.id || null\n            };\n        }\n        try {\n            response = await this.namespaces[ns].rpc_methods[message.method].fn(message.params, socket_id);\n        } catch (error) {\n            if (!message.id) return;\n            if (error instanceof Error) return {\n                jsonrpc: \"2.0\",\n                error: {\n                    code: -32e3,\n                    message: error.name,\n                    data: error.message\n                },\n                id: message.id\n            };\n            return {\n                jsonrpc: \"2.0\",\n                error,\n                id: message.id\n            };\n        }\n        if (!message.id) return;\n        if (message.method === \"rpc.login\" && response === true) {\n            const s = this.namespaces[ns].clients.get(socket_id);\n            s[\"_authenticated\"] = true;\n            this.namespaces[ns].clients.set(socket_id, s);\n        }\n        return {\n            jsonrpc: \"2.0\",\n            result: response,\n            id: message.id\n        };\n    }\n    /**\n  * Generate a new namespace store.\n  * Also preregister some special namespace methods.\n  * @private\n  * @param {String} name - namespaces identifier\n  * @return {undefined}\n  */ _generateNamespace(name) {\n        this.namespaces[name] = {\n            rpc_methods: {\n                __listMethods: {\n                    fn: ()=>Object.keys(this.namespaces[name].rpc_methods),\n                    protected: false\n                }\n            },\n            clients: /* @__PURE__ */ new Map(),\n            events: {}\n        };\n    }\n};\nvar RPC_ERRORS = /* @__PURE__ */ new Map([\n    [\n        -32e3,\n        \"Event not provided\"\n    ],\n    [\n        -32600,\n        \"Invalid Request\"\n    ],\n    [\n        -32601,\n        \"Method not found\"\n    ],\n    [\n        -32602,\n        \"Invalid params\"\n    ],\n    [\n        -32603,\n        \"Internal error\"\n    ],\n    [\n        -32604,\n        \"Params not found\"\n    ],\n    [\n        -32605,\n        \"Method forbidden\"\n    ],\n    [\n        -32606,\n        \"Event forbidden\"\n    ],\n    [\n        -32700,\n        \"Parse error\"\n    ]\n]);\nfunction createError(code, details) {\n    const error = {\n        code,\n        message: RPC_ERRORS.get(code) || \"Internal Server Error\"\n    };\n    if (details) error[\"data\"] = details;\n    return error;\n}\n// src/index.ts\nvar Client = class extends CommonClient {\n    constructor(address = \"ws://localhost:8080\", { autoconnect = true, reconnect = true, reconnect_interval = 1e3, max_reconnects = 5, ...rest_options } = {}, generate_request_id){\n        super(WebSocket, address, {\n            autoconnect,\n            reconnect,\n            reconnect_interval,\n            max_reconnects,\n            ...rest_options\n        }, generate_request_id);\n    }\n};\n //# sourceMappingURL=out.js.map\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL25vZGVfbW9kdWxlcy9ycGMtd2Vic29ja2V0cy9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQW9EO0FBQ1A7QUFDbEI7QUFDRDtBQUUxQiw4QkFBOEI7QUFDOUIsU0FBU0ssVUFBVUMsT0FBTyxFQUFFQyxPQUFPO0lBQ2pDLE9BQU8sSUFBSVAsMENBQWFBLENBQUNNLFNBQVNDO0FBQ3BDO0FBRUEsbUJBQW1CO0FBQ25CLElBQUlDLGtCQUFrQjtJQUNwQkMsT0FBT0MsS0FBSyxFQUFFO1FBQ1osT0FBT0MsS0FBS0MsU0FBUyxDQUFDRjtJQUN4QjtJQUNBRyxPQUFPSCxLQUFLLEVBQUU7UUFDWixPQUFPQyxLQUFLRyxLQUFLLENBQUNKO0lBQ3BCO0FBQ0Y7QUFFQSxvQkFBb0I7QUFDcEIsSUFBSUssZUFBZSxjQUFjYix1REFBWUE7SUFpQjNDOzs7Ozs7Ozs7RUFTQSxHQUNBYyxZQUFZQyxnQkFBZ0IsRUFBRVgsVUFBVSxxQkFBcUIsRUFBRSxFQUM3RFksY0FBYyxJQUFJLEVBQ2xCQyxZQUFZLElBQUksRUFDaEJDLHFCQUFxQixHQUFHLEVBQ3hCQyxpQkFBaUIsQ0FBQyxFQUNsQixHQUFHQyxjQUNKLEdBQUcsQ0FBQyxDQUFDLEVBQUVDLG1CQUFtQixFQUFFQyxRQUFRLENBQUU7UUFDckMsS0FBSztRQUNMLElBQUksQ0FBQ1AsZ0JBQWdCLEdBQUdBO1FBQ3hCLElBQUksQ0FBQ1EsS0FBSyxHQUFHLENBQUM7UUFDZCxJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ3BCLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNZLFdBQVcsR0FBR0E7UUFDbkIsSUFBSSxDQUFDUyxLQUFLLEdBQUc7UUFDYixJQUFJLENBQUNSLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDUyxrQkFBa0IsR0FBRyxLQUFLO1FBQy9CLElBQUksQ0FBQ1Isa0JBQWtCLEdBQUdBO1FB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SUFDQSxJQUFJeUYsU0FBU3JHLEtBQUssQ0FBQyxPQUFPLEdBQUdxRztJQUM3QixPQUFPckc7QUFDVDtBQUVBLGVBQWU7QUFDZixJQUFJc0csU0FBUyxjQUFjdEk7SUFDekJDLFlBQVlWLFVBQVUscUJBQXFCLEVBQUUsRUFDM0NZLGNBQWMsSUFBSSxFQUNsQkMsWUFBWSxJQUFJLEVBQ2hCQyxxQkFBcUIsR0FBRyxFQUN4QkMsaUJBQWlCLENBQUMsRUFDbEIsR0FBR0MsY0FDSixHQUFHLENBQUMsQ0FBQyxFQUFFQyxtQkFBbUIsQ0FBRTtRQUMzQixLQUFLLENBQ0hsQixXQUNBQyxTQUNBO1lBQ0VZO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0EsR0FBR0MsWUFBWTtRQUNqQixHQUNBQztJQUVKO0FBQ0Y7QUFFaUYsQ0FDakYsK0JBQStCO0NBQy9CLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGNvcmFsLXh5ei9hbmNob3Ivbm9kZV9tb2R1bGVzL3JwYy13ZWJzb2NrZXRzL2Rpc3QvaW5kZXgubWpzP2VmNWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFdlYlNvY2tldEltcGwsIHsgV2ViU29ja2V0U2VydmVyIH0gZnJvbSAnd3MnO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRlbWl0dGVyMyc7XG5pbXBvcnQgdXJsIGZyb20gJ25vZGU6dXJsJztcbmltcG9ydCB7IHYxIH0gZnJvbSAndXVpZCc7XG5cbi8vIHNyYy9saWIvY2xpZW50L3dlYnNvY2tldC50c1xuZnVuY3Rpb24gV2ViU29ja2V0KGFkZHJlc3MsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBXZWJTb2NrZXRJbXBsKGFkZHJlc3MsIG9wdGlvbnMpO1xufVxuXG4vLyBzcmMvbGliL3V0aWxzLnRzXG52YXIgRGVmYXVsdERhdGFQYWNrID0gY2xhc3Mge1xuICBlbmNvZGUodmFsdWUpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICB9XG4gIGRlY29kZSh2YWx1ZSkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgfVxufTtcblxuLy8gc3JjL2xpYi9jbGllbnQudHNcbnZhciBDb21tb25DbGllbnQgPSBjbGFzcyBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGFkZHJlc3M7XG4gIHJwY19pZDtcbiAgcXVldWU7XG4gIG9wdGlvbnM7XG4gIGF1dG9jb25uZWN0O1xuICByZWFkeTtcbiAgcmVjb25uZWN0O1xuICByZWNvbm5lY3RfdGltZXJfaWQ7XG4gIHJlY29ubmVjdF9pbnRlcnZhbDtcbiAgbWF4X3JlY29ubmVjdHM7XG4gIHJlc3Rfb3B0aW9ucztcbiAgY3VycmVudF9yZWNvbm5lY3RzO1xuICBnZW5lcmF0ZV9yZXF1ZXN0X2lkO1xuICBzb2NrZXQ7XG4gIHdlYlNvY2tldEZhY3Rvcnk7XG4gIGRhdGFQYWNrO1xuICAvKipcbiAgKiBJbnN0YW50aWF0ZSBhIENsaWVudCBjbGFzcy5cbiAgKiBAY29uc3RydWN0b3JcbiAgKiBAcGFyYW0ge3dlYlNvY2tldEZhY3Rvcnl9IHdlYlNvY2tldEZhY3RvcnkgLSBmYWN0b3J5IG1ldGhvZCBmb3IgV2ViU29ja2V0XG4gICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgLSB1cmwgdG8gYSB3ZWJzb2NrZXQgc2VydmVyXG4gICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSB3cyBvcHRpb25zIG9iamVjdCB3aXRoIHJlY29ubmVjdCBwYXJhbWV0ZXJzXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gZ2VuZXJhdGVfcmVxdWVzdF9pZCAtIGN1c3RvbSBnZW5lcmF0aW9uIHJlcXVlc3QgSWRcbiAgKiBAcGFyYW0ge0RhdGFQYWNrfSBkYXRhUGFjayAtIGRhdGEgcGFjayBjb250YWlucyBlbmNvZGVyIGFuZCBkZWNvZGVyXG4gICogQHJldHVybiB7Q29tbW9uQ2xpZW50fVxuICAqL1xuICBjb25zdHJ1Y3Rvcih3ZWJTb2NrZXRGYWN0b3J5LCBhZGRyZXNzID0gXCJ3czovL2xvY2FsaG9zdDo4MDgwXCIsIHtcbiAgICBhdXRvY29ubmVjdCA9IHRydWUsXG4gICAgcmVjb25uZWN0ID0gdHJ1ZSxcbiAgICByZWNvbm5lY3RfaW50ZXJ2YWwgPSAxZTMsXG4gICAgbWF4X3JlY29ubmVjdHMgPSA1LFxuICAgIC4uLnJlc3Rfb3B0aW9uc1xuICB9ID0ge30sIGdlbmVyYXRlX3JlcXVlc3RfaWQsIGRhdGFQYWNrKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLndlYlNvY2tldEZhY3RvcnkgPSB3ZWJTb2NrZXRGYWN0b3J5O1xuICAgIHRoaXMucXVldWUgPSB7fTtcbiAgICB0aGlzLnJwY19pZCA9IDA7XG4gICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcztcbiAgICB0aGlzLmF1dG9jb25uZWN0ID0gYXV0b2Nvbm5lY3Q7XG4gICAgdGhpcy5yZWFkeSA9IGZhbHNlO1xuICAgIHRoaXMucmVjb25uZWN0ID0gcmVjb25uZWN0O1xuICAgIHRoaXMucmVjb25uZWN0X3RpbWVyX2lkID0gdm9pZCAwO1xuICAgIHRoaXMucmVjb25uZWN0X2ludGVydmFsID0gcmVjb25uZWN0X2ludGVydmFsO1xuICAgIHRoaXMubWF4X3JlY29ubmVjdHMgPSBtYXhfcmVjb25uZWN0cztcbiAgICB0aGlzLnJlc3Rfb3B0aW9ucyA9IHJlc3Rfb3B0aW9ucztcbiAgICB0aGlzLmN1cnJlbnRfcmVjb25uZWN0cyA9IDA7XG4gICAgdGhpcy5nZW5lcmF0ZV9yZXF1ZXN0X2lkID0gZ2VuZXJhdGVfcmVxdWVzdF9pZCB8fCAoKCkgPT4gdHlwZW9mIHRoaXMucnBjX2lkID09PSBcIm51bWJlclwiID8gKyt0aGlzLnJwY19pZCA6IE51bWJlcih0aGlzLnJwY19pZCkgKyAxKTtcbiAgICBpZiAoIWRhdGFQYWNrKSB0aGlzLmRhdGFQYWNrID0gbmV3IERlZmF1bHREYXRhUGFjaygpO1xuICAgIGVsc2UgdGhpcy5kYXRhUGFjayA9IGRhdGFQYWNrO1xuICAgIGlmICh0aGlzLmF1dG9jb25uZWN0KVxuICAgICAgdGhpcy5fY29ubmVjdCh0aGlzLmFkZHJlc3MsIHtcbiAgICAgICAgYXV0b2Nvbm5lY3Q6IHRoaXMuYXV0b2Nvbm5lY3QsXG4gICAgICAgIHJlY29ubmVjdDogdGhpcy5yZWNvbm5lY3QsXG4gICAgICAgIHJlY29ubmVjdF9pbnRlcnZhbDogdGhpcy5yZWNvbm5lY3RfaW50ZXJ2YWwsXG4gICAgICAgIG1heF9yZWNvbm5lY3RzOiB0aGlzLm1heF9yZWNvbm5lY3RzLFxuICAgICAgICAuLi50aGlzLnJlc3Rfb3B0aW9uc1xuICAgICAgfSk7XG4gIH1cbiAgLyoqXG4gICogQ29ubmVjdHMgdG8gYSBkZWZpbmVkIHNlcnZlciBpZiBub3QgY29ubmVjdGVkIGFscmVhZHkuXG4gICogQG1ldGhvZFxuICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgKi9cbiAgY29ubmVjdCgpIHtcbiAgICBpZiAodGhpcy5zb2NrZXQpIHJldHVybjtcbiAgICB0aGlzLl9jb25uZWN0KHRoaXMuYWRkcmVzcywge1xuICAgICAgYXV0b2Nvbm5lY3Q6IHRoaXMuYXV0b2Nvbm5lY3QsXG4gICAgICByZWNvbm5lY3Q6IHRoaXMucmVjb25uZWN0LFxuICAgICAgcmVjb25uZWN0X2ludGVydmFsOiB0aGlzLnJlY29ubmVjdF9pbnRlcnZhbCxcbiAgICAgIG1heF9yZWNvbm5lY3RzOiB0aGlzLm1heF9yZWNvbm5lY3RzLFxuICAgICAgLi4udGhpcy5yZXN0X29wdGlvbnNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBDYWxscyBhIHJlZ2lzdGVyZWQgUlBDIG1ldGhvZCBvbiBzZXJ2ZXIuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgLSBSUEMgbWV0aG9kIG5hbWVcbiAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gcGFyYW1zIC0gb3B0aW9uYWwgbWV0aG9kIHBhcmFtZXRlcnNcbiAgKiBAcGFyYW0ge051bWJlcn0gdGltZW91dCAtIFJQQyByZXBseSB0aW1lb3V0IHZhbHVlXG4gICogQHBhcmFtIHtPYmplY3R9IHdzX29wdHMgLSBvcHRpb25zIHBhc3NlZCB0byB3c1xuICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG4gIGNhbGwobWV0aG9kLCBwYXJhbXMsIHRpbWVvdXQsIHdzX29wdHMpIHtcbiAgICBpZiAoIXdzX29wdHMgJiYgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHRpbWVvdXQpIHtcbiAgICAgIHdzX29wdHMgPSB0aW1lb3V0O1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIXRoaXMucmVhZHkpIHJldHVybiByZWplY3QobmV3IEVycm9yKFwic29ja2V0IG5vdCByZWFkeVwiKSk7XG4gICAgICBjb25zdCBycGNfaWQgPSB0aGlzLmdlbmVyYXRlX3JlcXVlc3RfaWQobWV0aG9kLCBwYXJhbXMpO1xuICAgICAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBwYXJhbXM6IHBhcmFtcyB8fCB2b2lkIDAsXG4gICAgICAgIGlkOiBycGNfaWRcbiAgICAgIH07XG4gICAgICB0aGlzLnNvY2tldC5zZW5kKHRoaXMuZGF0YVBhY2suZW5jb2RlKG1lc3NhZ2UpLCB3c19vcHRzLCAoZXJyb3IpID0+IHtcbiAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgdGhpcy5xdWV1ZVtycGNfaWRdID0geyBwcm9taXNlOiBbcmVzb2x2ZSwgcmVqZWN0XSB9O1xuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIHRoaXMucXVldWVbcnBjX2lkXS50aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5xdWV1ZVtycGNfaWRdO1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcInJlcGx5IHRpbWVvdXRcIikpO1xuICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBMb2dpbnMgd2l0aCB0aGUgb3RoZXIgc2lkZSBvZiB0aGUgY29ubmVjdGlvbi5cbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIExvZ2luIGNyZWRlbnRpYWxzIG9iamVjdFxuICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG4gIGFzeW5jIGxvZ2luKHBhcmFtcykge1xuICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLmNhbGwoXCJycGMubG9naW5cIiwgcGFyYW1zKTtcbiAgICBpZiAoIXJlc3ApIHRocm93IG5ldyBFcnJvcihcImF1dGhlbnRpY2F0aW9uIGZhaWxlZFwiKTtcbiAgICByZXR1cm4gcmVzcDtcbiAgfVxuICAvKipcbiAgKiBGZXRjaGVzIGEgbGlzdCBvZiBjbGllbnQncyBtZXRob2RzIHJlZ2lzdGVyZWQgb24gc2VydmVyLlxuICAqIEBtZXRob2RcbiAgKiBAcmV0dXJuIHtBcnJheX1cbiAgKi9cbiAgYXN5bmMgbGlzdE1ldGhvZHMoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuY2FsbChcIl9fbGlzdE1ldGhvZHNcIik7XG4gIH1cbiAgLyoqXG4gICogU2VuZHMgYSBKU09OLVJQQyAyLjAgbm90aWZpY2F0aW9uIHRvIHNlcnZlci5cbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCAtIFJQQyBtZXRob2QgbmFtZVxuICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBvcHRpb25hbCBtZXRob2QgcGFyYW1ldGVyc1xuICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG4gIG5vdGlmeShtZXRob2QsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIXRoaXMucmVhZHkpIHJldHVybiByZWplY3QobmV3IEVycm9yKFwic29ja2V0IG5vdCByZWFkeVwiKSk7XG4gICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIHBhcmFtc1xuICAgICAgfTtcbiAgICAgIHRoaXMuc29ja2V0LnNlbmQodGhpcy5kYXRhUGFjay5lbmNvZGUobWVzc2FnZSksIChlcnJvcikgPT4ge1xuICAgICAgICBpZiAoZXJyb3IpIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBTdWJzY3JpYmVzIGZvciBhIGRlZmluZWQgZXZlbnQuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBldmVudCAtIGV2ZW50IG5hbWVcbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICogQHRocm93cyB7RXJyb3J9XG4gICovXG4gIGFzeW5jIHN1YnNjcmliZShldmVudCkge1xuICAgIGlmICh0eXBlb2YgZXZlbnQgPT09IFwic3RyaW5nXCIpIGV2ZW50ID0gW2V2ZW50XTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNhbGwoXCJycGMub25cIiwgZXZlbnQpO1xuICAgIGlmICh0eXBlb2YgZXZlbnQgPT09IFwic3RyaW5nXCIgJiYgcmVzdWx0W2V2ZW50XSAhPT0gXCJva1wiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkZhaWxlZCBzdWJzY3JpYmluZyB0byBhbiBldmVudCAnXCIgKyBldmVudCArIFwiJyB3aXRoOiBcIiArIHJlc3VsdFtldmVudF1cbiAgICAgICk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgKiBVbnN1YnNjcmliZXMgZnJvbSBhIGRlZmluZWQgZXZlbnQuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBldmVudCAtIGV2ZW50IG5hbWVcbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICogQHRocm93cyB7RXJyb3J9XG4gICovXG4gIGFzeW5jIHVuc3Vic2NyaWJlKGV2ZW50KSB7XG4gICAgaWYgKHR5cGVvZiBldmVudCA9PT0gXCJzdHJpbmdcIikgZXZlbnQgPSBbZXZlbnRdO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY2FsbChcInJwYy5vZmZcIiwgZXZlbnQpO1xuICAgIGlmICh0eXBlb2YgZXZlbnQgPT09IFwic3RyaW5nXCIgJiYgcmVzdWx0W2V2ZW50XSAhPT0gXCJva1wiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHVuc3Vic2NyaWJpbmcgZnJvbSBhbiBldmVudCB3aXRoOiBcIiArIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgKiBDbG9zZXMgYSBXZWJTb2NrZXQgY29ubmVjdGlvbiBncmFjZWZ1bGx5LlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge051bWJlcn0gY29kZSAtIHNvY2tldCBjbG9zZSBjb2RlXG4gICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgLSBvcHRpb25hbCBkYXRhIHRvIGJlIHNlbnQgYmVmb3JlIGNsb3NpbmdcbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICovXG4gIGNsb3NlKGNvZGUsIGRhdGEpIHtcbiAgICB0aGlzLnNvY2tldC5jbG9zZShjb2RlIHx8IDFlMywgZGF0YSk7XG4gIH1cbiAgLyoqXG4gICogRW5hYmxlIC8gZGlzYWJsZSBhdXRvbWF0aWMgcmVjb25uZWN0aW9uLlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlY29ubmVjdCAtIGVuYWJsZSAvIGRpc2FibGUgcmVjb25uZWN0aW9uXG4gICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAqL1xuICBzZXRBdXRvUmVjb25uZWN0KHJlY29ubmVjdCkge1xuICAgIHRoaXMucmVjb25uZWN0ID0gcmVjb25uZWN0O1xuICB9XG4gIC8qKlxuICAqIFNldCB0aGUgaW50ZXJ2YWwgYmV0d2VlbiByZWNvbm5lY3Rpb24gYXR0ZW1wdHMuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7TnVtYmVyfSBpbnRlcnZhbCAtIHJlY29ubmVjdGlvbiBpbnRlcnZhbCBpbiBtaWxsaXNlY29uZHNcbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICovXG4gIHNldFJlY29ubmVjdEludGVydmFsKGludGVydmFsKSB7XG4gICAgdGhpcy5yZWNvbm5lY3RfaW50ZXJ2YWwgPSBpbnRlcnZhbDtcbiAgfVxuICAvKipcbiAgKiBTZXQgdGhlIG1heGltdW0gbnVtYmVyIG9mIHJlY29ubmVjdGlvbiBhdHRlbXB0cy5cbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtOdW1iZXJ9IG1heF9yZWNvbm5lY3RzIC0gbWF4aW11bSByZWNvbm5lY3Rpb24gYXR0ZW1wdHNcbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICovXG4gIHNldE1heFJlY29ubmVjdHMobWF4X3JlY29ubmVjdHMpIHtcbiAgICB0aGlzLm1heF9yZWNvbm5lY3RzID0gbWF4X3JlY29ubmVjdHM7XG4gIH1cbiAgLyoqXG4gICogQ29ubmVjdGlvbi9NZXNzYWdlIGhhbmRsZXIuXG4gICogQG1ldGhvZFxuICAqIEBwcml2YXRlXG4gICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgLSBXZWJTb2NrZXQgQVBJIGFkZHJlc3NcbiAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHdzIG9wdGlvbnMgb2JqZWN0XG4gICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAqL1xuICBfY29ubmVjdChhZGRyZXNzLCBvcHRpb25zKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0X3RpbWVyX2lkKTtcbiAgICB0aGlzLnNvY2tldCA9IHRoaXMud2ViU29ja2V0RmFjdG9yeShhZGRyZXNzLCBvcHRpb25zKTtcbiAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwib3BlblwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMuZW1pdChcIm9wZW5cIik7XG4gICAgICB0aGlzLmN1cnJlbnRfcmVjb25uZWN0cyA9IDA7XG4gICAgfSk7XG4gICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKHsgZGF0YTogbWVzc2FnZSB9KSA9PiB7XG4gICAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuICAgICAgICBtZXNzYWdlID0gQnVmZmVyLmZyb20obWVzc2FnZSkudG9TdHJpbmcoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1lc3NhZ2UgPSB0aGlzLmRhdGFQYWNrLmRlY29kZShtZXNzYWdlKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLm5vdGlmaWNhdGlvbiAmJiB0aGlzLmxpc3RlbmVycyhtZXNzYWdlLm5vdGlmaWNhdGlvbikubGVuZ3RoKSB7XG4gICAgICAgIGlmICghT2JqZWN0LmtleXMobWVzc2FnZS5wYXJhbXMpLmxlbmd0aClcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KG1lc3NhZ2Uubm90aWZpY2F0aW9uKTtcbiAgICAgICAgY29uc3QgYXJncyA9IFttZXNzYWdlLm5vdGlmaWNhdGlvbl07XG4gICAgICAgIGlmIChtZXNzYWdlLnBhcmFtcy5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSBhcmdzLnB1c2gobWVzc2FnZS5wYXJhbXMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLnBhcmFtcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGFyZ3MucHVzaChtZXNzYWdlLnBhcmFtc1tpXSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnF1ZXVlW21lc3NhZ2UuaWRdKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLm1ldGhvZCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChtZXNzYWdlLm1ldGhvZCwgbWVzc2FnZT8ucGFyYW1zKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoXCJlcnJvclwiIGluIG1lc3NhZ2UgPT09IFwicmVzdWx0XCIgaW4gbWVzc2FnZSlcbiAgICAgICAgdGhpcy5xdWV1ZVttZXNzYWdlLmlkXS5wcm9taXNlWzFdKFxuICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICdTZXJ2ZXIgcmVzcG9uc2UgbWFsZm9ybWVkLiBSZXNwb25zZSBtdXN0IGluY2x1ZGUgZWl0aGVyIFwicmVzdWx0XCIgb3IgXCJlcnJvclwiLCBidXQgbm90IGJvdGguJ1xuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIGlmICh0aGlzLnF1ZXVlW21lc3NhZ2UuaWRdLnRpbWVvdXQpXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnF1ZXVlW21lc3NhZ2UuaWRdLnRpbWVvdXQpO1xuICAgICAgaWYgKG1lc3NhZ2UuZXJyb3IpIHRoaXMucXVldWVbbWVzc2FnZS5pZF0ucHJvbWlzZVsxXShtZXNzYWdlLmVycm9yKTtcbiAgICAgIGVsc2UgdGhpcy5xdWV1ZVttZXNzYWdlLmlkXS5wcm9taXNlWzBdKG1lc3NhZ2UucmVzdWx0KTtcbiAgICAgIGRlbGV0ZSB0aGlzLnF1ZXVlW21lc3NhZ2UuaWRdO1xuICAgIH0pO1xuICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoZXJyb3IpID0+IHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKSk7XG4gICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsICh7IGNvZGUsIHJlYXNvbiB9KSA9PiB7XG4gICAgICBpZiAodGhpcy5yZWFkeSlcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmVtaXQoXCJjbG9zZVwiLCBjb2RlLCByZWFzb24pLCAwKTtcbiAgICAgIHRoaXMucmVhZHkgPSBmYWxzZTtcbiAgICAgIHRoaXMuc29ja2V0ID0gdm9pZCAwO1xuICAgICAgaWYgKGNvZGUgPT09IDFlMykgcmV0dXJuO1xuICAgICAgdGhpcy5jdXJyZW50X3JlY29ubmVjdHMrKztcbiAgICAgIGlmICh0aGlzLnJlY29ubmVjdCAmJiAodGhpcy5tYXhfcmVjb25uZWN0cyA+IHRoaXMuY3VycmVudF9yZWNvbm5lY3RzIHx8IHRoaXMubWF4X3JlY29ubmVjdHMgPT09IDApKVxuICAgICAgICB0aGlzLnJlY29ubmVjdF90aW1lcl9pZCA9IHNldFRpbWVvdXQoXG4gICAgICAgICAgKCkgPT4gdGhpcy5fY29ubmVjdChhZGRyZXNzLCBvcHRpb25zKSxcbiAgICAgICAgICB0aGlzLnJlY29ubmVjdF9pbnRlcnZhbFxuICAgICAgICApO1xuICAgIH0pO1xuICB9XG59O1xudmFyIFNlcnZlciA9IGNsYXNzIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgbmFtZXNwYWNlcztcbiAgZGF0YVBhY2s7XG4gIHdzcztcbiAgLyoqXG4gICogSW5zdGFudGlhdGUgYSBTZXJ2ZXIgY2xhc3MuXG4gICogQGNvbnN0cnVjdG9yXG4gICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSB3cyBjb25zdHJ1Y3RvcidzIHBhcmFtZXRlcnMgd2l0aCBycGNcbiAgKiBAcGFyYW0ge0RhdGFQYWNrfSBkYXRhUGFjayAtIGRhdGEgcGFjayBjb250YWlucyBlbmNvZGVyIGFuZCBkZWNvZGVyXG4gICogQHJldHVybiB7U2VydmVyfSAtIHJldHVybnMgYSBuZXcgU2VydmVyIGluc3RhbmNlXG4gICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGRhdGFQYWNrKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5hbWVzcGFjZXMgPSB7fTtcbiAgICBpZiAoIWRhdGFQYWNrKSB0aGlzLmRhdGFQYWNrID0gbmV3IERlZmF1bHREYXRhUGFjaygpO1xuICAgIGVsc2UgdGhpcy5kYXRhUGFjayA9IGRhdGFQYWNrO1xuICAgIHRoaXMud3NzID0gbmV3IFdlYlNvY2tldFNlcnZlcihvcHRpb25zKTtcbiAgICB0aGlzLndzcy5vbihcImxpc3RlbmluZ1wiLCAoKSA9PiB0aGlzLmVtaXQoXCJsaXN0ZW5pbmdcIikpO1xuICAgIHRoaXMud3NzLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0LCByZXF1ZXN0KSA9PiB7XG4gICAgICBjb25zdCB1ID0gdXJsLnBhcnNlKHJlcXVlc3QudXJsLCB0cnVlKTtcbiAgICAgIGNvbnN0IG5zID0gdS5wYXRobmFtZTtcbiAgICAgIGlmICh1LnF1ZXJ5LnNvY2tldF9pZCkgc29ja2V0Ll9pZCA9IHUucXVlcnkuc29ja2V0X2lkO1xuICAgICAgZWxzZSBzb2NrZXQuX2lkID0gdjEoKTtcbiAgICAgIHNvY2tldFtcIl9hdXRoZW50aWNhdGVkXCJdID0gZmFsc2U7XG4gICAgICBzb2NrZXQub24oXCJlcnJvclwiLCAoZXJyb3IpID0+IHRoaXMuZW1pdChcInNvY2tldC1lcnJvclwiLCBzb2NrZXQsIGVycm9yKSk7XG4gICAgICBzb2NrZXQub24oXCJjbG9zZVwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMubmFtZXNwYWNlc1tuc10uY2xpZW50cy5kZWxldGUoc29ja2V0Ll9pZCk7XG4gICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgT2JqZWN0LmtleXModGhpcy5uYW1lc3BhY2VzW25zXS5ldmVudHMpKSB7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm5hbWVzcGFjZXNbbnNdLmV2ZW50c1tldmVudF0uc29ja2V0cy5pbmRleE9mKFxuICAgICAgICAgICAgc29ja2V0Ll9pZFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGluZGV4ID49IDApXG4gICAgICAgICAgICB0aGlzLm5hbWVzcGFjZXNbbnNdLmV2ZW50c1tldmVudF0uc29ja2V0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChcImRpc2Nvbm5lY3Rpb25cIiwgc29ja2V0KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCF0aGlzLm5hbWVzcGFjZXNbbnNdKSB0aGlzLl9nZW5lcmF0ZU5hbWVzcGFjZShucyk7XG4gICAgICB0aGlzLm5hbWVzcGFjZXNbbnNdLmNsaWVudHMuc2V0KHNvY2tldC5faWQsIHNvY2tldCk7XG4gICAgICB0aGlzLmVtaXQoXCJjb25uZWN0aW9uXCIsIHNvY2tldCwgcmVxdWVzdCk7XG4gICAgICByZXR1cm4gdGhpcy5faGFuZGxlUlBDKHNvY2tldCwgbnMpO1xuICAgIH0pO1xuICAgIHRoaXMud3NzLm9uKFwiZXJyb3JcIiwgKGVycm9yKSA9PiB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcikpO1xuICB9XG4gIC8qKlxuICAqIFJlZ2lzdGVycyBhbiBSUEMgbWV0aG9kLlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIG1ldGhvZCBuYW1lXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBhIGNhbGxlZSBmdW5jdGlvblxuICAqIEBwYXJhbSB7U3RyaW5nfSBucyAtIG5hbWVzcGFjZSBpZGVudGlmaWVyXG4gICogQHRocm93cyB7VHlwZUVycm9yfVxuICAqIEByZXR1cm4ge09iamVjdH0gLSByZXR1cm5zIGFuIElNZXRob2Qgb2JqZWN0XG4gICovXG4gIHJlZ2lzdGVyKG5hbWUsIGZuLCBucyA9IFwiL1wiKSB7XG4gICAgaWYgKCF0aGlzLm5hbWVzcGFjZXNbbnNdKSB0aGlzLl9nZW5lcmF0ZU5hbWVzcGFjZShucyk7XG4gICAgdGhpcy5uYW1lc3BhY2VzW25zXS5ycGNfbWV0aG9kc1tuYW1lXSA9IHtcbiAgICAgIGZuLFxuICAgICAgcHJvdGVjdGVkOiBmYWxzZVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb3RlY3RlZDogKCkgPT4gdGhpcy5fbWFrZVByb3RlY3RlZE1ldGhvZChuYW1lLCBucyksXG4gICAgICBwdWJsaWM6ICgpID0+IHRoaXMuX21ha2VQdWJsaWNNZXRob2QobmFtZSwgbnMpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgKiBTZXRzIGFuIGF1dGggbWV0aG9kLlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIGFuIGFyYml0cmFyeSBhdXRoIG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBucyAtIG5hbWVzcGFjZSBpZGVudGlmaWVyXG4gICogQHRocm93cyB7VHlwZUVycm9yfVxuICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgKi9cbiAgc2V0QXV0aChmbiwgbnMgPSBcIi9cIikge1xuICAgIHRoaXMucmVnaXN0ZXIoXCJycGMubG9naW5cIiwgZm4sIG5zKTtcbiAgfVxuICAvKipcbiAgKiBNYXJrcyBhbiBSUEMgbWV0aG9kIGFzIHByb3RlY3RlZC5cbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBtZXRob2QgbmFtZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBucyAtIG5hbWVzcGFjZSBpZGVudGlmaWVyXG4gICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAqL1xuICBfbWFrZVByb3RlY3RlZE1ldGhvZChuYW1lLCBucyA9IFwiL1wiKSB7XG4gICAgdGhpcy5uYW1lc3BhY2VzW25zXS5ycGNfbWV0aG9kc1tuYW1lXS5wcm90ZWN0ZWQgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAqIE1hcmtzIGFuIFJQQyBtZXRob2QgYXMgcHVibGljLlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIG1ldGhvZCBuYW1lXG4gICogQHBhcmFtIHtTdHJpbmd9IG5zIC0gbmFtZXNwYWNlIGlkZW50aWZpZXJcbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICovXG4gIF9tYWtlUHVibGljTWV0aG9kKG5hbWUsIG5zID0gXCIvXCIpIHtcbiAgICB0aGlzLm5hbWVzcGFjZXNbbnNdLnJwY19tZXRob2RzW25hbWVdLnByb3RlY3RlZCA9IGZhbHNlO1xuICB9XG4gIC8qKlxuICAqIE1hcmtzIGFuIGV2ZW50IGFzIHByb3RlY3RlZC5cbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBldmVudCBuYW1lXG4gICogQHBhcmFtIHtTdHJpbmd9IG5zIC0gbmFtZXNwYWNlIGlkZW50aWZpZXJcbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICovXG4gIF9tYWtlUHJvdGVjdGVkRXZlbnQobmFtZSwgbnMgPSBcIi9cIikge1xuICAgIHRoaXMubmFtZXNwYWNlc1tuc10uZXZlbnRzW25hbWVdLnByb3RlY3RlZCA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICogTWFya3MgYW4gZXZlbnQgYXMgcHVibGljLlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIGV2ZW50IG5hbWVcbiAgKiBAcGFyYW0ge1N0cmluZ30gbnMgLSBuYW1lc3BhY2UgaWRlbnRpZmllclxuICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgKi9cbiAgX21ha2VQdWJsaWNFdmVudChuYW1lLCBucyA9IFwiL1wiKSB7XG4gICAgdGhpcy5uYW1lc3BhY2VzW25zXS5ldmVudHNbbmFtZV0ucHJvdGVjdGVkID0gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICogUmVtb3ZlcyBhIG5hbWVzcGFjZSBhbmQgY2xvc2VzIGFsbCBjb25uZWN0aW9uc1xuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge1N0cmluZ30gbnMgLSBuYW1lc3BhY2UgaWRlbnRpZmllclxuICAqIEB0aHJvd3Mge1R5cGVFcnJvcn1cbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICovXG4gIGNsb3NlTmFtZXNwYWNlKG5zKSB7XG4gICAgY29uc3QgbmFtZXNwYWNlID0gdGhpcy5uYW1lc3BhY2VzW25zXTtcbiAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICBkZWxldGUgbmFtZXNwYWNlLnJwY19tZXRob2RzO1xuICAgICAgZGVsZXRlIG5hbWVzcGFjZS5ldmVudHM7XG4gICAgICBmb3IgKGNvbnN0IHNvY2tldCBvZiBuYW1lc3BhY2UuY2xpZW50cy52YWx1ZXMoKSkgc29ja2V0LmNsb3NlKCk7XG4gICAgICBkZWxldGUgdGhpcy5uYW1lc3BhY2VzW25zXTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICogQ3JlYXRlcyBhIG5ldyBldmVudCB0aGF0IGNhbiBiZSBlbWl0dGVkIHRvIGNsaWVudHMuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gZXZlbnQgbmFtZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBucyAtIG5hbWVzcGFjZSBpZGVudGlmaWVyXG4gICogQHRocm93cyB7VHlwZUVycm9yfVxuICAqIEByZXR1cm4ge09iamVjdH0gLSByZXR1cm5zIGFuIElFdmVudCBvYmplY3RcbiAgKi9cbiAgZXZlbnQobmFtZSwgbnMgPSBcIi9cIikge1xuICAgIGlmICghdGhpcy5uYW1lc3BhY2VzW25zXSkgdGhpcy5fZ2VuZXJhdGVOYW1lc3BhY2UobnMpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm5hbWVzcGFjZXNbbnNdLmV2ZW50c1tuYW1lXTtcbiAgICAgIGlmIChpbmRleCAhPT0gdm9pZCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFscmVhZHkgcmVnaXN0ZXJlZCBldmVudCAke25zfSR7bmFtZX1gKTtcbiAgICB9XG4gICAgdGhpcy5uYW1lc3BhY2VzW25zXS5ldmVudHNbbmFtZV0gPSB7XG4gICAgICBzb2NrZXRzOiBbXSxcbiAgICAgIHByb3RlY3RlZDogZmFsc2VcbiAgICB9O1xuICAgIHRoaXMub24obmFtZSwgKC4uLnBhcmFtcykgPT4ge1xuICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDEgJiYgcGFyYW1zWzBdIGluc3RhbmNlb2YgT2JqZWN0KVxuICAgICAgICBwYXJhbXMgPSBwYXJhbXNbMF07XG4gICAgICBmb3IgKGNvbnN0IHNvY2tldF9pZCBvZiB0aGlzLm5hbWVzcGFjZXNbbnNdLmV2ZW50c1tuYW1lXS5zb2NrZXRzKSB7XG4gICAgICAgIGNvbnN0IHNvY2tldCA9IHRoaXMubmFtZXNwYWNlc1tuc10uY2xpZW50cy5nZXQoc29ja2V0X2lkKTtcbiAgICAgICAgaWYgKCFzb2NrZXQpIGNvbnRpbnVlO1xuICAgICAgICBzb2NrZXQuc2VuZChcbiAgICAgICAgICB0aGlzLmRhdGFQYWNrLmVuY29kZSh7XG4gICAgICAgICAgICBub3RpZmljYXRpb246IG5hbWUsXG4gICAgICAgICAgICBwYXJhbXNcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBwcm90ZWN0ZWQ6ICgpID0+IHRoaXMuX21ha2VQcm90ZWN0ZWRFdmVudChuYW1lLCBucyksXG4gICAgICBwdWJsaWM6ICgpID0+IHRoaXMuX21ha2VQdWJsaWNFdmVudChuYW1lLCBucylcbiAgICB9O1xuICB9XG4gIC8qKlxuICAqIFJldHVybnMgYSByZXF1ZXN0ZWQgbmFtZXNwYWNlIG9iamVjdFxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIG5hbWVzcGFjZSBpZGVudGlmaWVyXG4gICogQHRocm93cyB7VHlwZUVycm9yfVxuICAqIEByZXR1cm4ge09iamVjdH0gLSBuYW1lc3BhY2Ugb2JqZWN0XG4gICovXG4gIG9mKG5hbWUpIHtcbiAgICBpZiAoIXRoaXMubmFtZXNwYWNlc1tuYW1lXSkgdGhpcy5fZ2VuZXJhdGVOYW1lc3BhY2UobmFtZSk7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIHNlbGYucmVnaXN0ZXIgY29udmVuaWVuY2UgbWV0aG9kXG4gICAgICByZWdpc3Rlcihmbl9uYW1lLCBmbikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtdXN0IHByb3ZpZGUgZXhhY3RseSB0d28gYXJndW1lbnRzXCIpO1xuICAgICAgICBpZiAodHlwZW9mIGZuX25hbWUgIT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibmFtZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgICAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaGFuZGxlciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIHJldHVybiBzZWxmLnJlZ2lzdGVyKGZuX25hbWUsIGZuLCBuYW1lKTtcbiAgICAgIH0sXG4gICAgICAvLyBzZWxmLmV2ZW50IGNvbnZlbmllbmNlIG1ldGhvZFxuICAgICAgZXZlbnQoZXZfbmFtZSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtdXN0IHByb3ZpZGUgZXhhY3RseSBvbmUgYXJndW1lbnRcIik7XG4gICAgICAgIGlmICh0eXBlb2YgZXZfbmFtZSAhPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuYW1lIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgICAgIHJldHVybiBzZWxmLmV2ZW50KGV2X25hbWUsIG5hbWUpO1xuICAgICAgfSxcbiAgICAgIC8vIHNlbGYuZXZlbnRMaXN0IGNvbnZlbmllbmNlIG1ldGhvZFxuICAgICAgZ2V0IGV2ZW50TGlzdCgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHNlbGYubmFtZXNwYWNlc1tuYW1lXS5ldmVudHMpO1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgKiBFbWl0cyBhIHNwZWNpZmllZCBldmVudCB0byB0aGlzIG5hbWVzcGFjZS5cbiAgICAgICogQGlubmVyXG4gICAgICAqIEBtZXRob2RcbiAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IC0gZXZlbnQgbmFtZVxuICAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgLSBldmVudCBwYXJhbWV0ZXJzXG4gICAgICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgICAgICovXG4gICAgICBlbWl0KGV2ZW50LCAuLi5wYXJhbXMpIHtcbiAgICAgICAgY29uc3Qgc29ja2V0X2lkcyA9IFsuLi5zZWxmLm5hbWVzcGFjZXNbbmFtZV0uY2xpZW50cy5rZXlzKCldO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWQ7IGlkID0gc29ja2V0X2lkc1tpXTsgKytpKSB7XG4gICAgICAgICAgc2VsZi5uYW1lc3BhY2VzW25hbWVdLmNsaWVudHMuZ2V0KGlkKS5zZW5kKFxuICAgICAgICAgICAgc2VsZi5kYXRhUGFjay5lbmNvZGUoe1xuICAgICAgICAgICAgICBub3RpZmljYXRpb246IGV2ZW50LFxuICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyB8fCBbXVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAqIFJldHVybnMgYSBuYW1lIG9mIHRoaXMgbmFtZXNwYWNlLlxuICAgICAgKiBAaW5uZXJcbiAgICAgICogQG1ldGhvZFxuICAgICAgKiBAa2luZCBjb25zdGFudFxuICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICAqL1xuICAgICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgKiBSZXR1cm5zIGEgaGFzaCBvZiB3ZWJzb2NrZXQgb2JqZWN0cyBjb25uZWN0ZWQgdG8gdGhpcyBuYW1lc3BhY2UuXG4gICAgICAqIEBpbm5lclxuICAgICAgKiBAbWV0aG9kXG4gICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgICovXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIGNvbnN0IHNvY2tldF9pZHMgPSBbLi4uc2VsZi5uYW1lc3BhY2VzW25hbWVdLmNsaWVudHMua2V5cygpXTtcbiAgICAgICAgcmV0dXJuIHNvY2tldF9pZHMucmVkdWNlKFxuICAgICAgICAgIChhY2MsIGN1cnIpID0+ICh7XG4gICAgICAgICAgICAuLi5hY2MsXG4gICAgICAgICAgICBbY3Vycl06IHNlbGYubmFtZXNwYWNlc1tuYW1lXS5jbGllbnRzLmdldChjdXJyKVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHt9XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGNsaWVudCB1bmlxdWUgaWRlbnRpZmllcnMgY29ubmVjdGVkIHRvIHRoaXMgbmFtZXNwYWNlLlxuICAgICAgKiBAaW5uZXJcbiAgICAgICogQG1ldGhvZFxuICAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgICovXG4gICAgICBjbGllbnRzKCkge1xuICAgICAgICByZXR1cm4gc2VsZi5uYW1lc3BhY2VzW25hbWVdO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICogTGlzdHMgYWxsIGNyZWF0ZWQgZXZlbnRzIGluIGEgZ2l2ZW4gbmFtZXNwYWNlLiBEZWZhdWx0cyB0byBcIi9cIi5cbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtTdHJpbmd9IG5zIC0gbmFtZXNwYWNlcyBpZGVudGlmaWVyXG4gICogQHJlYWRvbmx5XG4gICogQHJldHVybiB7QXJyYXl9IC0gcmV0dXJucyBhIGxpc3Qgb2YgY3JlYXRlZCBldmVudHNcbiAgKi9cbiAgZXZlbnRMaXN0KG5zID0gXCIvXCIpIHtcbiAgICBpZiAoIXRoaXMubmFtZXNwYWNlc1tuc10pIHJldHVybiBbXTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5uYW1lc3BhY2VzW25zXS5ldmVudHMpO1xuICB9XG4gIC8qKlxuICAqIENyZWF0ZXMgYSBKU09OLVJQQyAyLjAgY29tcGxpYW50IGVycm9yXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIC0gaW5kaWNhdGVzIHRoZSBlcnJvciB0eXBlIHRoYXQgb2NjdXJyZWRcbiAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSAtIHByb3ZpZGVzIGEgc2hvcnQgZGVzY3JpcHRpb24gb2YgdGhlIGVycm9yXG4gICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBkYXRhIC0gZGV0YWlscyBjb250YWluaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGVycm9yXG4gICogQHJldHVybiB7T2JqZWN0fVxuICAqL1xuICBjcmVhdGVFcnJvcihjb2RlLCBtZXNzYWdlLCBkYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvZGUsXG4gICAgICBtZXNzYWdlLFxuICAgICAgZGF0YTogZGF0YSB8fCBudWxsXG4gICAgfTtcbiAgfVxuICAvKipcbiAgKiBDbG9zZXMgdGhlIHNlcnZlciBhbmQgdGVybWluYXRlcyBhbGwgY2xpZW50cy5cbiAgKiBAbWV0aG9kXG4gICogQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cbiAgY2xvc2UoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMud3NzLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuZW1pdChcImNsb3NlXCIpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAqIEhhbmRsZXMgYWxsIFdlYlNvY2tldCBKU09OIFJQQyAyLjAgcmVxdWVzdHMuXG4gICogQHByaXZhdGVcbiAgKiBAcGFyYW0ge09iamVjdH0gc29ja2V0IC0gd3Mgc29ja2V0IGluc3RhbmNlXG4gICogQHBhcmFtIHtTdHJpbmd9IG5zIC0gbmFtZXNwYWNlcyBpZGVudGlmaWVyXG4gICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAqL1xuICBfaGFuZGxlUlBDKHNvY2tldCwgbnMgPSBcIi9cIikge1xuICAgIHNvY2tldC5vbihcIm1lc3NhZ2VcIiwgYXN5bmMgKGRhdGEpID0+IHtcbiAgICAgIGNvbnN0IG1zZ19vcHRpb25zID0ge307XG4gICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIG1zZ19vcHRpb25zLmJpbmFyeSA9IHRydWU7XG4gICAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhKS50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgaWYgKHNvY2tldC5yZWFkeVN0YXRlICE9PSAxKSByZXR1cm47XG4gICAgICBsZXQgcGFyc2VkRGF0YTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnNlZERhdGEgPSB0aGlzLmRhdGFQYWNrLmRlY29kZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBzb2NrZXQuc2VuZChcbiAgICAgICAgICB0aGlzLmRhdGFQYWNrLmVuY29kZSh7XG4gICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICAgICAgZXJyb3I6IGNyZWF0ZUVycm9yKC0zMjcwMCwgZXJyb3IudG9TdHJpbmcoKSksXG4gICAgICAgICAgICBpZDogbnVsbFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIG1zZ19vcHRpb25zXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWREYXRhKSkge1xuICAgICAgICBpZiAoIXBhcnNlZERhdGEubGVuZ3RoKVxuICAgICAgICAgIHJldHVybiBzb2NrZXQuc2VuZChcbiAgICAgICAgICAgIHRoaXMuZGF0YVBhY2suZW5jb2RlKHtcbiAgICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICAgICAgZXJyb3I6IGNyZWF0ZUVycm9yKC0zMjYwMCwgXCJJbnZhbGlkIGFycmF5XCIpLFxuICAgICAgICAgICAgICBpZDogbnVsbFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBtc2dfb3B0aW9uc1xuICAgICAgICAgICk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgcGFyc2VkRGF0YSkge1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlMiA9IGF3YWl0IHRoaXMuX3J1bk1ldGhvZChtZXNzYWdlLCBzb2NrZXQuX2lkLCBucyk7XG4gICAgICAgICAgaWYgKCFyZXNwb25zZTIpIGNvbnRpbnVlO1xuICAgICAgICAgIHJlc3BvbnNlcy5wdXNoKHJlc3BvbnNlMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXNwb25zZXMubGVuZ3RoKSByZXR1cm47XG4gICAgICAgIHJldHVybiBzb2NrZXQuc2VuZCh0aGlzLmRhdGFQYWNrLmVuY29kZShyZXNwb25zZXMpLCBtc2dfb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX3J1bk1ldGhvZChwYXJzZWREYXRhLCBzb2NrZXQuX2lkLCBucyk7XG4gICAgICBpZiAoIXJlc3BvbnNlKSByZXR1cm47XG4gICAgICByZXR1cm4gc29ja2V0LnNlbmQodGhpcy5kYXRhUGFjay5lbmNvZGUocmVzcG9uc2UpLCBtc2dfb3B0aW9ucyk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogUnVucyBhIGRlZmluZWQgUlBDIG1ldGhvZC5cbiAgKiBAcHJpdmF0ZVxuICAqIEBwYXJhbSB7T2JqZWN0fSBtZXNzYWdlIC0gYSBtZXNzYWdlIHJlY2VpdmVkXG4gICogQHBhcmFtIHtPYmplY3R9IHNvY2tldF9pZCAtIHVzZXIncyBzb2NrZXQgaWRcbiAgKiBAcGFyYW0ge1N0cmluZ30gbnMgLSBuYW1lc3BhY2VzIGlkZW50aWZpZXJcbiAgKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfVxuICAqL1xuICBhc3luYyBfcnVuTWV0aG9kKG1lc3NhZ2UsIHNvY2tldF9pZCwgbnMgPSBcIi9cIikge1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgZXJyb3I6IGNyZWF0ZUVycm9yKC0zMjYwMCksXG4gICAgICAgIGlkOiBudWxsXG4gICAgICB9O1xuICAgIGlmIChtZXNzYWdlLmpzb25ycGMgIT09IFwiMi4wXCIpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyNjAwLCBcIkludmFsaWQgSlNPTiBSUEMgdmVyc2lvblwiKSxcbiAgICAgICAgaWQ6IG1lc3NhZ2UuaWQgfHwgbnVsbFxuICAgICAgfTtcbiAgICBpZiAoIW1lc3NhZ2UubWV0aG9kKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgZXJyb3I6IGNyZWF0ZUVycm9yKC0zMjYwMiwgXCJNZXRob2Qgbm90IHNwZWNpZmllZFwiKSxcbiAgICAgICAgaWQ6IG1lc3NhZ2UuaWQgfHwgbnVsbFxuICAgICAgfTtcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UubWV0aG9kICE9PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgZXJyb3I6IGNyZWF0ZUVycm9yKC0zMjYwMCwgXCJJbnZhbGlkIG1ldGhvZCBuYW1lXCIpLFxuICAgICAgICBpZDogbWVzc2FnZS5pZCB8fCBudWxsXG4gICAgICB9O1xuICAgIGlmIChtZXNzYWdlLnBhcmFtcyAmJiB0eXBlb2YgbWVzc2FnZS5wYXJhbXMgPT09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyNjAwKSxcbiAgICAgICAgaWQ6IG1lc3NhZ2UuaWQgfHwgbnVsbFxuICAgICAgfTtcbiAgICBpZiAobWVzc2FnZS5tZXRob2QgPT09IFwicnBjLm9uXCIpIHtcbiAgICAgIGlmICghbWVzc2FnZS5wYXJhbXMpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyZTMpLFxuICAgICAgICAgIGlkOiBtZXNzYWdlLmlkIHx8IG51bGxcbiAgICAgICAgfTtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSB7fTtcbiAgICAgIGNvbnN0IGV2ZW50X25hbWVzID0gT2JqZWN0LmtleXModGhpcy5uYW1lc3BhY2VzW25zXS5ldmVudHMpO1xuICAgICAgZm9yIChjb25zdCBuYW1lIG9mIG1lc3NhZ2UucGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZXZlbnRfbmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICAgICAgY29uc3QgbmFtZXNwYWNlID0gdGhpcy5uYW1lc3BhY2VzW25zXTtcbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgIHJlc3VsdHNbbmFtZV0gPSBcInByb3ZpZGVkIGV2ZW50IGludmFsaWRcIjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZXNwYWNlLmV2ZW50c1tldmVudF9uYW1lc1tpbmRleF1dLnByb3RlY3RlZCA9PT0gdHJ1ZSAmJiBuYW1lc3BhY2UuY2xpZW50cy5nZXQoc29ja2V0X2lkKVtcIl9hdXRoZW50aWNhdGVkXCJdID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICAgICAgZXJyb3I6IGNyZWF0ZUVycm9yKC0zMjYwNiksXG4gICAgICAgICAgICBpZDogbWVzc2FnZS5pZCB8fCBudWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb2NrZXRfaW5kZXggPSBuYW1lc3BhY2UuZXZlbnRzW2V2ZW50X25hbWVzW2luZGV4XV0uc29ja2V0cy5pbmRleE9mKHNvY2tldF9pZCk7XG4gICAgICAgIGlmIChzb2NrZXRfaW5kZXggPj0gMCkge1xuICAgICAgICAgIHJlc3VsdHNbbmFtZV0gPSBcInNvY2tldCBoYXMgYWxyZWFkeSBiZWVuIHN1YnNjcmliZWQgdG8gZXZlbnRcIjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBuYW1lc3BhY2UuZXZlbnRzW2V2ZW50X25hbWVzW2luZGV4XV0uc29ja2V0cy5wdXNoKHNvY2tldF9pZCk7XG4gICAgICAgIHJlc3VsdHNbbmFtZV0gPSBcIm9rXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICByZXN1bHQ6IHJlc3VsdHMsXG4gICAgICAgIGlkOiBtZXNzYWdlLmlkIHx8IG51bGxcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlLm1ldGhvZCA9PT0gXCJycGMub2ZmXCIpIHtcbiAgICAgIGlmICghbWVzc2FnZS5wYXJhbXMpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyZTMpLFxuICAgICAgICAgIGlkOiBtZXNzYWdlLmlkIHx8IG51bGxcbiAgICAgICAgfTtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBtZXNzYWdlLnBhcmFtcykge1xuICAgICAgICBpZiAoIXRoaXMubmFtZXNwYWNlc1tuc10uZXZlbnRzW25hbWVdKSB7XG4gICAgICAgICAgcmVzdWx0c1tuYW1lXSA9IFwicHJvdmlkZWQgZXZlbnQgaW52YWxpZFwiO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5uYW1lc3BhY2VzW25zXS5ldmVudHNbbmFtZV0uc29ja2V0cy5pbmRleE9mKHNvY2tldF9pZCk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICByZXN1bHRzW25hbWVdID0gXCJub3Qgc3Vic2NyaWJlZFwiO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmFtZXNwYWNlc1tuc10uZXZlbnRzW25hbWVdLnNvY2tldHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgcmVzdWx0c1tuYW1lXSA9IFwib2tcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgIHJlc3VsdDogcmVzdWx0cyxcbiAgICAgICAgaWQ6IG1lc3NhZ2UuaWQgfHwgbnVsbFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2UubWV0aG9kID09PSBcInJwYy5sb2dpblwiKSB7XG4gICAgICBpZiAoIW1lc3NhZ2UucGFyYW1zKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgICAgZXJyb3I6IGNyZWF0ZUVycm9yKC0zMjYwNCksXG4gICAgICAgICAgaWQ6IG1lc3NhZ2UuaWQgfHwgbnVsbFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoIXRoaXMubmFtZXNwYWNlc1tuc10ucnBjX21ldGhvZHNbbWVzc2FnZS5tZXRob2RdKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyNjAxKSxcbiAgICAgICAgaWQ6IG1lc3NhZ2UuaWQgfHwgbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IHJlc3BvbnNlID0gbnVsbDtcbiAgICBpZiAodGhpcy5uYW1lc3BhY2VzW25zXS5ycGNfbWV0aG9kc1ttZXNzYWdlLm1ldGhvZF0ucHJvdGVjdGVkID09PSB0cnVlICYmIHRoaXMubmFtZXNwYWNlc1tuc10uY2xpZW50cy5nZXQoc29ja2V0X2lkKVtcIl9hdXRoZW50aWNhdGVkXCJdID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgZXJyb3I6IGNyZWF0ZUVycm9yKC0zMjYwNSksXG4gICAgICAgIGlkOiBtZXNzYWdlLmlkIHx8IG51bGxcbiAgICAgIH07XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMubmFtZXNwYWNlc1tuc10ucnBjX21ldGhvZHNbbWVzc2FnZS5tZXRob2RdLmZuKFxuICAgICAgICBtZXNzYWdlLnBhcmFtcyxcbiAgICAgICAgc29ja2V0X2lkXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoIW1lc3NhZ2UuaWQpIHJldHVybjtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgIGNvZGU6IC0zMmUzLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubmFtZSxcbiAgICAgICAgICAgIGRhdGE6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlkOiBtZXNzYWdlLmlkXG4gICAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgaWQ6IG1lc3NhZ2UuaWRcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICghbWVzc2FnZS5pZCkgcmV0dXJuO1xuICAgIGlmIChtZXNzYWdlLm1ldGhvZCA9PT0gXCJycGMubG9naW5cIiAmJiByZXNwb25zZSA9PT0gdHJ1ZSkge1xuICAgICAgY29uc3QgcyA9IHRoaXMubmFtZXNwYWNlc1tuc10uY2xpZW50cy5nZXQoc29ja2V0X2lkKTtcbiAgICAgIHNbXCJfYXV0aGVudGljYXRlZFwiXSA9IHRydWU7XG4gICAgICB0aGlzLm5hbWVzcGFjZXNbbnNdLmNsaWVudHMuc2V0KHNvY2tldF9pZCwgcyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgcmVzdWx0OiByZXNwb25zZSxcbiAgICAgIGlkOiBtZXNzYWdlLmlkXG4gICAgfTtcbiAgfVxuICAvKipcbiAgKiBHZW5lcmF0ZSBhIG5ldyBuYW1lc3BhY2Ugc3RvcmUuXG4gICogQWxzbyBwcmVyZWdpc3RlciBzb21lIHNwZWNpYWwgbmFtZXNwYWNlIG1ldGhvZHMuXG4gICogQHByaXZhdGVcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIG5hbWVzcGFjZXMgaWRlbnRpZmllclxuICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgKi9cbiAgX2dlbmVyYXRlTmFtZXNwYWNlKG5hbWUpIHtcbiAgICB0aGlzLm5hbWVzcGFjZXNbbmFtZV0gPSB7XG4gICAgICBycGNfbWV0aG9kczoge1xuICAgICAgICBfX2xpc3RNZXRob2RzOiB7XG4gICAgICAgICAgZm46ICgpID0+IE9iamVjdC5rZXlzKHRoaXMubmFtZXNwYWNlc1tuYW1lXS5ycGNfbWV0aG9kcyksXG4gICAgICAgICAgcHJvdGVjdGVkOiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2xpZW50czogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgIGV2ZW50czoge31cbiAgICB9O1xuICB9XG59O1xudmFyIFJQQ19FUlJPUlMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gIFstMzJlMywgXCJFdmVudCBub3QgcHJvdmlkZWRcIl0sXG4gIFstMzI2MDAsIFwiSW52YWxpZCBSZXF1ZXN0XCJdLFxuICBbLTMyNjAxLCBcIk1ldGhvZCBub3QgZm91bmRcIl0sXG4gIFstMzI2MDIsIFwiSW52YWxpZCBwYXJhbXNcIl0sXG4gIFstMzI2MDMsIFwiSW50ZXJuYWwgZXJyb3JcIl0sXG4gIFstMzI2MDQsIFwiUGFyYW1zIG5vdCBmb3VuZFwiXSxcbiAgWy0zMjYwNSwgXCJNZXRob2QgZm9yYmlkZGVuXCJdLFxuICBbLTMyNjA2LCBcIkV2ZW50IGZvcmJpZGRlblwiXSxcbiAgWy0zMjcwMCwgXCJQYXJzZSBlcnJvclwiXVxuXSk7XG5mdW5jdGlvbiBjcmVhdGVFcnJvcihjb2RlLCBkZXRhaWxzKSB7XG4gIGNvbnN0IGVycm9yID0ge1xuICAgIGNvZGUsXG4gICAgbWVzc2FnZTogUlBDX0VSUk9SUy5nZXQoY29kZSkgfHwgXCJJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcIlxuICB9O1xuICBpZiAoZGV0YWlscykgZXJyb3JbXCJkYXRhXCJdID0gZGV0YWlscztcbiAgcmV0dXJuIGVycm9yO1xufVxuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBDbGllbnQgPSBjbGFzcyBleHRlbmRzIENvbW1vbkNsaWVudCB7XG4gIGNvbnN0cnVjdG9yKGFkZHJlc3MgPSBcIndzOi8vbG9jYWxob3N0OjgwODBcIiwge1xuICAgIGF1dG9jb25uZWN0ID0gdHJ1ZSxcbiAgICByZWNvbm5lY3QgPSB0cnVlLFxuICAgIHJlY29ubmVjdF9pbnRlcnZhbCA9IDFlMyxcbiAgICBtYXhfcmVjb25uZWN0cyA9IDUsXG4gICAgLi4ucmVzdF9vcHRpb25zXG4gIH0gPSB7fSwgZ2VuZXJhdGVfcmVxdWVzdF9pZCkge1xuICAgIHN1cGVyKFxuICAgICAgV2ViU29ja2V0LFxuICAgICAgYWRkcmVzcyxcbiAgICAgIHtcbiAgICAgICAgYXV0b2Nvbm5lY3QsXG4gICAgICAgIHJlY29ubmVjdCxcbiAgICAgICAgcmVjb25uZWN0X2ludGVydmFsLFxuICAgICAgICBtYXhfcmVjb25uZWN0cyxcbiAgICAgICAgLi4ucmVzdF9vcHRpb25zXG4gICAgICB9LFxuICAgICAgZ2VuZXJhdGVfcmVxdWVzdF9pZFxuICAgICk7XG4gIH1cbn07XG5cbmV4cG9ydCB7IENsaWVudCwgQ29tbW9uQ2xpZW50LCBEZWZhdWx0RGF0YVBhY2ssIFNlcnZlciwgV2ViU29ja2V0LCBjcmVhdGVFcnJvciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3V0LmpzLm1hcFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6WyJXZWJTb2NrZXRJbXBsIiwiV2ViU29ja2V0U2VydmVyIiwiRXZlbnRFbWl0dGVyIiwidXJsIiwidjEiLCJXZWJTb2NrZXQiLCJhZGRyZXNzIiwib3B0aW9ucyIsIkRlZmF1bHREYXRhUGFjayIsImVuY29kZSIsInZhbHVlIiwiSlNPTiIsInN0cmluZ2lmeSIsImRlY29kZSIsInBhcnNlIiwiQ29tbW9uQ2xpZW50IiwiY29uc3RydWN0b3IiLCJ3ZWJTb2NrZXRGYWN0b3J5IiwiYXV0b2Nvbm5lY3QiLCJyZWNvbm5lY3QiLCJyZWNvbm5lY3RfaW50ZXJ2YWwiLCJtYXhfcmVjb25uZWN0cyIsInJlc3Rfb3B0aW9ucyIsImdlbmVyYXRlX3JlcXVlc3RfaWQiLCJkYXRhUGFjayIsInF1ZXVlIiwicnBjX2lkIiwicmVhZHkiLCJyZWNvbm5lY3RfdGltZXJfaWQiLCJjdXJyZW50X3JlY29ubmVjdHMiLCJOdW1iZXIiLCJfY29ubmVjdCIsImNvbm5lY3QiLCJzb2NrZXQiLCJjYWxsIiwibWV0aG9kIiwicGFyYW1zIiwidGltZW91dCIsIndzX29wdHMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIkVycm9yIiwibWVzc2FnZSIsImpzb25ycGMiLCJpZCIsInNlbmQiLCJlcnJvciIsInByb21pc2UiLCJzZXRUaW1lb3V0IiwibG9naW4iLCJyZXNwIiwibGlzdE1ldGhvZHMiLCJub3RpZnkiLCJzdWJzY3JpYmUiLCJldmVudCIsInJlc3VsdCIsInVuc3Vic2NyaWJlIiwiY2xvc2UiLCJjb2RlIiwiZGF0YSIsInNldEF1dG9SZWNvbm5lY3QiLCJzZXRSZWNvbm5lY3RJbnRlcnZhbCIsImludGVydmFsIiwic2V0TWF4UmVjb25uZWN0cyIsImNsZWFyVGltZW91dCIsImFkZEV2ZW50TGlzdGVuZXIiLCJlbWl0IiwiQXJyYXlCdWZmZXIiLCJCdWZmZXIiLCJmcm9tIiwidG9TdHJpbmciLCJub3RpZmljYXRpb24iLCJsaXN0ZW5lcnMiLCJsZW5ndGgiLCJPYmplY3QiLCJrZXlzIiwiYXJncyIsInB1c2giLCJpIiwidGhlbiIsImFwcGx5IiwicmVhc29uIiwiU2VydmVyIiwibmFtZXNwYWNlcyIsIndzcyIsIm9uIiwicmVxdWVzdCIsInUiLCJucyIsInBhdGhuYW1lIiwicXVlcnkiLCJzb2NrZXRfaWQiLCJfaWQiLCJjbGllbnRzIiwiZGVsZXRlIiwiZXZlbnRzIiwiaW5kZXgiLCJzb2NrZXRzIiwiaW5kZXhPZiIsInNwbGljZSIsIl9nZW5lcmF0ZU5hbWVzcGFjZSIsInNldCIsIl9oYW5kbGVSUEMiLCJyZWdpc3RlciIsIm5hbWUiLCJmbiIsInJwY19tZXRob2RzIiwicHJvdGVjdGVkIiwiX21ha2VQcm90ZWN0ZWRNZXRob2QiLCJwdWJsaWMiLCJfbWFrZVB1YmxpY01ldGhvZCIsInNldEF1dGgiLCJfbWFrZVByb3RlY3RlZEV2ZW50IiwiX21ha2VQdWJsaWNFdmVudCIsImNsb3NlTmFtZXNwYWNlIiwibmFtZXNwYWNlIiwidmFsdWVzIiwiZ2V0Iiwib2YiLCJzZWxmIiwiZm5fbmFtZSIsImFyZ3VtZW50cyIsImV2X25hbWUiLCJldmVudExpc3QiLCJzb2NrZXRfaWRzIiwiY29ubmVjdGVkIiwicmVkdWNlIiwiYWNjIiwiY3VyciIsImNyZWF0ZUVycm9yIiwibXNnX29wdGlvbnMiLCJiaW5hcnkiLCJyZWFkeVN0YXRlIiwicGFyc2VkRGF0YSIsIkFycmF5IiwiaXNBcnJheSIsInJlc3BvbnNlcyIsInJlc3BvbnNlMiIsIl9ydW5NZXRob2QiLCJyZXNwb25zZSIsInJlc3VsdHMiLCJldmVudF9uYW1lcyIsInNvY2tldF9pbmRleCIsInMiLCJfX2xpc3RNZXRob2RzIiwiTWFwIiwiUlBDX0VSUk9SUyIsImRldGFpbHMiLCJDbGllbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/node_modules/rpc-websockets/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/../node_modules/@coral-xyz/anchor/node_modules/rpc-websockets/node_modules/eventemitter3/index.mjs":
/*!**********************************************************************************************************!*\
  !*** ../node_modules/@coral-xyz/anchor/node_modules/rpc-websockets/node_modules/eventemitter3/index.mjs ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventEmitter: () => (/* reexport default export from named module */ _index_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ \"(ssr)/../node_modules/@coral-xyz/anchor/node_modules/rpc-websockets/node_modules/eventemitter3/index.js\");\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_index_js__WEBPACK_IMPORTED_MODULE_0__);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYW5jaG9yL25vZGVfbW9kdWxlcy9ycGMtd2Vic29ja2V0cy9ub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFDO0FBRWQ7QUFDdkIsaUVBQWVBLHNDQUFZQSxFQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AY29yYWwteHl6L2FuY2hvci9ub2RlX21vZHVsZXMvcnBjLXdlYnNvY2tldHMvbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXgubWpzPzViNzciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuL2luZGV4LmpzJ1xuXG5leHBvcnQgeyBFdmVudEVtaXR0ZXIgfVxuZXhwb3J0IGRlZmF1bHQgRXZlbnRFbWl0dGVyXG4iXSwibmFtZXMiOlsiRXZlbnRFbWl0dGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@coral-xyz/anchor/node_modules/rpc-websockets/node_modules/eventemitter3/index.mjs\n");

/***/ })

};
;